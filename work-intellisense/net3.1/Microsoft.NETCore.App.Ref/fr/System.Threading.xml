<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary vsli:raw="The exception that is thrown when one thread acquires a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that another thread has abandoned by exiting without releasing it.">Exception levée lorsqu'un thread acquiert un objet <see cref="T:System.Threading.Mutex" /> qu'un autre thread a abandonné en se terminant sans le libérer.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with default values.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec des valeurs par défaut.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un index spécifié pour le mutex abandonné, le cas échéant, et un objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex.</summary>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Index du mutex abandonné dans le tableau des handles d’attente si l’exception est levée pour la méthode <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1 si l’exception est levée pour les méthodes <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with serialized data.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec des données sérialisées.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données d’objet sérialisées relatives à l’exception levée.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient les informations contextuelles sur la source ou la destination.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur spécifié.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Message d'erreur indiquant la raison de l'exception.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message and inner exception.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur et une exception interne spécifiés.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Message d'erreur indiquant la raison de l'exception.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Exception ayant provoqué l'exception actuelle. Si le paramètre <paramref name="inner" /> n'est pas <see langword="null" />, l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the inner exception, the index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur spécifié, l'exception interne, l'index pour le mutex abandonné, le cas échéant, et un objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Message d'erreur indiquant la raison de l'exception.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Exception ayant provoqué l'exception actuelle. Si le paramètre <paramref name="inner" /> n'est pas <see langword="null" />, l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Index du mutex abandonné dans le tableau des handles d’attente si l’exception est levée pour la méthode <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1 si l’exception est levée pour les méthodes <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the index of the abandoned mutex, if applicable, and the abandoned mutex.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur spécifié, l'index du mutex abandonné, le cas échéant, et le mutex abandonné.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Message d'erreur indiquant la raison de l'exception.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Index du mutex abandonné dans le tableau des handles d’attente si l’exception est levée pour la méthode <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1 si l’exception est levée pour les méthodes <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary vsli:raw="Gets the abandoned mutex that caused the exception, if known.">Obtient le mutex abandonné qui a provoqué l'exception, s'il est connu.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or &lt;see langword=&quot;null&quot; /&gt; if the abandoned mutex could not be identified.">Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné ou <see langword="null" /> si les mutex abandonnés n'ont pas pu être identifiés.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary vsli:raw="Gets the index of the abandoned mutex that caused the exception, if known.">Obtient l'index du mutex abandonné qui a provoqué l'exception, s'il est connu.</summary>
      <returns vsli:raw="The index, in the array of wait handles passed to the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or -1 if the index of the abandoned mutex could not be determined.">Index, dans le tableau des handles d’attente passés à <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> la méthode, de <see cref="T:System.Threading.Mutex" /> l’objet qui représente le mutex abandonné, ou-1 si l’index du mutex abandonné n’a pas pu être déterminé.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary vsli:raw="Provides the functionality to restore the migration, or flow, of the execution context between threads.">Fournit les fonctionnalités pour restaurer la migration, ou le flux, du contexte d'exécution entre threads.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">La structure <see cref="T:System.Threading.AsyncFlowControl" /> n'est pas utilisée sur le thread sur lequel elle a été créée.
ou
La structure <see cref="T:System.Threading.AsyncFlowControl" /> a déjà été utilisée pour appeler <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> ou <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified object is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Détermine si l'objet spécifié est égal à la structure <see cref="T:System.Threading.AsyncFlowControl" /> en cours.</summary>
      <param name="obj" vsli:raw="An object to compare with the current structure.">Objet à comparer à la structure en cours.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure and is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="obj" /> est une structure <see cref="T:System.Threading.AsyncFlowControl" /> et si elle est égale à la structure <see cref="T:System.Threading.AsyncFlowControl" /> en cours ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Determines whether the specified &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Détermine si la structure <see cref="T:System.Threading.AsyncFlowControl" /> spécifiée est égale à la structure <see cref="T:System.Threading.AsyncFlowControl" /> en cours.</summary>
      <param name="obj" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure to compare with the current structure.">Structure <see cref="T:System.Threading.AsyncFlowControl" /> à comparer à la structure en cours.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="obj" /> est égal à la structure <see cref="T:System.Threading.AsyncFlowControl" /> actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Obtient un code de hachage pour la structure <see cref="T:System.Threading.AsyncFlowControl" /> actuelle.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Code de hachage pour la structure <see cref="T:System.Threading.AsyncFlowControl" /> actuelle.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are equal.">Compare deux structures <see cref="T:System.Threading.AsyncFlowControl" /> pour déterminer si elles sont égales.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Structure <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Structure <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two structures are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les deux structures sont égales ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are not equal.">Compare deux structures <see cref="T:System.Threading.AsyncFlowControl" /> pour déterminer si elles sont inégales.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Structure <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Structure <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the structures are not equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si les structures ne sont pas égales ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary vsli:raw="Restores the flow of the execution context between threads.">Restaure le flux du contexte d'exécution entre threads.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">La structure <see cref="T:System.Threading.AsyncFlowControl" /> n'est pas utilisée sur le thread sur lequel elle a été créée.

ou -
La structure <see cref="T:System.Threading.AsyncFlowControl" /> a déjà été utilisée pour appeler <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> ou <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary vsli:raw="Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.">Représente les données ambiantes qui sont locales à un flux de contrôle asynchrone donné, par exemple une méthode asynchrone.</summary>
      <typeparam name="T" vsli:raw="The type of the ambient data.">Type des données ambiantes.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instance that does not receive change notifications.">Instancie une instance de <see cref="T:System.Threading.AsyncLocal`1" /> qui ne reçoit pas de notifications de modification.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; local instance that receives change notifications.">Instancie une instance locale de <see cref="T:System.Threading.AsyncLocal`1" /> qui ne reçoit pas de notifications de modification.</summary>
      <param name="valueChangedHandler" vsli:raw="The delegate that is called whenever the current value changes on any thread.">Le délégué est appelé à chaque modification de la valeur actuelle sur n'importe quel thread.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of the ambient data.">Obtient ou définit la valeur des données ambiantes.</summary>
      <returns vsli:raw="The value of the ambient data. If no value has been set, the returned value is &lt;c&gt;default(T)&lt;/c&gt;.">Valeur des données ambiantes. Si aucune valeur n’a été définie, la valeur retournée est <c>default (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary vsli:raw="The class that provides data change information to &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instances that register for change notifications.">Classe qui fournit les informations de modification des données aux instances de <see cref="T:System.Threading.AsyncLocal`1" /> qui s'inscrivent pour les notifications de modification.</summary>
      <typeparam name="T" vsli:raw="The type of the data.">Type des données.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary vsli:raw="Gets the data's current value.">Obtient la valeur actuelle des données.</summary>
      <returns vsli:raw="The data's current value.">Valeur actuelle des données.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary vsli:raw="Gets the data's previous value.">Obtient la valeur précédente des données.</summary>
      <returns vsli:raw="The data's previous value.">Valeur précédente des données.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary vsli:raw="Returns a value that indicates whether the value changes because of a change of execution context.">Retourne une valeur qui indique si la valeur est modifiée en raison d'un changement du contexte d'exécution.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value changed because of a change of execution context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si la valeur a changé en raison d’une modification du contexte d’exécution ; Sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, resets automatically after releasing a single waiting thread. This class cannot be inherited.">Représente un événement de synchronisation de threads qui, quand il est signalé, se réinitialise automatiquement après avoir libéré un thread en attente. Cette classe ne peut pas être héritée.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AutoResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AutoResetEvent" /> avec une valeur booléenne indiquant si l'état initial doit être défini comme signalé.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to non-signaled.">
        <see langword="true" /> pour définir l'état initial comme étant signalé ; <see langword="false" /> pour définir l'état initial comme étant non signalé.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary vsli:raw="Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.">Permet à plusieurs tâches de coopérer en parallèle sur un algorithme via plusieurs phases.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Nombre de threads participants.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> est inférieur à 0 ou supérieur à 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Nombre de threads participants.</param>
      <param name="postPhaseAction" vsli:raw="The &lt;see cref=&quot;T:System.Action`1&quot; /&gt; to be executed after each phase. null (Nothing in Visual Basic) may be passed to indicate no action is taken.">
        <see cref="T:System.Action`1" /> à exécuter après chaque phase. La valeur Null (Nothing en Visual Basic) peut être passée pour indiquer qu'aucune action n'est exécutée.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> est inférieur à 0 ou supérieur à 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be an additional participant.">Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura un participant supplémentaire.</summary>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Numéro de la phase du cloisonnement à laquelle les nouveaux participants participeront en premier.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Adding a participant would cause the barrier's participant count to exceed 32,767.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">L'ajout d'un participant provoquerait l'augmentation du nombre de participants du cloisonnement au-delà de 32 767.

ou -

La méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be additional participants.">Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura des participants supplémentaires.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to add to the barrier.">Nombre de participants supplémentaires à ajouter au cloisonnement.</param>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Numéro de la phase du cloisonnement à laquelle les nouveaux participants participeront en premier.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0.  &#xA;  &#xA; -or-  &#xA;  &#xA; Adding &lt;paramref name=&quot;participantCount&quot; /&gt; participants would cause the barrier's participant count to exceed 32,767.">
        <paramref name="participantCount" /> est inférieur à 0.

ou -
L'ajout de participants (<paramref name="participantCount" />) provoquerait l'augmentation du nombre de participants du cloisonnement au-delà de 32 767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">La méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary vsli:raw="Gets the number of the barrier's current phase.">Obtient le numéro de la phase actuelle du cloisonnement.</summary>
      <returns vsli:raw="Returns the number of the barrier's current phase.">Retourne le numéro de la phase actuelle du cloisonnement.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">La méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt;, and optionally releases the managed resources.">Libère les ressources non managées utilisées par le <see cref="T:System.Threading.Barrier" />, et libère éventuellement les ressources managées.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true pour libérer les ressources managées et non managées ; false pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary vsli:raw="Gets the total number of participants in the barrier.">Obtient le nombre total de participants au cloisonnement.</summary>
      <returns vsli:raw="Returns the total number of participants in the barrier.">Retourne le nombre total de participants au cloisonnement.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary vsli:raw="Gets the number of participants in the barrier that haven't yet signaled in the current phase.">Obtient le nombre de participants au cloisonnement qui n’ont pas encore été signalés dans la phase actuelle.</summary>
      <returns vsli:raw="Returns the number of participants in the barrier that haven't yet signaled in the current phase.">Retourne le nombre de participants dans le cloisonnement qui n’ont pas encore été signalés dans la phase actuelle.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be one less participant.">Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura un participant en moins.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">La barrière a déjà 0 participant.

ou -

La méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be fewer participants.">Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura moins de participants.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to remove from the barrier.">Nombre de participants supplémentaires à supprimer du cloisonnement.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The total participant count is less than the specified &lt;paramref name=&quot;participantCount&quot; /&gt;">Le nombre total de participants est inférieur au <paramref name="participantCount" /> spécifié</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current participant count is less than the specified participantCount.">La barrière a déjà 0 participant.

ou -

La méthode a été appelée à partir d'une action post-phase.

ou -

le nombre de participant actuel est inférieur au participantCount spécifié</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well.">Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Si une exception est levée par l'action de post-phase d'un cloisonnement après que tous les threads participants aient appelé SignalAndWait, l'exception sera incluse dans un wrapper dans une BarrierPostPhaseException et levée pour tous les threads participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout.">Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un entier signé 32 bits pour mesurer le délai d'attente.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si tous les participants ont atteint le cloisonnement dans le délai spécifié ; sinon <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Si une exception est levée par l'action de post-phase d'un cloisonnement après que tous les threads participants aient appelé SignalAndWait, l'exception sera incluse dans un wrapper dans une BarrierPostPhaseException et levée pour tous les threads participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout, while observing a cancellation token.">Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un entier signé 32 bits pour mesurer le délai d'attente, tout en observant un jeton d'annulation.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">si tous les participants ont atteint le cloisonnement dans le délai spécifié ; sinon false.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier, while observing a cancellation token.">Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, tout en observant un jeton d'annulation.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval.">Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un objet <see cref="T:System.TimeSpan" /> qui mesure l'intervalle de temps.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si tous les autres participants ont atteint le cloisonnement ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out, or it is greater than 32,767.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini, ou sa valeur est supérieure à 32 767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval, while observing a cancellation token.">Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un objet <see cref="T:System.TimeSpan" /> qui mesure l'intervalle de temps, tout en observant un jeton d'annulation.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si tous les autres participants ont atteint le cloisonnement ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary vsli:raw="The exception that is thrown when the post-phase action of a &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; fails.">Exception levée en cas d’échec de l’action postphase de <see cref="T:System.Threading.Barrier" />.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a system-supplied message that describes the error.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec un message système qui décrit l'erreur.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with the specified inner exception.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec l'exception interne spécifiée.</summary>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception.">Exception ayant provoqué l'exception actuelle.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with serialized data.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec des données sérialisées.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Objet qui contient les données sérialisées de l'objet.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Informations contextuelles sur la source ou la destination.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified message that describes the error.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec un message spécifié décrivant l'erreur.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Message décrivant l'exception. L'appelant de ce constructeur doit vérifier que cette chaîne a été localisée pour la culture en cours du système.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Message décrivant l'exception. L'appelant de ce constructeur doit vérifier que cette chaîne a été localisée pour la culture en cours du système.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Exception ayant provoqué l'exception actuelle. Si le paramètre <paramref name="innerException" /> n'est pas <see langword="null" />, l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary vsli:raw="Represents a method to be called within a new context.">Représente une méthode à appeler dans un nouveau contexte.</summary>
      <param name="state" vsli:raw="An object containing information to be used by the callback method each time it executes.">Objet contenant les informations que la méthode de rappel doit utiliser à chacune de ses exécutions.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary vsli:raw="Represents a synchronization primitive that is signaled when its count reaches zero.">Représente une primitive de synchronisation qui est signalée lorsque son décompte atteint zéro.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class with the specified count.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.CountdownEvent" /> à l'aide du décompte spécifié.</summary>
      <param name="initialCount" vsli:raw="The number of signals initially required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Nombre de signaux initialement requis pour définir <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by one.">Incrémente de un le décompte actuel de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">L'instance actuelle est déjà définie.

ou -
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est supérieur ou égal à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by a specified value.">Incrémente d'une valeur spécifiée le décompte actuel de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Valeur d'incrément de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> est inférieur ou égal à 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; after count is incremented by &lt;paramref name=&quot;signalCount&quot; /&gt;.">L'instance actuelle est déjà définie.

ou -
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est égal à ou supérieur à <see cref="F:System.Int32.MaxValue" /> une fois le nombre été incrémenté par <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary vsli:raw="Gets the number of remaining signals required to set the event.">Obtient le nombre de signaux restants requis pour définir l'événement.</summary>
      <returns vsli:raw="The number of remaining signals required to set the event.">Nombre de signaux restants requis pour définir l'événement.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, and optionally releases the managed resources.">Libère les ressources non managées utilisées par le <see cref="T:System.Threading.CountdownEvent" />, et libère éventuellement les ressources managées.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true pour libérer les ressources managées et non managées ; false pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary vsli:raw="Gets the numbers of signals initially required to set the event.">Obtient le nombre de signaux initialement requis pour définir l'événement.</summary>
      <returns vsli:raw="The number of signals initially required to set the event.">Nombre de signaux initialement requis pour définir l'événement.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary vsli:raw="Indicates whether the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; object's current count has reached zero.">Indique si le nombre actuel de l’objet <see cref="T:System.Threading.CountdownEvent" /> a atteint zéro.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current count is zero; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le nombre actuel est égal à zéro ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; to the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt;.">Réinitialise <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> avec la valeur <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt; property to a specified value.">Définit la propriété <see cref="P:System.Threading.CountdownEvent.InitialCount" /> spécifiée sur la valeur indiquée.</summary>
      <param name="count" vsli:raw="The number of signals required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Nombre de signaux requis pour définir <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is less than 0.">
        <paramref name="count" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary vsli:raw="Registers a signal with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Enregistre un signal avec le <see cref="T:System.Threading.CountdownEvent" />, en décrémentant la valeur de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signal caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le décompte a atteint zéro en raison du signal et si l’événement a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.">L'instance actuelle est déjà définie.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary vsli:raw="Registers multiple signals with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by the specified amount.">Inscrit plusieurs signaux avec <see cref="T:System.Threading.CountdownEvent" />, en décrémentant la valeur de <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> selon la valeur spécifiée.</summary>
      <param name="signalCount" vsli:raw="The number of signals to register.">Nombre de signaux à inscrire.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signals caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le décompte a atteint zéro en raison des signaux et si l’événement a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than 1.">
        <paramref name="signalCount" /> est inférieur à 1.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set. -or- Or &lt;paramref name=&quot;signalCount&quot; /&gt; is greater than &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">L'instance actuelle est déjà définie. - ou - Ou <paramref name="signalCount" /> est supérieur à <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by one.">Essaie d'incrémenter <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> par un.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero, this method will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’incrémentation a réussi ; sinon, false. Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est déjà à zéro, cette méthode retourne <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est égal à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by a specified value.">Essaie d'incrémenter <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> par une valeur spécifiée.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Valeur d'incrément de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero this will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’incrémentation a réussi ; sinon, false. Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est déjà à zéro, ceci retourne <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> est inférieur ou égal à 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; + &lt;paramref name=&quot;signalCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> est supérieur ou égal à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set.">Bloque le thread actuel jusqu'à ce que <see cref="T:System.Threading.CountdownEvent" /> soit défini.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un entier signé 32 bits permettant de mesurer le délai d'attente.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce que <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un entier signé 32 bits permettant de mesurer le délai d'attente, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L’instance actuelle a déjà été supprimée. - ou - le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce que <see cref="T:System.Threading.CountdownEvent" /> soit défini, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L’instance actuelle a déjà été supprimée. - ou - le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> permettant de mesurer le délai d'attente.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> permettant de mesurer le délai d'attente, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L’instance actuelle a déjà été supprimée. - ou - le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Obtient un <see cref="T:System.Threading.WaitHandle" /> qui est utilisé pour attendre l'événement à définir.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">
        <see cref="T:System.Threading.WaitHandle" /> qui est utilisé pour attendre l'événement à définir.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary vsli:raw="Indicates whether an &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; is reset automatically or manually after receiving a signal.">Indique si un <see cref="T:System.Threading.EventWaitHandle" /> est réinitialisé automatiquement ou manuellement après la réception d'un signal.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; resets automatically after releasing a single thread. If no threads are waiting, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; remains signaled until a thread blocks, and resets after releasing the thread.">Une fois signalé, le <see cref="T:System.Threading.EventWaitHandle" /> se réinitialise automatiquement après avoir libéré un seul thread. Si aucun thread n'attend, le <see cref="T:System.Threading.EventWaitHandle" /> conserve l'état signalé jusqu'à ce qu'un thread se bloque et se réinitialise après l'avoir libéré.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; releases all waiting threads and remains signaled until it is manually reset.">Lorsqu'il est signalé, le <see cref="T:System.Threading.EventWaitHandle" /> libère tous les threads en attente et conserve l'état signalé jusqu'à sa réinitialisation manuelle.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary vsli:raw="Represents a thread synchronization event.">Représente un événement de synchronisation de threads.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement et s'il se réinitialise automatiquement ou manuellement.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> pour définir l'état initial comme étant signalé ; <see langword="false" /> pour le définir comme étant non signalé.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement s'il a été créé à la suite de cet appel, s'il se réinitialise automatiquement ou manuellement, ainsi que le nom d'un événement de synchronisation du système.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Le nom d’un événement de synchronisation à l’échelle du système.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> fait plus de 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, spécifiant si le handle d’attente est signalé initialement s’il est créé suite à cet appel, s’il se réinitialise automatiquement ou manuellement, le nom d’un événement de synchronisation du système et une variable booléenne dont la valeur après l’appel indique si l’événement système nommé a été créé.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Le nom d’un événement de synchronisation à l’échelle du système.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local event was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system event was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system event already existed. This parameter is passed uninitialized.">Cette méthode retourne <see langword="true" /> si un événement local a été créé (en d'autres termes, si <paramref name="name" /> est <see langword="null" /> ou une chaîne vide) ou si l'événement système nommé spécifié a été créé ; <see langword="false" /> si l'événement système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> fait plus de 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists.">Ouvre l'événement de synchronisation nommé spécifié s'il existe déjà.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom de l’événement de synchronisation système à ouvrir.</param>
      <returns vsli:raw="An object that represents the named system event.">Objet qui représente l’événement système nommé.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> est une chaîne vide.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be opened. It may not exist, or a synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">L'événement de système nommé n'existe pas.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the security access required to use it.">L'événement nommé existe, mais l'utilisateur ne possède pas l'accès de sécurité requis pour l'utiliser.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, causing threads to block.">Définit l'état de l'événement comme étant non signalé, entraînant le blocage des threads.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l'opération aboutit ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été appelée précédemment sur <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary vsli:raw="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">Définit l'état de l'événement comme étant signalé, ce qui permet à un ou plusieurs threads en attente de continuer.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si l’opération aboutit ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été appelée précédemment sur <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.">Ouvre l’événement de synchronisation nommé spécifié, s’il existe déjà, et retourne une valeur indiquant si l’opération a réussi.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom de l’événement de synchronisation système à ouvrir.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; object that represents the named synchronization event if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.EventWaitHandle" /> qui représente l’événement de synchronisation nommé si l’appel a réussi, ou <see langword="null" /> si l’appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named synchronization event was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> si l’événement de synchronisation nommé a été ouvert ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> est une chaîne vide.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the desired security access.">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary vsli:raw="Manages the execution context for the current thread. This class cannot be inherited.">Gère le contexte d'exécution du thread actuel. Cette classe ne peut pas être héritée.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary vsli:raw="Captures the execution context from the current thread.">Capture le contexte d'exécution du thread actuel.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the execution context for the current thread.">Objet <see cref="T:System.Threading.ExecutionContext" /> capturant le contexte d'exécution du thread actuel.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current execution context.">Crée une copie du contexte d'exécution actuel.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the current execution context.">Objet <see cref="T:System.Threading.ExecutionContext" /> représentant le contexte d'exécution actuel.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This context cannot be copied because it is used. Only newly captured contexts can be copied.">Ce contexte ne peut pas être copié, car il est utilisé. Seuls les contextes récemment capturés peuvent être copiés.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Sets the specified &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object with the logical context information needed to recreate an instance of the current execution context.">Définit l'objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> spécifié avec les informations de contexte logiques nécessaires à la recréation d'une instance du contexte d'exécution en cours.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object to be populated with serialization information.">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> à remplir à l'aide des informations de sérialisation.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; structure representing the destination context of the serialization.">Structure <see cref="T:System.Runtime.Serialization.StreamingContext" /> représentant le contexte de destination de la sérialisation.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;info&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="info" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary vsli:raw="Indicates whether the flow of the execution context is currently suppressed.">Indique si le flux du contexte d'exécution est actuellement supprimé.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the flow is suppressed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le flux est supprimé ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary vsli:raw="Restores the flow of the execution context across asynchronous threads.">Restaure le flux du contexte d'exécution sur des threads asynchrones.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow cannot be restored because it is not being suppressed.">Le flux du contexte ne peut pas être restauré, car il n'est pas supprimé.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary vsli:raw="Runs a method in a specified execution context on the current thread.">Exécute une méthode dans un contexte d'exécution spécifié sur le thread actuel.</summary>
      <param name="executionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; to set.">
        <see cref="T:System.Threading.ExecutionContext" /> à définir.</param>
      <param name="callback" vsli:raw="A &lt;see cref=&quot;T:System.Threading.ContextCallback&quot; /&gt; delegate that represents the method to be run in the provided execution context.">Délégué <see cref="T:System.Threading.ContextCallback" /> représentant la méthode à exécuter dans le contexte d'exécution fourni.</param>
      <param name="state" vsli:raw="The object to pass to the callback method.">Objet à passer à la méthode de rappel.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;executionContext&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; has already been used as the argument to a &lt;see cref=&quot;M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)&quot; /&gt; call.">
        <paramref name="executionContext" /> est <see langword="null" />.

ou -
Le <paramref name="executionContext" /> n'a pas été acquis à l'aide d'une opération de capture.

ou -
Le <paramref name="executionContext" /> a déjà été utilisé comme argument pour un appel <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary vsli:raw="Suppresses the flow of the execution context across asynchronous threads.">Supprime le flux du contexte d'exécution sur des threads asynchrones.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure for restoring the flow.">Structure <see cref="T:System.Threading.AsyncFlowControl" /> pour restaurer le flux.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow is already suppressed.">Le flux du contexte est déjà supprimé.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary vsli:raw="Encapsulates and propagates the host execution context across threads.">Encapsule et propage le contexte d'exécution de l'hôte à travers des threads.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class using the specified state.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.HostExecutionContext" /> avec l'état spécifié.</summary>
      <param name="state" vsli:raw="An object representing the host execution context state.">Objet représentant l'état du contexte d'exécution de l'hôte.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current host execution context.">Crée une copie du contexte d'exécution de l'hôte en cours.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host context for the current thread.">Objet <see cref="T:System.Threading.HostExecutionContext" /> capturant le contexte de l'hôte du thread actuel.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary vsli:raw="When overridden in a derived class, releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt;, and optionally releases the managed resources.">En cas de substitution dans une classe dérivée, libère les ressources non managées utilisées par <see cref="T:System.Threading.WaitHandle" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary vsli:raw="Gets or sets the state of the host execution context.">Obtient ou définit l'état du contexte d'exécution de l'hôte.</summary>
      <returns vsli:raw="An object representing the host execution context state.">Objet représentant l'état du contexte d'exécution de l'hôte.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary vsli:raw="Provides the functionality that allows a common language runtime host to participate in the flow, or migration, of the execution context.">Fournit les fonctionnalités qui permettent à un hôte du Common Language Runtime de participer au flux, ou migration, du contexte d'exécution.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContextManager&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary vsli:raw="Captures the host execution context from the current thread.">Capture le contexte d'exécution de l'hôte du thread actuel.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host execution context of the current thread.">Objet <see cref="T:System.Threading.HostExecutionContext" /> capturant le contexte d'exécution de l'hôte du thread actuel.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary vsli:raw="Restores the host execution context to its prior state.">Restaure l'état antérieur du contexte d'exécution de l'hôte.</summary>
      <param name="previousState" vsli:raw="The previous context state to revert to.">État de contexte antérieur à restaurer.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;previousState&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; was not created on the current thread.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; is not the last state for the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt;.">
        <paramref name="previousState" /> a la valeur <see langword="null" />.

ou -
<paramref name="previousState" /> n'a pas été créé sur le thread en cours.

ou
<paramref name="previousState" /> n'est pas le dernier état du <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary vsli:raw="Sets the current host execution context to the specified host execution context.">Affecte le contexte d'exécution de l'hôte spécifié au contexte d'exécution de l'hôte actuel.</summary>
      <param name="hostExecutionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to be set.">
        <see cref="T:System.Threading.HostExecutionContext" /> à définir.</param>
      <returns vsli:raw="An object for restoring the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to its previous state.">Objet permettant de restaurer l'état antérieur du <see cref="T:System.Threading.HostExecutionContext" />.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;hostExecutionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;hostExecutionContext&quot; /&gt; has been the argument to a previous &lt;see cref=&quot;M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)&quot; /&gt; method call.">Le <paramref name="hostExecutionContext" /> n'a pas été acquis à l'aide d'une opération de capture.

ou -
Le <paramref name="hostExecutionContext" /> a été l'argument d'un appel de méthode <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" /> précédent.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary vsli:raw="Provides atomic operations for variables that are shared by multiple threads.">Fournit des opérations atomiques pour des variables partagées par plusieurs threads.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary vsli:raw="Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.">Ajoute deux entiers à 32 bits et remplace le premier entier par la somme, sous la forme d'une opération atomique.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Variable qui contient la première valeur à ajouter. La somme des deux valeurs est stockée dans <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur à ajouter à l'entier à <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">La nouvelle valeur stockée à <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary vsli:raw="Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.">Ajoute deux entiers à 64 bits et remplace le premier entier par la somme, sous la forme d’une opération atomique.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Variable qui contient la première valeur à ajouter. La somme des deux valeurs est stockée dans <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur à ajouter à l'entier à <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">La nouvelle valeur stockée à <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary vsli:raw="Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.">Compare deux nombres à virgule flottante double précision et remplace le premier en cas d'égalité.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destination, dont la valeur est comparée avec <paramref name="comparand" /> et qui peut être remplacée.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur comparée à celle de <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine dans <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary vsli:raw="Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.">Compare deux entiers signés de 32 bits et remplace la première valeur en cas d'égalité.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destination, dont la valeur est comparée avec <paramref name="comparand" /> et qui peut être remplacée.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur comparée à celle de <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine dans <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary vsli:raw="Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.">Compare deux entiers signés de 64 bits et remplace la première valeur en cas d'égalité.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destination, dont la valeur est comparée avec <paramref name="comparand" /> et qui peut être remplacée.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur comparée à celle de <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine dans <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary vsli:raw="Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.">Compare deux handles ou pointeurs spécifiques à la plateforme et remplace le premier en cas d’égalité.</summary>
      <param name="location1" vsli:raw="The destination &lt;see cref=&quot;T:System.IntPtr&quot; /&gt;, whose value is compared with the value of &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced by &lt;paramref name=&quot;value&quot; /&gt;.">Destination <see cref="T:System.IntPtr" />, dont la valeur est comparée à celle de <paramref name="comparand" /> et qui peut être remplacée par <paramref name="value" />.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that replaces the destination value if the comparison results in equality.">Valeur <see cref="T:System.IntPtr" /> qui remplace la valeur de destination si la comparaison conclut à une égalité.</param>
      <param name="comparand" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur <see cref="T:System.IntPtr" /> comparée à celle de <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine dans <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary vsli:raw="Compares two objects for reference equality and, if they are equal, replaces the first object.">Compare deux objets et remplace le premier en cas d’égalité des références.</summary>
      <param name="location1" vsli:raw="The destination object that is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Objet de destination comparé par référence à <paramref name="comparand" /> et qui peut être remplacé.</param>
      <param name="value" vsli:raw="The object that replaces the destination object if the reference comparison results in equality.">Objet qui remplace l'objet de destination si la comparaison par référence conclut à une égalité.</param>
      <param name="comparand" vsli:raw="The object that is compared by reference to the object at &lt;paramref name=&quot;location1&quot; /&gt;.">Objet qui est comparé par référence à l’objet se trouvant à l’emplacement <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine dans <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary vsli:raw="Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.">Compare deux nombres à virgule flottante simple précision et remplace le premier en cas d'égalité.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destination, dont la valeur est comparée avec <paramref name="comparand" /> et qui peut être remplacée.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur comparée à celle de <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine dans <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary vsli:raw="Compares two instances of the specified reference type &lt;paramref name=&quot;T&quot; /&gt; for reference equality and, if they are equal, replaces the first one.">Compare deux instances du type référence spécifié <paramref name="T" /> pour et remplace la première en cas d’égalité par référence.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Destination dont la valeur est comparée par référence à <paramref name="comparand" /> et qui peut être remplacée. C'est un paramètre référence (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison by reference results in equality.">Valeur qui remplace la valeur de destination si la comparaison par référence conclut à une égalité.</param>
      <param name="comparand" vsli:raw="The value that is compared by reference to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur qui est comparée par référence à la valeur se trouvant à l’emplacement <paramref name="location1" />.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt;, &lt;paramref name=&quot;value&quot; /&gt;, and &lt;paramref name=&quot;comparand&quot; /&gt;. This type must be a reference type.">Type à utiliser pour <paramref name="location1" />, <paramref name="value" /> et <paramref name="comparand" />. Ce type doit être un type référence.</typeparam>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine dans <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary vsli:raw="Decrements a specified variable and stores the result, as an atomic operation.">Décrémente une variable spécifiée et stocke le résultat, sous la forme d'une opération atomique.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Variable dont la valeur doit être décrémentée.</param>
      <returns vsli:raw="The decremented value.">Valeur décrémentée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary vsli:raw="Decrements the specified variable and stores the result, as an atomic operation.">Décrémente la variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Variable dont la valeur doit être décrémentée.</param>
      <returns vsli:raw="The decremented value.">Valeur décrémentée.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary vsli:raw="Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.">Définit une valeur spécifiée pour un nombre à virgule flottante double précision, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable à laquelle affecter la valeur spécifiée.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valeur affectée au paramètre <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary vsli:raw="Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.">Affecte un entier signé 32 bits à une valeur spécifiée, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable à laquelle affecter la valeur spécifiée.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valeur affectée au paramètre <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary vsli:raw="Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.">Affecte un entier signé 64 bits à une valeur spécifiée, puis retourne la valeur d’origine, sous la forme d’une opération atomique.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable à laquelle affecter la valeur spécifiée.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valeur affectée au paramètre <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.">Définit une valeur spécifiée pour un handle ou un pointeur spécifique à la plateforme, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable à laquelle affecter la valeur spécifiée.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valeur affectée au paramètre <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary vsli:raw="Sets an object to a specified value and returns a reference to the original object, as an atomic operation.">Définit une valeur spécifiée pour un objet, puis retourne une référence à l'objet d'origine sous la forme d'une opération atomique.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable à laquelle affecter la valeur spécifiée.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valeur affectée au paramètre <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary vsli:raw="Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.">Définit une valeur spécifiée pour un nombre à virgule flottante simple précision, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable à laquelle affecter la valeur spécifiée.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valeur affectée au paramètre <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary vsli:raw="Sets a variable of the specified type &lt;paramref name=&quot;T&quot; /&gt; to a specified value and returns the original value, as an atomic operation.">Définit une valeur spécifiée pour une variable du type <paramref name="T" /> spécifié et retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Variable à laquelle affecter la valeur spécifiée. Il s’agit d’un paramètre de référence (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valeur affectée au paramètre <paramref name="location1" />.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt;. This type must be a reference type.">Type à utiliser pour <paramref name="location1" /> et <paramref name="value" />. Ce type doit être un type référence.</typeparam>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valeur d’origine de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location1" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Incrémente une variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Variable dont la valeur doit être incrémentée.</param>
      <returns vsli:raw="The incremented value.">Valeur incrémentée.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Incrémente une variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Variable dont la valeur doit être incrémentée.</param>
      <returns vsli:raw="The incremented value.">Valeur incrémentée.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L’adresse de <paramref name="location" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary vsli:raw="Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt; execute after memory accesses that follow the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt;.">Synchronise l'accès à la mémoire comme suit : Le processeur qui exécute le thread actuel ne peut pas réorganiser les instructions de manière à ce que les accès à la mémoire antérieurs à l’appel de <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> s’exécutent après les accès à la mémoire postérieurs à l’appel de <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary vsli:raw="Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.">Fournit un cloisonnement de mémoire à l’échelle du processus qui garantit que les lectures et les écritures des processeurs ne peuvent pas se déplacer au sein du cloisonnement.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary vsli:raw="Returns a 64-bit value, loaded as an atomic operation.">Retourne une valeur de 64 bits chargée sous la forme d'une opération atomique.</summary>
      <param name="location" vsli:raw="The 64-bit value to be loaded.">Valeur 64 bits à charger.</param>
      <returns vsli:raw="The loaded value.">Valeur chargée.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary vsli:raw="Provides lazy initialization routines.">Fournit des routines d'initialisation tardives.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary vsli:raw="Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.">Initialise un type référence cible avec le constructeur sans paramètre du type, s’il n’a pas déjà été initialisé.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Référence à initialiser si elle ne l’a pas déjà été.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Type de la référence à initialiser.</typeparam>
      <returns vsli:raw="The initialized object.">Objet initialisé.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Autorisations pour accéder au constructeur de type <paramref name="T" /> manquant.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Le type <paramref name="T" /> n’a pas de constructeur sans paramètre.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary vsli:raw="Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.">Initialise un type référence cible ou un type valeur avec son constructeur sans paramètre, s’il n’a pas déjà été initialisé.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Référence ou valeur de type <c>T</c> à initialiser si elle ne l’a pas déjà été.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Référence à une valeur booléenne qui détermine si la cible a déjà été initialisée.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Référence à un objet utilisé comme verrou mutuellement exclusif pour l'initialisation de <paramref name="target" />. Si <paramref name="syncLock" /> est <see langword="null" /> null, un nouvel objet est instancié.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Type de la référence à initialiser.</typeparam>
      <returns vsli:raw="The initialized object.">Objet initialisé.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Autorisations pour accéder au constructeur de type <paramref name="T" /> manquant.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Le type <paramref name="T" /> n’a pas de constructeur sans paramètre.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference or value type by using a specified function if it hasn't already been initialized.">Initialise un type référence cible ou un type valeur à l'aide d'une fonction spécifiée s'il n'a pas déjà été initialisé.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Référence ou valeur de type <c>T</c> à initialiser si elle ne l’a pas déjà été.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Référence à une valeur booléenne qui détermine si la cible a déjà été initialisée.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Référence à un objet utilisé comme verrou mutuellement exclusif pour l'initialisation de <paramref name="target" />. Si <paramref name="syncLock" /> est <see langword="null" /> null, un nouvel objet est instancié.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference or value.">Fonction appelée pour initialiser la référence ou la valeur.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Type de la référence à initialiser.</typeparam>
      <returns vsli:raw="The initialized object.">Objet initialisé.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Autorisations pour accéder au constructeur de type <paramref name="T" /> manquant.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Le type <paramref name="T" /> n’a pas de constructeur sans paramètre.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type by using a specified function if it hasn't already been initialized.">Initialise un type référence cible à l'aide d'une fonction spécifiée s'il n'a pas déjà été initialisé.</summary>
      <param name="target" vsli:raw="The reference to initialize if it hasn't already been initialized.">Référence à initialiser si elle ne l’a pas déjà été.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference.">Fonction appelée pour initialiser la référence.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Type de la référence à initialiser.</typeparam>
      <returns vsli:raw="The initialized object.">Objet initialisé.</returns>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Le type <paramref name="T" /> n’a pas de constructeur sans paramètre.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; returned null (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> a retourné null (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type with a specified function if it has not already been initialized.">Initialise un type référence cible ou avec une fonction spécifiée s’il n’a pas déjà été initialisé.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Référence à initialiser si elle ne l’a pas déjà été.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing&#xA;            &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Référence à un objet utilisé comme verrou mutuellement exclusif pour l'initialisation de <paramref name="target" />. Si <paramref name="syncLock" /> est <see langword="null" /> null, un nouvel objet est instancié.</param>
      <param name="valueFactory" vsli:raw="The method to invoke to initialize &lt;paramref name=&quot;target&quot; /&gt;.">Méthode à appeler pour initialiser <paramref name="target" />.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Type de la référence à initialiser.</typeparam>
      <returns vsli:raw="The initialized object.">Objet initialisé.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary vsli:raw="Defines the lock that implements single-writer/multiple-reader semantics. This is a value type.">Définit le verrou qui implémente une sémantique writer unique / lecteurs multiples. Il s'agit d'un type valeur.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary vsli:raw="Indicates whether a specified object is a &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; and is equal to the current instance.">Indique si un objet spécifié est un <see cref="T:System.Threading.LockCookie" /> et est égal à l'instance actuelle.</summary>
      <param name="obj" vsli:raw="The object to compare to the current instance.">Objet à comparer avec l'instance actuelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value of &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la valeur de <paramref name="obj" /> est égale à la valeur de l'instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether the current instance is equal to the specified &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt;.">Détermine si l'instance actuelle est égale à l'objet <see cref="T:System.Threading.LockCookie" /> spécifié.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to the current instance.">
        <see cref="T:System.Threading.LockCookie" /> à comparer à l'instance en cours.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="obj" /> est égal à la valeur de l'instance actuelle ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retourne le code de hachage de cette instance.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Code de hachage d'un entier signé 32 bits.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are equal.">Indique si deux structures <see cref="T:System.Threading.LockCookie" /> sont égales.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> à comparer à <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> à comparer à <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="a" /> est égal à <paramref name="b" /> ; sinon <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are not equal.">Indique si deux structures <see cref="T:System.Threading.LockCookie" /> ne sont pas égales.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> à comparer à <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> à comparer à <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is not equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="a" /> n'est pas égal à <paramref name="b" /> ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary vsli:raw="The exception that is thrown when recursive entry into a lock is not compatible with the recursion policy for the lock.">L'exception levée lorsque l'entrée récursive dans un verrou n'est pas compatible avec la stratégie de récurrence pour le verrou.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a system-supplied message that describes the error.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.LockRecursionException" /> avec un message système qui décrit l'erreur.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with serialized data.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.LockRecursionException" /> avec des données sérialisées.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Objet qui contient les données sérialisées de l'objet.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Informations contextuelles sur la source ou la destination.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified message that describes the error.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.LockRecursionException" /> avec un message spécifié décrivant l'erreur.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Message décrivant l'exception. L'appelant de ce constructeur doit vérifier que cette chaîne a été localisée pour la culture système en cours.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.LockRecursionException" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Message décrivant l'exception. L'appelant de ce constructeur doit vérifier que cette chaîne a été localisée pour la culture système en cours.</param>
      <param name="innerException" vsli:raw="The exception that caused the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Exception à l'origine de l'exception actuelle. Si le paramètre <paramref name="innerException" /> n'est pas <see langword="null" />, l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary vsli:raw="Specifies whether a lock can be entered multiple times by the same thread.">Spécifie si un verrou peut être entré plusieurs fois par le même thread.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary vsli:raw="If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.">Si un thread essaie d'entrer un verrou de manière récursive, une exception est levée. Certaines classes peuvent autoriser certaines récurrences lorsque ce paramètre est appliqué.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary vsli:raw="A thread can enter a lock recursively. Some classes may restrict this capability.">Un thread peut entrer un verrou de manière récursive. Certaines classes peuvent restreindre cette fonction.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class cannot be inherited.">Représente un événement de synchronisation de thread qui, quand il est signalé, doit être réinitialisé manuellement. Cette classe ne peut pas être héritée.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ManualResetEvent" /> avec une valeur booléenne indiquant si l'état initial doit être défini comme signalé.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to nonsignaled.">
        <see langword="true" /> pour définir un état initial signalé ; <see langword="false" /> pour définir un état initial non signalé.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class is a lightweight alternative to &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt;.">Représente un événement de synchronisation de thread qui, quand il est signalé, doit être réinitialisé manuellement. Cette classe est une alternative légère à <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with an initial state of nonsignaled.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ManualResetEventSlim" /> avec "non signalé" comme état initial.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ManualResetEventSlim" /> avec une valeur booléenne indiquant si l'état initial doit être défini comme signalé.</summary>
      <param name="initialState" vsli:raw="true to set the initial state signaled; false to set the initial state to nonsignaled.">true pour définir l'état initial à "signalé" ; false pour le définir à "non signalé".</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled and a specified spin count.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ManualResetEventSlim" /> avec une valeur booléenne indiquant si l’état initial doit être défini comme étant signalé et un nombre de spins spécifié.</summary>
      <param name="initialState" vsli:raw="true to set the initial state to signaled; false to set the initial state to nonsignaled.">true pour définir l'état initial à "signalé" ; false pour le définir à "non signalé".</param>
      <param name="spinCount" vsli:raw="The number of spin waits that will occur before falling back to a kernel-based wait operation.">Nombre d'attentes de spins qui se produiront avant de revenir à une opération d'attente basée sur le noyau.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;spinCount&quot; /&gt; is less than 0 or greater than the maximum allowed value.">
        <paramref name="spinCount" /> est inférieur à 0 ou supérieur à la valeur maximale autorisée.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;, and optionally releases the managed resources.">Libère les ressources non managées utilisées par le <see cref="T:System.Threading.ManualResetEventSlim" />, et libère éventuellement les ressources managées.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true pour libérer les ressources managées et non managées ; false pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary vsli:raw="Gets whether the event is set.">Obtient une valeur qui indique si l'événement est défini.</summary>
      <returns vsli:raw="true if the event is set; otherwise, false.">true si l'événement est défini ; sinon, false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, which causes threads to block.">Définit l'état de l'événement à "non signalé", ce qui entraîne le blocage des threads.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'objet a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary vsli:raw="Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.">Définit l'état de l'événement à "signalé", ce qui permet à un ou plusieurs threads en attente sur l'événement de continuer à s'exécuter.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary vsli:raw="Gets the number of spin waits that will occur before falling back to a kernel-based wait operation.">Obtient le nombre d’attentes de spins qui se produiront avant de revenir à une opération d’attente basée sur le noyau.</summary>
      <returns vsli:raw="Returns the number of spin waits that will occur before falling back to a kernel-based wait operation.">Retourne le nombre d’attentes de spins qui se produiront avant de revenir à une opération d’attente basée sur le noyau.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel soit défini.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Le nombre maximal de serveurs a été dépassé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'objet a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel soit défini, à l'aide d'un entier signé 32 bits pour mesurer l'intervalle de temps.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.ManualResetEventSlim" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Le nombre maximal de serveurs a été dépassé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'objet a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel soit défini, à l'aide d'un entier signé 32 bits pour mesurer l'intervalle de temps, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.ManualResetEventSlim" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Le nombre maximal de serveurs a été dépassé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">L'objet a déjà été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé<paramref name="cancellationToken" /> a été supprimé.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; receives a signal, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel reçoive un signal, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Le nombre maximal de serveurs a été dépassé.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">L'objet a déjà été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé<paramref name="cancellationToken" /> a été supprimé.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was&#xA;            canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> pour mesurer l'intervalle de temps.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.ManualResetEventSlim" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.

ou -
Le nombre de millisecondes dans <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Le nombre maximal de serveurs a été dépassé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'objet a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> pour mesurer l'intervalle de temps, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <see cref="T:System.Threading.ManualResetEventSlim" /> a été défini ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.

ou -
Le nombre de millisecondes dans <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Le nombre maximal de serveurs a été dépassé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">L'objet a déjà été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé<paramref name="cancellationToken" /> a été supprimé.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Obtient l'objet <see cref="T:System.Threading.WaitHandle" /> sous-jacent pour ce <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns vsli:raw="The underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; event object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Objet d'événement <see cref="T:System.Threading.WaitHandle" /> sous-jacent pour ce <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary vsli:raw="Provides a mechanism that synchronizes access to objects.">Fournit un mécanisme qui synchronise l'accès aux objets.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object.">Acquiert un verrou exclusif sur l'objet spécifié.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the monitor lock.">Objet sur lequel acquérir le verrou du moniteur.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Acquiert un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objet sur lequel attendre.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.  &#xA;  &#xA; Note   If no exception occurs, the output of this method is always &lt;see langword=&quot;true&quot; /&gt;.">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.
Remarque   Si aucune exception ne se produit, la sortie de cette méthode est toujours <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary vsli:raw="Releases an exclusive lock on the specified object.">Libère un verrou exclusif sur l'objet spécifié.</summary>
      <param name="obj" vsli:raw="The object on which to release the lock.">Objet sur lequel libérer le verrou.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread does not own the lock for the specified object.">Le thread en cours ne possède pas le verrou pour l'objet spécifié.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary vsli:raw="Determines whether the current thread holds the lock on the specified object.">Détermine si le thread actuel détient le verrou sur l'objet spécifié.</summary>
      <param name="obj" vsli:raw="The object to test.">Objet à tester.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the lock on &lt;paramref name=&quot;obj&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel détient le verrou sur <paramref name="obj" /> ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;obj&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary vsli:raw="Gets the number of times there was contention when trying to take the monitor's lock.">Obtient le nombre de fois où il y a eu de la contention lors des tentatives de prendre le verrou du moniteur.</summary>
      <returns vsli:raw="The number of times there was contention when trying to take the monitor's lock.">Nombre de conflits lors de la tentative d’exécution du verrou du moniteur.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary vsli:raw="Notifies a thread in the waiting queue of a change in the locked object's state.">Avertit un thread situé dans la file d'attente en suspens d'un changement d'état de l'objet verrouillé.</summary>
      <param name="obj" vsli:raw="The object a thread is waiting for.">Objet attendu par un thread.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary vsli:raw="Notifies all waiting threads of a change in the object's state.">Avertit tous les threads en attente d'un changement d'état de l'objet.</summary>
      <param name="obj" vsli:raw="The object that sends the pulse.">Objet qui envoie l'impulsion.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object.">Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objet sur lequel acquérir le verrou.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Tente d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objet sur lequel acquérir le verrou.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.">Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours du nombre spécifié de millisecondes.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objet sur lequel acquérir le verrou.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Délai d'attente du verrou en millisecondes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> est négatif et n’est pas égal à <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Tente, pendant le nombre spécifié de millisecondes, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objet sur lequel acquérir le verrou.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Délai d'attente du verrou en millisecondes.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> est négatif et n’est pas égal à <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.">Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours de la période spécifiée.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objet sur lequel acquérir le verrou.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">
        <see cref="T:System.TimeSpan" /> représentant le délai d'attente du verrou. Une valeur de -1 milliseconde spécifie une attente infinie.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">La valeur de <paramref name="timeout" /> en millisecondes est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde), ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Tente, pendant le délai spécifié, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objet sur lequel acquérir le verrou.</param>
      <param name="timeout" vsli:raw="The amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">Délai d'attente du verrou. Une valeur de -1 milliseconde spécifie une attente infinie.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">La valeur de <paramref name="timeout" /> en millisecondes est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde), ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock.">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objet sur lequel attendre.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.">
        <see langword="true" /> si l'appel est retourné parce que l'appelant a de nouveau acquis le verrou pour l'objet spécifié. Cette méthode ne retourne rien si le verrou n'est pas acquis à nouveau.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objet sur lequel attendre.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">La valeur du paramètre <paramref name="millisecondsTimeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle. Cette méthode spécifie également si le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) est abandonné avant l'attente et acquis à nouveau par la suite.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objet sur lequel attendre.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> n’est pas appelé à partir d’un bloc de code synchronisé.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">La valeur du paramètre <paramref name="millisecondsTimeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objet sur lequel attendre.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">
        <see cref="T:System.TimeSpan" /> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;timeout&quot; /&gt; parameter in milliseconds is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">La valeur en millisecondes du paramètre <paramref name="timeout" /> est négative et ne représente pas <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde) ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle. Le domaine de synchronisation associé au contexte synchronisé peut être abandonné avant l’attente et acquis de nouveau par la suite.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objet sur lequel attendre.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">
        <see cref="T:System.TimeSpan" /> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> n’est pas appelé à partir d’un bloc de code synchronisé.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Le thread qui appelle Wait quitte ensuite l’état d’attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;timeout&quot; /&gt; parameter is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Le paramètre <paramref name="timeout" /> est négatif et ne représente pas <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde), ou est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary vsli:raw="A synchronization primitive that can also be used for interprocess synchronization.">Primitive de synchronisation qui peut également être utilisée pour la synchronisation entre processus.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with default properties.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec des propriétés par défaut.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the mutex; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour accorder au thread appelant la propriété initiale du mutex ; sinon, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex, et une chaîne représentant le nom du mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour donner au thread appelant la propriété initiale du mutex système nommé si celui-ci est créé en réponse à cet appel ; sinon, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom du <see cref="T:System.Threading.Mutex" />. Si cette valeur est <see langword="null" />, <see cref="T:System.Threading.Mutex" /> est sans nom.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">Le mutex nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Le mutex nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> fait plus de 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex, une chaîne qui représente le nom du mutex et une valeur booléenne qui, quand la méthode retourne son résultat, indique si la propriété initiale du mutex a été accordée au thread appelant.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> pour donner au thread appelant la propriété initiale du mutex système nommé si celui-ci est créé en réponse à cet appel ; sinon, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom du <see cref="T:System.Threading.Mutex" />. Si cette valeur est <see langword="null" />, <see cref="T:System.Threading.Mutex" /> est sans nom.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains a Boolean that is &lt;see langword=&quot;true&quot; /&gt; if a local mutex was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system mutex was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system mutex already existed. This parameter is passed uninitialized.">Cette méthode retourne une valeur booléenne qui est <see langword="true" /> si un mutex local a été créé (en d'autres termes, si <paramref name="name" /> est <see langword="null" /> ou une chaîne vide) ou si le mutex système nommé spécifié a été créé ; <see langword="false" /> si le mutex système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">Le mutex nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Le mutex nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> fait plus de 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists.">Ouvre le mutex nommé spécifié s'il existe déjà.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom du mutex système à ouvrir.</param>
      <returns vsli:raw="An object that represents the named system mutex.">Objet qui représente le mutex système nommé.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> est une chaîne vide.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">Le mutex nommé n'existe pas.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">Le mutex nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; once.">Libère l'objet <see cref="T:System.Threading.Mutex" /> une seule fois.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The calling thread does not own the mutex.">Le thread appelant ne possède pas le mutex.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.">Ouvre le mutex nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom du mutex système à ouvrir.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the named mutex if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Mutex" /> qui représente la structure mutex nommée si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named mutex was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> si le mutex nommé a été ouvert ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> est une chaîne vide.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">Le mutex nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary vsli:raw="Defines a lock that supports single writers and multiple readers.">Définit un verrou qui prend en charge  les writers uniques et les lecteurs multiples.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLock&quot; /&gt; class.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary vsli:raw="Acquires a reader lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Acquiert un verrou de lecteur en utilisant une valeur <see cref="T:System.Int32" /> comme délai d'attente.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Délai en millisecondes.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="millisecondsTimeout" /> expire avant que la demande de verrou soit accordée.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary vsli:raw="Acquires a reader lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Acquiert un verrou de lecteur en utilisant une valeur <see cref="T:System.TimeSpan" /> comme délai d'attente.</summary>
      <param name="timeout" vsli:raw="A &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">
        <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary vsli:raw="Acquires the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Acquiert un verrou de writer en utilisant une valeur <see cref="T:System.Int32" /> comme délai d'attente.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Délai en millisecondes.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary vsli:raw="Acquires the writer lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Acquiert un verrou de writer en utilisant une valeur <see cref="T:System.TimeSpan" /> comme délai d'attente.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">
        <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary vsli:raw="Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.">Indique si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence.</summary>
      <param name="seqNum" vsli:raw="The sequence number.">Numéro de séquence.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le verrou de writer a été accordé à un thread depuis l'obtention du numéro de séquence ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt; was called.">Restaure le verrou du thread à l'état qu'il avait avant l'appel à <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> retourné par <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">Le thread n'a pas de verrou de writer.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">L’adresse de <paramref name="lockCookie" /> est un pointeur null.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds a reader lock.">Obtient une valeur indiquant si le thread actif détient un verrou de lecteur.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds a reader lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actif détient un verrou de lecteur ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds the writer lock.">Obtient une valeur indiquant si le thread actif détient le verrou de writer.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the writer lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actif détient le verrou de writer ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary vsli:raw="Releases the lock, regardless of the number of times the thread acquired the lock.">Libère le verrou quel que soit le nombre de fois où il a été acquis par le thread.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value representing the released lock.">Valeur <see cref="T:System.Threading.LockCookie" /> représentant le verrou libéré.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary vsli:raw="Decrements the lock count.">Décrémente le nombre de verrous.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have any reader or writer locks.">Le thread n'a pas de verrous de writer ou de lecteur.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary vsli:raw="Decrements the lock count on the writer lock.">Décrémente le nombre de verrous sur le verrou de writer.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">Le thread n'a pas de verrou de writer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before calling &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Restaure l'état de verrou du thread au moment précédant l'appel à <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> retourné par <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">L’adresse de <paramref name="lockCookie" /> est un pointeur null.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <see langword="Int32" /> pour définir le délai d'attente.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Délai en millisecondes.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Valeur <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="millisecondsTimeout" /> expire avant que la demande de verrou soit accordée.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using a &lt;see langword=&quot;TimeSpan&quot; /&gt; value for the time-out.">Met à niveau un verrou de lecteur vers le verrou de writer en utilisant une valeur <see langword="TimeSpan" /> pour définir le délai d'attente.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">
        <see langword="TimeSpan" /> spécifiant la durée du délai d'attente.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Valeur <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expire avant que la demande de verrou soit accordée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> spécifie une valeur négative autre que -1 milliseconde.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary vsli:raw="Gets the current sequence number.">Obtient le numéro de séquence actuel.</summary>
      <returns vsli:raw="The current sequence number.">Numéro de séquence actuel.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary vsli:raw="Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.">Représente un verrou utilisé pour gérer l'accès à une ressource, en autorisant plusieurs threads pour la lecture ou un accès exclusif en écriture.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class with default property values.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> avec des valeurs de propriété par défaut.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class, specifying the lock recursion policy.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, en spécifiant la stratégie de récurrence du verrou.</summary>
      <param name="recursionPolicy" vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Une des valeurs d'énumération qui spécifie la stratégie de récurrence du verrou.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary vsli:raw="Gets the total number of unique threads that have entered the lock in read mode.">Obtient le nombre total de threads uniques qui ont entré le verrou en mode lecture.</summary>
      <returns vsli:raw="The number of unique threads that have entered the lock in read mode.">Nombre de threads uniques qui ont entré le verrou en mode lecture.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingReadCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount&quot; /&gt; is greater than zero.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> est supérieur à zéro.

ou -
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> est supérieur à zéro.

ou -
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> est supérieur à zéro.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary vsli:raw="Tries to enter the lock in read mode.">Essaie d'entrer le verrou en mode lecture.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the read lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the write lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, et le thread actuel a tenté d’acquérir le verrou en lecture alors qu’il le détient déjà.
ou
La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, et le thread actuel a tenté d’acquérir le verrou en lecture alors qu’il détient déjà le verrou en écriture.

ou -
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne devraient normalement jamais rencontrer cette exception.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode.">Essaie d'entrer le verrou en mode de mise à niveau.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou dans un mode quelconque.

ou -
Le thread actuel est entré en mode lecture, et une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage.

ou -
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary vsli:raw="Tries to enter the lock in write mode.">Essaie d'entrer le verrou en mode écriture.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou dans un mode quelconque.
ou
Le thread actuel est entré en mode lecture et n’a pas de verrou en écriture. Une tentative d’entrer le verrou en mode écriture risquerait donc de créer un interblocage.
ou
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary vsli:raw="Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).">Réduit le nombre de récurrences pour le mode lecture, et quitte le mode lecture si le compte résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in read mode.">Le thread actuel n'a pas entré le verrou en mode lecture.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary vsli:raw="Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).">Réduit le nombre de récurrences pour le mode de mise à niveau, et quitte le mode de mise à niveau si le compte résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in upgradeable mode.">Le thread actuel n'a pas entré le verrou en mode de mise à niveau.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary vsli:raw="Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).">Réduit le nombre de récurrences pour le mode écriture, et quitte le mode écriture si le compte résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in write mode.">Le thread actuel n'a pas entré le verrou en mode écriture.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in read mode.">Obtient une valeur qui indique si le thread actuel a entré le verrou en mode lecture.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered read mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel a entré le verrou en mode lecture ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.">Obtient une valeur qui indique si le thread actuel a entré le verrou en mode de mise à niveau.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered upgradeable mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel a entré le verrou en mode de mise à niveau ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in write mode.">Obtient une valeur qui indique si le thread actuel a entré le verrou en mode écriture.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered write mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel a entré le verrou en mode écriture ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary vsli:raw="Gets a value that indicates the recursion policy for the current &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object.">Obtient une valeur qui indique la stratégie de récurrence pour l'objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> actuel.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Une des valeurs d'énumération qui spécifie la stratégie de récurrence du verrou.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.">Obtient le nombre de fois où le thread actuel a entré le verrou en mode lecture, comme une indication de récurrence.</summary>
      <returns vsli:raw="0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.">0 (zéro) si le thread actuel n'a pas entré le verrou en mode lecture, 1 si le thread a entré le verrou en mode lecture mais pas de façon récursive, ou n si le thread a entré le verrou de façon récursive n - 1 fois.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.">Obtient le nombre de fois où le thread actuel a entré le verrou en mode de mise à niveau, comme une indication de récurrence.</summary>
      <returns vsli:raw="0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.">0 si le thread actuel n'a pas entré le verrou en mode pouvant être mis à niveau, 1 si le thread a entré le verrou en mode pouvant être mis à niveau mais pas de façon récursive, ou n si le thread a entré le verrou en mode pouvant être mis à niveau de façon récursive n - 1 fois.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.">Obtient le nombre de fois où le thread actuel a entré le verrou en mode écriture, comme une indication de récurrence.</summary>
      <returns vsli:raw="0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.">0 si le n si le thread a entré le verrou en mode écriture de façon récursive n - 1 fois.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional integer time-out.">Essaie d'entrer le verrou en mode lecture, avec un délai d'attente entier facultatif.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Nombre de millisecondes à attendre, ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread appelant est entré en mode lecture, sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.

ou -
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional time-out.">Essaie d'entrer le verrou en mode lecture, avec un délai d'attente facultatif.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervalle d'attente, ou -1 millisecondes pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread appelant est entré en mode lecture, sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.

ou -
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.

ou -
La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Essaie d'entrer le verrou en mode de mise à niveau, avec un délai d'attente facultatif.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Nombre de millisecondes à attendre, ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread appelant est entré en mode de mise à niveau, sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.

ou -
Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage.

ou
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Essaie d'entrer le verrou en mode de mise à niveau, avec un délai d'attente facultatif.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervalle d'attente, ou -1 millisecondes pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread appelant est entré en mode de mise à niveau, sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.

ou -
Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage.

ou -
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.

ou -
La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Essaie d'entrer le verrou en mode écriture, avec un délai d'attente facultatif.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Nombre de millisecondes à attendre, ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread appelant est entré en mode écriture, sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.

ou -
Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode écriture risquerait de créer un interblocage.

ou -
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Essaie d'entrer le verrou en mode écriture, avec un délai d'attente facultatif.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervalle d'attente, ou -1 millisecondes pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread appelant est entré en mode écriture, sinon, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.

ou -
Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode écriture risquerait de créer un interblocage.

ou -
Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.

ou -
La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in read mode.">Obtient le nombre total de threads qui attendent pour entrer le verrou en mode lecture.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter read mode.">Le nombre total des threads qui attendent pour entrer en mode lecture.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in upgradeable mode.">Obtient le nombre total de threads qui attendent pour entrer le verrou en mode de mise à niveau.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter upgradeable mode.">Le nombre total des threads qui attendent pour entrer en mode de mise à niveau.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in write mode.">Obtient le nombre total de threads qui attendent pour entrer le verrou en mode écriture.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter write mode.">Le nombre total des threads qui attendent pour entrer en mode écriture.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary vsli:raw="Limits the number of threads that can access a resource or pool of resources concurrently.">Limite le nombre de threads qui peuvent accéder simultanément à une ressource ou à un pool de ressources.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d’entrées et le nombre maximal d’entrées simultanées.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Nombre maximal de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.">
        <paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> est inférieur à 1.

ou -
<paramref name="initialCount" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d’entrées et le nombre maximal d’entrées simultanées, et en spécifiant en option le nom d’un objet sémaphore système.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Nombre maximal de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom d'un objet de sémaphore système nommé.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> est inférieur à 1.

ou -
<paramref name="initialCount" /> est inférieur à 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées, en spécifiant en option le nom d'un objet sémaphore système et en spécifiant une variable qui reçoit une valeur indiquant si un sémaphore système a été créé.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be satisfied concurrently.">Nombre initial de demandes pour le sémaphore qui peut être satisfait simultanément.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be satisfied concurrently.">Nombre maximal de demandes pour le sémaphore qui peut être satisfait simultanément.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom d'un objet de sémaphore système nommé.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local semaphore was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system semaphore was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system semaphore already existed. This parameter is passed uninitialized.">Cette méthode retourne <see langword="true" /> si un sémaphore local a été créé (en d'autres termes, si <paramref name="name" /> est <see langword="null" /> ou une chaîne vide) ou si le sémaphore système nommé spécifié a été créé ; <see langword="false" /> si le sémaphore système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> est inférieur à 1.

ou -
<paramref name="initialCount" /> est inférieur à 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists.">Ouvre le sémaphore nommé spécifié s'il existe déjà.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom du sémaphore système à ouvrir.</param>
      <returns vsli:raw="An object that represents the named system semaphore.">Objet qui représente le sémaphore système nommé.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> est une chaîne vide.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">Le sémaphore nommé n'existe pas.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary vsli:raw="Exits the semaphore and returns the previous count.">Quitte le sémaphore et retourne le compteur antérieur.</summary>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Compteur du sémaphore avant appel de la méthode <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">Le compteur du sémaphore est déjà à la valeur maximale.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Une erreur Win32 s'est produite avec un sémaphore nommé.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.">Le sémaphore actuel représente un sémaphore système nommé, mais l'utilisateur ne détient pas de droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.

ou -
Le sémaphore actuel représente un sémaphore système nommé, mais il n'a pas été ouvert avec des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary vsli:raw="Exits the semaphore a specified number of times and returns the previous count.">Quitte le sémaphore un nombre spécifié de fois et retourne le compteur précédent.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">Nombre de fois où quitter le sémaphore.</param>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Compteur du sémaphore avant appel de la méthode <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> est inférieur à 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">Le compteur du sémaphore est déjà à la valeur maximale.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Une erreur Win32 s'est produite avec un sémaphore nommé.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.">Le sémaphore actuel représente un sémaphore système nommé, mais l'utilisateur ne détient pas de droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.

ou -
Le sémaphore actuel représente un sémaphore système nommé, mais il n'a pas été ouvert avec des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.">Ouvre le sémaphore nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nom du sémaphore système à ouvrir.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; object that represents the named semaphore if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Semaphore" /> qui représente le sémaphore nommé si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named semaphore was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> si le sémaphore nommé a été ouvert ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> est une chaîne vide.

ou -
<paramref name="name" /> fait plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> est <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Une erreur Win32 s’est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary vsli:raw="The exception that is thrown when the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method is called on a semaphore whose count is already at the maximum.">Exception levée lorsque la méthode <see cref="Overload:System.Threading.Semaphore.Release" /> est appelée sur un sémaphore dont le compteur est déjà au maximum.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with default values.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SemaphoreFullException" /> avec des valeurs par défaut.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with serialized data.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SemaphoreFullException" /> avec des données sérialisées.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données d’objet sérialisées relatives à l’exception levée.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient les informations contextuelles sur la source ou la destination.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SemaphoreFullException" /> avec un message d'erreur spécifié.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Message d'erreur qui explique la raison de l'exception.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SemaphoreFullException" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Message d'erreur qui explique la raison de l'exception.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Exception ayant provoqué l'exception actuelle. Si le paramètre <paramref name="innerException" /> n'est pas <see langword="null" />, l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary vsli:raw="Represents a lightweight alternative to &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; that limits the number of threads that can access a resource or pool of resources concurrently.">Représente une alternative légère à <see cref="T:System.Threading.Semaphore" /> qui limite le nombre de threads pouvant accéder simultanément à une ressource ou à un pool de ressources.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial number of requests that can be granted concurrently.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SemaphoreSlim" />, en spécifiant le nombre initial de demandes qui peuvent être accordées simultanément.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial and maximum number of requests that can be granted concurrently.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SemaphoreSlim" />, en spécifiant le nombre initial et le nombre maximal de demandes qui peuvent être accordées simultanément.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
      <param name="maxCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Nombre maximal de demandes pour le sémaphore qui peut être accordé simultanément.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0, or &lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maxCount&quot; /&gt;, or &lt;paramref name=&quot;maxCount&quot; /&gt; is equal to or less than 0.">
        <paramref name="initialCount" /> est inférieur à 0 ou <paramref name="initialCount" /> est supérieur à <paramref name="maxCount" /> ou <paramref name="maxCount" /> est inférieur ou égal à 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Retourne un <see cref="T:System.Threading.WaitHandle" /> qui peut être utilisé pour attendre sur un sémaphore.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">
        <see cref="T:System.Threading.WaitHandle" /> qui peut être utilisé pour l'attente sur le sémaphore.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> a été supprimé.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary vsli:raw="Gets the number of remaining threads that can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object.">Obtient le nombre de threads restants qui peuvent accéder à l'objet <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="The number of remaining threads that can enter the semaphore.">Nombre de threads restants qui peuvent accéder au sémaphore.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, and optionally releases the managed resources.">Libère les ressources non managées utilisées par le <see cref="T:System.Threading.SemaphoreSlim" />, et libère éventuellement les ressources managées.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object once.">Libère l’objet <see cref="T:System.Threading.SemaphoreSlim" /> une seule fois.</summary>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Décompte précédent de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">Le <see cref="T:System.Threading.SemaphoreSlim" /> a déjà atteint sa taille maximale.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object a specified number of times.">Libère l’objet <see cref="T:System.Threading.SemaphoreSlim" /> un nombre de fois déterminé.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">Nombre de fois où quitter le sémaphore.</param>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Décompte précédent de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> est inférieur à 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">Le <see cref="T:System.Threading.SemaphoreSlim" /> a déjà atteint sa taille maximale.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Bloque le thread actuel jusqu'à ce qu'il puisse accéder à <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout.">Bloque le thread actuel jusqu'à ce qu'il puisse entrer dans <see cref="T:System.Threading.SemaphoreSlim" />, à l'aide d'un entier signé 32 bits qui spécifie le délai d'attente.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Nombre de millisecondes à attendre, <see cref="F:System.Threading.Timeout.Infinite" />(-1) pour attendre indéfiniment, ou zéro pour tester l’état du handle d’attente et retourner immédiatement.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel est entré avec succès dans le <see cref="T:System.Threading.SemaphoreSlim" /> ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif autre que -1, qui représente un délai d’expiration infini - ou - le délai d’attente est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce qu'il puisse entrer dans <see cref="T:System.Threading.SemaphoreSlim" />, à l'aide d'un entier signé 32 bits qui spécifie le délai d'attente, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Nombre de millisecondes à attendre, <see cref="F:System.Threading.Timeout.Infinite" />(-1) pour attendre indéfiniment, ou zéro pour tester l’état du handle d’attente et retourner immédiatement.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel est entré avec succès dans le <see cref="T:System.Threading.SemaphoreSlim" /> ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif autre que -1, qui représente un délai d’expiration infini.

ou -

<paramref name="millisecondsTimeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; instance has been disposed, or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">L’instance <see cref="T:System.Threading.SemaphoreSlim" /> a été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé le jeton <paramref name="cancellationToken" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce qu'il puisse accéder à <see cref="T:System.Threading.SemaphoreSlim" />, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Jeton <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA; -or-&#xA;&#xA; The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L’instance actuelle a déjà été supprimée.

ou -
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to specify the timeout.">Bloque le thread actuel jusqu'à ce qu'il puisse entrer dans <see cref="T:System.Threading.SemaphoreSlim" />, à l'aide d'un <see cref="T:System.TimeSpan" /> pour spécifier le délai d'attente.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre, <see cref="T:System.TimeSpan" /> qui représente -1 millisecondes pour attendre indéfiniment ou <see cref="T:System.TimeSpan" /> qui représente 0 milliseconde pour tester le handle d’attente et retourner immédiatement.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel est entré avec succès dans le <see cref="T:System.Threading.SemaphoreSlim" /> ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1, qui représente un délai d’expiration infini.

ou -

<paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.">L’instance semaphoreSlim a été supprimée.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloque le thread actuel jusqu'à ce qu'il puisse entrer dans <see cref="T:System.Threading.SemaphoreSlim" />, à l'aide d'un <see cref="T:System.TimeSpan" /> qui spécifie le délai d'attente, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre, <see cref="T:System.TimeSpan" /> qui représente -1 millisecondes pour attendre indéfiniment ou <see cref="T:System.TimeSpan" /> qui représente 0 milliseconde pour tester le handle d’attente et retourner immédiatement.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si le thread actuel est entré avec succès dans le <see cref="T:System.Threading.SemaphoreSlim" /> ; sinon, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-.&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1, qui représente un délai d’expiration infini.
-ou-.
<paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L’instance semaphoreSlim a été supprimée.

ou -

Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">De façon asynchrone attentes d'entrer <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Tâche qui se termine après l’accès au sémaphore.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> a été supprimé.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval.">Attend de façon asynchrone avant d'entrer <see cref="T:System.Threading.SemaphoreSlim" />, en utilisant un entier signé 32 bits pour mesurer l'intervalle de temps.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Nombre de millisecondes à attendre, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour attendre indéfiniment, ou zéro pour tester l’état du handle d’attente et retourner immédiatement.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tâche qui se termine avec une valeur <see langword="true" /> si le thread actuel accède correctement à <see cref="T:System.Threading.SemaphoreSlim" />, sinon la valeur <see langword="false" /> est retournée.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif autre que -1, qui représente un délai d’expiration infini.

ou -
<paramref name="millisecondsTimeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Attend de façon asynchrone avant d'entrer <see cref="T:System.Threading.SemaphoreSlim" />, en utilisant un entier signé 32 bits pour mesurer l'intervalle de temps, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Nombre de millisecondes à attendre, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour attendre indéfiniment, ou zéro pour tester l’état du handle d’attente et retourner immédiatement.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tâche qui se termine avec une valeur <see langword="true" /> si le thread actuel accède correctement à <see cref="T:System.Threading.SemaphoreSlim" />, sinon la valeur <see langword="false" /> est retournée.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> est un nombre autre que -1, qui représente un délai d’attente infini.

ou -

<paramref name="millisecondsTimeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Attend de façon asynchrone avant d'entrer <see cref="T:System.Threading.SemaphoreSlim" />, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Jeton <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Tâche qui ne se termine lorsque le sémaphore a été spécifié.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Attend de façon asynchrone avant d'entrer <see cref="T:System.Threading.SemaphoreSlim" />, en utilisant <see cref="T:System.TimeSpan" /> pour mesurer l'intervalle de temps.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre, <see cref="T:System.TimeSpan" /> qui représente -1 millisecondes pour attendre indéfiniment ou <see cref="T:System.TimeSpan" /> qui représente 0 milliseconde pour tester le handle d’attente et retourner immédiatement.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tâche qui se termine avec une valeur <see langword="true" /> si le thread actuel accède correctement à <see cref="T:System.Threading.SemaphoreSlim" />, sinon la valeur <see langword="false" /> est retournée.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L’instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1, qui représente un délai d’expiration infini.

ou -
<paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Attend de façon asynchrone avant d'entrer <see cref="T:System.Threading.SemaphoreSlim" />, en utilisant <see cref="T:System.TimeSpan" /> pour mesurer l'intervalle de temps, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre, <see cref="T:System.TimeSpan" /> qui représente -1 millisecondes pour attendre indéfiniment ou <see cref="T:System.TimeSpan" /> qui représente 0 milliseconde pour tester le handle d’attente et retourner immédiatement.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Jeton <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tâche qui se termine avec une valeur <see langword="true" /> si le thread actuel accède correctement à <see cref="T:System.Threading.SemaphoreSlim" />, sinon la valeur <see langword="false" /> est retournée.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1, qui représente un délai d’expiration infini.

ou -

<paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">
        <see cref="T:System.Threading.SemaphoreSlim" /> a été supprimé.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary vsli:raw="Represents a method to be called when a message is to be dispatched to a synchronization context.">Représente une méthode à appeler lorsqu'un message doit être distribué à un contexte de synchronisation.</summary>
      <param name="state" vsli:raw="The object passed to the delegate.">Objet passé au délégué.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary vsli:raw="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.">Fournit une primitive de verrou d'exclusion mutuelle où un thread, qui tente d'acquérir le verrou, attend dans une boucle en effectuant des vérifications de manière répétée jusqu'à ce que le verrou devienne disponible.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SpinLock&quot; /&gt; structure with the option to track thread IDs to improve debugging.">Initialise une nouvelle instance de la structure de <see cref="T:System.Threading.SpinLock" /> avec l'option permettant de suivre les ID de thread afin d'améliorer le débogage.</summary>
      <param name="enableThreadOwnerTracking" vsli:raw="Whether to capture and use thread IDs for debugging purposes.">Indique s'il faut capturer et utiliser des ID de thread à des fins de débogage.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary vsli:raw="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Acquiert le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True si le verrou est acquis ; sinon, false. <paramref name="lockTaken" /> doit être initialisé avec la valeur false avant l'appel à cette méthode.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling Enter.">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler ENTRÉE.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary vsli:raw="Releases the lock.">Libère le verrou.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary vsli:raw="Releases the lock.">Libère le verrou.</summary>
      <param name="useMemoryBarrier" vsli:raw="A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.">Valeur booléenne qui indique si une barrière mémoire doit être émise pour publier immédiatement l'opération de sortie sur d'autres threads.</param>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">Le suivi de la propriété du thread est autorisé, et le thread actuel n'est pas le propriétaire de ce verrou.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary vsli:raw="Gets whether the lock is currently held by any thread.">Obtient une valeur qui indique si le verrou est actuellement détenu par un thread.</summary>
      <returns vsli:raw="true if the lock is currently held by any thread; otherwise false.">True si le verrou est actuellement détenu par un thread ; sinon, false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary vsli:raw="Gets whether the lock is held by the current thread.">Obtient une valeur qui indique si le verrou est détenu par le thread actuel.</summary>
      <returns vsli:raw="true if the lock is held by the current thread; otherwise false.">True si le verrou est détenu par le thread actuel ; sinon, false.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Thread ownership tracking is disabled.">Le suivi de la propriété du thread est désactivé.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary vsli:raw="Gets whether thread ownership tracking is enabled for this instance.">Obtient une valeur qui indique si le suivi de la propriété des threads est activé pour cette instance.</summary>
      <returns vsli:raw="true if thread ownership tracking is enabled for this instance; otherwise false.">True si le suivi de la propriété du thread est autorisé pour cette instance ; sinon, false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True si le verrou est acquis ; sinon, false. <paramref name="lockTaken" /> doit être initialisé avec la valeur false avant l'appel à cette méthode.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True si le verrou est acquis ; sinon, false. <paramref name="lockTaken" /> doit être initialisé avec la valeur false avant l'appel à cette méthode.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tente d'acquérir le verrou de façon fiable, de sorte que même si une exception se produit dans l'appel de méthode, <paramref name="lockTaken" /> peut être examiné de façon fiable pour déterminer si le verrou a été acquis.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True si le verrou est acquis ; sinon, false. <paramref name="lockTaken" /> doit être initialisé avec la valeur false avant l'appel à cette méthode.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" /> millisecondes.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">L'argument <paramref name="lockTaken" /> doit être initialisé sur false avant d'appeler TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Le suivi de la propriété du thread est activé et le thread actuel a déjà acquis ce verrou.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary vsli:raw="Provides support for spin-based waiting.">Prend en charge l'attente basée sur les spins.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary vsli:raw="Gets the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Obtient le nombre de fois où <see cref="M:System.Threading.SpinWait.SpinOnce" /> a été appelé sur cette instance.</summary>
      <returns vsli:raw="Returns an integer that represents the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Retourne un entier qui représente le nombre d'appels de <see cref="M:System.Threading.SpinWait.SpinOnce" /> sur cette instance.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary vsli:raw="Gets whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Obtient une valeur qui indique si l'appel suivant à <see cref="M:System.Threading.SpinWait.SpinOnce" /> générera le processeur, en déclenchant un changement de contexte forcé.</summary>
      <returns vsli:raw="Whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Indique si l'appel suivant à <see cref="M:System.Threading.SpinWait.SpinOnce" /> générera le processeur, en déclenchant un changement de contexte forcé.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary vsli:raw="Resets the spin counter.">Réinitialise le compteur de spins.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary vsli:raw="Performs a single spin.">Exécute un seul spin.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary vsli:raw="Performs a single spin and calls &lt;see cref=&quot;M:System.Threading.Thread.Sleep(System.Int32)&quot; /&gt; after a minimum spin count.">Effectue un seul spin et appelle <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> après un nombre minimal de spins.</summary>
      <param name="sleep1Threshold" vsli:raw="A minimum spin count after which &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt; may be used. A value of -1 disables the use of &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt;.">Nombre minimal de spins après lequel <see langword="Thread.Sleep(1)" /> peut être utilisé. La valeur -1 désactive l’utilisation de <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sleep1Threshold&quot; /&gt; is less than -1.">
        <paramref name="sleep1Threshold" /> est inférieur à -1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary vsli:raw="Spins until the specified condition is satisfied.">Effectue des spins jusqu'à ce que la condition spécifiée soit satisfaite.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Délégué à exécuter de façon répétée jusqu'à ce qu'il retourne la valeur true.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">L’argument <paramref name="condition" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Effectue des spins jusqu'à ce que la condition spécifiée soit satisfaite ou jusqu'à ce que le délai d'attente expire.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Délégué à exécuter de façon répétée jusqu'à ce qu'il retourne la valeur true.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> si la condition est satisfaite dans le délai imparti ; sinon, false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">L’argument <paramref name="condition" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Effectue des spins jusqu'à ce que la condition spécifiée soit satisfaite ou jusqu'à ce que le délai d'attente expire.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Délégué à exécuter de façon répétée jusqu'à ce qu'il retourne la valeur true.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre, ou TimeSpan qui représente -1 millième de seconde pour attendre indéfiniment.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> si la condition est satisfaite dans le délai imparti ; sinon, false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">L’argument <paramref name="condition" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary vsli:raw="Provides the basic functionality for propagating a synchronization context in various synchronization models.">Fournit les fonctionnalités de base pour propager un contexte de synchronisation dans plusieurs modèles de synchronisation.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; class.">Crée une instance de la classe <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary vsli:raw="When overridden in a derived class, creates a copy of the synchronization context.">En cas de substitution dans une classe dérivée, crée une copie du contexte de synchronisation.</summary>
      <returns vsli:raw="A new &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object.">Nouvel objet <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary vsli:raw="Gets the synchronization context for the current thread.">Obtient le contexte de synchronisation du thread actuel.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object representing the current synchronization context.">Objet <see cref="T:System.Threading.SynchronizationContext" /> représentant le contexte de synchronisation actuel.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary vsli:raw="Determines if wait notification is required.">Détermine si une notification de périodes d'attente est requise.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if wait notification is required; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si une notification de périodes d'attente est requise ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has completed.">Lors d'une substitution dans une classe dérivée, répond à la notification selon laquelle une opération est terminée.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has started.">Lors d'une substitution dans une classe dérivée, répond à la notification selon laquelle une opération est lancée.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches an asynchronous message to a synchronization context.">Lors d'une substitution dans une classe dérivée, distribue un message asynchrone à un contexte de synchronisation.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Délégué <see cref="T:System.Threading.SendOrPostCallback" /> à appeler.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Objet passé au délégué.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches a synchronous message to a synchronization context.">Lors d’une substitution dans une classe dérivée, distribue un message synchrone à un contexte de synchronisation.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Délégué <see cref="T:System.Threading.SendOrPostCallback" /> à appeler.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Objet passé au délégué.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="The method was called in a Windows Store app. The implementation of &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; for Windows Store apps does not support the &lt;see cref=&quot;M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)&quot; /&gt; method.">La méthode a été appelée dans une application Windows Store. L'implémentation de <see cref="T:System.Threading.SynchronizationContext" /> pour les applications Windows Store ne prend pas en charge la méthode <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary vsli:raw="Sets the current synchronization context.">Définit le contexte de synchronisation actuel.</summary>
      <param name="syncContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object to be set.">Objet <see cref="T:System.Threading.SynchronizationContext" /> à définir.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary vsli:raw="Sets notification that wait notification is required and prepares the callback method so it can be called more reliably when a wait occurs.">Définit une notification selon laquelle une notification de périodes d'attente est requise et prépare la méthode de rappel pour qu'elle puisse être appelée de manière plus fiable lorsqu'une attente se produit.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Waits for any or all the elements in the specified array to receive a signal.">Attend que tout ou une partie des éléments du tableau spécifié reçoivent un signal.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Tableau de type <see cref="T:System.IntPtr" /> contenant les handles de système d'exploitation natifs.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles; &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" /> pour attendre tous les handles ; <see langword="false" /> pour attendre un handle quelconque.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Index du tableau de l'objet ayant respecté l'attente.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;waitHandles&quot; /&gt; is null.">
        <paramref name="waitHandles" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Helper function that waits for any or all the elements in the specified array to receive a signal.">Fonction d'assistance attendant que tout ou une partie des éléments du tableau spécifié reçoivent un signal.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Tableau de type <see cref="T:System.IntPtr" /> contenant les handles de système d'exploitation natifs.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles;  &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" /> pour attendre tous les handles ; <see langword="false" /> pour attendre un handle quelconque.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Index du tableau de l'objet ayant respecté l'attente.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary vsli:raw="The exception that is thrown when a method requires the caller to own the lock on a given Monitor, and the method is invoked by a caller that does not own that lock.">Exception levée lorsqu'une méthode exige de l'appelant qu'il possède un verrou sur un objet Monitor donné et que la méthode est appelée par un appelant qui ne possède pas ce verrou.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with default properties.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SynchronizationLockException" /> avec des propriétés par défaut.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with serialized data.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SynchronizationLockException" /> avec des données sérialisées.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; that holds the serialized object data about the exception being thrown.">
        <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données d'objet sérialisées concernant l'exception levée.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; that contains contextual information about the source or destination.">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient des informations contextuelles relatives à la source ou à la destination.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SynchronizationLockException" /> avec un message d'erreur spécifié.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Message d'erreur qui explique la raison de l'exception.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.SynchronizationLockException" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Message d'erreur qui explique la raison de l'exception.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Exception ayant provoqué l'exception actuelle. Si le paramètre <paramref name="innerException" /> n'est pas <see langword="null" />, l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary vsli:raw="Provides thread-local storage of data.">Fournit le stockage local des données de thread.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of data stored per-thread.">Spécifie le type de données stockées par thread.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Initialise l’instance <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance and specifies whether all values are accessible from any thread.">Initialise l’instance <see cref="T:System.Threading.ThreadLocal`1" /> et spécifie si toutes les valeurs sont accessibles à partir de n’importe quel thread.</summary>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> pour suivre toutes les valeurs définies dans l’instance et les exposer par le biais de la propriété <see cref="P:System.Threading.ThreadLocal`1.Values" /> ; <see langword="false" /> sinon.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function.">Initialise l'instance de <see cref="T:System.Threading.ThreadLocal`1" /> avec la fonction <paramref name="valueFactory" /> spécifiée.</summary>
      <param name="valueFactory" vsli:raw="The  &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">
        <see cref="T:System.Func`1" /> appelé pour produire une valeur initialisée tardivement quand une tentative est effectuée pour récupérer <see cref="P:System.Threading.ThreadLocal`1.Value" /> sans qu’il ait été précédemment initialisé.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> est une référence Null (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function and a flag that indicates whether all values are accessible from any thread.">Initialise l’instance <see cref="T:System.Threading.ThreadLocal`1" /> avec la fonction <paramref name="valueFactory" /> spécifiée et un indicateur qui indique si toutes les valeurs sont accessibles à partir de n’importe quel thread.</summary>
      <param name="valueFactory" vsli:raw="The &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">
        <see cref="T:System.Func`1" /> appelé pour produire une valeur initialisée tardivement lorsqu'une tentative est effectuée pour récupérer <see cref="P:System.Threading.ThreadLocal`1.Value" /> sans qu'il ait été précédemment initialisé.</param>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> pour suivre toutes les valeurs définies dans l’instance et les exposer par le biais de la propriété <see cref="P:System.Threading.ThreadLocal`1.Values" /> ; <see langword="false" /> sinon.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">
        <paramref name="valueFactory" /> est une référence <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; class.">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Libère les ressources utilisées par cette instance de <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing" vsli:raw="A Boolean value that indicates whether this method is being called due to a call to &lt;see cref=&quot;M:System.Threading.ThreadLocal`1.Dispose&quot; /&gt;.">Valeur booléenne qui indique si cette méthode est appelée en raison d'un appel à <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Libère les ressources utilisées par cette instance de <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary vsli:raw="Gets whether &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread.">Obtient une valeur qui indique si <see cref="P:System.Threading.ThreadLocal`1.Value" /> est initialisé sur le thread actuel.</summary>
      <returns vsli:raw="true if &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread; otherwise false.">True si <see cref="P:System.Threading.ThreadLocal`1.Value" /> est initialisé sur le thread actuel ; sinon, false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’instance <see cref="T:System.Threading.ThreadLocal`1" /> a été supprimée.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary vsli:raw="Creates and returns a string representation of this instance for the current thread.">Crée et retourne une représentation sous forme de chaîne de cette instance pour le thread actuel.</summary>
      <returns vsli:raw="The result of calling &lt;see cref=&quot;M:System.Object.ToString&quot; /&gt; on the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt;.">Résultat de l'appel à <see cref="M:System.Object.ToString" /> sur <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’instance <see cref="T:System.Threading.ThreadLocal`1" /> a été supprimée.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; for the current thread is a null reference (Nothing in Visual Basic).">Le <see cref="P:System.Threading.ThreadLocal`1.Value" /> du thread actuel est une référence null (Nothing en Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">La fonction d'initialisation a tenté de référencer <see cref="P:System.Threading.ThreadLocal`1.Value" /> de manière récursive.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Aucun constructeur sans paramètre n’est fourni et aucune fabrique de valeurs n’est fournie.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of this instance for the current thread.">Obtient ou définit la valeur de cette instance pour le thread actuel.</summary>
      <returns vsli:raw="Returns an instance of the object that this ThreadLocal is responsible for initializing.">Retourne une instance de l'objet dont ce ThreadLocal est chargé de l'initialisation.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’instance <see cref="T:System.Threading.ThreadLocal`1" /> a été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">La fonction d'initialisation a tenté de référencer <see cref="P:System.Threading.ThreadLocal`1.Value" /> de manière récursive.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Aucun constructeur sans paramètre n’est fourni et aucune fabrique de valeurs n’est fournie.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary vsli:raw="Gets a list containing the values stored by all threads that have accessed this instance.">Obtient une liste de toutes les valeurs actuellement stockées par tous les threads qui ont accès à cette instance.</summary>
      <returns vsli:raw="A list for all of the values stored by all of the threads that have accessed this instance.">Liste de toutes les valeurs actuellement stockées par tous les threads qui ont accès à cette instance.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Values stored by all threads are not available because this instance was initialized with the &lt;paramref name=&quot;trackAllValues&quot; /&gt; argument set to &lt;see langword=&quot;false&quot; /&gt; in the call to a class constructor.">Les valeurs stockées par tous les threads ne sont pas disponibles, car cette instance a été initialisée avec l’argument <paramref name="trackAllValues" /> défini sur <see langword="false" /> dans l’appel à un constructeur de classe.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’instance <see cref="T:System.Threading.ThreadLocal`1" /> a été supprimée.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary vsli:raw="Contains methods for performing volatile memory operations.">Contient des méthodes pour effectuer des opérations de mémoire volatile.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la valeur du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant cette méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <returns vsli:raw="The value that was read.">Valeur qui a été lue. Il s'agit de la dernière valeur écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary vsli:raw="Reads the object reference from the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lit la référence d'objet à partir du champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît après cette méthode dans le code, le processeur ne peut pas la déplacer avant la méthode.</summary>
      <param name="location" vsli:raw="The field to read.">Champ à lire.</param>
      <typeparam name="T" vsli:raw="The type of field to read. This must be a reference type, not a value type.">Type du champ à lire. Il doit s'agir d'un type référence, et non d'un type valeur.</typeparam>
      <returns vsli:raw="The reference to &lt;paramref name=&quot;T&quot; /&gt; that was read. This reference is the latest written by any processor in the computer, regardless of the number of processors or the state of processor cache.">Référence à <paramref name="T" /> qui a été lue. Il s'agit de la dernière référence écrite par un processeur de l'ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeur.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la valeur spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Champ dans lequel la valeur est écrite.</param>
      <param name="value" vsli:raw="The value to write.">Valeur à écrire. La valeur est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary vsli:raw="Writes the specified object reference to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Écrit la référence d'objet spécifiée dans le champ spécifié. Sur les systèmes qui en ont besoin, insère une barrière mémoire qui empêche le processeur de réorganiser les opérations de mémoire comme suit : Si une opération de lecture ou d'écriture apparaît avant cette méthode dans le code, le processeur ne peut pas la déplacer après la méthode.</summary>
      <param name="location" vsli:raw="The field where the object reference is written.">Champ dans lequel la référence d'objet est écrite.</param>
      <param name="value" vsli:raw="The object reference to write.">Référence d'objet à écrire. La référence est écrite immédiatement, de sorte qu'elle est visible pour tous les processeurs de l'ordinateur.</param>
      <typeparam name="T" vsli:raw="The type of field to write. This must be a reference type, not a value type.">Type du champ dans lequel écrire. Il doit s'agir d'un type référence, et non d'un type valeur.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary vsli:raw="The exception that is thrown when an attempt is made to open a system mutex, semaphore, or event wait handle that does not exist.">Exception levée durant une tentative d’ouverture d’un mutex système, d’un sémaphore ou d’un handle d’attente d’événement qui n’existe pas.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with default values.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> avec des valeurs par défaut.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with serialized data.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> avec des données sérialisées.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données d’objet sérialisées relatives à l’exception levée.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient les informations contextuelles sur la source ou la destination.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> avec un message d'erreur spécifié.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Message d'erreur qui explique la raison de l'exception.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Message d'erreur qui explique la raison de l'exception.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Exception ayant provoqué l'exception actuelle. Si le paramètre <paramref name="innerException" /> n'est pas <see langword="null" />, l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
    </member>
  </members>
</doc>