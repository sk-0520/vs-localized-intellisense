<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary vsli:raw="The exception that is thrown when one thread acquires a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that another thread has abandoned by exiting without releasing it.">Eccezione generata quando un thread acquisisce un oggetto <see cref="T:System.Threading.Mutex" /> che un altro thread ha abbandonato uscendo senza rilasciarlo.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with default values.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con i valori predefiniti.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con un indice specificato per il mutex abbandonato, se applicabile, e un oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex.</summary>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Indice del mutex abbandonato nella matrice degli handle di attesa se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o-1 se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> oppure <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with serialized data.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con dati serializzati.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati di oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con un messaggio di errore specificato.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Messaggio di errore che spiega il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message and inner exception.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con il messaggio di errore e l'eccezione interna specificati.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Messaggio di errore che spiega il motivo dell'eccezione.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="inner" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the inner exception, the index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con il messaggio di errore, l'eccezione interna, l'indice per il mutex abbandonato, se applicabile, specificati e un oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Messaggio di errore che spiega il motivo dell'eccezione.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="inner" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Indice del mutex abbandonato nella matrice degli handle di attesa se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o-1 se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> oppure <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the index of the abandoned mutex, if applicable, and the abandoned mutex.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.AbandonedMutexException" /> con il messaggio di errore, l'indice del mutex abbandonato, se applicabile, e il mutex abbandonato specificati.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Messaggio di errore che spiega il motivo dell'eccezione.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Indice del mutex abbandonato nella matrice degli handle di attesa se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o-1 se l'eccezione viene generata per il metodo <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> oppure <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary vsli:raw="Gets the abandoned mutex that caused the exception, if known.">Ottiene il mutex abbandonato che ha causato l'eccezione, se noto.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or &lt;see langword=&quot;null&quot; /&gt; if the abandoned mutex could not be identified.">Oggetto <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex abbandonato oppure <see langword="null" /> se il mutex abbandonato non è stato identificato.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary vsli:raw="Gets the index of the abandoned mutex that caused the exception, if known.">Ottiene l'indice del mutex abbandonato che ha causato l'eccezione, se noto.</summary>
      <returns vsli:raw="The index, in the array of wait handles passed to the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or -1 if the index of the abandoned mutex could not be determined.">Indice, nella matrice di handle di attesa passati al <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> metodo, <see cref="T:System.Threading.Mutex" /> dell'oggetto che rappresenta il mutex abbandonato oppure-1 se non è stato possibile determinare l'indice del mutex abbandonato.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary vsli:raw="Provides the functionality to restore the migration, or flow, of the execution context between threads.">Fornisce la funzionalità per ripristinare la migrazione, o flusso, del contesto di esecuzione fra thread.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">La struttura <see cref="T:System.Threading.AsyncFlowControl" /> non viene utilizzata sul thread in cui è stata creata.
In alternativa
La struttura <see cref="T:System.Threading.AsyncFlowControl" /> è già stata utilizzata per chiamare il metodo <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified object is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Determina se l'oggetto specificato è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</summary>
      <param name="obj" vsli:raw="An object to compare with the current structure.">Oggetto da confrontare con la struttura corrente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure and is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> è una struttura <see cref="T:System.Threading.AsyncFlowControl" /> ed è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Determines whether the specified &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Determina se la struttura <see cref="T:System.Threading.AsyncFlowControl" /> specificata è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</summary>
      <param name="obj" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure to compare with the current structure.">Struttura <see cref="T:System.Threading.AsyncFlowControl" /> da confrontare con la struttura corrente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> è uguale alla struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Ottiene un codice hash per la struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Codice hash per la struttura <see cref="T:System.Threading.AsyncFlowControl" /> corrente.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are equal.">Confronta due strutture <see cref="T:System.Threading.AsyncFlowControl" /> per stabilire se sono uguali.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two structures are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le due strutture sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are not equal.">Confronta due strutture <see cref="T:System.Threading.AsyncFlowControl" /> per stabilire se sono diverse.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Struttura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the structures are not equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se le strutture non sono uguali; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary vsli:raw="Restores the flow of the execution context between threads.">Ripristina il flusso del contesto di esecuzione fra i thread.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">La struttura <see cref="T:System.Threading.AsyncFlowControl" /> non viene utilizzata sul thread in cui è stata creata.
-oppure-
La struttura <see cref="T:System.Threading.AsyncFlowControl" /> è già stata utilizzata per chiamare il metodo <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary vsli:raw="Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.">Rappresenta dati di ambiente locali rispetto a un flusso di controllo asincrono specificato, ad esempio un metodo asincrono.</summary>
      <typeparam name="T" vsli:raw="The type of the ambient data.">Tipo dei dati di ambiente.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instance that does not receive change notifications.">Crea un'istanza dell'istanza di <see cref="T:System.Threading.AsyncLocal`1" /> che non riceve notifiche di modifica.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; local instance that receives change notifications.">Crea un'istanza dell'istanza di <see cref="T:System.Threading.AsyncLocal`1" /> locale che riceve notifiche di modifica.</summary>
      <param name="valueChangedHandler" vsli:raw="The delegate that is called whenever the current value changes on any thread.">Delegato chiamato ogni volta che il valore corrente cambia in qualsiasi thread.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of the ambient data.">Ottiene o imposta il valore dei dati di ambiente.</summary>
      <returns vsli:raw="The value of the ambient data. If no value has been set, the returned value is &lt;c&gt;default(T)&lt;/c&gt;.">Valore dei dati di ambiente. Se non è stato impostato alcun valore, il valore restituito è <c>default (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary vsli:raw="The class that provides data change information to &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instances that register for change notifications.">Classe che fornisce le informazioni di modifica dei dati alle istanze di <see cref="T:System.Threading.AsyncLocal`1" /> registrate per le notifiche di modifica.</summary>
      <typeparam name="T" vsli:raw="The type of the data.">Tipo di dati.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary vsli:raw="Gets the data's current value.">Ottiene il valore corrente dei dati.</summary>
      <returns vsli:raw="The data's current value.">Valore corrente dei dati.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary vsli:raw="Gets the data's previous value.">Ottiene il valore precedente dei dati.</summary>
      <returns vsli:raw="The data's previous value.">Valore precedente dei dati.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary vsli:raw="Returns a value that indicates whether the value changes because of a change of execution context.">Restituisce un valore che indica se il valore cambia a seguito di una modifica del contesto di esecuzione.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value changed because of a change of execution context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se il valore è stato modificato a causa di una modifica del contesto di esecuzione. in caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, resets automatically after releasing a single waiting thread. This class cannot be inherited.">Rappresenta un evento di sincronizzazione thread che viene reimpostato automaticamente quando viene segnalato, dopo avere rilasciato un singolo thread in attesa. Questa classe non può essere ereditata.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AutoResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.AutoResetEvent" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to non-signaled.">
        <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostare lo stato iniziale su non segnalato.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary vsli:raw="Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.">Consente a più attività di funzionare in modo cooperativo in un algoritmo in parallelo tramite più fasi.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Numero di thread che partecipano.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> è minore di 0 o maggiore di 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Numero di thread che partecipano.</param>
      <param name="postPhaseAction" vsli:raw="The &lt;see cref=&quot;T:System.Action`1&quot; /&gt; to be executed after each phase. null (Nothing in Visual Basic) may be passed to indicate no action is taken.">Oggetto <see cref="T:System.Action`1" /> da eseguire dopo ogni fase. null (Nothing in Visual Basic) può essere passato per non indicare che non viene intrapresa alcuna azione.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> è minore di 0 o maggiore di 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be an additional participant.">Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che sarà presente un partecipante aggiuntivo.</summary>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Numero di fase della barriera in corrispondenza di cui parteciperanno inizialmente i nuovi partecipanti.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Adding a participant would cause the barrier's participant count to exceed 32,767.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">L'aggiunta di un partecipante provocherebbe il superamento del conteggio del partecipante della barriera di 32.767.
-oppure-
Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be additional participants.">Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che saranno presenti partecipanti aggiuntivi.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to add to the barrier.">Numero di partecipanti aggiuntivi da aggiungere alla barriera.</param>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Numero di fase della barriera in corrispondenza di cui parteciperanno inizialmente i nuovi partecipanti.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0.  &#xA;  &#xA; -or-  &#xA;  &#xA; Adding &lt;paramref name=&quot;participantCount&quot; /&gt; participants would cause the barrier's participant count to exceed 32,767.">
        <paramref name="participantCount" /> è minore di 0.
-oppure-
L'aggiunta di partecipanti <paramref name="participantCount" /> provocherebbe il superamento del conteggio del partecipante della barriera di 32.767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary vsli:raw="Gets the number of the barrier's current phase.">Ottiene il numero di fase corrente della barriera.</summary>
      <returns vsli:raw="Returns the number of the barrier's current phase.">Restituisce il numero di fase corrente della barriera.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt;, and optionally releases the managed resources.">Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.Barrier" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">True per rilasciare sia le risorse gestite sia quelle non gestite; false per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary vsli:raw="Gets the total number of participants in the barrier.">Ottiene il numero totale di partecipanti nella barriera.</summary>
      <returns vsli:raw="Returns the total number of participants in the barrier.">Restituisce il numero totale di partecipanti nella barriera.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary vsli:raw="Gets the number of participants in the barrier that haven't yet signaled in the current phase.">Ottiene il numero di partecipanti nella barriera che non hanno ancora eseguito la segnalazione nella fase corrente.</summary>
      <returns vsli:raw="Returns the number of participants in the barrier that haven't yet signaled in the current phase.">Restituisce il numero di partecipanti nella barriera che non hanno ancora segnalato nella fase corrente.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be one less participant.">Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che sarà presente un partecipante in meno.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">La barriera dispone già di 0 partecipanti.
-oppure-
Il metodo è stato richiamato dall'interno di un'azione post-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be fewer participants.">Notifica all'oggetto <see cref="T:System.Threading.Barrier" /> che saranno presenti meno partecipanti.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to remove from the barrier.">Numero di partecipanti aggiuntivi da rimuovere dalla barriera.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The total participant count is less than the specified &lt;paramref name=&quot;participantCount&quot; /&gt;">Il conteggio totale dei partecipanti è minore del <paramref name="participantCount" /> specificato</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current participant count is less than the specified participantCount.">La barriera dispone già di 0 partecipanti.
-oppure-
Il metodo è stato richiamato dall'interno di un'azione post-fase.
-oppure-
il conteggio del partecipante corrente è minore del conteggio del partecipante specificato</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well.">Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Se un'eccezione viene generata da un'azione post-fase di una Barriera dopo che tutti thread che partecipano hanno chiamato SignalAndWait, l'eccezione verrà sottoposta a wrapping in un BarrierPostPhaseException e sarà generata su tutti i thread che partecipano.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout.">Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un Signed Integer a 32 bit per misurare il timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se tutti i partecipanti raggiungono la barriera entro il tempo specificato; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Se un'eccezione viene generata da un'azione post-fase di una Barriera dopo che tutti thread che partecipano hanno chiamato SignalAndWait, l'eccezione verrà sottoposta a wrapping in un BarrierPostPhaseException e sarà generata su tutti i thread che partecipano.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout, while observing a cancellation token.">Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un Signed Integer a 32 bit per misurare il timeout, al contempo osservando un token di annullamento.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">true se tutti i partecipanti raggiungono la barriera entro il tempo specificato; in caso contrario, false.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier, while observing a cancellation token.">Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, al contempo osservando un token di annullamento.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval.">Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se tutti gli altri partecipanti hanno raggiunto la barriera; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out, or it is greater than 32,767.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito, oppure è più grande di 32.767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval, while observing a cancellation token.">Segnala che un partecipante ha raggiunto la barriera e attende che venga raggiunta anche da tutti gli altri partecipanti, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo, al contempo osservando un token di annullamento.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se tutti gli altri partecipanti hanno raggiunto la barriera; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">Il metodo viene richiamato dall'interno di un'azione post-fase, la barriera dispone attualmente di 0 partecipanti o la barriera viene segnalata da più thread registrati come partecipanti.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary vsli:raw="The exception that is thrown when the post-phase action of a &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; fails.">Eccezione generata quando l'azione post-fase di un oggetto <see cref="T:System.Threading.Barrier" /> non viene eseguita correttamente.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a system-supplied message that describes the error.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con un messaggio fornito dal sistema in cui viene descritto l'errore.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with the specified inner exception.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con l'eccezione interna specificata.</summary>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception.">Eccezione che ha determinato l'eccezione corrente.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with serialized data.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con dati serializzati.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Oggetto che contiene i dati oggetto serializzati.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified message that describes the error.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con un messaggio specificato in cui viene descritto l'errore.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Messaggio in cui viene descritta l'eccezione. Il chiamante del costruttore deve garantire che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.BarrierPostPhaseException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Messaggio in cui viene descritta l'eccezione. Il chiamante del costruttore deve garantire che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary vsli:raw="Represents a method to be called within a new context.">Rappresenta un metodo da chiamare all'interno di un nuovo contesto.</summary>
      <param name="state" vsli:raw="An object containing information to be used by the callback method each time it executes.">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback ogni volta che viene eseguito.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary vsli:raw="Represents a synchronization primitive that is signaled when its count reaches zero.">Rappresenta una primitiva di sincronizzazione segnalata quando il relativo conteggio raggiunge lo zero.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class with the specified count.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.CountdownEvent" /> con il conteggio specificato.</summary>
      <param name="initialCount" vsli:raw="The number of signals initially required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Numero di segnali inizialmente richiesti per impostare l'oggetto <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by one.">Incrementa di uno il conteggio corrente di <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">L'istanza corrente è già impostata.
-oppure-
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è uguale a o maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by a specified value.">Incrementa di un valore specificato il conteggio corrente di <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Valore che indica l'incremento di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> è minore o uguale a 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; after count is incremented by &lt;paramref name=&quot;signalCount&quot; /&gt;.">L'istanza corrente è già impostata.
-oppure-
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è uguale o maggiore a <see cref="F:System.Int32.MaxValue" /> dopo che il conteggio è incrementato da <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary vsli:raw="Gets the number of remaining signals required to set the event.">Ottiene il numero di segnali restanti necessari per impostare l'evento.</summary>
      <returns vsli:raw="The number of remaining signals required to set the event.">Numero di segnali restanti necessari per impostare l'evento.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, and optionally releases the managed resources.">Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.CountdownEvent" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">True per rilasciare sia le risorse gestite sia quelle non gestite; false per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary vsli:raw="Gets the numbers of signals initially required to set the event.">Ottiene il numero di segnali necessari inizialmente per impostare l'evento.</summary>
      <returns vsli:raw="The number of signals initially required to set the event.">Numero di segnali necessari inizialmente per impostare l'evento.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary vsli:raw="Indicates whether the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; object's current count has reached zero.">Indica se il conteggio corrente dell'oggetto <see cref="T:System.Threading.CountdownEvent" /> ha raggiunto lo zero.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current count is zero; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il conteggio corrente è zero. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; to the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt;.">Reimposta <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> sul valore di <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt; property to a specified value.">Reimposta la proprietà <see cref="P:System.Threading.CountdownEvent.InitialCount" /> al valore specificato.</summary>
      <param name="count" vsli:raw="The number of signals required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Numero di segnali necessari per impostare l'oggetto <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is less than 0.">
        <paramref name="count" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary vsli:raw="Registers a signal with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Registra un segnale con l'oggetto <see cref="T:System.Threading.CountdownEvent" />, decrementando il valore di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signal caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il conteggio ha raggiunto lo zero a causa del segnale e l'evento è stato impostato; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.">L'istanza corrente è già impostata.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary vsli:raw="Registers multiple signals with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by the specified amount.">Registra più segnali con l'oggetto <see cref="T:System.Threading.CountdownEvent" />, decrementandone il valore di <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> della quantità specificata.</summary>
      <param name="signalCount" vsli:raw="The number of signals to register.">Numero di segnali da registrare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signals caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il conteggio ha raggiunto lo zero a causa dei segnali e l'evento è stato impostato; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than 1.">
        <paramref name="signalCount" /> è minore di 1.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set. -or- Or &lt;paramref name=&quot;signalCount&quot; /&gt; is greater than &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">L'istanza corrente è già impostata. oppure <paramref name="signalCount" /> è maggiore di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by one.">Tenta di incrementare <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> di uno.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero, this method will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'incremento ha avuto esito positivo; in caso contrario, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è già zero, questo metodo restituirà <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è uguale a <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by a specified value.">Tenta di incrementare <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> in base a un valore specificato.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Valore che indica l'incremento di <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero this will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'incremento ha avuto esito positivo; in caso contrario, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> è già zero, verrà restituito <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> è minore o uguale a 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; + &lt;paramref name=&quot;signalCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> è uguale a o maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un intero con segno a 32 bit per misurare il timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un intero con segno a 32 bit per misurare il timeout e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L'istanza corrente è già stata eliminata. oppure l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> aveva creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L'istanza corrente è già stata eliminata. oppure l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> aveva creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare il timeout.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.CountdownEvent" /> non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare il timeout e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.CountdownEvent" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L'istanza corrente è già stata eliminata. oppure l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> aveva creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Ottiene un oggetto <see cref="T:System.Threading.WaitHandle" /> utilizzato per attendere l'impostazione dell'evento.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Oggetto <see cref="T:System.Threading.WaitHandle" /> utilizzato per attendere l'impostazione dell'evento.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary vsli:raw="Indicates whether an &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; is reset automatically or manually after receiving a signal.">Indica se <see cref="T:System.Threading.EventWaitHandle" /> verrà reimpostato automaticamente o manualmente dopo la ricezione di un segnale.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; resets automatically after releasing a single thread. If no threads are waiting, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; remains signaled until a thread blocks, and resets after releasing the thread.">Con la segnalazione, <see cref="T:System.Threading.EventWaitHandle" /> viene reimpostato automaticamente dopo il rilascio di un singolo thread. Se non sono presenti thread in attesa, <see cref="T:System.Threading.EventWaitHandle" /> resta segnalato fino al blocco di un thread e viene reimpostato dopo il rilascio del thread.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; releases all waiting threads and remains signaled until it is manually reset.">Con la segnalazione, <see cref="T:System.Threading.EventWaitHandle" /> rilascia tutti i thread in attesa e resta segnalato finché non viene reimpostato manualmente.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary vsli:raw="Represents a thread synchronization event.">Rappresenta un evento di sincronizzazione dei thread.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato e se la reimpostazione viene eseguita automaticamente o manualmente.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostarlo su non segnalato.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato se creato a seguito di questa chiamata e se la reimpostazione viene eseguita automaticamente o manualmente e indicando il nome di un evento di sincronizzazione di sistema.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome di un evento di sincronizzazione a livello di sistema.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema e una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome di un evento di sincronizzazione a livello di sistema.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local event was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system event was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system event already existed. This parameter is passed uninitialized.">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato; <see langword="false" /> se l'evento di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists.">Apre l'evento di sincronizzazione denominato specificato, se esistente.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
      <returns vsli:raw="An object that represents the named system event.">Oggetto che rappresenta l'evento di sistema denominato.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be opened. It may not exist, or a synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">L'evento di sistema denominato non esiste.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the security access required to use it.">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per utilizzarlo.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, causing threads to block.">Imposta lo stato dell'evento su non segnalato, provocando il blocco dei thread.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary vsli:raw="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">Imposta lo stato dell'evento su segnalato, per consentire a uno o più thread in attesa di procedere.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.">Apre l'evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; object that represents the named synchronization event if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named synchronization event was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the desired security access.">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary vsli:raw="Manages the execution context for the current thread. This class cannot be inherited.">Gestisce il contesto di esecuzione per il thread corrente. Questa classe non può essere ereditata.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary vsli:raw="Captures the execution context from the current thread.">Acquisisce il contesto di esecuzione dal thread corrente.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the execution context for the current thread.">Oggetto <see cref="T:System.Threading.ExecutionContext" /> che rappresenta il contesto di esecuzione per il thread corrente.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current execution context.">Crea una copia del contesto di esecuzione corrente.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the current execution context.">Oggetto <see cref="T:System.Threading.ExecutionContext" /> che rappresenta il contesto di esecuzione corrente.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This context cannot be copied because it is used. Only newly captured contexts can be copied.">Non è possibile copiare questo contesto perché è in uso. È possibile copiare solo i contesti acquisiti di recente.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Sets the specified &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object with the logical context information needed to recreate an instance of the current execution context.">Imposta l'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> specificato con le informazioni logiche sul contesto necessarie per ricreare un'istanza del contesto di esecuzione corrente.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object to be populated with serialization information.">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> da completare con le informazioni di serializzazione.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; structure representing the destination context of the serialization.">Struttura <see cref="T:System.Runtime.Serialization.StreamingContext" /> che rappresenta il contesto di destinazione della serializzazione.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;info&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="info" /> costruito in modo predefinito è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary vsli:raw="Indicates whether the flow of the execution context is currently suppressed.">Indica se il flusso del contesto di esecuzione attualmente è soppresso.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the flow is suppressed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il flusso è soppresso; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary vsli:raw="Restores the flow of the execution context across asynchronous threads.">Ripristina il flusso del contesto di esecuzione fra thread asincroni.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow cannot be restored because it is not being suppressed.">Non è possibile ripristinare il flusso del contesto perché non verrà soppresso.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary vsli:raw="Runs a method in a specified execution context on the current thread.">Esegue un metodo in un contesto di esecuzione specifico sul thread corrente.</summary>
      <param name="executionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; to set.">Oggetto <see cref="T:System.Threading.ExecutionContext" /> da impostare.</param>
      <param name="callback" vsli:raw="A &lt;see cref=&quot;T:System.Threading.ContextCallback&quot; /&gt; delegate that represents the method to be run in the provided execution context.">Delegato <see cref="T:System.Threading.ContextCallback" /> che rappresenta il metodo da eseguire nel contesto di esecuzione fornito.</param>
      <param name="state" vsli:raw="The object to pass to the callback method.">Oggetto da passare al metodo di callback.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;executionContext&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; has already been used as the argument to a &lt;see cref=&quot;M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)&quot; /&gt; call.">
        <paramref name="executionContext" /> costruito in modo predefinito è <see langword="null" />.
In alternativa
<paramref name="executionContext" /> non è stato acquisito tramite un'operazione di acquisizione.
-oppure-
<paramref name="executionContext" /> è stato già utilizzato come argomento per una chiamata <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary vsli:raw="Suppresses the flow of the execution context across asynchronous threads.">Sopprime il flusso del contesto di esecuzione fra thread asincroni.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure for restoring the flow.">Struttura <see cref="T:System.Threading.AsyncFlowControl" /> per il ripristino del flusso.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow is already suppressed.">Il flusso del contesto è già soppresso.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary vsli:raw="Encapsulates and propagates the host execution context across threads.">Incapsula e propaga il contesto di esecuzione host fra i thread.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class using the specified state.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.HostExecutionContext" /> con lo stato specificato.</summary>
      <param name="state" vsli:raw="An object representing the host execution context state.">Oggetto che rappresenta lo stato del contesto di esecuzione dell'host.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current host execution context.">Crea una copia del contesto di esecuzione dell'host corrente.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host context for the current thread.">Oggetto <see cref="T:System.Threading.HostExecutionContext" /> che rappresenta il contesto dell'host per il thread corrente.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary vsli:raw="When overridden in a derived class, releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt;, and optionally releases the managed resources.">Quando ne viene eseguito l'override in una classe derivata, libera le risorse non gestite usate da <see cref="T:System.Threading.WaitHandle" /> ed eventualmente di liberare le risorse gestite.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite, <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary vsli:raw="Gets or sets the state of the host execution context.">Ottiene o imposta lo stato del contesto di esecuzione dell'host.</summary>
      <returns vsli:raw="An object representing the host execution context state.">Oggetto che rappresenta lo stato del contesto di esecuzione dell'host.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary vsli:raw="Provides the functionality that allows a common language runtime host to participate in the flow, or migration, of the execution context.">Fornisce la funzionalità che consente a un host Common Language Runtime di partecipare al flusso, o migrazione, del contesto di esecuzione.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContextManager&quot; /&gt; class.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary vsli:raw="Captures the host execution context from the current thread.">Acquisisce il contesto di esecuzione dell'host dal thread corrente.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host execution context of the current thread.">Oggetto <see cref="T:System.Threading.HostExecutionContext" /> che rappresenta il contesto di esecuzione dell'host del thread corrente.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary vsli:raw="Restores the host execution context to its prior state.">Ripristina lo stato precedente del contesto di esecuzione dell'host.</summary>
      <param name="previousState" vsli:raw="The previous context state to revert to.">Stato precedente del contesto da ripristinare.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;previousState&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; was not created on the current thread.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; is not the last state for the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt;.">
        <paramref name="previousState" /> è <see langword="null" />.
In alternativa
<paramref name="previousState" /> non è stato creato sul thread corrente.
In alternativa
<paramref name="previousState" /> non è l'ultimo stato di <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary vsli:raw="Sets the current host execution context to the specified host execution context.">Imposta il contesto di esecuzione dell'host corrente sul contesto di esecuzione dell'host specificato.</summary>
      <param name="hostExecutionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to be set.">Oggetto <see cref="T:System.Threading.HostExecutionContext" /> da impostare.</param>
      <returns vsli:raw="An object for restoring the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to its previous state.">Oggetto per il ripristino dello stato precedente di <see cref="T:System.Threading.HostExecutionContext" />.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;hostExecutionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;hostExecutionContext&quot; /&gt; has been the argument to a previous &lt;see cref=&quot;M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)&quot; /&gt; method call.">
        <paramref name="hostExecutionContext" /> non è stato acquisito tramite un'operazione di acquisizione.
-oppure-
<paramref name="hostExecutionContext" /> è stato l'argomento di una chiamata al metodo <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" /> precedente.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary vsli:raw="Provides atomic operations for variables that are shared by multiple threads.">Consente di eseguire operazioni atomiche per variabili condivise da più thread.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary vsli:raw="Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.">Aggiunge due Integer a 32 bit e sostituisce il primo con la somma, come operazione atomica.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Variabile contenente il primo valore da sommare. La somma dei due valori viene memorizzata in <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Valore da aggiungere all'integer in corrispondenza di <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">Nuovo valore memorizzato in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary vsli:raw="Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.">Aggiunge due Integer a 64 bit e sostituisce il primo con la somma, come operazione atomica.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Variabile contenente il primo valore da aggiungere. La somma dei due valori viene memorizzata in <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Valore da aggiungere all'integer in corrispondenza di <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">Nuovo valore memorizzato in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary vsli:raw="Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.">Confronta due numeri a virgola mobile e precisione doppia per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary vsli:raw="Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.">Confronta due interi con segno a 32 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary vsli:raw="Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.">Confronta due interi con segno a 64 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary vsli:raw="Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.">Confronta due puntatori o handle specifici della piattaforma per verificarne l'uguaglianza. Se sono uguali, sostituisce il primo elemento.</summary>
      <param name="location1" vsli:raw="The destination &lt;see cref=&quot;T:System.IntPtr&quot; /&gt;, whose value is compared with the value of &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced by &lt;paramref name=&quot;value&quot; /&gt;.">
        <see cref="T:System.IntPtr" /> di destinazione, il cui valore viene confrontato con il valore di <paramref name="comparand" /> e, se possibile, sostituito da <paramref name="value" />.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that replaces the destination value if the comparison results in equality.">
        <see cref="T:System.IntPtr" /> che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">
        <see cref="T:System.IntPtr" /> da confrontare al valore in corrispondenza di <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary vsli:raw="Compares two objects for reference equality and, if they are equal, replaces the first object.">Confronta due oggetti per verificarne l'uguaglianza dei riferimenti. Se sono uguali, sostituisce il primo oggetto.</summary>
      <param name="location1" vsli:raw="The destination object that is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Oggetto di destinazione confrontato per riferimento con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value" vsli:raw="The object that replaces the destination object if the reference comparison results in equality.">Oggetto che sostituisce l'oggetto di destinazione se il confronto dei riferimenti rileva l'uguaglianza.</param>
      <param name="comparand" vsli:raw="The object that is compared by reference to the object at &lt;paramref name=&quot;location1&quot; /&gt;.">Oggetto confrontato per riferimento con l'oggetto in <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary vsli:raw="Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.">Confronta due numeri a virgola mobile e precisione singola per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destinazione il cui valore viene confrontato con <paramref name="comparand" /> ed eventualmente sostituito.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valore confrontato con il valore in corrispondenza di <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary vsli:raw="Compares two instances of the specified reference type &lt;paramref name=&quot;T&quot; /&gt; for reference equality and, if they are equal, replaces the first one.">Confronta due istanze del tipo di riferimento <paramref name="T" /> specificato per verificarne l'uguaglianza dei riferimenti. Se sono uguali, sostituisce la prima istanza.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Destinazione il cui valore viene confrontato per riferimento con <paramref name="comparand" /> ed eventualmente sostituito. Questo rappresenta un parametro di riferimento (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison by reference results in equality.">Valore che sostituisce il valore di destinazione se il confronto dei riferimenti rileva l'uguaglianza.</param>
      <param name="comparand" vsli:raw="The value that is compared by reference to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valore confrontato per riferimento con il valore in <paramref name="location1" />.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt;, &lt;paramref name=&quot;value&quot; /&gt;, and &lt;paramref name=&quot;comparand&quot; /&gt;. This type must be a reference type.">Tipo da utilizzare per <paramref name="location1" />, <paramref name="value" /> e <paramref name="comparand" />. Questo tipo deve essere un tipo di riferimento.</typeparam>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale in <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary vsli:raw="Decrements a specified variable and stores the result, as an atomic operation.">Consente di diminuire una variabile specificata e di memorizzarne il risultato, come operazione atomica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Variabile il cui valore deve essere diminuito.</param>
      <returns vsli:raw="The decremented value.">Valore diminuito.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary vsli:raw="Decrements the specified variable and stores the result, as an atomic operation.">Consente di diminuire la variabile specificata e di memorizzare il risultato, come operazione atomica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Variabile il cui valore deve essere diminuito.</param>
      <returns vsli:raw="The decremented value.">Valore diminuito.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary vsli:raw="Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.">Imposta un numero in virgola mobile a precisione doppia su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variabile da impostare sul valore specificato.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary vsli:raw="Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.">Imposta un intero con segno a 32 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variabile da impostare sul valore specificato.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary vsli:raw="Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.">Imposta un intero con segno a 64 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variabile da impostare sul valore specificato.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.">Imposta un puntatore o un handle specifico della piattaforma su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variabile da impostare sul valore specificato.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary vsli:raw="Sets an object to a specified value and returns a reference to the original object, as an atomic operation.">Imposta un oggetto su un valore specificato e restituisce un riferimento all'oggetto originale, come operazione atomica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variabile da impostare sul valore specificato.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary vsli:raw="Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.">Imposta un numero in virgola mobile a precisione singola su un valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variabile da impostare sul valore specificato.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary vsli:raw="Sets a variable of the specified type &lt;paramref name=&quot;T&quot; /&gt; to a specified value and returns the original value, as an atomic operation.">Imposta una variabile del tipo <paramref name="T" /> indicato sul valore specificato e restituisce il valore originale, come operazione atomica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Variabile su cui impostare il valore specificato. Rappresenta un parametro di riferimento (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valore su cui è impostato il parametro <paramref name="location1" />.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt;. This type must be a reference type.">Tipo da utilizzare per <paramref name="location1" /> e <paramref name="value" />. Questo tipo deve essere un tipo di riferimento.</typeparam>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valore originale di <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Variabile il cui valore deve essere aumentato.</param>
      <returns vsli:raw="The incremented value.">Valore aumentato.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Variabile il cui valore deve essere aumentato.</param>
      <returns vsli:raw="The incremented value.">Valore aumentato.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">L'indirizzo di <paramref name="location" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary vsli:raw="Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt; execute after memory accesses that follow the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt;.">Sincronizza l'accesso alla memoria nel modo seguente: il processore che esegue il thread corrente non può riordinare le istruzioni in modo tale che gli accessi alla memoria prima della chiamata a <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> vengano eseguiti dopo quelli successivi alla chiamata a <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary vsli:raw="Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.">Offre una barriera di memoria estesa ai processi che assicura che le letture e le scritture da qualsiasi CPU non possano superare la barriera.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary vsli:raw="Returns a 64-bit value, loaded as an atomic operation.">Restituisce un valore a 64 bit, caricato come operazione atomica.</summary>
      <param name="location" vsli:raw="The 64-bit value to be loaded.">Valore a 64 bit da caricare.</param>
      <returns vsli:raw="The loaded value.">Valore caricato.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary vsli:raw="Provides lazy initialization routines.">Fornisce routine di inizializzazione differita.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary vsli:raw="Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.">Inizializza un tipo di riferimento di destinazione con il relativo costruttore senza parametri se non è già stato inizializzato.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Riferimento da inizializzare se non è già stato inizializzato.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo del riferimento da inizializzare.</typeparam>
      <returns vsli:raw="The initialized object.">Oggetto inizializzato.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Le autorizzazioni per accedere al costruttore di tipo <paramref name="T" /> erano mancanti.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary vsli:raw="Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.">Inizializza un tipo riferimento o valore di destinazione con il relativo costruttore senza parametri se non è già stato inizializzato.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Riferimento o valore di tipo <c>T</c> da inizializzare se non è già stato inizializzato.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Riferimento a un valore booleano che determina se la destinazione è già stata inizializzata.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Riferimento a un oggetto utilizzato come blocco a esclusione reciproca per l'inizializzazione di <paramref name="target" />. Se <paramref name="syncLock" /> è <see langword="null" />, verrà creata un'istanza di un nuovo oggetto.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo del riferimento da inizializzare.</typeparam>
      <returns vsli:raw="The initialized object.">Oggetto inizializzato.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Le autorizzazioni per accedere al costruttore di tipo <paramref name="T" /> erano mancanti.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference or value type by using a specified function if it hasn't already been initialized.">Inizializza un tipo di riferimento o di valore di destinazione utilizzando una funzione specificata se non è già stato inizializzato.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Riferimento o valore di tipo <c>T</c> da inizializzare se non è già stato inizializzato.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Riferimento a un valore booleano che determina se la destinazione è già stata inizializzata.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Riferimento a un oggetto utilizzato come blocco a esclusione reciproca per l'inizializzazione di <paramref name="target" />. Se <paramref name="syncLock" /> è <see langword="null" />, verrà creata un'istanza di un nuovo oggetto.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference or value.">Funzione chiamata per inizializzare il riferimento o il valore.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo del riferimento da inizializzare.</typeparam>
      <returns vsli:raw="The initialized object.">Oggetto inizializzato.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Le autorizzazioni per accedere al costruttore di tipo <paramref name="T" /> erano mancanti.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type by using a specified function if it hasn't already been initialized.">Inizializza un tipo di riferimento di destinazione utilizzando una funzione specificata se non è già stato inizializzato.</summary>
      <param name="target" vsli:raw="The reference to initialize if it hasn't already been initialized.">Riferimento da inizializzare se non è già stato inizializzato.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference.">Funzione chiamata per inizializzare il riferimento.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo del riferimento da inizializzare.</typeparam>
      <returns vsli:raw="The initialized object.">Oggetto inizializzato.</returns>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">Il tipo <paramref name="T" /> non dispone di un costruttore senza parametri.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; returned null (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> restituisce null (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type with a specified function if it has not already been initialized.">Inizializza un tipo di riferimento di destinazione con una funzione specificata se non è già stato inizializzato.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Riferimento da inizializzare se non è già stato inizializzato.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing&#xA;            &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Riferimento a un oggetto utilizzato come blocco a esclusione reciproca per l'inizializzazione di <paramref name="target" />. Se <paramref name="syncLock" /> è <see langword="null" />, verrà creata un'istanza di un nuovo oggetto.</param>
      <param name="valueFactory" vsli:raw="The method to invoke to initialize &lt;paramref name=&quot;target&quot; /&gt;.">Metodo da richiamare per inizializzare <paramref name="target" />.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo del riferimento da inizializzare.</typeparam>
      <returns vsli:raw="The initialized object.">Oggetto inizializzato.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary vsli:raw="Defines the lock that implements single-writer/multiple-reader semantics. This is a value type.">Definisce il blocco che implementa la semantica writer singolo/visualizzatori multipli. Si tratta di un tipo di valore.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary vsli:raw="Indicates whether a specified object is a &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; and is equal to the current instance.">Indica se un oggetto specificato è una struttura <see cref="T:System.Threading.LockCookie" /> ed è uguale all'istanza corrente.</summary>
      <param name="obj" vsli:raw="The object to compare to the current instance.">Oggetto da confrontare con l'istanza corrente della classe.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value of &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il valore di <paramref name="obj" /> è uguale al valore dell'istanza corrente; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether the current instance is equal to the specified &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt;.">Indica se l'istanza corrente è uguale all'oggetto <see cref="T:System.Threading.LockCookie" /> specificato.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to the current instance.">
        <see cref="T:System.Threading.LockCookie" /> da confrontare con l'istanza corrente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> è uguale al valore dell'istanza corrente. In caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Restituisce il codice hash per l'istanza.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Codice hash di un intero con segno a 32 bit.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are equal.">Indica se due strutture <see cref="T:System.Threading.LockCookie" /> sono uguali.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="a" /> è uguale a <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are not equal.">Indica se due strutture <see cref="T:System.Threading.LockCookie" /> non sono uguali.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">Oggetto <see cref="T:System.Threading.LockCookie" /> da confrontare con <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is not equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="a" /> non è uguale a <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary vsli:raw="The exception that is thrown when recursive entry into a lock is not compatible with the recursion policy for the lock.">Eccezione generata quando una voce ricorsiva in un blocco non è compatibile con i criteri di ricorsione per tale blocco.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a system-supplied message that describes the error.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con un messaggio fornito dal sistema in cui viene descritto l'errore.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with serialized data.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con dati serializzati.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Oggetto che contiene i dati oggetto serializzati.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified message that describes the error.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con un messaggio specificato in cui viene descritto l'errore.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Messaggio in cui viene descritta l'eccezione. Il chiamante di questo costruttore deve assicurare che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.LockRecursionException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Messaggio in cui viene descritta l'eccezione. Il chiamante di questo costruttore deve assicurare che la stringa sia stata localizzata in base alle impostazioni cultura correnti del sistema.</param>
      <param name="innerException" vsli:raw="The exception that caused the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Eccezione che ha causato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary vsli:raw="Specifies whether a lock can be entered multiple times by the same thread.">Specifica se lo stesso thread può accedere a un blocco più volte.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary vsli:raw="If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.">Se un thread tenta di accedere a un blocco in modo ricorsivo, viene generata un'eccezione. È possibile che alcune classi consentano particolari ricorsioni quando questa impostazione è attivata.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary vsli:raw="A thread can enter a lock recursively. Some classes may restrict this capability.">Un thread può accedere a un blocco in modo ricorsivo. Alcune classi possono limitare questa funzionalità.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class cannot be inherited.">Rappresenta un evento di sincronizzazione dei thread che, quando viene segnalato, deve essere reimpostato manualmente. Questa classe non può essere ereditata.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.ManualResetEvent" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to nonsignaled.">Viene restituito <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostare lo stato iniziale su non segnalato.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class is a lightweight alternative to &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt;.">Rappresenta un evento di sincronizzazione dei thread che, quando viene segnalato, deve essere reimpostato manualmente. La classe è un'alternativa leggera a <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with an initial state of nonsignaled.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ManualResetEventSlim" /> con uno stato iniziale di non segnalato.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.ManualResetEventSlim" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
      <param name="initialState" vsli:raw="true to set the initial state signaled; false to set the initial state to nonsignaled.">true per impostare lo stato iniziale su segnalato; false per impostarlo su non segnalato.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled and a specified spin count.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ManualResetEventSlim" /> con un valore booleano che indica se impostare lo stato iniziale su segnalato e un conteggio delle rotazioni specificato.</summary>
      <param name="initialState" vsli:raw="true to set the initial state to signaled; false to set the initial state to nonsignaled.">true per impostare lo stato iniziale su segnalato; false per impostarlo su non segnalato.</param>
      <param name="spinCount" vsli:raw="The number of spin waits that will occur before falling back to a kernel-based wait operation.">Numero di attese di rotazione che devono verificarsi prima di eseguire il fallback su un'operazione di attesa basata sul kernel.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;spinCount&quot; /&gt; is less than 0 or greater than the maximum allowed value.">
        <paramref name="spinCount" /> è minore di 0 o maggiore del valore massimo consentito.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;, and optionally releases the managed resources.">Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">True per rilasciare sia le risorse gestite sia quelle non gestite; false per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary vsli:raw="Gets whether the event is set.">Ottiene un valore che indica se l'evento è impostato.</summary>
      <returns vsli:raw="true if the event is set; otherwise, false.">true se l'evento è impostato, altrimenti false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, which causes threads to block.">Imposta lo stato dell'evento su non segnalato, provocando il blocco dei thread.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary vsli:raw="Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.">Imposta lo stato dell'evento su segnalato, per consentire a uno o più thread in attesa dell'evento di procedere.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary vsli:raw="Gets the number of spin waits that will occur before falling back to a kernel-based wait operation.">Ottiene il numero di attese di rotazione che devono verificarsi prima di eseguire il fallback su un'operazione di attesa basata sul kernel.</summary>
      <returns vsli:raw="Returns the number of spin waits that will occur before falling back to a kernel-based wait operation.">Restituisce il numero di attese di rotazione che devono verificarsi prima di eseguire il fallback su un'operazione di attesa basata sul kernel.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un intero con segno a 32 bit per misurare l'intervallo di tempo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un intero con segno a 32 bit per misurare l'intervallo di tempo e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">L'oggetto è già stato eliminato o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; receives a signal, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non riceve un segnale, osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">L'oggetto è già stato eliminato o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was&#xA;            canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.
-oppure-
Il numero di millisecondi in <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">L'oggetto è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> corrente non viene impostato, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se l'oggetto <see cref="T:System.Threading.ManualResetEventSlim" /> è stato impostato. In caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.
-oppure-
Il numero di millisecondi in <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Superato il numero massimo di oggetti waiter consentiti.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">L'oggetto è già stato eliminato o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Ottiene l'oggetto <see cref="T:System.Threading.WaitHandle" /> sottostante per questo oggetto <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns vsli:raw="The underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; event object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Oggetto evento <see cref="T:System.Threading.WaitHandle" /> sottostante per questo oggetto <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary vsli:raw="Provides a mechanism that synchronizes access to objects.">Fornisce un meccanismo che sincronizza l'accesso agli oggetti.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object.">Acquisisce un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the monitor lock.">Oggetto sui cui acquisire il blocco del monitoraggio.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Acquisisce un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Oggetto per il quale attendere.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.  &#xA;  &#xA; Note   If no exception occurs, the output of this method is always &lt;see langword=&quot;true&quot; /&gt;.">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.
Nota   Se non si verifica alcuna eccezione, l'output di questo metodo è sempre <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary vsli:raw="Releases an exclusive lock on the specified object.">Viene rilasciato un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj" vsli:raw="The object on which to release the lock.">Oggetto sul quale rilasciare il blocco.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread does not own the lock for the specified object.">Il blocco per l'oggetto specificato non è di proprietà del thread corrente.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary vsli:raw="Determines whether the current thread holds the lock on the specified object.">Determina se il thread corrente specificato contiene il blocco sull'oggetto specificato.</summary>
      <param name="obj" vsli:raw="The object to test.">Oggetto da testare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the lock on &lt;paramref name=&quot;obj&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente è responsabile del blocco su <paramref name="obj" />; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;obj&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary vsli:raw="Gets the number of times there was contention when trying to take the monitor's lock.">Ottiene il numero di volte in cui si è verificata una contesa durante il tentativo di acquisire il blocco del monitoraggio.</summary>
      <returns vsli:raw="The number of times there was contention when trying to take the monitor's lock.">Il numero di volte in cui si è verificato un conflitto durante il tentativo di eseguire il blocco del monitoraggio.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary vsli:raw="Notifies a thread in the waiting queue of a change in the locked object's state.">Consente di notificare a un thread della coda di attesa che lo stato dell'oggetto bloccato è stato modificato.</summary>
      <param name="obj" vsli:raw="The object a thread is waiting for.">Oggetto atteso da un thread.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary vsli:raw="Notifies all waiting threads of a change in the object's state.">Notifica a tutti i thread in attesa che lo stato dell'oggetto è stato modificato.</summary>
      <param name="obj" vsli:raw="The object that sends the pulse.">Oggetto che invia l'impulso.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object.">Prova ad acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Oggetto sul quale acquisire il blocco.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Prova ad acquisire un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Oggetto sul quale acquisire il blocco.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.">Viene eseguito, per un numero specificato di millisecondi, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Oggetto sul quale acquisire il blocco.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Prova ad acquisire, per il numero di millisecondi specificato, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Oggetto sul quale acquisire il blocco.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.">Viene eseguito, per una quantità di tempo specificata, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Oggetto sul quale acquisire il blocco.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta la durata di attesa del blocco. Un valore di -1 millisecondo specifica un'attesa infinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Prova ad acquisire, per la quantità di tempo specificata, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Oggetto sul quale acquisire il blocco.</param>
      <param name="timeout" vsli:raw="The amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">Quantità di tempo che rappresenta la durata di attesa del blocco. Un valore di -1 millisecondo specifica un'attesa infinita.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock.">Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Oggetto per il quale attendere.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.">Viene restituito <see langword="true" /> se la chiamata è stata restituita perché il chiamante ha riacquisito il blocco per l'oggetto specificato. Non viene restituito alcun valore se il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Oggetto per il quale attendere.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.">Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Questo metodo consente anche di specificare se il dominio di sincronizzazione per il contesto, qualora si trovi in un contesto di sincronizzazione, viene terminato prima dell'attesa e riacquisito in un secondo momento.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Oggetto per il quale attendere.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Oggetto per il quale attendere.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;timeout&quot; /&gt; parameter in milliseconds is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Il valore del parametro <paramref name="timeout" /> in millisecondi è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.">Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Esce eventualmente dal dominio di sincronizzazione per il contesto di sincronizzazione prima dell'attesa e riacquisisce il dominio in un secondo momento.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Oggetto per il quale attendere.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">Il thread da cui è stato richiamato Wait viene interrotto più tardi dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;timeout&quot; /&gt; parameter is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">Il parametro <paramref name="timeout" /> è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary vsli:raw="A synchronization primitive that can also be used for interprocess synchronization.">Primitiva di sincronizzazione che può essere usata anche per la sincronizzazione interprocesso.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with default properties.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con le proprietà predefinite.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the mutex; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Viene restituito <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex; in caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex e con una stringa che rappresenta il nome del mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex di sistema denominato, se questo è stato creato come risultato della chiamata; in caso contrario, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome di <see cref="T:System.Threading.Mutex" />. Se il valore è <see langword="null" />, l'oggetto <see cref="T:System.Threading.Mutex" /> è senza nome.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">Il mutex denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Il mutex denominato non può essere creato, forse perché un handle di attesa di un tipo diverso ha lo stesso nome.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex, con una stringa che rappresenta il nome del mutex e con un valore booleano che, quando il metodo viene restituito, indichi se al thread chiamante era stata concessa la proprietà iniziale del mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex di sistema denominato, se questo è stato creato come risultato della chiamata; in caso contrario, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome di <see cref="T:System.Threading.Mutex" />. Se il valore è <see langword="null" />, l'oggetto <see cref="T:System.Threading.Mutex" /> è senza nome.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains a Boolean that is &lt;see langword=&quot;true&quot; /&gt; if a local mutex was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system mutex was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system mutex already existed. This parameter is passed uninitialized.">Quando questo metodo viene restituito, contiene un valore booleano che è <see langword="true" /> se è stato creato un mutex locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il mutex di sistema denominato specificato; <see langword="false" /> se il mutex di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">Il mutex denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Il mutex denominato non può essere creato, forse perché un handle di attesa di un tipo diverso ha lo stesso nome.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists.">Apre il mutex denominato specificato, se esistente.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome del mutex di sistema da aprire.</param>
      <returns vsli:raw="An object that represents the named system mutex.">Oggetto che rappresenta il mutex di sistema denominato.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">Il mutex denominato non esiste.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; once.">Rilascia l'oggetto <see cref="T:System.Threading.Mutex" /> una volta.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The calling thread does not own the mutex.">Il thread di chiamata non è il proprietario del mutex.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.">Apre il mutex denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è stata completata.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome del mutex di sistema da aprire.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the named mutex if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quando questo metodo viene restituito, contiene un oggetto di <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex denominato se la chiamata ha esito positivo o <see langword="null" /> se la chiamata ha esito negativo. Questo parametro viene trattato come non inizializzato.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named mutex was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> se il mutex denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary vsli:raw="Defines a lock that supports single writers and multiple readers.">Definisce un blocco che supporta writer singoli e lettori multipli.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLock&quot; /&gt; class.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary vsli:raw="Acquires a reader lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Acquisisce un blocco del lettore, usando un valore <see cref="T:System.Int32" /> per il timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Timeout in millisecondi.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">L'intervallo <paramref name="millisecondsTimeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary vsli:raw="Acquires a reader lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Acquisisce un blocco del lettore, usando un valore <see cref="T:System.TimeSpan" /> per il timeout.</summary>
      <param name="timeout" vsli:raw="A &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Parametro <see langword="TimeSpan" /> che specifica il periodo di timeout.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">Il parametro <paramref name="timeout" /> specifica un valore negativo diverso da -1 millisecondi.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary vsli:raw="Acquires the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Acquisisce un blocco del writer, usando un valore <see cref="T:System.Int32" /> per il timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Timeout in millisecondi.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary vsli:raw="Acquires the writer lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Acquisisce un blocco del writer, usando un valore <see cref="T:System.TimeSpan" /> per il timeout.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Parametro <see langword="TimeSpan" /> che specifica il periodo di timeout.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">Il parametro <paramref name="timeout" /> specifica un valore negativo diverso da -1 millisecondi.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary vsli:raw="Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.">Indica se sono stati concessi blocchi del writer a uno o più thread da quando è stato ottenuto il numero di sequenza.</summary>
      <param name="seqNum" vsli:raw="The sequence number.">Numero di sequenza.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se sono stati concessi blocchi del writer a uno o più thread da quando è stato ottenuto il numero di sequenza; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt; was called.">Ripristina lo stato del blocco del thread in vigore prima della chiamata al metodo <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt;.">Oggetto <see cref="T:System.Threading.LockCookie" /> restituito dal metodo <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">Il thread non è responsabile del blocco del writer.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="lockCookie" /> è un puntatore Null.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds a reader lock.">Ottiene un valore che indica se il thread corrente è responsabile di un blocco del lettore.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds a reader lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente è responsabile del blocco del lettore; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds the writer lock.">Viene fornito un valore che indica se il thread corrente è responsabile del blocco del writer.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the writer lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente è responsabile del blocco del writer; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary vsli:raw="Releases the lock, regardless of the number of times the thread acquired the lock.">Consente il rilascio del blocco indipendentemente dal numero di acquisizioni del blocco da parte del thread.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value representing the released lock.">Valore <see cref="T:System.Threading.LockCookie" /> che rappresenta il blocco rilasciato.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary vsli:raw="Decrements the lock count.">Consente di diminuire il conteggio dei blocchi.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have any reader or writer locks.">Il thread non è responsabile di blocchi di lettura o del writer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary vsli:raw="Decrements the lock count on the writer lock.">Consente di diminuire il conteggio dei blocchi nel blocco del writer.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">Il thread non è responsabile del blocco del writer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before calling &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Ripristina lo stato del blocco del thread in vigore prima della chiamata a <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Oggetto <see cref="T:System.Threading.LockCookie" /> restituito dal metodo <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">L'indirizzo di <paramref name="lockCookie" /> è un puntatore Null.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Consente l'aggiornamento da un blocco di lettura al blocco del writer, utilizzando un valore <see langword="Int32" /> per il timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Timeout in millisecondi.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Valore <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">L'intervallo <paramref name="millisecondsTimeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using a &lt;see langword=&quot;TimeSpan&quot; /&gt; value for the time-out.">Consente l'aggiornamento da un blocco di lettura al blocco del writer, utilizzando un valore <see langword="TimeSpan" /> per il timeout.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Parametro <see langword="TimeSpan" /> che specifica il periodo di timeout.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Valore <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">L'intervallo <paramref name="timeout" /> scade prima che la richiesta di blocco sia stata soddisfatta.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">Il parametro <paramref name="timeout" /> specifica un valore negativo diverso da -1 millisecondi.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary vsli:raw="Gets the current sequence number.">Viene fornito il numero di sequenza corrente.</summary>
      <returns vsli:raw="The current sequence number.">Numero di sequenza corrente.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary vsli:raw="Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.">Rappresenta un blocco utilizzato per gestire l'accesso a una risorsa, consentendo a più thread l'accesso in lettura o l'accesso esclusivo in scrittura.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class with default property values.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> con i valori predefiniti delle proprietà.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class, specifying the lock recursion policy.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, specificando i criteri di ricorsione del blocco.</summary>
      <param name="recursionPolicy" vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary vsli:raw="Gets the total number of unique threads that have entered the lock in read mode.">Ottiene il numero complessivo di thread univoci per i quali è stato attivato il blocco in modalità lettura.</summary>
      <returns vsli:raw="The number of unique threads that have entered the lock in read mode.">Numero di thread univoci per i quali è stato attivato il blocco in modalità lettura.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingReadCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount&quot; /&gt; is greater than zero.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> è maggiore di zero.
In alternativa
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> è maggiore di zero.
In alternativa
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> è maggiore di zero.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary vsli:raw="Tries to enter the lock in read mode.">Tenta di accedere al blocco in modalità di lettura.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the read lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the write lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di lettura.
-oppure-
La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di scrittura.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che questa eccezione non dovrebbe mai essere riscontrata dalle applicazioni.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode.">Tenta di accedere al blocco in modalità aggiornabile.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.
-oppure-
Il thread corrente ha acceduto alla modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary vsli:raw="Tries to enter the lock in write mode.">Tenta di accedere al blocco in modalità di scrittura.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.
-oppure-
Il thread corrente ha acceduto alla modalità di lettura e non possiede già un blocco in scrittura, pertanto il tentativo di accedere al blocco in modalità di scrittura creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary vsli:raw="Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).">Riduce il conteggio della ricorsione per la modalità di lettura ed esce da questa modalità se il conteggio risultante è 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in read mode.">Il thread corrente non ha acceduto al blocco in modalità di lettura.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary vsli:raw="Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).">Riduce il conteggio della ricorsione per la modalità aggiornabile ed esce da questa modalità se il conteggio risultante è 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in upgradeable mode.">Il thread corrente non ha acceduto al blocco in modalità aggiornabile.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary vsli:raw="Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).">Riduce il conteggio della ricorsione per la modalità di scrittura ed esce da questa modalità se il conteggio risultante è 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in write mode.">Il thread corrente non ha acceduto al blocco in modalità di scrittura.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in read mode.">Ottiene un valore che indica se il thread corrente ha acceduto al blocco in modalità di lettura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered read mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente ha acceduto alla modalità di lettura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.">Ottiene un valore che indica se il thread corrente ha acceduto al blocco in modalità aggiornabile.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered upgradeable mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in write mode.">Ottiene un valore che indica se il thread corrente ha acceduto al blocco in modalità di scrittura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered write mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary vsli:raw="Gets a value that indicates the recursion policy for the current &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object.">Ottiene un valore che indica i criteri di ricorsione per l'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> corrente.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.">Ottiene il numero di volte in cui il thread corrente ha acceduto al blocco in modalità di lettura, come indicazione della ricorsione.</summary>
      <returns vsli:raw="0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.">0 (zero) se per il thread corrente non è stata attivata la modalità lettura, 1 se per il thread è stata attivata la modalità lettura ma non in modo ricorsivo o n se per il thread è stato attivato il blocco in modo ricorsivo n - 1 volte.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.">Ottiene il numero di volte in cui il thread corrente ha acceduto al blocco in modalità aggiornabile, come indicazione della ricorsione.</summary>
      <returns vsli:raw="0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.">0 (zero) se per il thread corrente non è stata attivata la modalità aggiornabile, 1 se per il thread è stata attivata la modalità aggiornabile ma non in modo ricorsivo o n se per il thread è stata attivata la modalità aggiornabile in modo ricorsivo n - 1 volte.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.">Ottiene il numero di volte in cui il thread corrente ha acceduto al blocco in modalità di scrittura, come indicazione della ricorsione.</summary>
      <returns vsli:raw="0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.">0 (zero) se per il thread corrente non è stata attivata la modalità scrittura, 1 se per il thread è stata attivata la modalità scrittura ma non in modo ricorsivo o n se per il thread è stata attivata la modalità scrittura in modo ricorsivo n - 1 volte.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional integer time-out.">Tenta di accedere al blocco in modalità di lettura con un timeout intero facoltativo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Numero di millisecondi di attesa, oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per attendere per un periodo di tempo indefinito.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di lettura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
In alternativa
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional time-out.">Tenta di accedere al blocco in modalità di lettura con un timeout facoltativo.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervallo di attesa, oppure -1 millisecondi per attendere per un periodo di tempo indefinito.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di lettura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.
-oppure-
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Tenta di accedere al blocco in modalità aggiornabile con un timeout facoltativo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Numero di millisecondi di attesa, oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per attendere per un periodo di tempo indefinito.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Tenta di accedere al blocco in modalità aggiornabile con un timeout facoltativo.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervallo di attesa, oppure -1 millisecondi per attendere per un periodo di tempo indefinito.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.
-oppure-
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Tenta di accedere al blocco in modalità di scrittura con un timeout facoltativo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Numero di millisecondi di attesa, oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per attendere per un periodo di tempo indefinito.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Tenta di accedere al blocco in modalità di scrittura con un timeout facoltativo.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervallo di attesa, oppure -1 millisecondi per attendere per un periodo di tempo indefinito.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.
-oppure-
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.
-oppure-
Il numero di ricorsione supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.
-oppure-
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in read mode.">Ottiene il numero complessivo di thread in attesa di accedere al blocco in modalità di lettura.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter read mode.">Numero complessivo di thread in attesa di accedere alla modalità di lettura.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in upgradeable mode.">Ottiene il numero complessivo di thread in attesa di accedere al blocco in modalità aggiornabile.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter upgradeable mode.">Numero complessivo di thread in attesa di accedere in modalità aggiornabile.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in write mode.">Ottiene il numero complessivo di thread in attesa di accedere al blocco in modalità di scrittura.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter write mode.">Numero complessivo di thread in attesa di accedere alla modalità di scrittura.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary vsli:raw="Limits the number of threads that can access a resource or pool of resources concurrently.">Limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di voci iniziale e il numero massimo di voci contemporanei.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.">
        <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> è minore di 1.
-oppure-
<paramref name="initialCount" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di voci iniziale e il numero massimo di voci contemporanee, nonché indicando facoltativamente il nome di un oggetto semaforo di sistema.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome di un oggetto semaforo di sistema denominato.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.
-oppure-
La lunghezza di<paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> è minore di 1.
-oppure-
<paramref name="initialCount" /> è minore di 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema e specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be satisfied concurrently.">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be satisfied concurrently.">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome di un oggetto semaforo di sistema denominato.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local semaphore was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system semaphore was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system semaphore already existed. This parameter is passed uninitialized.">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato; <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.
-oppure-
La lunghezza di<paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> è minore di 1.
-oppure-
<paramref name="initialCount" /> è minore di 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists.">Apre il semaforo denominato specificato, se esistente.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome del semaforo di sistema da aprire.</param>
      <returns vsli:raw="An object that represents the named system semaphore.">Oggetto che rappresenta il semaforo di sistema denominato.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">Il semaforo denominato non esiste.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary vsli:raw="Exits the semaphore and returns the previous count.">Esce dal semaforo e restituisce il conteggio precedente.</summary>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-oppure-
Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary vsli:raw="Exits the semaphore a specified number of times and returns the previous count.">Esce dal semaforo il numero di volte specificato e restituisce il conteggio precedente.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">Numero di uscite dal semaforo.</param>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> è minore di 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-oppure-
Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.">Apre il semaforo denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nome del semaforo di sistema da aprire.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; object that represents the named semaphore if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named semaphore was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">Il parametro <paramref name="name" /> è una stringa vuota.
-oppure-
La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> è <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Errore Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary vsli:raw="The exception that is thrown when the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method is called on a semaphore whose count is already at the maximum.">Eccezione generata quando il metodo <see cref="Overload:System.Threading.Semaphore.Release" /> viene chiamato su un semaforo il cui conteggio ha già raggiunto il valore massimo.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with default values.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con i valori predefiniti.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with serialized data.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con dati serializzati.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati di oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con un messaggio di errore specificato.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreFullException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary vsli:raw="Represents a lightweight alternative to &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; that limits the number of threads that can access a resource or pool of resources concurrently.">Rappresenta un'alternativa semplificata a <see cref="T:System.Threading.Semaphore" /> che limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial number of requests that can be granted concurrently.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreSlim" /> specificando il numero iniziale di richieste che possono essere concesse simultaneamente.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> è minore di 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial and maximum number of requests that can be granted concurrently.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SemaphoreSlim" /> specificando il numero iniziale e massimo di richieste che possono essere concesse contemporaneamente.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
      <param name="maxCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Numero massimo delle richieste per il semaforo che possono essere concesse contemporaneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0, or &lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maxCount&quot; /&gt;, or &lt;paramref name=&quot;maxCount&quot; /&gt; is equal to or less than 0.">
        <paramref name="initialCount" /> è minore di 0, o <paramref name="initialCount" /> è maggiore di <paramref name="maxCount" /> o <paramref name="maxCount" /> è uguale o minore di 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Restituisce un oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere utilizzato per attendere il semaforo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere usato per attendere il semaforo.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary vsli:raw="Gets the number of remaining threads that can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object.">Ottiene il numero di thread rimanenti che possono accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="The number of remaining threads that can enter the semaphore.">Numero di thread rimanenti che possono accedere al semaforo.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, and optionally releases the managed resources.">Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> e, facoltativamente, le risorse gestite.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite, <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object once.">Rilascia l'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> una volta.</summary>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Numero precedente di <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">
        <see cref="T:System.Threading.SemaphoreSlim" /> ha già raggiunto la dimensione massima.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object a specified number of times.">Rilascia l'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> un numero di volte specificato.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">Numero di uscite dal semaforo.</param>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Numero precedente di <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> è minore di 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">
        <see cref="T:System.Threading.SemaphoreSlim" /> ha già raggiunto la dimensione massima.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Blocca il thread corrente finché non può immettere <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout.">Blocca il thread corrente finché non è in grado di accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un intero con segno a 32 bit che specifica il timeout.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1 che rappresenta un timeout infinito oppure il timeout è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché non è in grado di accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un intero con segno a 32 bit che specifica il timeout mentre al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="millisecondsTimeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; instance has been disposed, or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">È stata eliminata l'istanza di <see cref="T:System.Threading.SemaphoreSlim" /> o <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché non può accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" /> osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Token <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA; -or-&#xA;&#xA; The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L'istanza corrente è già stata eliminata.
-oppure-
L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to specify the timeout.">Blocca il thread corrente finché quest'ultimo non può accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un oggetto <see cref="T:System.TimeSpan" /> per specificare il timeout.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.">L'istanza di semaphoreSlim è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Blocca il thread corrente finché non è in grado di accedere all'oggetto <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un oggetto <see cref="T:System.TimeSpan" /> che specifica il timeout e al contempo osservando un oggetto <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />; altrimenti, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-.&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">L'istanza di semaphoreSlim è stata eliminata.
-oppure-
L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Attività che verrà completata quando si accede al semaforo.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval.">In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un Integer con segno a 32 bit per misurare l'intervallo di tempo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="millisecondsTimeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando un Integer con segno a 32 bit per misurare l'intervallo di tempo, mentre osserva <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">Numero di millisecondi di attesa, <see cref="F:System.Threading.Timeout.Infinite" />(-1) per un'attesa illimitata oppure zero per testare lo stato dell'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">Oggetto <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> è un numero diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="millisecondsTimeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, mentre osserva <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Token <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Attività che verrà completata quando il semaforo verrà inserito.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">L'istanza corrente è già stata eliminata.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">In modo asincrono attende di immettere <see cref="T:System.Threading.SemaphoreSlim" />, utilizzando <see cref="T:System.TimeSpan" /> per misurare l'intervallo di tempo, mentre osserva <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">
        <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa, <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi di attesa illimitata o <see cref="T:System.TimeSpan" /> che rappresenta 0 millisecondi per testare l'handle di attesa e tornare immediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Token <see cref="T:System.Threading.CancellationToken" /> da osservare.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Attività che verrà completata con un risultato <see langword="true" /> se il thread corrente ha immesso correttamente <see cref="T:System.Threading.SemaphoreSlim" />, in caso contrario, con un risultato <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.
-oppure-
<paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">
        <paramref name="cancellationToken" /> è stato annullato.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">L'interfaccia <see cref="T:System.Threading.SemaphoreSlim" /> è stata eliminata.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary vsli:raw="Represents a method to be called when a message is to be dispatched to a synchronization context.">Rappresenta un metodo da chiamare quando un messaggio deve essere inviato a un contesto di sincronizzazione.</summary>
      <param name="state" vsli:raw="The object passed to the delegate.">Oggetto passato al delegato.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary vsli:raw="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.">Fornisce una primitiva di blocco a esclusione reciproca in cui un thread che tenta di acquisire il blocco rimane in attesa in un ciclo eseguendo controlli ripetuti finché il blocco non diventa disponibile.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SpinLock&quot; /&gt; structure with the option to track thread IDs to improve debugging.">Inizializza una nuova istanza della struttura <see cref="T:System.Threading.SpinLock" /> con l'opzione di rilevamento degli ID dei thread per migliorare il debug.</summary>
      <param name="enableThreadOwnerTracking" vsli:raw="Whether to capture and use thread IDs for debugging purposes.">Valore che indica se acquisire e utilizzare gli ID dei thread per scopi di debug.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary vsli:raw="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Acquisisce il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling Enter.">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary vsli:raw="Releases the lock.">Rilascia il blocco.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">Il rilevamento della proprietà dei thread è abilitato e il thread corrente non è il proprietario di questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary vsli:raw="Releases the lock.">Rilascia il blocco.</summary>
      <param name="useMemoryBarrier" vsli:raw="A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.">Valore booleano che indica se generare un limite di memoria per pubblicare immediatamente l'operazione di uscita agli altri thread.</param>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">Il rilevamento della proprietà dei thread è abilitato e il thread corrente non è il proprietario di questo blocco.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary vsli:raw="Gets whether the lock is currently held by any thread.">Ottiene un valore che indica se attualmente il blocco è mantenuto da un thread.</summary>
      <returns vsli:raw="true if the lock is currently held by any thread; otherwise false.">true se attualmente il blocco è mantenuto da un thread; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary vsli:raw="Gets whether the lock is held by the current thread.">Ottiene un valore che indica se il blocco è mantenuto dal thread corrente.</summary>
      <returns vsli:raw="true if the lock is held by the current thread; otherwise false.">true se il blocco è mantenuto dal thread corrente; in caso contrario, false.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Thread ownership tracking is disabled.">Il rilevamento della proprietà dei thread è disabilitato.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary vsli:raw="Gets whether thread ownership tracking is enabled for this instance.">Ottiene un valore che indica se per questa istanza è abilitato il rilevamento della proprietà dei thread.</summary>
      <returns vsli:raw="true if thread ownership tracking is enabled for this instance; otherwise false.">true se per questa istanza è abilitato il rilevamento della proprietà dei thread; in caso contrario, false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tenta di acquisire il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tenta di acquisire il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tenta di acquisire il blocco in modo affidabile, in modo tale che anche se si verifica un'eccezione all'interno della chiamata al metodo, è possibile esaminare l'oggetto <paramref name="lockTaken" /> in maniera affidabile per determinare se il blocco è stato acquisito.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se il blocco è stato acquisito. In caso contrario, False. Prima di chiamare questo metodo è necessario inizializzare <paramref name="lockTaken" /> su False.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito o il timeout è più grande di <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">È necessario inizializzare l'argomento <paramref name="lockTaken" /> su False prima della chiamata a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">Il rilevamento della proprietà dei thread è abilitato e il thread corrente ha già acquisito questo blocco.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary vsli:raw="Provides support for spin-based waiting.">Fornisce il supporto per l'attesa basata su rotazione.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary vsli:raw="Gets the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Ottiene il numero di chiamate di <see cref="M:System.Threading.SpinWait.SpinOnce" /> su questa istanza.</summary>
      <returns vsli:raw="Returns an integer that represents the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Restituisce un intero che rappresenta il numero di volte in cui <see cref="M:System.Threading.SpinWait.SpinOnce" /> è stato chiamato su questa istanza.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary vsli:raw="Gets whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Ottiene un valore che indica se la chiamata successiva a <see cref="M:System.Threading.SpinWait.SpinOnce" /> comporterà la cessione del processore, attivando un cambio imposto di contesto.</summary>
      <returns vsli:raw="Whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Valore che indica se la chiamata successiva a <see cref="M:System.Threading.SpinWait.SpinOnce" /> comporterà la cessione del processore, attivando un cambio imposto di contesto.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary vsli:raw="Resets the spin counter.">Reimposta il contatore delle rotazioni.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary vsli:raw="Performs a single spin.">Esegue una sola rotazione.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary vsli:raw="Performs a single spin and calls &lt;see cref=&quot;M:System.Threading.Thread.Sleep(System.Int32)&quot; /&gt; after a minimum spin count.">Esegue un solo spin e chiama <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> dopo un numero spin minimo.</summary>
      <param name="sleep1Threshold" vsli:raw="A minimum spin count after which &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt; may be used. A value of -1 disables the use of &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt;.">Numero spin minimo dopo il quale è possibile usare <see langword="Thread.Sleep(1)" />. Il valore -1 disabilita l'uso di <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sleep1Threshold&quot; /&gt; is less than -1.">
        <paramref name="sleep1Threshold" /> è minore di -1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary vsli:raw="Spins until the specified condition is satisfied.">Esegue rotazioni finché non è stata soddisfatta la condizione specificata.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Delegato da eseguire ripetutamente finché non restituisce true.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">L'argomento <paramref name="condition" /> è Null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Esegue rotazioni finché non è stata soddisfatta la condizione specificata o fino allo scadere del timeout specificato.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Delegato da eseguire ripetutamente finché non restituisce true.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> se la condizione viene soddisfatta entro lo scadere del timeout; in caso contrario, false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">L'argomento <paramref name="condition" /> è Null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Esegue rotazioni finché non è stata soddisfatta la condizione specificata o fino allo scadere del timeout specificato.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Delegato da eseguire ripetutamente finché non restituisce true.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa. In alternativa, per un'attesa indefinita, oggetto TimeSpan che rappresenta -1 millisecondi.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> se la condizione viene soddisfatta entro lo scadere del timeout; in caso contrario, false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">L'argomento <paramref name="condition" /> è Null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary vsli:raw="Provides the basic functionality for propagating a synchronization context in various synchronization models.">Fornisce la funzionalità di base per propagare un contesto di sincronizzazione in vari modelli di sincronizzazione.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; class.">Crea una nuova istanza della classe <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary vsli:raw="When overridden in a derived class, creates a copy of the synchronization context.">Quando ne viene eseguito l'override in una classe derivata, crea una copia del contesto di sincronizzazione.</summary>
      <returns vsli:raw="A new &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object.">Nuovo oggetto <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary vsli:raw="Gets the synchronization context for the current thread.">Ottiene il contesto di sincronizzazione per il thread corrente.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object representing the current synchronization context.">Oggetto <see cref="T:System.Threading.SynchronizationContext" /> che rappresenta il contesto di sincronizzazione corrente.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary vsli:raw="Determines if wait notification is required.">Determina se è necessaria la notifica dell'attesa.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if wait notification is required; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se è richiesta la notifica dell'attesa; in caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has completed.">Quando ne viene eseguito l'override in una classe derivata, risponde alla notifica di completamento di un'operazione.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has started.">Quando ne viene eseguito l'override in una classe derivata, risponde alla notifica di avvio di un'operazione.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches an asynchronous message to a synchronization context.">Quando ne viene eseguito l'override in una classe derivata, invia un messaggio asincrono a un contesto di sincronizzazione.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Delegato di <see cref="T:System.Threading.SendOrPostCallback" /> da chiamare.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Oggetto passato al delegato.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches a synchronous message to a synchronization context.">Quando ne viene eseguito l'override in una classe derivata, invia un messaggio sincrono a un contesto di sincronizzazione.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Delegato di <see cref="T:System.Threading.SendOrPostCallback" /> da chiamare.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Oggetto passato al delegato.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="The method was called in a Windows Store app. The implementation of &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; for Windows Store apps does not support the &lt;see cref=&quot;M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)&quot; /&gt; method.">Il metodo è stato chiamato in un'App Windows Store. L'implementazione di <see cref="T:System.Threading.SynchronizationContext" /> per le applicazioni Windows Store non supporta il metodo <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary vsli:raw="Sets the current synchronization context.">Imposta il contesto di sincronizzazione corrente.</summary>
      <param name="syncContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object to be set.">Oggetto <see cref="T:System.Threading.SynchronizationContext" /> da impostare.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary vsli:raw="Sets notification that wait notification is required and prepares the callback method so it can be called more reliably when a wait occurs.">Imposta la notifica che indica che è richiesta la notifica di attesa e prepara il metodo di callback in modo che possa essere chiamato in modo più affidabile in caso di attesa.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Waits for any or all the elements in the specified array to receive a signal.">Attende che uno qualsiasi o tutti gli elementi della matrice specificata ricevano un segnale.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Matrice di tipo <see cref="T:System.IntPtr" /> contenente gli handle nativi del sistema operativo.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles; &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" /> per attendere tutti gli handle; <see langword="false" /> per attendere un handle qualsiasi.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Indice della matrice dell'oggetto che ha soddisfatto l'attesa.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;waitHandles&quot; /&gt; is null.">
        <paramref name="waitHandles" /> è null.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Helper function that waits for any or all the elements in the specified array to receive a signal.">Funzione di supporto che attende che uno qualsiasi o tutti gli elementi della matrice specificata ricevano un segnale.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Matrice di tipo <see cref="T:System.IntPtr" /> contenente gli handle nativi del sistema operativo.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles;  &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" /> per attendere tutti gli handle; <see langword="false" /> per attendere un handle qualsiasi.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Indice della matrice dell'oggetto che ha soddisfatto l'attesa.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary vsli:raw="The exception that is thrown when a method requires the caller to own the lock on a given Monitor, and the method is invoked by a caller that does not own that lock.">Eccezione generata quando un metodo richiede che il chiamante sia il proprietario del blocco su un Monitor specifico, e tale metodo viene richiamato da un chiamante che non è proprietario del blocco.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with default properties.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con le proprietà predefinite.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with serialized data.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con dati serializzati.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; that holds the serialized object data about the exception being thrown.">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; that contains contextual information about the source or destination.">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con un messaggio di errore specificato.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.SynchronizationLockException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary vsli:raw="Provides thread-local storage of data.">Consente l'archiviazione dei dati nella memoria locale dei thread.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of data stored per-thread.">Specifica il tipo di dati archiviati per thread.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance and specifies whether all values are accessible from any thread.">Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" /> e specifica se tutti i valori sono accessibili da qualsiasi thread.</summary>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> per tenere traccia di tutti i valori impostati sull'istanza ed esporli tramite la proprietà <see cref="P:System.Threading.ThreadLocal`1.Values" />. In caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function.">Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" /> con la funzione <paramref name="valueFactory" /> specificata.</summary>
      <param name="valueFactory" vsli:raw="The  &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">Oggetto <see cref="T:System.Func`1" /> richiamato per produrre un valore con inizializzazione differita quando si prova a recuperare l'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> senza che sia stato inizializzato in precedenza.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> è un riferimento null (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function and a flag that indicates whether all values are accessible from any thread.">Inizializza l'istanza di <see cref="T:System.Threading.ThreadLocal`1" /> con la funzione <paramref name="valueFactory" /> specificata e un flag che indica se tutti i valori sono accessibili da qualsiasi thread.</summary>
      <param name="valueFactory" vsli:raw="The &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">Oggetto <see cref="T:System.Func`1" /> richiamato per produrre un valore con inizializzazione differita quando si tenta di recuperare l'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> senza che sia stato inizializzato in precedenza.</param>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> per tenere traccia di tutti i valori impostati sull'istanza ed esporli tramite la proprietà <see cref="P:System.Threading.ThreadLocal`1.Values" />. In caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">
        <paramref name="valueFactory" /> è un riferimento <see langword="null" /> (<see langword="Nothing" /> in Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; class.">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Rilascia le risorse usate dall'istanza di <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing" vsli:raw="A Boolean value that indicates whether this method is being called due to a call to &lt;see cref=&quot;M:System.Threading.ThreadLocal`1.Dispose&quot; /&gt;.">Valore booleano che indica se questo metodo viene chiamato a causa di una chiamata a <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Rilascia le risorse usate dall'istanza di <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary vsli:raw="Gets whether &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread.">Ottiene un valore che indica se l'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> è inizializzato sul thread corrente.</summary>
      <returns vsli:raw="true if &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread; otherwise false.">true se <see cref="P:System.Threading.ThreadLocal`1.Value" /> viene inizializzato sul thread corrente; in caso contrario, false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary vsli:raw="Creates and returns a string representation of this instance for the current thread.">Crea e restituisce una rappresentazione di stringa di questa istanza per il thread corrente.</summary>
      <returns vsli:raw="The result of calling &lt;see cref=&quot;M:System.Object.ToString&quot; /&gt; on the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt;.">Risultato della chiamata di <see cref="M:System.Object.ToString" /> su <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; for the current thread is a null reference (Nothing in Visual Basic).">L'oggetto <see cref="P:System.Threading.ThreadLocal`1.Value" /> per il thread corrente è un riferimento Null (Nothing in Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">La funzione di inizializzazione tenta di fare riferimento in modo ricorsivo a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Non viene fornito alcun costruttore senza parametri e non è specificato alcun valore di factory.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of this instance for the current thread.">Ottiene o imposta il valore di questa istanza per il thread corrente.</summary>
      <returns vsli:raw="Returns an instance of the object that this ThreadLocal is responsible for initializing.">Restituisce un'istanza dell'oggetto della cui inizializzazione è responsabile questo oggetto ThreadLocal.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">La funzione di inizializzazione tenta di fare riferimento in modo ricorsivo a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Non viene fornito alcun costruttore senza parametri e non è specificato alcun valore di factory.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary vsli:raw="Gets a list containing the values stored by all threads that have accessed this instance.">Ottiene un elenco di tutti i valori attualmente archiviati da tutti i thread che hanno eseguito l'accesso a questa istanza.</summary>
      <returns vsli:raw="A list for all of the values stored by all of the threads that have accessed this instance.">Elenco di tutti i valori attualmente archiviati da tutti i thread che hanno eseguito l'accesso a questa istanza.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Values stored by all threads are not available because this instance was initialized with the &lt;paramref name=&quot;trackAllValues&quot; /&gt; argument set to &lt;see langword=&quot;false&quot; /&gt; in the call to a class constructor.">I valori archiviati da tutti i thread non sono disponibili perché questa istanza è stata inizializzata con l'argomento <paramref name="trackAllValues" /> impostato su <see langword="false" /> nella chiamata al costruttore di una classe.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">L’istanza di <see cref="T:System.Threading.ThreadLocal`1" /> è stata eliminata.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary vsli:raw="Contains methods for performing volatile memory operations.">Contiene metodi per l'esecuzione di operazioni relative alla memoria volatile.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il valore del campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <returns vsli:raw="The value that was read.">Valore letto. Questo valore è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary vsli:raw="Reads the object reference from the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Legge il riferimento a un oggetto dal campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata dopo questo metodo nel codice, il processore non può spostarla prima di questo metodo.</summary>
      <param name="location" vsli:raw="The field to read.">Campo da leggere.</param>
      <typeparam name="T" vsli:raw="The type of field to read. This must be a reference type, not a value type.">Tipo di campo da leggere. Deve essere un tipo di riferimento, non un tipo di valore.</typeparam>
      <returns vsli:raw="The reference to &lt;paramref name=&quot;T&quot; /&gt; that was read. This reference is the latest written by any processor in the computer, regardless of the number of processors or the state of processor cache.">Riferimento a <paramref name="T" /> che è stato letto. Questo riferimento è l'ultimo che è stato scritto da un processore qualsiasi nel computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il valore specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo in cui viene scritto il valore.</param>
      <param name="value" vsli:raw="The value to write.">Valore da scrivere. Il valore viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary vsli:raw="Writes the specified object reference to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Scrive il riferimento a un oggetto specificato nel campo specificato. Nei sistemi che lo richiedono, inserisce una barriera di memoria che impedisce al processore di riordinare le operazioni di memoria come segue: Se un'operazione di lettura o di scrittura viene visualizzata prima di questo metodo nel codice, il processore non può spostarla dopo questo metodo.</summary>
      <param name="location" vsli:raw="The field where the object reference is written.">Campo in cui viene scritto il riferimento a un oggetto.</param>
      <param name="value" vsli:raw="The object reference to write.">Riferimento a un oggetto da scrivere. Il riferimento viene scritto immediatamente, in modo da essere reso visibile a tutti i processori nel computer.</param>
      <typeparam name="T" vsli:raw="The type of field to write. This must be a reference type, not a value type.">Tipo di campo da scrivere. Deve essere un tipo di riferimento, non un tipo di valore.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary vsli:raw="The exception that is thrown when an attempt is made to open a system mutex, semaphore, or event wait handle that does not exist.">Eccezione generata quando viene effettuato un tentativo di aprire un mutex di sistema, un semaforo o un handle di attesa evento inesistente.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with default values.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con i valori predefiniti.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with serialized data.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con dati serializzati.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene i dati di oggetto serializzati relativi all'eccezione generata.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente le informazioni contestuali sull'origine o sulla destinazione.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con un messaggio di errore specificato.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con un messaggio di errore specificato e un riferimento all'eccezione interna che è la causa dell'eccezione corrente.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Messaggio di errore in cui viene indicato il motivo dell'eccezione.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Eccezione che ha determinato l'eccezione corrente. Se il parametro <paramref name="innerException" /> non è <see langword="null" />, l'eccezione corrente viene generata in un blocco <see langword="catch" /> in cui viene gestita l'eccezione interna.</param>
    </member>
  </members>
</doc>