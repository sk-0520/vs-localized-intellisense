<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary vsli:raw="The exception that is thrown when one thread acquires a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that another thread has abandoned by exiting without releasing it.">A exceção gerada quando um thread adquire um objeto <see cref="T:System.Threading.Mutex" /> que outro thread abandonou ao ser fechado sem liberá-lo.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with default values.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com valores padrão.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com um índice especificado para o mutex abandonado, se aplicável, e um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex.</summary>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">O índice do mutex abandonado na matriz de identificadores de espera, se a exceção é gerada para o método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1, se a exceção é gerada para os métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex abandonado.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with serialized data.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com dados serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma mensagem de erro especificada.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Uma mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message and inner exception.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma exceção interna e uma mensagem de erro especificadas.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Uma mensagem de erro que explica a razão da exceção.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="inner" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the inner exception, the index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma mensagem de erro, a exceção interna, o índice para o mutex abandonado, se aplicável, e um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex especificados.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Uma mensagem de erro que explica a razão da exceção.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="inner" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">O índice do mutex abandonado na matriz de identificadores de espera, se a exceção é gerada para o método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1, se a exceção é gerada para os métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex abandonado.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the index of the abandoned mutex, if applicable, and the abandoned mutex.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AbandonedMutexException" /> com uma mensagem de erro, o índice do mutex abandonado, se aplicável, e o mutex abandonado especificados.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Uma mensagem de erro que explica a razão da exceção.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">O índice do mutex abandonado na matriz de identificadores de espera, se a exceção é gerada para o método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1, se a exceção é gerada para os métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex abandonado.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary vsli:raw="Gets the abandoned mutex that caused the exception, if known.">Obtém o mutex abandonado que causou a exceção, se for conhecido.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or &lt;see langword=&quot;null&quot; /&gt; if the abandoned mutex could not be identified.">Um <see cref="T:System.Threading.Mutex" /> objeto que representa o mutex abandonado ou <see langword="null" /> se o mutex abandonado não pôde ser identificado.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary vsli:raw="Gets the index of the abandoned mutex that caused the exception, if known.">Obtém o índice do mutex abandonado que causou a exceção, se for conhecido.</summary>
      <returns vsli:raw="The index, in the array of wait handles passed to the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or -1 if the index of the abandoned mutex could not be determined.">O índice, na matriz de identificadores de espera passado para <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> o método, <see cref="T:System.Threading.Mutex" /> do objeto que representa o mutex abandonado, ou-1 se o índice do mutex abandonado não puder ser determinado.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary vsli:raw="Provides the functionality to restore the migration, or flow, of the execution context between threads.">Fornece a funcionalidade para restaurar a migração ou o fluxo do contexto de execução entre threads.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> não é usada no thread em que ela foi criada.
- ou -
A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> já foi usada para chamar <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> ou <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified object is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Determina se o objeto especificado é igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</summary>
      <param name="obj" vsli:raw="An object to compare with the current structure.">Um objeto a ser comparado com a estrutura atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure and is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> for uma estrutura <see cref="T:System.Threading.AsyncFlowControl" /> e for igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Determines whether the specified &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Determina se a estrutura <see cref="T:System.Threading.AsyncFlowControl" /> especificada é igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</summary>
      <param name="obj" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure to compare with the current structure.">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" /> a comparar à estrutura atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> for igual à estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Obtém um código hash para a estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Um código hash para a estrutura <see cref="T:System.Threading.AsyncFlowControl" /> atual.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are equal.">Compara duas estruturas <see cref="T:System.Threading.AsyncFlowControl" /> para determinar se elas são iguais.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two structures are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas estruturas forem iguais, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are not equal.">Compara duas estruturas <see cref="T:System.Threading.AsyncFlowControl" /> para determinar se elas não são iguais.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the structures are not equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as estruturas não forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary vsli:raw="Restores the flow of the execution context between threads.">Restaura o fluxo do contexto de execução entre threads.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> não é usada no thread em que ela foi criada.
- ou -
A estrutura <see cref="T:System.Threading.AsyncFlowControl" /> já foi usada para chamar <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> ou <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary vsli:raw="Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.">Representa dados de ambiente que são locais para um determinado fluxo de controle assíncrono, como um método assíncrono.</summary>
      <typeparam name="T" vsli:raw="The type of the ambient data.">O tipo dos dados do ambiente.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instance that does not receive change notifications.">Cria uma instância <see cref="T:System.Threading.AsyncLocal`1" /> que não recebe notificações de alteração.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; local instance that receives change notifications.">Cria uma instância local <see cref="T:System.Threading.AsyncLocal`1" /> que recebe notificações de alteração.</summary>
      <param name="valueChangedHandler" vsli:raw="The delegate that is called whenever the current value changes on any thread.">O delegado que é chamado sempre que o valor atual é alterado em qualquer thread.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of the ambient data.">Obtém ou define o valor dos dados ambiente.</summary>
      <returns vsli:raw="The value of the ambient data. If no value has been set, the returned value is &lt;c&gt;default(T)&lt;/c&gt;.">O valor dos dados de ambiente. Se nenhum valor tiver sido definido, o valor retornado será <c>padrão (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary vsli:raw="The class that provides data change information to &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instances that register for change notifications.">A classe que fornece informações de alteração de dados para instâncias <see cref="T:System.Threading.AsyncLocal`1" /> que se registram para notificações de alteração.</summary>
      <typeparam name="T" vsli:raw="The type of the data.">O tipo de dados.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary vsli:raw="Gets the data's current value.">Obtém o valor atual dos dados.</summary>
      <returns vsli:raw="The data's current value.">O valor atual dos dados.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary vsli:raw="Gets the data's previous value.">Obtém o valor anterior dos dados.</summary>
      <returns vsli:raw="The data's previous value.">O valor anterior dos dados.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary vsli:raw="Returns a value that indicates whether the value changes because of a change of execution context.">Retorna um valor que indica se o valor é alterado devido a uma alteração do contexto de execução.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value changed because of a change of execution context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o valor foi alterado devido a uma alteração de contexto de execução; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, resets automatically after releasing a single waiting thread. This class cannot be inherited.">Representa um evento de sincronização de thread que, quando sinalizado, é redefinido automaticamente após a liberação de um thread em espera único. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AutoResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Inicializa uma nova instância da classe <see cref="T:System.Threading.AutoResetEvent" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to non-signaled.">
        <see langword="true" /> para definir o estado inicial como sinalizado; <see langword="false" /> para defini-lo como não sinalizado.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary vsli:raw="Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.">Permite que várias tarefas trabalhem de forma colaborativa em um algoritmo em paralelo por meio de várias fases.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">O número de threads participantes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> é menor que 0 ou maior que 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">O número de threads participantes.</param>
      <param name="postPhaseAction" vsli:raw="The &lt;see cref=&quot;T:System.Action`1&quot; /&gt; to be executed after each phase. null (Nothing in Visual Basic) may be passed to indicate no action is taken.">O <see cref="T:System.Action`1" /> a ser executado após cada fase. null (Nothing no Visual Basic) pode ser passado para indicar que nenhuma ação é executada.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> é menor que 0 ou maior que 32.767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be an additional participant.">Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá um participante adicional.</summary>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">O número de fase da barreira em que os novos participantes participarão primeiro.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Adding a participant would cause the barrier's participant count to exceed 32,767.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">Adicionar um participante fará com que a contagem de participantes da barreira exceda 32.767.
- ou -
O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be additional participants.">Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá participantes adicionais.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to add to the barrier.">O número de participantes adicionais a serem adicionados à barreira.</param>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">O número de fase da barreira em que os novos participantes participarão primeiro.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0.  &#xA;  &#xA; -or-  &#xA;  &#xA; Adding &lt;paramref name=&quot;participantCount&quot; /&gt; participants would cause the barrier's participant count to exceed 32,767.">
        <paramref name="participantCount" /> é menor que 0.
- ou -
Adicionar <paramref name="participantCount" /> participantes fará com que a contagem de participantes da barreira exceda 32.767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary vsli:raw="Gets the number of the barrier's current phase.">Obtém o número da fase atual da barreira.</summary>
      <returns vsli:raw="Returns the number of the barrier's current phase.">Retorna o número da fase atual da barreira.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt;, and optionally releases the managed resources.">Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.Barrier" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true para liberar os recursos gerenciados e não gerenciados; false para liberar somente os recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary vsli:raw="Gets the total number of participants in the barrier.">Obtém o número total de participantes na barreira.</summary>
      <returns vsli:raw="Returns the total number of participants in the barrier.">Retorna o número total de participantes na barreira.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary vsli:raw="Gets the number of participants in the barrier that haven't yet signaled in the current phase.">Obtém o número de participantes na barreira que ainda não foram sinalizados na fase atual.</summary>
      <returns vsli:raw="Returns the number of participants in the barrier that haven't yet signaled in the current phase.">Retorna o número de participantes na barreira que ainda não foram sinalizados na fase atual.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be one less participant.">Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá um participante a menos.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">A barreira já tem 0 participantes.
- ou -
O método foi invocado de dentro de uma ação pós-fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be fewer participants.">Notifica o <see cref="T:System.Threading.Barrier" /> de que haverá menos participantes.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to remove from the barrier.">O número de participantes adicionais a serem removidos da barreira.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The total participant count is less than the specified &lt;paramref name=&quot;participantCount&quot; /&gt;">A contagem total de participantes é menor que a <paramref name="participantCount" /> especificada</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current participant count is less than the specified participantCount.">A barreira já tem 0 participantes.
- ou -
O método foi invocado de dentro de uma ação pós-fase.
- ou -
A contagem de participantes atual é menor do que a participantCount especificada</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well.">Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Se uma exceção for gerada com base na ação pós-fase de um Barrier depois que todos os threads participantes tiverem chamado SignalAndWait, a exceção será encapsulada em um BarrierPostPhaseException e gerada em todos os threads participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout.">Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um inteiro com sinal de 32 bits para medir o tempo limite.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se todos os participantes atingirem a barreira dentro do tempo especificado, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Se uma exceção for gerada com base na ação pós-fase de um Barrier depois que todos os threads participantes tiverem chamado SignalAndWait, a exceção será encapsulada em um BarrierPostPhaseException e gerada em todos os threads participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout, while observing a cancellation token.">Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um inteiro com sinal de 32 bits para medir o tempo limite, enquanto observa um token de cancelamento.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">se todos os participantes atingirem a barreira dentro do tempo especificado, caso contrário, false</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier, while observing a cancellation token.">Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira, enquanto observa um token de cancelamento.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval.">Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um objeto <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se todos os outros participantes atingirem a barreira, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out, or it is greater than 32,767.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito ou é maior que 32.767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval, while observing a cancellation token.">Indica que um participante atingiu a barreira e aguarda até que todos os outros participantes atinjam a barreira também, usando um objeto <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo, enquanto observa um token de cancelamento.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se todos os outros participantes atingirem a barreira, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">O método foi invocado em uma ação pós-fase, a barreira atualmente tem 0 participantes ou a barreira é sinalizada por um número maior de threads do que os que estão registrados como participantes.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary vsli:raw="The exception that is thrown when the post-phase action of a &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; fails.">A exceção que é lançada quando a ação pós-fase de um <see cref="T:System.Threading.Barrier" /> falha.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a system-supplied message that describes the error.">Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com uma mensagem fornecida pelo sistema que descreve o erro.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with the specified inner exception.">Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com a exceção interna especificada.</summary>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception.">A exceção que é a causa da exceção atual.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with serialized data.">Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com dados serializados.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">O objeto que mantém os dados de objeto serializados.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">As informações contextuais sobre a origem ou o destino.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified message that describes the error.">Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com uma mensagem especificada que descreve o erro.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">A mensagem que descreve a exceção. O chamador desse construtor é necessário para garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa uma nova instância da classe <see cref="T:System.Threading.BarrierPostPhaseException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">A mensagem que descreve a exceção. O chamador desse construtor é necessário para garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary vsli:raw="Represents a method to be called within a new context.">Representa um método a ser chamado dentro de um novo contexto.</summary>
      <param name="state" vsli:raw="An object containing information to be used by the callback method each time it executes.">Um objeto que contém as informações a serem usadas pelo método de retorno de chamada sempre que ele for executado.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary vsli:raw="Represents a synchronization primitive that is signaled when its count reaches zero.">Representa um primitivo de sincronização que é sinalizado quando sua contagem atinge zero.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class with the specified count.">Inicializa uma nova instância da classe <see cref="T:System.Threading.CountdownEvent" /> com a contagem especificada.</summary>
      <param name="initialCount" vsli:raw="The number of signals initially required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">O número de sinais inicialmente necessários para definir o <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by one.">Incrementa a contagem atual de <see cref="T:System.Threading.CountdownEvent" /> em um.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">A instância atual já está definida.
- ou -
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> é igual a ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by a specified value.">Incrementa a contagem atual de <see cref="T:System.Threading.CountdownEvent" /> em um valor especificado.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">O valor pelo qual aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> é menor ou igual a 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; after count is incremented by &lt;paramref name=&quot;signalCount&quot; /&gt;.">A instância atual já está definida.
- ou -
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> é igual ou maior que <see cref="F:System.Int32.MaxValue" /> depois que a contagem é incrementada em <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary vsli:raw="Gets the number of remaining signals required to set the event.">Obtém o número de sinais restantes necessárias para definir o evento.</summary>
      <returns vsli:raw="The number of remaining signals required to set the event.">O número de sinais restantes necessários para definir o evento.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, and optionally releases the managed resources.">Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.CountdownEvent" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true para liberar os recursos gerenciados e não gerenciados; false para liberar somente os recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary vsli:raw="Gets the numbers of signals initially required to set the event.">Obtém os números de sinais inicialmente necessários para definir o evento.</summary>
      <returns vsli:raw="The number of signals initially required to set the event.">O número de sinais inicialmente exigidos para definir o evento.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary vsli:raw="Indicates whether the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; object's current count has reached zero.">Indica se a contagem atual do objeto <see cref="T:System.Threading.CountdownEvent" /> chegou a zero.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current count is zero; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a contagem atual for zero; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; to the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt;.">Redefine o <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> para o valor de <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt; property to a specified value.">Redefine a propriedade <see cref="P:System.Threading.CountdownEvent.InitialCount" /> com um valor especificado.</summary>
      <param name="count" vsli:raw="The number of signals required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">O número de sinais necessários para definir o <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is less than 0.">
        <paramref name="count" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary vsli:raw="Registers a signal with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Registra um sinal com o <see cref="T:System.Threading.CountdownEvent" />, diminuindo o valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signal caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o sinal tiver feito a contagem alcançar zero e o evento tiver sido definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.">A instância atual já está definida.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary vsli:raw="Registers multiple signals with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by the specified amount.">Registra vários sinais com o <see cref="T:System.Threading.CountdownEvent" />, diminuindo o valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> pelo valor especificado.</summary>
      <param name="signalCount" vsli:raw="The number of signals to register.">O número de sinais a serem registrados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signals caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os sinais tiverem feito a contagem alcançar zero e o evento tiver sido definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than 1.">
        <paramref name="signalCount" /> é menor que 1.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set. -or- Or &lt;paramref name=&quot;signalCount&quot; /&gt; is greater than &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">A instância atual já está definida. – ou – Ou <paramref name="signalCount" /> é maior que <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by one.">Tenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> por um.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero, this method will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o incremento foi bem-sucedido, caso contrário, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> já estiver em zero, esse método retornará <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> é igual a <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by a specified value.">Tenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> em um valor especificado.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">O valor pelo qual aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero this will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o incremento foi bem-sucedido, caso contrário, false. Se <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> já estiver em zero, isso retornará <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> é menor ou igual a 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; + &lt;paramref name=&quot;signalCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> é igual a ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set.">Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout.">Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um inteiro com sinal de 32 bits para medir o tempo limite.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um inteiro com sinal de 32 bits para medir o tempo limite, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">A instância atual já foi descartada. – ou – O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">A instância atual já foi descartada. – ou – O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout.">Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o tempo limite.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que o <see cref="T:System.Threading.CountdownEvent" /> seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o tempo limite, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.CountdownEvent" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">
        <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">A instância atual já foi descartada. – ou – O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Obtém um <see cref="T:System.Threading.WaitHandle" /> que é usado para aguardar o evento a ser definido.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Um <see cref="T:System.Threading.WaitHandle" /> que é usado para aguardar a definição do evento.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary vsli:raw="Indicates whether an &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; is reset automatically or manually after receiving a signal.">Indica se um <see cref="T:System.Threading.EventWaitHandle" /> é redefinido de forma automática ou manual após receber um sinal.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; resets automatically after releasing a single thread. If no threads are waiting, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; remains signaled until a thread blocks, and resets after releasing the thread.">Quando sinalizado, o <see cref="T:System.Threading.EventWaitHandle" /> é redefinido automaticamente após o lançamento de um único thread. Se nenhum thread estiver aguardando, o <see cref="T:System.Threading.EventWaitHandle" /> permanece sinalizado até que um thread seja bloqueado e é redefinido após a liberação do thread.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; releases all waiting threads and remains signaled until it is manually reset.">Quando sinalizado, o <see cref="T:System.Threading.EventWaitHandle" /> libera todos os threads em espera e permanece sinalizado até ser redefinido manualmente.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary vsli:raw="Represents a thread synchronization event.">Representa um evento de sincronização de thread.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.">Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente e se ele redefine automática ou manualmente.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> para definir o estado inicial como sinalizado; <see langword="false" /> para defini-lo como não sinalizado.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.">Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente e o nome de um evento de sincronização do sistema.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <see langword="false" /> para defini-lo como não sinalizado.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome de um evento de sincronização de todo o sistema.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">O evento nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Não foi possível criar o evento nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.">Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente, o nome de um evento de sincronização do sistema e uma variável booliana cujo valor após a chamada indica se o evento de sistema nomeado foi criado.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <see langword="false" /> para defini-lo como não sinalizado.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome de um evento de sincronização de todo o sistema.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local event was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system event was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system event already existed. This parameter is passed uninitialized.">Quando esse método for retornado, conterá <see langword="true" /> se um evento local tiver sido criado (ou seja, se <paramref name="name" /> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o evento de sistema nomeado especificado tiver sido criado; <see langword="false" /> se o evento de sistema nomeado especificado já existia. Este parâmetro é passado não inicializado.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">O evento nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Não foi possível criar o evento nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists.">Abre o evento de sincronização nomeado especificado, caso ele já exista.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do evento de sincronização de sistema a ser aberto.</param>
      <returns vsli:raw="An object that represents the named system event.">Um objeto que representa o evento do sistema nomeado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be opened. It may not exist, or a synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">O evento do sistema nomeado não existe.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the security access required to use it.">O evento nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, causing threads to block.">Define o estado do evento como não sinalizado, fazendo com que os threads sejam bloqueados.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary vsli:raw="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">Define o estado do evento a ser sinalizado, permitindo que um ou mais threads de espera prossigam.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.">Abre o evento de sincronização nomeado especificado, se ele já existir e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do evento de sincronização de sistema a ser aberto.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; object that represents the named synchronization event if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quando é retornado, esse método contém um objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa o evento de sincronização nomeado se a chamada tiver sido bem-sucedida ou <see langword="null" /> se a chamada tiver falhado. Esse parâmetro é tratado como não inicializado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named synchronization event was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> se o evento de sincronização nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the desired security access.">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary vsli:raw="Manages the execution context for the current thread. This class cannot be inherited.">Gerencia o contexto de execução do thread atual. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary vsli:raw="Captures the execution context from the current thread.">Captura o contexto de execução do thread atual.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the execution context for the current thread.">Um objeto <see cref="T:System.Threading.ExecutionContext" /> que representa o contexto de execução do thread atual.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current execution context.">Cria uma cópia do contexto de execução atual.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the current execution context.">Um objeto <see cref="T:System.Threading.ExecutionContext" /> que representa o contexto de execução atual.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This context cannot be copied because it is used. Only newly captured contexts can be copied.">Não é possível copiar neste contexto porque ele é usado. Apenas contextos recém-capturados podem ser copiados.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Sets the specified &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object with the logical context information needed to recreate an instance of the current execution context.">Define o objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> especificado com as informações lógicas do contexto necessárias para recriar uma instância do contexto de execução atual.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object to be populated with serialization information.">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> a ser preenchido com informações de serialização.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; structure representing the destination context of the serialization.">A estrutura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que representa o contexto de destino da serialização.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;info&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="info" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary vsli:raw="Indicates whether the flow of the execution context is currently suppressed.">Indica se o fluxo do contexto de execução está suprimido no momento.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the flow is suppressed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o fluxo for suprimido; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary vsli:raw="Restores the flow of the execution context across asynchronous threads.">Restaura o fluxo do contexto de execução em threads assíncronos.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow cannot be restored because it is not being suppressed.">O fluxo do contexto não pode ser restaurado porque não está sendo suprimido.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary vsli:raw="Runs a method in a specified execution context on the current thread.">Executa um método em um contexto de execução especificado no thread atual.</summary>
      <param name="executionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; to set.">
        <see cref="T:System.Threading.ExecutionContext" /> ao dataset.</param>
      <param name="callback" vsli:raw="A &lt;see cref=&quot;T:System.Threading.ContextCallback&quot; /&gt; delegate that represents the method to be run in the provided execution context.">Um <see cref="T:System.Threading.ContextCallback" /> delegado que representa o método a ser executado no contexto de execução fornecido.</param>
      <param name="state" vsli:raw="The object to pass to the callback method.">O objeto a passar para o método de retorno de chamada.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;executionContext&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; has already been used as the argument to a &lt;see cref=&quot;M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)&quot; /&gt; call.">
        <paramref name="executionContext" /> é <see langword="null" />.
- ou -
<paramref name="executionContext" /> não foi adquirido por meio de uma operação de captura.
- ou -
<paramref name="executionContext" /> já foi usado como argumento para uma chamada <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary vsli:raw="Suppresses the flow of the execution context across asynchronous threads.">Suprime o fluxo do contexto de execução em threads assíncronos.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure for restoring the flow.">Uma estrutura <see cref="T:System.Threading.AsyncFlowControl" /> para restaurar o fluxo.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow is already suppressed.">O fluxo do contexto já está suprimido.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary vsli:raw="Encapsulates and propagates the host execution context across threads.">Encapsula e propaga o contexto de execução do host em threads.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class using the specified state.">Inicializa uma nova instância da classe <see cref="T:System.Threading.HostExecutionContext" /> usando o estado especificado.</summary>
      <param name="state" vsli:raw="An object representing the host execution context state.">Um objeto que representa o estado do contexto de execução do host.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current host execution context.">Cria uma cópia do contexto de execução do host atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host context for the current thread.">Um objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa o contexto do host para o thread atual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary vsli:raw="When overridden in a derived class, releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt;, and optionally releases the managed resources.">Quando substituído em uma classe derivada, libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.WaitHandle" /> e, opcionalmente, libera os recursos gerenciados.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary vsli:raw="Gets or sets the state of the host execution context.">Obtém ou define o estado do contexto de execução do host.</summary>
      <returns vsli:raw="An object representing the host execution context state.">Um objeto que representa o estado do contexto de execução do host.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary vsli:raw="Provides the functionality that allows a common language runtime host to participate in the flow, or migration, of the execution context.">Fornece a funcionalidade que permite que um host Common Language Runtime participe do fluxo ou migração do contexto de execução.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContextManager&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary vsli:raw="Captures the host execution context from the current thread.">Captura o contexto de execução do host do thread atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host execution context of the current thread.">Um objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa o contexto de execução do host do thread atual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary vsli:raw="Restores the host execution context to its prior state.">Restaura o contexto de execução do host para seu estado anterior.</summary>
      <param name="previousState" vsli:raw="The previous context state to revert to.">O estado de contexto anterior para o qual reverter.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;previousState&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; was not created on the current thread.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; is not the last state for the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt;.">
        <paramref name="previousState" /> é <see langword="null" />.
- ou -
<paramref name="previousState" /> não foi criado no thread atual.
- ou -
<paramref name="previousState" /> não é o último estado para o <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary vsli:raw="Sets the current host execution context to the specified host execution context.">Define o contexto de execução do host atual para o contexto de execução do host especificado.</summary>
      <param name="hostExecutionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to be set.">O <see cref="T:System.Threading.HostExecutionContext" /> a ser definido.</param>
      <returns vsli:raw="An object for restoring the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to its previous state.">Um objeto para restaurar o <see cref="T:System.Threading.HostExecutionContext" /> a seu estado anterior.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;hostExecutionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;hostExecutionContext&quot; /&gt; has been the argument to a previous &lt;see cref=&quot;M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)&quot; /&gt; method call.">
        <paramref name="hostExecutionContext" /> não foi adquirido por meio de uma operação de captura.
- ou -
<paramref name="hostExecutionContext" /> tem sido o argumento para uma chamada de método <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" /> anterior.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary vsli:raw="Provides atomic operations for variables that are shared by multiple threads.">Fornece operações atômicas para variáveis que são compartilhadas por vários threads.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary vsli:raw="Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.">Adiciona dois números inteiros de 32 bits e substitui o primeiro inteiro com a soma, como uma operação atômica.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Uma variável que contém o primeiro valor a ser adicionado. A soma dos dois valores é armazenada em <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">O valor a ser adicionado ao inteiro em <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">O novo valor armazenado em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary vsli:raw="Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.">Adiciona dois números inteiros de 64 bits e substitui o primeiro inteiro com a soma, como uma operação atômica.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Uma variável que contém o primeiro valor a ser adicionado. A soma dos dois valores é armazenada em <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">O valor a ser adicionado ao inteiro em <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">O novo valor armazenado em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary vsli:raw="Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.">Compara se dois pontos flutuantes de precisão dupla são iguais e, se eles forem, substitui o primeiro valor.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary vsli:raw="Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.">Compara dois inteiros com sinal de 32 bits para verificar se são iguais e, em caso de igualdade, substitui o primeiro valor.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary vsli:raw="Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.">Compara dois inteiros com sinal de 64 bits para verificar se são iguais e, em caso de igualdade, substitui o primeiro valor.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary vsli:raw="Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.">Compara dois ponteiros ou identificadores específicos da plataforma quanto à igualdade e, se eles são iguais, substitui o primeiro.</summary>
      <param name="location1" vsli:raw="The destination &lt;see cref=&quot;T:System.IntPtr&quot; /&gt;, whose value is compared with the value of &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced by &lt;paramref name=&quot;value&quot; /&gt;.">O <see cref="T:System.IntPtr" /> de destino, cujo valor é comparado com o valor de <paramref name="comparand" /> e possivelmente substituído por <paramref name="value" />.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that replaces the destination value if the comparison results in equality.">O <see cref="T:System.IntPtr" /> que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">O <see cref="T:System.IntPtr" /> comparado ao valor em <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary vsli:raw="Compares two objects for reference equality and, if they are equal, replaces the first object.">Compara dois objetos quanto à igualdade de referência e, se eles forem iguais, substitui o primeiro objeto.</summary>
      <param name="location1" vsli:raw="The destination object that is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">O objeto de destino que é comparado pela referência com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value" vsli:raw="The object that replaces the destination object if the reference comparison results in equality.">O objeto que substitui o objeto de destino quando a comparação de referência resulta em igualdade.</param>
      <param name="comparand" vsli:raw="The object that is compared by reference to the object at &lt;paramref name=&quot;location1&quot; /&gt;.">O objeto que é comparado pela referência ao objeto em <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary vsli:raw="Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.">Compara se dois números de ponto flutuante de precisão simples são iguais e, se eles são, substitui o primeiro valor.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">O destino, cujo valor é comparado com <paramref name="comparand" /> e possivelmente substituído.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">O valor comparado ao valor em <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary vsli:raw="Compares two instances of the specified reference type &lt;paramref name=&quot;T&quot; /&gt; for reference equality and, if they are equal, replaces the first one.">Compara duas instâncias do tipo de referência <paramref name="T" /> especificado em relação à igualdade e, se elas forem iguais, substitui a primeira.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">O destino, cujo valor é comparado por referência com <paramref name="comparand" /> e possivelmente substituído. Esse é um parâmetro de referência (<see langword="ref" /> no C# e <see langword="ByRef" /> no Visual Basic).</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison by reference results in equality.">O valor que substitui o valor de destino quando a comparação pela referência resulta em igualdade.</param>
      <param name="comparand" vsli:raw="The value that is compared by reference to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">O valor que é comparado pela referência com o valor em <paramref name="location1" />.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt;, &lt;paramref name=&quot;value&quot; /&gt;, and &lt;paramref name=&quot;comparand&quot; /&gt;. This type must be a reference type.">O tipo a ser usado para <paramref name="location1" />, <paramref name="value" /> e <paramref name="comparand" />. Esse tipo deve ser um tipo de referência.</typeparam>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original em <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary vsli:raw="Decrements a specified variable and stores the result, as an atomic operation.">Decrementa uma variável especificada e armazena o resultado, como uma operação atômica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">A variável cujo valor deve ser decrementado.</param>
      <returns vsli:raw="The decremented value.">O valor decrementado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary vsli:raw="Decrements the specified variable and stores the result, as an atomic operation.">Diminui uma variável especificada e armazena o resultado como uma operação atômica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">A variável cujo valor deve ser decrementado.</param>
      <returns vsli:raw="The decremented value.">O valor decrementado.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary vsli:raw="Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.">Define um número de ponto flutuante de precisão dupla para um valor especificado e retorna o valor original, como uma operação atômica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">A variável a ser definida com o valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary vsli:raw="Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.">Define um inteiro com sinal de 32 bits com um valor especificado e retorna o valor original, como uma operação atômica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">A variável a ser definida com o valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary vsli:raw="Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.">Define um inteiro com sinal de 64 bits com um valor especificado e retorna o valor original, como uma operação atômica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">A variável a ser definida com o valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.">Define um identificador específico de plataforma ou um ponteiro para um valor especificado e retorna o valor original como uma operação atômica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">A variável a ser definida com o valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary vsli:raw="Sets an object to a specified value and returns a reference to the original object, as an atomic operation.">Define um objeto com um valor especificado e retorna uma referência ao objeto original, como uma operação atômica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">A variável a ser definida com o valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary vsli:raw="Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.">Define um número de ponto flutuante de precisão simples para um valor especificado e retorna o valor original como uma operação atômica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">A variável a ser definida com o valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary vsli:raw="Sets a variable of the specified type &lt;paramref name=&quot;T&quot; /&gt; to a specified value and returns the original value, as an atomic operation.">Define uma variável do tipo <paramref name="T" /> especificado como um valor especificado e retorna o valor original como uma operação atômica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">A variável a ser definida com o valor especificado. Esse é um parâmetro de referência (<see langword="ref" /> no C# e <see langword="ByRef" /> no Visual Basic).</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">O valor para o qual o parâmetro <paramref name="location1" /> é definido.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt;. This type must be a reference type.">O tipo a ser usado para o <paramref name="location1" /> e <paramref name="value" />. Esse tipo deve ser um tipo de referência.</typeparam>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">O valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location1" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Incrementa uma variável especificada e armazena o resultado, como uma operação atômica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">A variável cujo valor deve ser incrementado.</param>
      <returns vsli:raw="The incremented value.">O valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Incrementa uma variável especificada e armazena o resultado, como uma operação atômica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">A variável cujo valor deve ser incrementado.</param>
      <returns vsli:raw="The incremented value.">O valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">O endereço de <paramref name="location" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary vsli:raw="Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt; execute after memory accesses that follow the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt;.">Sincroniza o acesso à memória da seguinte maneira: o processador que executa o thread atual não pode reorganizar as instruções de forma que os acessos à memória anteriores à chamada para <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> sejam executados depois dos acessos à memória posteriores à chamada para <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary vsli:raw="Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.">Fornece uma barreira de memória em todo o processo, que garante que leituras e gravações de qualquer CPU não possam se mover pela barreira.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary vsli:raw="Returns a 64-bit value, loaded as an atomic operation.">Retorna um valor de 64 bits, carregado como uma operação atômica.</summary>
      <param name="location" vsli:raw="The 64-bit value to be loaded.">O valor de 64 bits a ser carregado.</param>
      <returns vsli:raw="The loaded value.">O valor carregado.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary vsli:raw="Provides lazy initialization routines.">Fornece rotinas de inicialização lentas.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary vsli:raw="Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.">Inicializa um tipo de referência de destino com o construtor sem parâmetro de tipo se ele ainda não foi inicializado.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Uma referência para inicializar se ela ainda não tiver sido inicializada.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">O tipo da referência a ser inicializada.</typeparam>
      <returns vsli:raw="The initialized object.">O objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Permissões para acessar o construtor do tipo <paramref name="T" /> estavam ausentes.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary vsli:raw="Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.">Inicializa uma referência de destino ou um tipo de valor com seu construtor sem parâmetro se ele ainda não foi inicializado.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Uma referência ou um valor do tipo <c>T</c> a ser inicializado se já não tiver sido inicializado.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Uma referência a um valor booliano que determina se o destino já foi inicializado.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Uma referência a um objeto usado como o bloqueio mutuamente exclusivo para inicializar <paramref name="target" />. Se <paramref name="syncLock" /> for <see langword="null" />, será criada uma instância de um novo objeto.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">O tipo da referência a ser inicializada.</typeparam>
      <returns vsli:raw="The initialized object.">O objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Permissões para acessar o construtor do tipo <paramref name="T" /> estavam ausentes.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference or value type by using a specified function if it hasn't already been initialized.">Inicializa um tipo de valor ou referência de destino usando uma função especificadas se ainda não tiver sido inicializada.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Uma referência ou um valor do tipo <c>T</c> a ser inicializado se já não tiver sido inicializado.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Uma referência a um valor booliano que determina se o destino já foi inicializado.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Uma referência a um objeto usado como o bloqueio mutuamente exclusivo para inicializar <paramref name="target" />. Se <paramref name="syncLock" /> for <see langword="null" />, será criada uma instância de um novo objeto.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference or value.">A função que é chamada para inicializar a referência ou valor.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">O tipo da referência a ser inicializada.</typeparam>
      <returns vsli:raw="The initialized object.">O objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Permissões para acessar o construtor do tipo <paramref name="T" /> estavam ausentes.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type by using a specified function if it hasn't already been initialized.">Inicializa um tipo de referência de destino usando uma função especificadas se ainda não tiver sido inicializada.</summary>
      <param name="target" vsli:raw="The reference to initialize if it hasn't already been initialized.">Uma referência a ser inicializada se ainda não tiver sido.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference.">A função que é chamada para inicializar a referência.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">O tipo da referência a ser inicializada.</typeparam>
      <returns vsli:raw="The initialized object.">O objeto inicializado.</returns>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">O tipo <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; returned null (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> retornou null (Nothing no Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type with a specified function if it has not already been initialized.">Inicializará um tipo de referência de destino com uma função especificada se ainda não tiver sido inicializado.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Uma referência para inicializar se ela ainda não tiver sido inicializada.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing&#xA;            &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Uma referência a um objeto usado como o bloqueio mutuamente exclusivo para inicializar <paramref name="target" />. Se <paramref name="syncLock" /> for <see langword="null" />, será criada uma instância de um novo objeto.</param>
      <param name="valueFactory" vsli:raw="The method to invoke to initialize &lt;paramref name=&quot;target&quot; /&gt;.">O método a ser invocado para inicializar <paramref name="target" />.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">O tipo da referência a ser inicializada.</typeparam>
      <returns vsli:raw="The initialized object.">O objeto inicializado.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary vsli:raw="Defines the lock that implements single-writer/multiple-reader semantics. This is a value type.">Define o bloqueio que implementa a semântica de único gravador/vários leitores. Este é um tipo de valor.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary vsli:raw="Indicates whether a specified object is a &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; and is equal to the current instance.">Indica se o objeto especificado é um <see cref="T:System.Threading.LockCookie" /> e é igual à instância atual.</summary>
      <param name="obj" vsli:raw="The object to compare to the current instance.">O objeto a ser comparado com a instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value of &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o valor de <paramref name="obj" /> for igual ao valor da instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether the current instance is equal to the specified &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt;.">Indica se a instância atual é igual ao <see cref="T:System.Threading.LockCookie" /> especificado.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to the current instance.">O <see cref="T:System.Threading.LockCookie" /> a ser comparado com a instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> é igual ao valor da instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retorna o código hash para essa instância.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Um código de hash do inteiro assinado de 32 bits.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are equal.">Indica se duas estruturas <see cref="T:System.Threading.LockCookie" /> são iguais.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="a" /> for igual a <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are not equal.">Indica se duas estruturas <see cref="T:System.Threading.LockCookie" /> não são iguais.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">O <see cref="T:System.Threading.LockCookie" /> para comparar com <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is not equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="a" /> não for igual a <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary vsli:raw="The exception that is thrown when recursive entry into a lock is not compatible with the recursion policy for the lock.">A exceção que é lançada quando a entrada recursiva em um bloqueio não é compatível com a política de recursão para o bloqueio.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a system-supplied message that describes the error.">Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com uma mensagem fornecida pelo sistema que descreve o erro.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with serialized data.">Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com dados serializados.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">O objeto que mantém os dados de objeto serializados.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">As informações contextuais sobre a origem ou o destino.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified message that describes the error.">Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com uma mensagem especificada que descreve o erro.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">A mensagem que descreve a exceção. O chamador desse construtor deve garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa uma nova instância da classe <see cref="T:System.Threading.LockRecursionException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">A mensagem que descreve a exceção. O chamador desse construtor deve garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
      <param name="innerException" vsli:raw="The exception that caused the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">A exceção que causou a exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary vsli:raw="Specifies whether a lock can be entered multiple times by the same thread.">Especifica se um bloqueio pode ser inserido várias vezes pelo mesmo thread.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary vsli:raw="If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.">Se um thread tentar inserir um bloqueio recursivamente, uma exceção será lançada. Algumas classes podem permitir determinadas recursões quando essa configuração está em vigor.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary vsli:raw="A thread can enter a lock recursively. Some classes may restrict this capability.">Um thread pode inserir um bloqueio recursivamente. Algumas classes podem restringir essa funcionalidade.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class cannot be inherited.">Representa um evento de sincronização de thread que, quando sinalizado, deve ser redefinido manualmente. Essa classe não pode ser herdada.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEvent" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to nonsignaled.">
        <see langword="true" /> para definir o estado inicial como sinalizado; <see langword="false" /> para defini-lo como não sinalizado.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class is a lightweight alternative to &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt;.">Representa um evento de sincronização de thread que, quando sinalizado, deve ser redefinido manualmente. Esta classe é uma alternativa leve para <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with an initial state of nonsignaled.">Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEventSlim" /> com um estado inicial de não sinalizado.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEventSlim" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado.</summary>
      <param name="initialState" vsli:raw="true to set the initial state signaled; false to set the initial state to nonsignaled.">true para definir o estado inicial como sinalizado; false para defini-lo como não sinalizado.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled and a specified spin count.">Inicializa uma nova instância da classe <see cref="T:System.Threading.ManualResetEventSlim" /> com um valor booliano que indica se é necessário definir o estado inicial como sinalizado e uma contagem de rotação especificada.</summary>
      <param name="initialState" vsli:raw="true to set the initial state to signaled; false to set the initial state to nonsignaled.">true para definir o estado inicial como sinalizado; false para defini-lo como não sinalizado.</param>
      <param name="spinCount" vsli:raw="The number of spin waits that will occur before falling back to a kernel-based wait operation.">O número de esperas de rotação que ocorrerão antes de retornar para uma operação de espera com base em kernel.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;spinCount&quot; /&gt; is less than 0 or greater than the maximum allowed value.">
        <paramref name="spinCount" /> é menor que 0 ou maior que o valor máximo permitido.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;, and optionally releases the managed resources.">Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.ManualResetEventSlim" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true para liberar os recursos gerenciados e não gerenciados; false para liberar somente os recursos não gerenciados.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary vsli:raw="Gets whether the event is set.">Descobre se o evento está definido.</summary>
      <returns vsli:raw="true if the event is set; otherwise, false.">true se o evento for definido; caso contrário, false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, which causes threads to block.">Define o estado do evento como não sinalizado, o que causa o bloqueio dos threads.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary vsli:raw="Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.">Define o estado do evento a ser sinalizado, que permite que um ou mais threads aguardem a continuação do evento.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary vsli:raw="Gets the number of spin waits that will occur before falling back to a kernel-based wait operation.">Obtém o número de esperas de rotação que ocorrerão antes de retornar para uma operação de espera com base em kernel.</summary>
      <returns vsli:raw="Returns the number of spin waits that will occur before falling back to a kernel-based wait operation.">Retorna o número de esperas de rotação que ocorrerão antes de fazer fallback para uma operação de espera baseada em kernel.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set.">Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> seja definido.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval.">Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">O número de milissegundos de espera ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar por tempo indefinido.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">O objeto já foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; receives a signal, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual receba um sinal, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">O objeto já foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was&#xA;            canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.
- ou -
O número de milissegundos em <paramref name="timeout" /> é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">O objeto já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que o <see cref="T:System.Threading.ManualResetEventSlim" /> atual seja definido, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <see cref="T:System.Threading.ManualResetEventSlim" /> foi definido; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.
- ou -
O número de milissegundos em <paramref name="timeout" /> é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">O número máximo de erros foi excedido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">O objeto já foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado.</exception>
      <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Obtém o objeto <see cref="T:System.Threading.WaitHandle" /> subjacente para este <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns vsli:raw="The underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; event object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">O objeto de evento <see cref="T:System.Threading.WaitHandle" /> subjacente deste <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary vsli:raw="Provides a mechanism that synchronizes access to objects.">Fornece um mecanismo que sincroniza o acesso a objetos.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object.">Adquire um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the monitor lock.">O objeto no qual adquirir o bloqueio do monitor.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Obtém um bloqueio exclusivo no objeto especificado e define automaticamente um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">O objeto no qual aguardar.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.  &#xA;  &#xA; Note   If no exception occurs, the output of this method is always &lt;see langword=&quot;true&quot; /&gt;.">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.
Observação   Se não nenhuma exceção ocorrer, a saída desse método sempre será <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary vsli:raw="Releases an exclusive lock on the specified object.">Libera um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to release the lock.">O objeto no qual liberar o bloqueio.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread does not own the lock for the specified object.">O thread atual não é o proprietário do bloqueio do objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary vsli:raw="Determines whether the current thread holds the lock on the specified object.">Determina se o thread atual mantém o bloqueio no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object to test.">O objeto a ser testado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the lock on &lt;paramref name=&quot;obj&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual mantiver o bloqueio no <paramref name="obj" />; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;obj&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary vsli:raw="Gets the number of times there was contention when trying to take the monitor's lock.">Obtém o número de vezes em que houve contenção ao tentar realizar o bloqueio do monitor.</summary>
      <returns vsli:raw="The number of times there was contention when trying to take the monitor's lock.">O número de vezes que houve contenção ao tentar usar o bloqueio do monitor.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary vsli:raw="Notifies a thread in the waiting queue of a change in the locked object's state.">Notifica um thread na fila de espera de uma alteração no estado do objeto bloqueado.</summary>
      <param name="obj" vsli:raw="The object a thread is waiting for.">O objeto ao qual um thread está aguardando.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary vsli:raw="Notifies all waiting threads of a change in the object's state.">Notifica todos os threads em espera de uma alteração no estado do objeto.</summary>
      <param name="obj" vsli:raw="The object that sends the pulse.">O objeto que envia o pulso.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object.">Tenta adquirir um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">O objeto no qual adquirir o bloqueio.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual adquirir o bloqueio; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Tenta obter um bloqueio exclusivo no objeto especificado e define automaticamente um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">O objeto no qual adquirir o bloqueio.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.">Tentativas, durante o período especificado de milésimos de segundos, para adquirir um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">O objeto no qual adquirir o bloqueio.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">O número de milésimos de segundos de espera do bloqueio.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual adquirir o bloqueio; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> é negativo e diferente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Tenta, pelo número de milissegundos especificado, obter um bloqueio exclusivo no objeto especificado e define de forma atômica um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">O objeto no qual adquirir o bloqueio.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">O número de milésimos de segundos de espera do bloqueio.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> é negativo e diferente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.">Tentativas, durante o período especificado de tempo, para adquirir um bloqueio exclusivo no objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">O objeto no qual adquirir o bloqueio.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">Um <see cref="T:System.TimeSpan" /> que representa a quantidade de tempo a esperar pelo bloqueio. Um valor de -1 milissegundo especifica uma espera infinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual adquirir o bloqueio; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">O valor de <paramref name="timeout" /> em milissegundos é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundo) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Tenta, pelo período especificado, obter um bloqueio exclusivo no objeto especificado e define automaticamente um valor que indica se o bloqueio foi realizado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">O objeto no qual adquirir o bloqueio.</param>
      <param name="timeout" vsli:raw="The amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">A quantidade de tempo a esperar pelo bloqueio. Um valor de -1 milissegundo especifica uma espera infinita.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">O resultado da tentativa de adquirir o bloqueio, passado por referência. A entrada deve ser <see langword="false" />. A saída será <see langword="true" /> se o bloqueio for adquirido; caso contrário, a saída será <see langword="false" />. A saída é definida mesmo se ocorrer uma exceção durante a tentativa de adquirir o bloqueio.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">A entrada para <paramref name="lockTaken" /> é <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">O valor de <paramref name="timeout" /> em milissegundos é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundo) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock.">Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">O objeto no qual aguardar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.">
        <see langword="true" /> se a chamada foi retornada porque o chamador adquiriu o bloqueio novamente para o objeto especificado. Este método não será retornado se o bloqueio não for adquirido novamente.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">O objeto no qual aguardar.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">O número de milissegundos de espera antes que o thread entre na fila pronta.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">O valor do parâmetro <paramref name="millisecondsTimeout" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.">Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta. Esse método também especifica se o domínio de sincronização para o contexto (se estiver em um contexto sincronizado) é encerrado antes do tempo de espera e readquirido posteriormente.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">O objeto no qual aguardar.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">O número de milissegundos de espera antes que o thread entre na fila pronta.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para sair e readquirir o domínio de sincronização para o contexto (se estiver em um contexto sincronizado) antes do tempo de espera; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> não é invocado de dentro de um bloco de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">O valor do parâmetro <paramref name="millisecondsTimeout" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">O objeto no qual aguardar.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">Um <see cref="T:System.TimeSpan" /> que representa o período de tempo de espera antes que o thread entre na fila pronta.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">O thread de chamada não é proprietário do bloqueio do objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">O thread que invoca <see langword="Wait" /> é posteriormente interrompido do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;timeout&quot; /&gt; parameter in milliseconds is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">O valor do parâmetro <paramref name="timeout" /> em milissegundos é negativo e não representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundos) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.">Libera o bloqueio de um objeto e bloqueia o thread atual até que ele adquira o bloqueio novamente. Se o intervalo de tempo limite especificado transcorrer, o thread entrará na fila pronta. Opcionalmente, encerra o domínio de sincronização para o contexto sincronizado antes do tempo de espera e, depois disso, readquire o domínio.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">O objeto no qual aguardar.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">Um <see cref="T:System.TimeSpan" /> que representa o período de tempo de espera antes que o thread entre na fila pronta.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para sair e readquirir o domínio de sincronização para o contexto (se estiver em um contexto sincronizado) antes do tempo de espera; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">
        <see langword="true" /> se o bloqueio foi readquirido antes de ter decorrido o tempo especificado e <see langword="false" /> se o bloqueio foi readquirido depois que o tempo especificado foi decorrido. O método não retorna até que o bloqueio seja readquirido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> não é invocado de dentro de um bloco de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">O thread que invoca Wait é interrompido posteriormente do estado de espera. Isso acontece quando outro thread chama o método <see cref="M:System.Threading.Thread.Interrupt" /> desse thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;timeout&quot; /&gt; parameter is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">O parâmetro <paramref name="timeout" /> é negativo e não representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milissegundo) ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary vsli:raw="A synchronization primitive that can also be used for interprocess synchronization.">Um primitivo de sincronização que também pode ser usado para sincronização entre processos.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with default properties.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com propriedades padrão.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial do mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the mutex; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para dar ao thread de chamada propriedade inicial do mutex; caso contrário, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter uma propriedade inicial do mutex e uma cadeia de caracteres que é o nome do mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do <see cref="T:System.Threading.Mutex" />. Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial de mutex, uma cadeia de caracteres que é o nome do mutex e um valor booliano que, quando o método retorna, indica se o thread de chamada foi concedido a propriedade inicial do mutex.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do <see cref="T:System.Threading.Mutex" />. Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains a Boolean that is &lt;see langword=&quot;true&quot; /&gt; if a local mutex was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system mutex was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system mutex already existed. This parameter is passed uninitialized.">Quando este método retorna, contém um valor booliano que é <see langword="true" /> se um mutex local foi criado (ou seja, se <paramref name="name" /> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o mutex do sistema nomeado especificado foi criado; <see langword="false" /> se o mutex do sistema nomeado já existia. Este parâmetro é passado não inicializado.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tem mais de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists.">Abre o mutex nomeado especificado, caso ele já exista.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do mutex do sistema a ser aberto.</param>
      <returns vsli:raw="An object that represents the named system mutex.">Um objeto que representa o mutex do sistema nomeado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">O mutex nomeado não existe.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; once.">Libera o <see cref="T:System.Threading.Mutex" /> uma vez.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The calling thread does not own the mutex.">O thread de chamada não tem o mutex.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.">Abre o mutex nomeado especificado, quando ele já existe e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do mutex do sistema a ser aberto.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the named mutex if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quando este método retorna, ele contém um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named mutex was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> se o mutex nomeado foi aberto com sucesso, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary vsli:raw="Defines a lock that supports single writers and multiple readers.">Define um bloqueio que dá suporte a autores únicos e múltiplos leitores.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLock&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary vsli:raw="Acquires a reader lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Adquire um bloqueio de leitor, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">O tempo limite em milissegundos.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary vsli:raw="Acquires a reader lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Adquire um bloqueio de leitor, usando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</summary>
      <param name="timeout" vsli:raw="A &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Um <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary vsli:raw="Acquires the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Adquire um bloqueio de gravador, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">O tempo limite em milissegundos.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary vsli:raw="Acquires the writer lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Adquire um bloqueio de gravador, usando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary vsli:raw="Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.">Indica se o bloqueio de gravador foi concedido a qualquer thread desde que o número de sequência foi obtido.</summary>
      <param name="seqNum" vsli:raw="The sequence number.">O número de sequência.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o bloqueio de gravador tiver sido concedido a qualquer thread desde que o número de sequência foi obtido; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt; was called.">Restaura o status de bloqueio do thread para o status prévio antes de <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> ser chamado.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt;.">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">O thread não tem o bloqueio de gravador.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds a reader lock.">Obtém um valor que indica se o thread atual mantém um bloqueio de leitor.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds a reader lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual mantém um bloqueio de leitor; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds the writer lock.">Obtém um valor que indica se o thread atual mantém um bloqueio de gravador.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the writer lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual mantiver o bloqueio do gravador; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary vsli:raw="Releases the lock, regardless of the number of times the thread acquired the lock.">Libera o bloqueio, independentemente do número de vezes que o thread adquiriu o bloqueio.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value representing the released lock.">Um valor <see cref="T:System.Threading.LockCookie" /> que representa o bloqueio liberado.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary vsli:raw="Decrements the lock count.">Diminui a contagem de bloqueio.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have any reader or writer locks.">O thread não tem nenhum bloqueio de leitor ou de gravador.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary vsli:raw="Decrements the lock count on the writer lock.">Diminui a contagem de bloqueio no bloqueio de gravador.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">O thread não tem o bloqueio de gravador.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before calling &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Restaura o status de bloqueio do thread para o que era antes de chamar <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Atualiza um bloqueio de leitor para o bloqueio de gravador, usando um valor <see langword="Int32" /> para o tempo limite.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">O tempo limite em milissegundos.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using a &lt;see langword=&quot;TimeSpan&quot; /&gt; value for the time-out.">Faz o upgrade de um bloqueio de leitor para o bloqueio de gravador usando um valor <see langword="TimeSpan" /> para o tempo limite.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary vsli:raw="Gets the current sequence number.">Obtém o número de sequência atual.</summary>
      <returns vsli:raw="The current sequence number.">O número de sequência atual.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary vsli:raw="Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.">Representa um bloqueio que é usado para gerenciar o acesso a um recurso, permitindo vários threads para leitura ou acesso exclusivo para gravação.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class with default property values.">Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> com os valores da propriedade padrão.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class, specifying the lock recursion policy.">Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, especificando a política de recursão de bloqueio.</summary>
      <param name="recursionPolicy" vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Um dos valores de enumeração que especifica a política de recursão de bloqueio.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary vsli:raw="Gets the total number of unique threads that have entered the lock in read mode.">Obtém o número total de threads exclusivos que inseriram o bloqueio no modo de leitura.</summary>
      <returns vsli:raw="The number of unique threads that have entered the lock in read mode.">O número de threads exclusivos que inseriram o bloqueio no modo de leitura.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingReadCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount&quot; /&gt; is greater than zero.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> é maior que zero.
- ou -
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> é maior que zero.
- ou -
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> é maior que zero.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary vsli:raw="Tries to enter the lock in read mode.">Tenta entrar no bloqueio em modo de leitura.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the read lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the write lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de leitura.
- ou -
A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de gravação.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca devem encontrar essa exceção.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode.">Tenta entrar no bloqueio no modo atualizável.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.
- ou -
O thread atual entrou no modo de leitura, portanto, tentar entrar no modo atualizável criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary vsli:raw="Tries to enter the lock in write mode.">Tenta entrar no bloqueio em modo de gravação.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.
- ou -
O thread atual entrou no modo de leitura e ainda não tem um bloqueio de gravação. Portanto, tentar entrar no bloqueio em modo de gravação criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary vsli:raw="Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).">Reduz a contagem de recursão para o modo de leitura e sai do modo de leitura se a contagem resultante é 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in read mode.">O thread atual não entrou no bloqueio no modo de leitura.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary vsli:raw="Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).">Reduz a contagem de recursão para o modo de upgrade e sai do modo de upgrade se a contagem resultante é 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in upgradeable mode.">O thread atual não entrou no bloqueio em modo de upgrade.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary vsli:raw="Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).">Reduz a contagem de recursão para o modo de gravação e sai do modo de gravação se a contagem resultante é 0 (zero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in write mode.">O thread atual não entrou no bloqueio em modo de gravação.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in read mode.">Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de leitura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered read mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o thread atual tiver entrado no modo de leitura; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.">Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de upgrade.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered upgradeable mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o thread atual tiver inserido o modo atualizável; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in write mode.">Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de gravação.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered write mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Se o thread atual tiver entrado no modo de gravação; caso contrário <see langword="false" />,.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary vsli:raw="Gets a value that indicates the recursion policy for the current &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object.">Obtém um valor que indica a política de recursão do objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> atual.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Um dos valores de enumeração que especifica a política de recursão de bloqueio.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.">Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de leitura, como uma indicação de recursão.</summary>
      <returns vsli:raw="0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.">0 (zero) se o thread atual não tiver entrado no modo de leitura, 1 se o thread tiver entrado no modo de leitura, mas não o tiver inserido recursivamente, ou n se o thread tiver inserido o bloqueio recursivamente n -1 vezes.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.">Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de upgrade, como uma indicação de recursão.</summary>
      <returns vsli:raw="0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.">0 se o thread atual não tiver inserido o modo atualizável, 1 se o thread tiver inserido o modo atualizável, mas não o tiver inserido recursivamente, ou n se o thread tiver inserido o modo atualizável recursivamente n -1 vezes.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.">Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de gravação, como uma indicação de recursão.</summary>
      <returns vsli:raw="0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.">0 se o thread atual não tiver entrado no modo de gravação, 1 se o thread tiver entrado no modo de gravação, mas não o tiver inserido recursivamente, ou n se o thread tiver entrado no modo de gravação recursivamente n -1 vezes.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional integer time-out.">Tenta inserir o bloqueio no modo de gravação com um tempo limite inteiro opcional.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional time-out.">Tenta entrar no bloqueio no modo de leitura, com um tempo limite opcional.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.
- ou -
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.
- ou -
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.
- ou -
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.
- ou -
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.
- ou -
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in read mode.">Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de leitura.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter read mode.">O número total de threads que estão aguardando para entrar no modo de leitura.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in upgradeable mode.">Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de upgrade.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter upgradeable mode.">O número total de threads que estão aguardando para entrar no modo atualizável.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in write mode.">Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de gravação.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter write mode.">O número total de threads que estão aguardando para entrar no modo de gravação.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary vsli:raw="Limits the number of threads that can access a resource or pool of resources concurrently.">Limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.">
        <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> é menor que 1.
-ou-
<paramref name="initialCount" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas e, opcionalmente, especificando o nome de um objeto de sinal de sistema.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome de um objeto de sinal de sistema nomeado.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> é menor que 1.
-ou-
<paramref name="initialCount" /> é menor que 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema e especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be satisfied concurrently.">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be satisfied concurrently.">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome de um objeto de sinal de sistema nomeado.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local semaphore was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system semaphore was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system semaphore already existed. This parameter is passed uninitialized.">Quando este método retorna, ele conterá <see langword="true" />, se um semáforo local tiver sido criado (isto é, se <paramref name="name" /> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o semáforo de sistema nomeado especificado tiver sido criado, <see langword="false" /> se o semáforo de sistema nomeado especificado já existia. Este parâmetro é passado não inicializado.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> é menor que 1.
-ou-
<paramref name="initialCount" /> é menor que 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists.">Abre o semáforo nomeado especificado, caso ele já exista.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do semáforo do sistema a ser aberto.</param>
      <returns vsli:raw="An object that represents the named system semaphore.">Um objeto que representa o semáforo do sistema nomeado.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">O semáforo nomeado não existe.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary vsli:raw="Exits the semaphore and returns the previous count.">Sai do sinal e retorna à contagem anterior.</summary>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">A contagem de semáforo já está no valor máximo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Ocorreu um erro de Win32 com um semáforo nomeado.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-ou-
O sinal do atual representa um sinal de sistema nomeado, mas não foi aberto com <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary vsli:raw="Exits the semaphore a specified number of times and returns the previous count.">Sai do sinal de um número de vezes especificado e retorna à contagem anterior.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">O número de vezes para sair do sinal.</param>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> é menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">A contagem de semáforo já está no valor máximo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Ocorreu um erro de Win32 com um semáforo nomeado.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
-ou-
O sinal atual representa um sinal de sistema nomeado, mas não foi aberto com direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.">Abre o semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">O nome do semáforo do sistema a ser aberto.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; object that represents the named semaphore if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Quando esse método retorna, contém um objeto <see cref="T:System.Threading.Semaphore" /> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named semaphore was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> se o semáforo nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> é uma cadeia de caracteres vazia.
-ou-
<paramref name="name" /> tem mais de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> é <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Erro do Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary vsli:raw="The exception that is thrown when the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method is called on a semaphore whose count is already at the maximum.">A exceção que é lançada quando o método <see cref="Overload:System.Threading.Semaphore.Release" /> é chamado em um semáforo cuja contagem já está no máximo.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with default values.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com valores padrão.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with serialized data.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com dados serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com uma mensagem de erro especificada.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">A mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreFullException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">A mensagem de erro que explica a razão da exceção.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary vsli:raw="Represents a lightweight alternative to &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; that limits the number of threads that can access a resource or pool of resources concurrently.">Representa uma alternativa leve para <see cref="T:System.Threading.Semaphore" /> que limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial number of requests that can be granted concurrently.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreSlim" />, especificando o número inicial de solicitações que podem ser concedidas simultaneamente.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> é menor que 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial and maximum number of requests that can be granted concurrently.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SemaphoreSlim" />, especificando o número inicial e o máximo de solicitações que podem ser concedidas simultaneamente.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <param name="maxCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0, or &lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maxCount&quot; /&gt;, or &lt;paramref name=&quot;maxCount&quot; /&gt; is equal to or less than 0.">
        <paramref name="initialCount" /> é menor que 0, <paramref name="initialCount" /> é maior que <paramref name="maxCount" /> ou <paramref name="maxCount" /> é igual ou menor que 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Retorna um <see cref="T:System.Threading.WaitHandle" /> que pode ser usado para aguardar o semáforo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Um <see cref="T:System.Threading.WaitHandle" /> que pode ser usado para aguardar o semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary vsli:raw="Gets the number of remaining threads that can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object.">Obtém o número de threads restantes que podem inserir o objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="The number of remaining threads that can enter the semaphore.">O número de threads restantes que podem inserir o semáforo.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, and optionally releases the managed resources.">Libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.SemaphoreSlim" /> e opcionalmente libera os recursos gerenciados.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object once.">Libera o objeto <see cref="T:System.Threading.SemaphoreSlim" /> uma única vez.</summary>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">A contagem anterior do <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">O <see cref="T:System.Threading.SemaphoreSlim" /> já atingiu seu tamanho máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object a specified number of times.">Libera o objeto <see cref="T:System.Threading.SemaphoreSlim" /> um número de vezes especificado.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">O número de vezes para sair do sinal.</param>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">A contagem anterior do <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> é menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">O <see cref="T:System.Threading.SemaphoreSlim" /> já atingiu seu tamanho máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Bloqueia o thread atual até que o <see cref="T:System.Threading.SemaphoreSlim" /> possa ser inserido.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout.">Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits que especifica o tempo limite.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" />(-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits que especifica o tempo limite, observando simultaneamente um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" />(-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="millisecondsTimeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; instance has been disposed, or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">A instância de <see cref="T:System.Threading.SemaphoreSlim" /> foi descartada ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, enquanto observar uma <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">O token <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA; -or-&#xA;&#xA; The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">A instância atual já foi descartada.
- ou -
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to specify the timeout.">Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> para especificar o tempo limite.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.">A instância semaphoreSlim foi descartada.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloqueia o thread atual até que ele possa inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> que especifica o tempo limite, observando simultaneamente um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o thread atual inseriu o <see cref="T:System.Threading.SemaphoreSlim" /> com êxito; caso contrário, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-.&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
-ou-.
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">A instância semaphoreSlim foi descartada.
- ou -
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Uma tarefa que será concluída quando o semáforo for inserido.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval.">Aguarda de forma assíncrona para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="millisecondsTimeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um inteiro com sinal de 32 bits para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">O número de milissegundos de espera, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) de espera indefinidamente ou zero para testar o estado do identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">O <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> é um número diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="millisecondsTimeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, ao observar um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">O token <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Uma tarefa que será concluída quando o semáforo for inserido.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">A instância atual já foi descartada.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Espera assincronamente para inserir o <see cref="T:System.Threading.SemaphoreSlim" />, usando um <see cref="T:System.TimeSpan" /> para medir o intervalo de tempo, enquanto observa um <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera, um <see cref="T:System.TimeSpan" /> que representa -1 milissegundo de espera indefinidamente ou um <see cref="T:System.TimeSpan" /> que representa 0 milissegundo para testar o identificador de espera e retornar imediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">O token <see cref="T:System.Threading.CancellationToken" /> a ser observado.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Uma tarefa será concluída com um resultado de <see langword="true" /> se o thread atual tiver inserido com êxito o <see cref="T:System.Threading.SemaphoreSlim" />, caso contrário, com um resultado de <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.
- ou -
<paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">O <see cref="T:System.Threading.SemaphoreSlim" /> foi descartado.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary vsli:raw="Represents a method to be called when a message is to be dispatched to a synchronization context.">Representa um método a ser chamado quando uma mensagem deve ser distribuída em um contexto de sincronização.</summary>
      <param name="state" vsli:raw="The object passed to the delegate.">O objeto passado ao delegado.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary vsli:raw="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.">Fornece um primitivo de bloqueio de exclusão mútua onde um thread que tenta adquirir o bloqueio aguarda em um loop, fazendo verificações repetidamente até que o bloqueio esteja disponível.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SpinLock&quot; /&gt; structure with the option to track thread IDs to improve debugging.">Inicializa uma nova instância da estrutura <see cref="T:System.Threading.SpinLock" /> com a opção para acompanhar IDs de thread para melhorar a depuração.</summary>
      <param name="enableThreadOwnerTracking" vsli:raw="Whether to capture and use thread IDs for debugging purposes.">Indica se IDs de threads serão capturadas e usadas para fins de depuração.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary vsli:raw="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Adquire o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling Enter.">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary vsli:raw="Releases the lock.">Libera o bloqueio.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">O acompanhamento de propriedade de thread está habilitado e o thread atual não é o proprietário deste bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary vsli:raw="Releases the lock.">Libera o bloqueio.</summary>
      <param name="useMemoryBarrier" vsli:raw="A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.">Um valor booliano que indica se um limite de memória deve ser emitido para publicar imediatamente a operação de saída em outros threads.</param>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">O acompanhamento de propriedade de thread está habilitado e o thread atual não é o proprietário deste bloqueio.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary vsli:raw="Gets whether the lock is currently held by any thread.">Especifica se o bloqueio é mantido atualmente por algum thread.</summary>
      <returns vsli:raw="true if the lock is currently held by any thread; otherwise false.">true se o bloqueio estiver sendo mantido por qualquer thread; caso contrário, false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary vsli:raw="Gets whether the lock is held by the current thread.">Especifica se o bloqueio é mantido pelo thread atual.</summary>
      <returns vsli:raw="true if the lock is held by the current thread; otherwise false.">true se o bloqueio for mantido pelo thread atual; caso contrário, false.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Thread ownership tracking is disabled.">O acompanhamento de propriedade de thread está desabilitado.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary vsli:raw="Gets whether thread ownership tracking is enabled for this instance.">Especifica se o acompanhamento de propriedade de thread está habilitado para esta instância.</summary>
      <returns vsli:raw="true if thread ownership tracking is enabled for this instance; otherwise false.">true se o rastreamento de propriedade de thread estiver habilitado para esta instância; caso contrário, false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tenta adquirir o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tenta adquirir o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Tenta adquirir o bloqueio de maneira confiável, de forma que mesmo se uma exceção ocorrer dentro da chamada de método, <paramref name="lockTaken" /> poderá ser examinado com confiança para determinar se o bloqueio foi adquirido.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">True se o bloqueio tiver sido adquirido; caso contrário, false. <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar esse método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">O argumento <paramref name="lockTaken" /> deve ser inicializado como false antes de chamar TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">O acompanhamento de propriedade de thread está habilitado e o thread atual há adquiriu este bloqueio.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary vsli:raw="Provides support for spin-based waiting.">Fornece suporte à espera baseada em rotação.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary vsli:raw="Gets the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Obtém o número de vezes que <see cref="M:System.Threading.SpinWait.SpinOnce" /> foi chamado nessa instância.</summary>
      <returns vsli:raw="Returns an integer that represents the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Retorna um inteiro que representa o número de vezes que <see cref="M:System.Threading.SpinWait.SpinOnce" /> foi chamado nessa instância.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary vsli:raw="Gets whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Especifica se a próxima chamada para <see cref="M:System.Threading.SpinWait.SpinOnce" /> produzirá o processador, disparando uma alternância de contexto forçado.</summary>
      <returns vsli:raw="Whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Se a próxima chamada para <see cref="M:System.Threading.SpinWait.SpinOnce" /> gerará o processador, disparando uma alternância de contexto forçada.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary vsli:raw="Resets the spin counter.">Redefine o contador de rotação.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary vsli:raw="Performs a single spin.">Executa uma única rotação.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary vsli:raw="Performs a single spin and calls &lt;see cref=&quot;M:System.Threading.Thread.Sleep(System.Int32)&quot; /&gt; after a minimum spin count.">Executa uma única rotação e chama <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> após uma contagem mínima de rotação.</summary>
      <param name="sleep1Threshold" vsli:raw="A minimum spin count after which &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt; may be used. A value of -1 disables the use of &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt;.">Uma contagem mínima de rotação após a qual o <see langword="Thread.Sleep(1)" /> pode ser usado. Um valor de -1 desabilita o uso de <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sleep1Threshold&quot; /&gt; is less than -1.">
        <paramref name="sleep1Threshold" /> é menor que -1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary vsli:raw="Spins until the specified condition is satisfied.">Gira até que a condição especificada seja atendida.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Um delegado a ser executado repetidamente até retornar true.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">O argumento <paramref name="condition" /> é nulo.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Gira até que a condição especificada seja atendida ou até que o tempo limite especificado expire.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Um delegado a ser executado repetidamente até retornar true.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> se a condição for atendida dentro do tempo limite; caso contrário, false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">O argumento <paramref name="condition" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Gira até que a condição especificada seja atendida ou até que o tempo limite especificado expire.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Um delegado a ser executado repetidamente até retornar true.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos de espera ou um TimeSpan que representa -1 milissegundo de espera indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> se a condição for atendida dentro do tempo limite; caso contrário, false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">O argumento <paramref name="condition" /> é nulo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary vsli:raw="Provides the basic functionality for propagating a synchronization context in various synchronization models.">Fornece a funcionalidade básica para propagação de um contexto de sincronização em vários modelos de sincronização.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; class.">Cria uma nova instância da classe <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary vsli:raw="When overridden in a derived class, creates a copy of the synchronization context.">Quando substituído em uma classe derivada, cria uma cópia do contexto de sincronização.</summary>
      <returns vsli:raw="A new &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object.">Um novo objeto <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary vsli:raw="Gets the synchronization context for the current thread.">Obtém o contexto de sincronização do thread atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object representing the current synchronization context.">Um objeto <see cref="T:System.Threading.SynchronizationContext" /> que representa o contexto de sincronização atual.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary vsli:raw="Determines if wait notification is required.">Determina se a notificação de espera é necessária.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if wait notification is required; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a notificação de espera for necessária, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has completed.">Quando substituído em uma classe derivada, responde à notificação de que uma operação foi concluída.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has started.">Quando substituído em uma classe derivada, responde à notificação de que uma operação foi iniciada.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches an asynchronous message to a synchronization context.">Quando substituído em uma classe derivada, envia uma mensagem assíncrona a um contexto de sincronização.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">O delegado de <see cref="T:System.Threading.SendOrPostCallback" /> a ser chamado.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">O objeto passado ao delegado.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches a synchronous message to a synchronization context.">Quando substituído em uma classe derivada, expede uma mensagem síncrona a um contexto de sincronização.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">O delegado de <see cref="T:System.Threading.SendOrPostCallback" /> a ser chamado.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">O objeto passado ao delegado.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="The method was called in a Windows Store app. The implementation of &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; for Windows Store apps does not support the &lt;see cref=&quot;M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)&quot; /&gt; method.">O método foi chamado em um aplicativo da Windows Store. A implementação de <see cref="T:System.Threading.SynchronizationContext" /> para aplicativos da Windows Store não dá suporte ao método <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary vsli:raw="Sets the current synchronization context.">Define o contexto de sincronização atual.</summary>
      <param name="syncContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object to be set.">O objeto <see cref="T:System.Threading.SynchronizationContext" /> a ser definido.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary vsli:raw="Sets notification that wait notification is required and prepares the callback method so it can be called more reliably when a wait occurs.">Define a notificação de que a notificação de espera é necessária e prepara o método de retorno de chamada para que possa ser chamado com mais confiança quando ocorre uma espera.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Waits for any or all the elements in the specified array to receive a signal.">Aguarda até que um ou todos os elementos da matriz especificada recebam um sinal.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Uma matriz do tipo <see cref="T:System.IntPtr" /> que contém os identificadores do sistema operacional nativo.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles; &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" /> para aguardar todos os identificadores; <see langword="false" /> para aguardar qualquer identificador.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">O índice da matriz do objeto que atendeu à espera.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;waitHandles&quot; /&gt; is null.">
        <paramref name="waitHandles" /> é nulo.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Helper function that waits for any or all the elements in the specified array to receive a signal.">Função auxiliar que aguarda até que um ou todos os elementos da matriz especificada recebam um sinal.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Uma matriz do tipo <see cref="T:System.IntPtr" /> que contém os identificadores do sistema operacional nativo.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles;  &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" /> para aguardar todos os identificadores; <see langword="false" /> para aguardar qualquer identificador.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">O índice da matriz do objeto que atendeu à espera.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary vsli:raw="The exception that is thrown when a method requires the caller to own the lock on a given Monitor, and the method is invoked by a caller that does not own that lock.">A exceção que é lançada quando um método exige que o chamador possua o bloqueio em um determinado Monitor, e o método é invocado por um chamador que não possui o bloqueio.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with default properties.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com propriedades padrão.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with serialized data.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com dados serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; that holds the serialized object data about the exception being thrown.">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; that contains contextual information about the source or destination.">O <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com uma mensagem de erro especificada.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">A mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa uma nova instância da classe <see cref="T:System.Threading.SynchronizationLockException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">A mensagem de erro que explica a razão da exceção.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary vsli:raw="Provides thread-local storage of data.">Fornece armazenamento de dados local de thread.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of data stored per-thread.">Especifica o tipo dos dados armazenados por thread.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance and specifies whether all values are accessible from any thread.">Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" /> e especifica se todos os valores podem ser acessados de qualquer thread.</summary>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> para controlar valores definidos na instância e expô-los por meio da propriedade <see cref="P:System.Threading.ThreadLocal`1.Values" />; caso contrário <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function.">Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" /> com função <paramref name="valueFactory" /> especificada.</summary>
      <param name="valueFactory" vsli:raw="The  &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">O <see cref="T:System.Func`1" /> invocado para produzir um valor inicializado lentamente quando é feita uma tentativa de recuperar o <see cref="P:System.Threading.ThreadLocal`1.Value" /> sem ele ter sido anteriormente inicializado.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> é uma referência nula (Nada no Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function and a flag that indicates whether all values are accessible from any thread.">Inicializa a instância <see cref="T:System.Threading.ThreadLocal`1" /> com a função <paramref name="valueFactory" /> especificada e um sinalizador que indica se todos os valores estão acessíveis em qualquer thread.</summary>
      <param name="valueFactory" vsli:raw="The &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">O <see cref="T:System.Func`1" /> invocado para produzir um valor inicializado lentamente quando é feita uma tentativa de recuperar o <see cref="P:System.Threading.ThreadLocal`1.Value" /> sem ele ter sido anteriormente inicializado.</param>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> para controlar valores definidos na instância e expô-los por meio da propriedade <see cref="P:System.Threading.ThreadLocal`1.Values" />; caso contrário <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">
        <paramref name="valueFactory" /> é uma referência <see langword="null" /> (<see langword="Nothing" /> no Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; class.">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Libera os recursos usados por esta instância <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing" vsli:raw="A Boolean value that indicates whether this method is being called due to a call to &lt;see cref=&quot;M:System.Threading.ThreadLocal`1.Dispose&quot; /&gt;.">Um valor booliano que indica se esse método está sendo chamado devido a uma chamada a <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Libera os recursos usados por esta instância <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary vsli:raw="Gets whether &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread.">Indica se <see cref="P:System.Threading.ThreadLocal`1.Value" /> é inicializado no thread atual.</summary>
      <returns vsli:raw="true if &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread; otherwise false.">true se <see cref="P:System.Threading.ThreadLocal`1.Value" /> for inicializado no thread atual; caso contrário, false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary vsli:raw="Creates and returns a string representation of this instance for the current thread.">Cria e retorna uma representação de cadeia de caracteres desta instância para o thread atual.</summary>
      <returns vsli:raw="The result of calling &lt;see cref=&quot;M:System.Object.ToString&quot; /&gt; on the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt;.">O resultado da chamada a <see cref="M:System.Object.ToString" /> no <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; for the current thread is a null reference (Nothing in Visual Basic).">O <see cref="P:System.Threading.ThreadLocal`1.Value" /> para o thread atual é uma referência nula (Nothing no Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">A função de inicialização tentou referenciar <see cref="P:System.Threading.ThreadLocal`1.Value" /> recursivamente.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Nenhum construtor sem parâmetros é fornecido e nenhum alocador de valor é fornecido.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of this instance for the current thread.">Obtém ou define o valor dessa instância para o thread atual.</summary>
      <returns vsli:raw="Returns an instance of the object that this ThreadLocal is responsible for initializing.">Retorna uma instância do objeto que este ThreadLocal é responsável por inicializar.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">A função de inicialização tentou referenciar <see cref="P:System.Threading.ThreadLocal`1.Value" /> recursivamente.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">Nenhum construtor sem parâmetros é fornecido e nenhum alocador de valor é fornecido.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary vsli:raw="Gets a list containing the values stored by all threads that have accessed this instance.">Obtém uma lista de todos os valores armazenados no momento por todos os threads que acessaram essa instância.</summary>
      <returns vsli:raw="A list for all of the values stored by all of the threads that have accessed this instance.">Uma lista de todos os valores armazenados no momento por todos os threads que acessaram essa instância.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Values stored by all threads are not available because this instance was initialized with the &lt;paramref name=&quot;trackAllValues&quot; /&gt; argument set to &lt;see langword=&quot;false&quot; /&gt; in the call to a class constructor.">Os valores armazenados por todos os threads não estão disponíveis porque a instância foi inicializada com o argumento <paramref name="trackAllValues" /> definido como <see langword="false" /> na chamada para um construtor de classe.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">A instância <see cref="T:System.Threading.ThreadLocal`1" /> foi descartada.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary vsli:raw="Contains methods for performing volatile memory operations.">Contém métodos para executar operações de memória voláteis.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê o valor do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <returns vsli:raw="The value that was read.">O valor que foi lido. Este valor é o último gravado por qualquer processador no computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary vsli:raw="Reads the object reference from the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lê a referência de objeto do campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer após esse método no código, o processador não poderá movê-la para antes desse método.</summary>
      <param name="location" vsli:raw="The field to read.">O campo a ser lido.</param>
      <typeparam name="T" vsli:raw="The type of field to read. This must be a reference type, not a value type.">O tipo do campo a ser lido. Este deve ser um tipo de referência, não um tipo de valor.</typeparam>
      <returns vsli:raw="The reference to &lt;paramref name=&quot;T&quot; /&gt; that was read. This reference is the latest written by any processor in the computer, regardless of the number of processors or the state of processor cache.">A referência a <paramref name="T" /> que foi lida. A referência é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava o valor especificado no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">O campo em que o valor é gravado.</param>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado. O valor é gravado imediatamente para que fique visível a todos os processadores no computador.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary vsli:raw="Writes the specified object reference to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Grava a referência de objeto especificada no campo especificado. Em sistemas que precisam dele, insere uma barreira de memória que impede que o processador reordene as operações de memória da seguinte maneira: se uma leitura ou gravação aparecer antes desse método no código, o processador não poderá movê-la para depois desse método.</summary>
      <param name="location" vsli:raw="The field where the object reference is written.">O campo em que a referência de objeto é gravada.</param>
      <param name="value" vsli:raw="The object reference to write.">A referência de objeto a gravar. A referência é gravada imediatamente para que fique visível a todos os processadores no computador.</param>
      <typeparam name="T" vsli:raw="The type of field to write. This must be a reference type, not a value type.">O tipo de campo a ser gravado. Este deve ser um tipo de referência, não um tipo de valor.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary vsli:raw="The exception that is thrown when an attempt is made to open a system mutex, semaphore, or event wait handle that does not exist.">A exceção que é gerada quando é feita uma tentativa de abrir um semáforo, um mutex do sistema ou um identificador de espera de evento que não existe.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with default values.">Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com valores padrão.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with serialized data.">Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com dados serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message.">Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com uma mensagem de erro especificada.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">A mensagem de erro que explica a razão da exceção.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">A mensagem de erro que explica a razão da exceção.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">A exceção que é a causa da exceção atual. Caso o parâmetro <paramref name="innerException" /> não seja <see langword="null" />, a exceção atual é acionada em um bloco <see langword="catch" /> que identifica a exceção interna.</param>
    </member>
  </members>
</doc>