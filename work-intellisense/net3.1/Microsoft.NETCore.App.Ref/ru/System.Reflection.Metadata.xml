<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>Маскированные биты типа содержимого, соответствующие значениям <see cref="T:System.Reflection.AssemblyContentType" />.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>Для данной сборки отключена оптимизация JIT-компилятора.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>Для данной сборки отключено отслеживание JIT-компилятора.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>Ссылка на сборку содержит полный (не хэшированный) открытый ключ. Неприменимо к определению сборки.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>Реализация базовой сборки, используемой в среде выполнения, не должна совпадать с версией, видимой во время компиляции.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>Сборка содержит код среды выполнения Windows.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>Определяет хэш-алгоритмы, используемые для хэширования файлов сборки и создания строгого имени.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>Извлекает хэш-алгоритм MD5.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>Маска, указывающая на отсутствие алгоритма хеширования.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>Извлекает пересмотренный алгоритм SHA, исправляющий неопубликованный дефект в SHA.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>Извлекает версию алгоритма SHA с размером хэша 256 бит.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>Извлекает версию алгоритма SHA с размером хэша 384 бит.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>Извлекает версию алгоритма SHA с размером хэша 512 бит.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>Указывает действия безопасности, которые можно выполнить с помощью декларативной безопасности.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>Вызывающий код может получить доступ к ресурсу, который определен текущим объектом разрешения, даже если вызывающие операторы, находящиеся выше в стеке вызовов, не имеют разрешения на доступ к ресурсу.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>Убедитесь, что всем вызывающим объектам в цепочке вызовов предоставлено указанное разрешение.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>Без дополнительных проверок отклоните требование для указанного разрешения.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>Производному классу, наследующему класс или переопределяющему метод, требуется предоставить указанное разрешение.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>Убедитесь, что непосредственно вызывающему объекту предоставлено указанное разрешение.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>Нет декларативных действий безопасности.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>Без дополнительных проверок отклоните требование для всех разрешений, кроме указанных.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>Запрос на минимальный набор разрешений, необходимых для выполнения кода. Это действие может использоваться только в пределах сборки.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>Запрос дополнительных разрешений, которые не являются обязательными (не требуются для выполнения). Этот запрос неявно отклоняет все прочие разрешения, не запрошенные специально. Это действие может использоваться только в пределах сборки.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>Запрос на непредоставление вызывающему коду разрешений, которые могут быть неправильно использованы. Это действие может использоваться только в пределах сборки.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>Ресурс не экспортируется из сборки.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>Ресурс экспортируется из сборки.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>Маскирует только атрибуты, связанные с видимостью.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>Представляет форму типа массива.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.ArrayShape" />.</summary>
      <param name="rank">Число измерений в массиве.</param>
      <param name="sizes">Размер каждого измерения.</param>
      <param name="lowerBounds">Нижняя граница каждого измерения.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>Получает нижние границы всех измерений. Длина может быть меньше, чем ранг, в этом случае нижние границы для конечных измерений не указаны.</summary>
      <returns>Массив нижних границ.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>Получает число измерений в массиве.</summary>
      <returns>Число измерений.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>Получает размеры всех измерений.</summary>
      <returns>Массив размеров.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>Возвращает значение, которое указывает, содержит ли файл метаданные.</summary>
      <returns>
        <see langword="true" />, если файл содержит метаданные, в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>Возвращает хэш-значение содержимого файла, вычисленное с использованием <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.</summary>
      <returns>Экземпляр <see cref="T:System.Reflection.Metadata.BlobHandle" />, представляющий хэш-значение содержимого файла.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>Возвращает имя файла, включая расширение.</summary>
      <returns>Экземпляр <see cref="T:System.Reflection.Metadata.StringHandle" />, представляющий имя файла с расширением.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>Представляет коллекцию <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>Набор ссылок на сборки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>Сравнивает текущее содержимое данного средства чтения с содержимым другого средства чтения.</summary>
      <param name="other">Экземпляр <see cref="T:System.Reflection.Metadata.BlobBuilder" /> для сравнения с данным экземпляром.</param>
      <returns>Значение <see langword="true" />, если объекты равны; в противном случае — значение <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>Возвращает последовательность всех больших двоичных объектов, представляющих содержимое построителя.</summary>
      <returns>Последовательность больших двоичных объектов.</returns>
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="suffix" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>Резервирует непрерывный блок байтов.</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>Пытается записать последовательность байтов в построитель. Возвращаемое значение указывает количество успешно записанных байтов.</summary>
      <param name="source" />
      <param name="byteCount" />
      <returns>Количество байтов, успешно записанных из <paramref name="source" />.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="source" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>Записывает значение <see cref="T:System.Boolean" /> в построитель.</summary>
      <param name="value">Значение для записи.</param>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>Записывает значение <see cref="T:System.Byte" /> в построитель.</summary>
      <param name="value">Значение для записи.</param>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>Записывает указанное число байтов из буфера в построитель.</summary>
      <param name="buffer" />
      <param name="byteCount">Количество записываемых байтов.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>Записывает указанное количество экземпляров байтового значения в построитель.</summary>
      <param name="value" />
      <param name="byteCount">Число экземпляров <paramref name="value" />, которые требуется записать.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>Записывает содержимое массива байтов в построитель.</summary>
      <param name="buffer">Байтовый массив для записи.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Записывает указанное число байтов, начиная с заданного индекса в массиве байтов, в построитель.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Количество записываемых байтов.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Записывает содержимое неизменяемого массива байтов в построитель.</summary>
      <param name="buffer">Записываемый массив.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>Записывает указанное число байтов, начиная с заданного индекса в неизменяемом массиве, в построитель.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Количество записываемых байтов.</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>Реализует кодировку сжатого целого числа без знака в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value">Значение для записи.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> невозможно представить как сжатое целое число без знака.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>Реализует кодировку сжатого целого числа со знаком в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value">Значение для записи.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> невозможно представить как сжатое целое число со знаком.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>Записывает значение константы (см раздел 22.9 в части II документа ECMA-335) в текущей позиции.</summary>
      <param name="value">Записываемое значение константы.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> не относится к типу константы.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> используется по умолчанию (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>Записывает ссылку на кучу (смещение в куче) или таблицу (номер строки).</summary>
      <param name="reference">Смещение в куче или номер строки в таблице.</param>
      <param name="isSmall">
        <see langword="true" /> для кодирования ссылки в виде 16-битного целого числа; <see langword="false" /> для ее кодирования в виде 32-битного целого числа.</param>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>Записывает строку в формате SerString (см. раздел 23.3 "Пользовательские атрибуты" в документе ECMA-335-II).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>Записывает строку в формате кучи User String (#US) (см. раздел 24.2.4 "Кучи #US и #Blob" в документе ECMA-335-II).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>Записывает массив символов в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>Записывает строку в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>Записывает строку в кодировке UTF8 в текущей позиции.</summary>
      <param name="value">Значение константы.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> для кодирования суррогатов без пары указанным образом; <see langword="false" /> для их замены на символ U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>Создает средство чтения указанного блока памяти.</summary>
      <param name="buffer">Указатель на начало блока памяти.</param>
      <param name="length">Длина блока памяти в байтах.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> имеет значение <see langword="null" />, а значение <paramref name="length" /> больше нуля.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> является отрицательным значением.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Текущая платформа не поддерживает прямой порядок байтов.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>Перемещает средство чтения вперед на количество байтов, необходимое в соответствии с заданным выравниванием.</summary>
      <param name="alignment" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>Возвращает указатель на байт в текущей позиции средства чтения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>Ищет указанный байт в большом двоичном объекте после текущей позиции.</summary>
      <param name="value">Искомое значение байта.</param>
      <returns>Индекс относительно текущей позиции или –1, если байт не найден в большом двоичном объекте после текущей позиции.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>Возвращает общую длину базового блока памяти.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>Возвращает или задает смещение от начала большого двоичного объекта до текущей позиции.</summary>
      <exception cref="T:System.BadImageFormatException">Задано смещение за пределами базового средства чтения.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>Считывает дескриптор кучи большого двоичного объекта, закодированный как сжатое целое число.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>Считывает байты начиная с текущей позиции.</summary>
      <param name="byteCount">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns>Массив байтов.</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>Считывает байты начиная с текущей позиции и записывает их в указанный буфер начиная с заданного смещения.</summary>
      <param name="byteCount">Количество байтов, чтение которых необходимо выполнить.</param>
      <param name="buffer">Буфер назначения, в который будут записываться считанные байты.</param>
      <param name="bufferOffset">Смещение в буфере назначения, в который будут записываться считанные байты.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>Считывает сжатое целое число без знака. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <returns>Значение считанного сжатого целого числа.</returns>
      <exception cref="T:System.BadImageFormatException">Данные в текущей позиции не являлись допустимым сжатым целым числом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>Считывает сжатое целое число со знаком. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <returns>Значение считанного сжатого целого числа.</returns>
      <exception cref="T:System.BadImageFormatException">Данные в текущей позиции не являлись допустимым сжатым целым числом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>Считывает значение константы (см раздел 22.9 в части II документа ECMA-335) в текущей позиции.</summary>
      <param name="typeCode" />
      <returns>Упакованное значение константы. Чтобы избежать выделения объекта, используйте методы Read* напрямую.</returns>
      <exception cref="T:System.BadImageFormatException">Ошибка при чтении из большого двоичного объекта.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> не является допустимым <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>Считывает число <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.BadImageFormatException">Данные в текущей позиции не являлись допустимым числом <see cref="T:System.Decimal" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>Считывает код типа, закодированный в сериализованном значении пользовательского атрибута.</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />, если кодировка недопустима.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>Считывает строку, которая закодирована как сжатое целое число, содержащее длину, за которой следует содержимое в формате UTF8. Строки NULL кодируются как один байт 0xFF.</summary>
      <returns>Строковое значение или <see langword="null" />.</returns>
      <exception cref="T:System.BadImageFormatException">Кодировка недопустима.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>Считывает код типа, закодированный в сигнатуре.</summary>
      <returns>Код типа, закодированный в сериализованном значении пользовательского атрибута, если кодировка допустима, или <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />, если кодировка недопустима.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>Считывает дескриптор типа, закодированный в сигнатуре как TypeDefOrRefOrSpecEncoded (см. ECMA-335 II.23.2.8).</summary>
      <returns>Дескриптор в случае допустимой кодировки. В противном случае дескриптор, свойство <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> которого равно <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>Считывает строку в кодировке UTF16 (прямой порядок байтов) начиная с текущей позиции.</summary>
      <param name="byteCount">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns>Строка.</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>Считывает строку в кодировке UTF8 начиная с текущей позиции.</summary>
      <param name="byteCount">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns>Строка.</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>Считывает оставшееся количество байтов от текущей позиции до конца базового блока памяти.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>Возвращает средство чтения в начало базового блока памяти.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>Возвращает указатель на байт в начале базового блока памяти.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>Считывает сжатое целое число без знака. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value">Значение считанного сжатого целого числа.</param>
      <returns>
        <see langword="true" /> при успешном считывании значения. <see langword="false" />, если данные в текущей позиции не являлись допустимым сжатым целым числом.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>Считывает сжатое целое число со знаком. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value">Значение считанного сжатого целого числа.</param>
      <returns>
        <see langword="true" /> при успешном считывании значения. <see langword="false" />, если данные в текущей позиции не являлись допустимым сжатым целым числом.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>Сравнивает текущее содержимое данного средства чтения с содержимым другого средства чтения.</summary>
      <param name="other" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="source" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="source" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>Реализует кодировку сжатого целого числа без знака в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> невозможно представить как сжатое целое число без знака.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>Реализует кодировку сжатого целого числа со знаком в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> невозможно представить как сжатое целое число со знаком.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>Записывает значение константы (см раздел 22.9 в части II документа ECMA-335) в текущей позиции.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> не относится к типу константы.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>Записывает ссылку на кучу (смещение в куче) или таблицу (номер строки).</summary>
      <param name="reference">Смещение в куче или номер строки в таблице.</param>
      <param name="isSmall">
        <see langword="true" /> для кодирования ссылки в виде 16-битного целого числа; <see langword="false" /> для кодирования в виде 32-битного целого числа.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>Записывает строку в формате SerString (см. раздел 23.3 "Пользовательские атрибуты" в документе ECMA-335-II).</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>Записывает строку в формате кучи User String (#US) (см. раздел 24.2.4 "Кучи #US и #Blob" в документе ECMA-335-II).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>Записывает строку в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>Записывает строку в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>Записывает строку в кодировке UTF8 в текущей позиции.</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>Возвращает родительский дескриптор (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>Возвращает код типа, определяющий тип значения константы.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>Возвращает значение константы.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>Задает значения, представляющие типы констант метаданных.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Тип Boolean.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>1-байтовое целое число без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>Тип символа.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>Тип 8-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>Тип 2-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>Тип 4-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>Тип 8-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>Недопустимый тип.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>Пустая ссылка.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>Тип 1-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>Тип 4-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>Тип <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>Тип 2-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>Тип 4-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>Тип 8-байтового целого числа без знака.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>Возвращает конструктор (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) типа пользовательского атрибута.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>Декодирует аргументы, закодированные в большом двоичном объекте значения.</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>Возвращает дескриптор сущности метаданных, к которой применяется атрибут.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>Возвращает значение атрибута.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>Представляет именованный аргумент, декодированный из сигнатуры настраиваемого атрибута.</summary>
      <typeparam name="TType">Тип, используемый для представления типов значений, декодированных из сигнатуры настраиваемого атрибута.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> с использованием заданного имени, вида, типа и значения.</summary>
      <param name="name">Имя аргумента.</param>
      <param name="kind">Вид аргумента.</param>
      <param name="type">Тип аргумента.</param>
      <param name="value">Значение аргумента.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>Получает вид аргумента.</summary>
      <returns>Тип аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>Получает имя аргумента.</summary>
      <returns>Имя аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>Получает тип аргумента.</summary>
      <returns>Тип аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>Возвращает значение аргумента.</summary>
      <returns>Объект, содержащий значение аргумента.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>Задает константы, определяющие типы аргументов в сигнатуре настраиваемого атрибута.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>Аргумент field.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>Аргумент property.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>Представляет типизированный аргумент для настраиваемого атрибута метаданных.</summary>
      <typeparam name="TType">Тип аргумента.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> с использованием заданного типа и значения аргумента.</summary>
      <param name="type">Тип аргумента.</param>
      <param name="value">Значение аргумента.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>Получает тип аргумента.</summary>
      <returns>Тип аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>Возвращает значение аргумента.</summary>
      <returns>Значение аргумента.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>Представляет пользовательский атрибут типа, заданного параметром <paramref name="TType" />.</summary>
      <typeparam name="TType">Тип атрибута.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> с использованием заданного количества фиксированных и именованных аргументов.</summary>
      <param name="fixedArguments">Фиксированные аргументы.</param>
      <param name="namedArguments">Именованные аргументы.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>Получает фиксированные аргументы для пользовательского атрибута.</summary>
      <returns>Неизменяемый массив аргументов.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>Получает именованные аргументы для значения пользовательского атрибута.</summary>
      <returns>Неизменяемый массив аргументов.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>Возвращает смещение (в байтах) от начала большого двоичного объекта метаданных до начала большого двоичного объекта <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Document">
      <summary>Исходный документ в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>Возвращает хэш-код содержимого документа.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>Возвращает хэш-алгоритм, который используется для расчета <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256 и т. д.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>Возвращает язык исходного кода (C#, VB, F# и т. д.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>Возвращает большой двоичный объект с именем документа.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>Значение <see cref="T:System.Reflection.Metadata.BlobHandle" />, представляющее большой двоичный объект в куче #Blob в переносимом PDB-файле, структурированном как имя документа.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <param name="rank" />
      <param name="sizes" />
      <param name="lowerBounds" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <param name="fixedArguments" />
      <param name="namedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <param name="fixedArguments" />
      <param name="namedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <param name="variableCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <param name="convention" />
      <param name="genericParameterCount" />
      <param name="isInstanceMethod" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <param name="genericArgumentCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <param name="argumentCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <param name="attributeCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <param name="isInstanceProperty" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
      <param name="catchType" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
      <param name="filterStart" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <param name="type" />
      <param name="isOptional" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <param name="kind" />
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="catchType" />
      <param name="filterOffset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="catchType" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="filterOffset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <param name="startOffset" />
      <param name="length" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <param name="exceptionRegionCount" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <param name="codeBuilder" />
      <param name="controlFlowBuilder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="code" />
      <param name="label" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="signature" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder" />
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="label" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>Идентификатор на основе 1, определяющий метку в контексте <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>Предоставляет методы для кодирования литералов.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">Создает экземпляр класса <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> с использованием указанного построителя больших двоичных объектов.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>Возвращает кодировщик, используемый для кодирования литерального значения.</summary>
      <returns>Кодировщик литерального значения.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>Кодирует тип и значение литерала с помощью указанных делегатов.</summary>
      <param name="type">Делегат, используемый для кодирования типа литерала. Вызывается этим методом в первую очередь.</param>
      <param name="scalar">Делегат, используемый для кодирования значения литерала. Вызывается этим методом во вторую очередь.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>Возвращает пару кодировщиков, которые должны использоваться для кодирования типа и значения литерала в порядке их следования в списке параметров.</summary>
      <param name="type">Когда этот метод возвращает управление, содержит кодировщик типа элемента настраиваемого атрибута, используемый для кодирования типа литерала.</param>
      <param name="scalar">Когда этот метод возвращает управление, содержит кодированный скаляр, используемый для кодирования значения литерала.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>Кодирует тип и элементы векторного литерала с помощью указанных делегатов.</summary>
      <param name="arrayType">Делегат, используемый для кодирования типа вектора. Вызывается этим методом в первую очередь.</param>
      <param name="vector">Делегат, используемый для кодирования элементов вектора. Вызывается этим методом во вторую очередь.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>Возвращает пару кодировщиков, которые должны использоваться для кодирования типа и элементов векторного литерала в порядке их следования в списке параметров.</summary>
      <param name="arrayType">Когда этот метод возвращает управление, содержит кодировщик типа массива настраиваемого атрибута, используемый для кодирования типа вектора.</param>
      <param name="vector">Когда этот метод возвращает управление, содержит кодировщик вектора, используемый для кодирования элементов вектора.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>Возвращает кодировщик вектора, используемый для кодирования элементов вектора.</summary>
      <returns>Кодировщик вектора, используемый для кодирования элементов вектора.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>Вычисляет дескриптор сущности в поколении метаданных, в котором она определена, по заданному маркеру сущности в агрегатных метаданных.</summary>
      <param name="handle">Дескриптор сущности в агрегатных метаданных.</param>
      <param name="generation">Поколение, в котором определена сущность.</param>
      <returns>Дескриптор сущности в метаданных <paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>Класс MetadataBuilder считывает и записывает метаданные для сборки с высокой производительностью. Он предназначен для использования компиляторами и другими средствами создания сборок.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Создает построитель для таблиц и куч метаданных.</summary>
      <param name="userStringHeapStartOffset">Начальное смещение кучи пользовательских строк. Совокупный размер куч пользовательских строк для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
      <param name="stringHeapStartOffset">Начальное смещение кучи строк. Совокупный размер куч строк для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
      <param name="blobHeapStartOffset">Начальное смещение кучи больших двоичных объектов. Совокупный размер куч больших двоичных объектов для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
      <param name="guidHeapStartOffset">Начальное смещение кучи идентификаторов GUID. Совокупный размер куч идентификаторов GUID для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>Добавляет значение по умолчанию для параметра, поля или свойства.</summary>
      <param name="parent">Дескриптор родительской сущности, который может быть следующим: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value">Значение константы.</param>
      <returns>Дескриптор добавляемой константы.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет настраиваемый атрибут.</summary>
      <param name="parent">Сущность, к которой необходимо присоединить настраиваемый атрибут: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> или <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor">Конструктор настраиваемого атрибута: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value">Большой двоичный объект со значением настраиваемого атрибута.</param>
      <returns>Дескриптор добавляемого настраиваемого атрибута.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет пользовательскую отладочную информацию.</summary>
      <param name="parent">Сущность, к которой необходимо присоединить отладочную информацию: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> или <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind">Тип информации. Определяет структуру большого двоичного объекта <paramref name="value" />.</param>
      <param name="value">Большой двоичный объект с пользовательской отладочной информацией.</param>
      <returns>Дескриптор добавляемой пользовательской отладочной информации.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет атрибут декларативной безопасности к типу, методу или сборке.</summary>
      <param name="parent">Дескриптор родительской сущности, который может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action">Декларативное действие безопасности.</param>
      <param name="permissionSet">Большой двоичный объект с набором разрешений.</param>
      <returns>Дескриптор добавляемого атрибута декларативной безопасности.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>Добавляет сведения об отладке документа.</summary>
      <param name="name">Большой двоичный объект с именем документа.</param>
      <param name="hashAlgorithm">Идентификатор GUID хэш-алгоритма, используемого для вычисления значения <paramref name="hash" />.</param>
      <param name="hash">Хэш-код содержимого документа.</param>
      <param name="language">Идентификатор GUID языка.</param>
      <returns>Дескриптор добавляемого документа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Добавляет определение события.</summary>
      <param name="attributes">Атрибуты события.</param>
      <param name="name">Имя события.</param>
      <param name="type">Тип события: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns>Дескриптор добавляемого определения события.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Добавляет экспортируемый тип.</summary>
      <param name="attributes">Атрибуты типа.</param>
      <param name="namespace">Пространство имен типа.</param>
      <param name="name">Имя типа.</param>
      <param name="implementation">Дескриптор сущности реализации, который может быть следующим: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> или <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId">Идентификатор определения типа.</param>
      <returns>Дескриптор добавляемого экспортируемого типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет определение поля.</summary>
      <param name="attributes">Атрибуты поля.</param>
      <param name="name">Имя поля.</param>
      <param name="signature">Подпись поля. Используйте <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> для создания большого двоичного объекта.</param>
      <returns>Дескриптор добавляемого определения поля.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Определяет макет поля для определения поля.</summary>
      <param name="field">Дескриптор определения поля.</param>
      <param name="offset">Смещение поля в байтах внутри экземпляра объявляющего типа.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Добавляет сопоставление поля с его начальным значением, хранящимся в образе PE.</summary>
      <param name="field">Дескриптор определения поля.</param>
      <param name="offset">Смещение внутри блока в образе PE, по которому хранятся начальные значения сопоставленных полей (обычно в разделе .text).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Добавляет определение универсального параметра.</summary>
      <param name="parent">Дескриптор родительской сущности, который может быть <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes">Атрибуты универсального параметра.</param>
      <param name="name">Имя параметра.</param>
      <param name="index">Отсчитываемый от нуля индекс параметра.</param>
      <returns>Дескриптор добавляемого универсального параметра.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Добавляет ограничение типа к универсальному параметру.</summary>
      <param name="genericParameter">Ограничиваемый универсальный параметр.</param>
      <param name="constraint">Ограничение типа, которое может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns>Дескриптор добавляемого ограничения универсального параметра.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет сведения об отладке локальной области.</summary>
      <param name="parentScope">Дескриптор родительской области.</param>
      <param name="imports">Дескриптор области импорта.</param>
      <returns>Дескриптор добавляемой области импорта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Добавляет реализацию интерфейса к типу.</summary>
      <param name="type">Тип, реализующий интерфейс.</param>
      <param name="implementedInterface">Реализуемый интерфейс, который может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns>Дескриптор добавляемой реализации интерфейса.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет сведения об отладке локальной константы.</summary>
      <param name="name">Имя переменной.</param>
      <param name="signature">Большой двоичный объект LocalConstantSig.</param>
      <returns>Дескриптор добавляемой локальной константы.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>Добавляет сведения об отладке локальной области.</summary>
      <param name="method">Содержащий метод.</param>
      <param name="importScope">Дескриптор связанной области импорта.</param>
      <param name="variableList">Если в области объявляются переменные, укажите дескриптор первой из них. В противном случае укажите дескриптор первой переменной, объявляемой в следующем определении области. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />, если переменные не объявляются ни в одной области.</param>
      <param name="constantList">Если в области объявляются константы, укажите дескриптор первой из них. В противном случае укажите дескриптор первой константы, объявляемой в следующем определении области. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />, если константы не объявляются ни в одной области.</param>
      <param name="startOffset">Смещение первой инструкции, входящей в область.</param>
      <param name="length">Длина области (в байтах).</param>
      <returns>Дескриптор добавляемой локальной области.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>Добавляет сведения об отладке локальной переменной.</summary>
      <param name="attributes">Атрибуты локальной переменной.</param>
      <param name="index">Отсчитываемый от нуля индекс локальной переменной в локальной сигнатуре.</param>
      <param name="name">Имя переменной.</param>
      <returns>Дескриптор добавляемой локальной переменной.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>Добавляет ресурс манифеста.</summary>
      <param name="attributes">Атрибуты ресурса манифеста.</param>
      <param name="name">Имя ресурса манифеста.</param>
      <param name="implementation">Дескриптор сущности реализации, который может быть следующим: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> или <see langword="null" />.</param>
      <param name="offset">Задает смещение в байтах, с которого начинается эта запись ресурса в указанном файле.</param>
      <returns>Дескриптор добавляемого ресурса манифеста.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет сведения о маршалинге к полю или параметру.</summary>
      <param name="parent">Дескриптор родительской сущности, который может быть следующим: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> или <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor">Большой двоичный объект дескриптора.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет строку в таблицу MemberRef.</summary>
      <param name="parent">Содержащая сущность, которая может быть следующей: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name">Имя элемента.</param>
      <param name="signature">Сигнатура элемента.</param>
      <returns>Дескриптор добавляемой ссылки на элемент.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет сведения об отладке метода.</summary>
      <param name="document">Дескриптор отдельного документа, содержащего все точки последовательности метода, или значение <see langword="null" />, если метод не имеет точек последовательности или охватывает несколько документов.</param>
      <param name="sequencePoints">Большой двоичный объект с точками последовательности или значение <see langword="null" />, если метод не имеет точек последовательности.</param>
      <returns>Дескриптор добавляемых сведений об отладке метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>Добавляет определение метода.</summary>
      <param name="attributes">Атрибуты метода.</param>
      <param name="implAttributes">Атрибуты реализации метода.</param>
      <param name="name">Имя метода.</param>
      <param name="signature">Сигнатура метода.</param>
      <param name="bodyOffset">Смещение внутри блока в образе PE, по которому хранятся тела методов (поток IL), или значение –1, если у метода нет тела.</param>
      <param name="parameterList">Если метод объявляет параметры в таблице Params, укажите дескриптор первого из них. В противном случае укажите дескриптор первого параметра, объявляемого в следующем определении метода. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />, если в модуле не объявляются параметры.</param>
      <returns>Дескриптор добавляемого определения метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Определяет реализацию объявления метода внутри типа.</summary>
      <param name="type">Определение типа.</param>
      <param name="methodBody">Дескриптор сущности тела метода, который может быть следующим: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration">Дескриптор сущности объявления метода, который может быть следующим: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <returns>Дескриптор добавляемой реализации метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Добавляет сведения об импорте в определение метода.</summary>
      <param name="method">Дескриптор определения метода.</param>
      <param name="attributes">Атрибуты импорта метода.</param>
      <param name="name">Имя неуправляемого метода.</param>
      <param name="module">Модуль, содержащий неуправляемый метод.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Связывает метод (получения, задания, добавления и т. д.) со свойством или событием.</summary>
      <param name="association">Дескриптор сущности связи, который может быть следующим: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics">Атрибуты семантики метода.</param>
      <param name="methodDefinition">Определение метода.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет спецификацию метода (для создания экземпляра).</summary>
      <param name="method">Дескриптор сущности универсального метода, который может быть следующим: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation">Большой двоичный объект для создания экземпляра, который кодирует универсальные аргументы метода.</param>
      <returns>Дескриптор добавляемой спецификации метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Определяет отношение вложенности к указанным определениям типов.</summary>
      <param name="type">Дескриптор определения вложенного типа.</param>
      <param name="enclosingType">Дескриптор определения включающего типа.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Добавляет определение параметра.</summary>
      <param name="attributes">Атрибуты параметра.</param>
      <param name="name">Необязательный параметр. Имя параметра.</param>
      <param name="sequenceNumber">Порядковый номер параметра. Значение 0 указывает на тип возвращаемого значения метода-владельца; затем его параметры нумеруются от 1.</param>
      <returns>Дескриптор добавляемого параметра.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Добавляет определение свойства.</summary>
      <param name="attributes">Атрибуты свойства.</param>
      <param name="name">Имя свойства.</param>
      <param name="signature">Сигнатура свойства.</param>
      <returns>Дескриптор добавляемого определения свойства.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Добавляет сведения об отладке метода конечного автомата.</summary>
      <param name="moveNextMethod">Дескриптор метода <see langword="MoveNext" /> конечного автомата (метода, созданного компилятором).</param>
      <param name="kickoffMethod">Дескриптор начального метода (определенного пользователем метода-итератора или асинхронного метода).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Добавляет определение типа.</summary>
      <param name="attributes">Атрибуты типа.</param>
      <param name="namespace">Пространство имен типа.</param>
      <param name="name">Имя типа.</param>
      <param name="baseType">Дескриптор сущности базового типа, который может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> или <see langword="null" />.</param>
      <param name="fieldList">Если в типе объявляются поля, укажите дескриптор первого из них. В противном случае укажите дескриптор первого поля, объявляемого в следующем определении типа. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />, если поля не объявляются ни в одном типе модуля.</param>
      <param name="methodList">Если в типе объявляются методы, укажите дескриптор первого из них. В противном случае укажите дескриптор первого метода, объявляемого в следующем определении типа. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />, если методы не объявляются ни в одном типе модуля.</param>
      <returns>Дескриптор добавляемого определения типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>Определяет макет типа для определения типа.</summary>
      <param name="type">Определение типа.</param>
      <param name="packingSize">Указывает, что поля должны размещаться в экземпляре типа по байтовым адресам, кратным <paramref name="packingSize" />, или по естественному выравниванию для этого типа поля в зависимости от того, какое из этих значений меньше. Значение должно быть одним из следующих: 0, 1, 2, 4, 8, 16, 32, 64 или 128. Нулевое значение указывает, что используемый упаковочный размер должен соответствовать значению по умолчанию для текущей платформы.</param>
      <param name="size">Указывает минимальный размер экземпляра типа; предназначен для обеспечения заполнения. Объем выделенной памяти равен размеру, вычисленному на основе макета, или <paramref name="size" /> в зависимости от того, какое из этих значений больше. Обратите внимание, что если эта директива применяется к типу значения, размер будет меньше 1 МБ.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>Добавляет ссылку на тип.</summary>
      <param name="resolutionScope">Сущность, определяющая тип целевого объекта; может быть следующей: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see langword="null" />.</param>
      <param name="namespace">Пространство имен ссылки на тип.</param>
      <param name="name">Имя ссылки на тип.</param>
      <returns>Дескриптор добавляемой ссылки на тип.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>Добавляет указанный большой двоичный объект в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value">Массив, содержащий большой двоичный объект.</param>
      <returns>Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Добавляет указанный большой двоичный объект из массива байтов в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value">Массив, содержащий большой двоичный объект.</param>
      <returns>Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>Добавляет указанный большой двоичный объект из неизменяемого массива байтов в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value">Экземпляр построителя больших двоичных объектов, содержащий большой двоичный объект.</param>
      <returns>Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>Кодирует строку в кодировке UTF16 в большой двоичный объект, а затем добавляет этот объект в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value">Строка для добавления.</param>
      <returns>Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>Кодирует строку в кодировке UTF8 в большой двоичный объект, а затем добавляет этот объект в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value">Значение для сложения.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> для кодирования суррогатов без пары указанным образом; <see langword="false" /> для их замены на символ U+FFFD.</param>
      <returns>Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>Кодирует значение константы в большой двоичный объект, а затем добавляет этот объект в кучу больших двоичных объектов, если его еще нет в ней. Использует кодировку UTF16 для кодирования строковых констант.</summary>
      <param name="value">Добавляемое значение константы.</param>
      <returns>Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>Кодирует имя документа отладки и добавляет его в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value">Добавляемое имя документа.</param>
      <returns>Дескриптор добавляемого или существующего большого двоичного объекта с именем документа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>Добавляет указанный идентификатор GUID в кучу идентификаторов GUID, если его еще нет в ней.</summary>
      <param name="guid">Добавляемый идентификатор GUID.</param>
      <returns>Дескриптор добавляемого или существующего идентификатора GUID.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>Добавляет указанную строку в кучу строк, если ее еще нет в ней.</summary>
      <param name="value">Строка для добавления.</param>
      <returns>Дескриптор добавляемой или существующей строки.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>Добавляет указанную строку в кучу пользовательских строк, если ее еще нет в ней.</summary>
      <param name="value">Строка для добавления.</param>
      <returns>Дескриптор добавляемой или существующей строки. Это значение может использоваться в <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Возвращает текущее количество элементов в указанной таблице.</summary>
      <param name="table">Индекс таблицы.</param>
      <returns>Количество элементов в таблице.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>Возвращает текущее количество элементов в каждой таблице.</summary>
      <returns>Массив размера <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, в котором каждый элемент заполнен текущим числом строк в соответствующей таблице.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>Резервирует место для идентификатора GUID в куче идентификаторов GUID.</summary>
      <returns>Дескриптор резервируемого идентификатора GUID и объект <see cref="T:System.Reflection.Metadata.Blob" />, представляющий большой двоичный объект с идентификатором GUID, хранящийся в куче.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>Резервирует место в куче пользовательских строк для строки указанной длины.</summary>
      <param name="length">Число резервируемых символов.</param>
      <returns>Дескриптор резервируемой пользовательской строки и объект <see cref="T:System.Reflection.Metadata.Blob" />, представляющий весь большой двоичный объект с пользовательской строкой (включая ее длину и завершающий символ). Дескриптор может использоваться в <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
Используйте <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> для заполнения содержимого большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>Задает емкость указанной кучи.</summary>
      <param name="heap">Индекс кучи.</param>
      <param name="byteCount">Число байтов.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Задает емкость указанной таблицы.</summary>
      <param name="table">Индекс таблицы.</param>
      <param name="rowCount">Число строк в таблице.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>Предоставляет методы расширения для работы с определенными необработанными элементами куч и таблиц метаданных ECMA-335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Перечисляет записи журнала EnC.</summary>
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Перечисляет записи схемы EnC.</summary>
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Возвращает смещение от начала метаданных до указанной кучи.</summary>
      <param name="reader" />
      <param name="heapIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Возвращает размер указанной кучи.</summary>
      <param name="reader" />
      <param name="heapIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>Возвращает маркер <see cref="T:System.Reflection.Metadata.Blob" />, следующий за заданным в <see cref="T:System.Reflection.Metadata.Blob" /> куче, или нулевой маркер, если он является последним.</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>Возвращает маркер строки, следующей за заданной строкой в куче строк, или нулевой маркер, если она является последней.</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>Возвращает маркер UserString, следующего за заданным значением в куче UserString, или нулевой маркер, если он является последним.</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Возвращает смещение от начала метаданных до указанной таблицы.</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Возвращает число строк в указанной таблице.</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Возвращает размер строки в указанной таблице.</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>Перечисляет типы, определяющие одно или несколько событий.</summary>
      <param name="reader" />
      <returns>Результирующая последовательность точно соответствует записям в таблице EventMap, т. е. n-й возвращенный <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> хранится в n-й строке EventMap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>Перечисляет типы, определяющие одно или несколько свойств.</summary>
      <param name="reader" />
      <returns>Результирующая последовательность точно соответствует записям в таблице схему свойств, т. е. n-й возвращенный <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> хранится в n-й строке схемы свойств.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>При наличии обработчика типа и вида необработанного типа, находящегося в BLOB-объекте сигнатуры, определяет, является ли целевой тип типом значения или ссылочным типом.</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>Построитель корней метаданных для внедрения в переносимый исполняемый образ.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>Создает построитель корня метаданных.</summary>
      <param name="tablesAndHeaps">Построитель заполнен сущностями метаданных, хранящимися в таблицах, и значениями из куч. Сущности и значения перечисляются при сериализации корня метаданных.</param>
      <param name="metadataVersion">Строка версии, записанная в заголовок метаданных. Значение по умолчанию: "v4.0.30319".</param>
      <param name="suppressValidation">
        <see langword="true" /> для подавления базовой проверки таблиц метаданных во время сериализации; в противном случае — <paramref name="false" />.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>Версия метаданных.</summary>
      <returns>Строка, представляющая версию метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>Сериализует содержимое корня метаданных в заданный <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder">Построитель для записи.</param>
      <param name="methodBodyStreamRva">Относительный виртуальный адрес начала потока тела метода. Используется для вычисления конечного значения полей RVA таблицы MethodDef.</param>
      <param name="mappedFieldDataStreamRva">Относительный виртуальный адрес начала потока данных инициализации поля. Используется для вычисления конечного значения полей RVA таблицы FieldRVA.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>Возвращает размеры различных структур метаданных.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>Определяет, следует ли подавлять базовую проверку таблиц метаданных. Проверка подтверждает, что записи в таблицах были добавлены в порядке, требуемом спецификацией ECMA. Она не применяет все требования спецификации к таблицам метаданных.</summary>
      <returns>
        <see langword="true" /> для подавления базовой проверки таблиц метаданных; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>Предоставляет сведения о размерах различных структур метаданных.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>Число строк внешней таблицы.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Возвращает выровненный размер указанной кучи.</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>Точные (невыровненные) размеры кучи.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>Число строк таблицы.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>Создает дескриптор сущности на основе значения токена.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Создает <see cref="T:System.Reflection.Metadata.EntityHandle" /> на основе значения токена.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" />
      <returns>Отсчитываемое от нуля смещение или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" /> или <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" />
      <returns>Отсчитываемый от 1 индекс в куче #Guid. В отличие от других куч, которые, по сути, представляют собой байтовые массивы, куча #Guid является массивом 16-байтовых идентификаторов GUID.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" />
      <returns>Смещение в соответствующей куче или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" /> или <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" /> в контексте <paramref name="reader" />, в куче метаданных.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Отсчитываемое от нуля смещение или -1, если <paramref name="handle" /> не является дескриптором кучи метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" />
      <returns>Отсчитываемое от нуля смещение или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" /> или <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" />
      <returns>Отсчитываемое от нуля смещение.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>Возвращает номер строки записи, соответствующей указанному дескриптору <paramref name="handle" />, в таблице метаданных.</summary>
      <param name="handle" />
      <returns>Отсчитываемый от 1 номер строки или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" />.
См. раздел <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Возвращает номер строки записи, соответствующей указанному дескриптору <paramref name="handle" /> в контексте <paramref name="reader" />, в таблице метаданных.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Отсчитываемый от 1 номер строки.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>Возвращает токен метаданных для указанного дескриптора <paramref name="handle" />.</summary>
      <param name="handle" />
      <returns>Токен метаданных или 0, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>Возвращает токен метаданных для указанного дескриптора <paramref name="handle" />.</summary>
      <param name="handle" />
      <returns>Токен метаданных или 0, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Возвращает токен метаданных для указанного дескриптора <paramref name="handle" /> в контексте <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Токен метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Возвращает токен метаданных для указанного дескриптора <paramref name="handle" /> в контексте <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Токен метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>Создает дескриптор на основе значения токена.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Создает <see cref="T:System.Reflection.Metadata.EntityHandle" /> на основе значения токена.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Максимальное число таблиц, которые могут присутствовать в метаданных Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Максимальное число таблиц, которые могут присутствовать в метаданных Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>Возвращает индекс <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> кучи, соответствующей указанному <see cref="T:System.Reflection.Metadata.HandleKind" />.</summary>
      <param name="type">Тип дескриптора.</param>
      <param name="index">Индекс кучи.</param>
      <returns>Значение <see langword="true" />, если тип дескриптора соответствует куче Ecma335; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>Возвращает индекс <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> таблицы, соответствующей указанному <see cref="T:System.Reflection.Metadata.HandleKind" />.</summary>
      <param name="type">Тип дескриптора.</param>
      <param name="index">Индекс таблицы.</param>
      <returns>Значение <see langword="true" />, если тип дескриптора соответствует таблице Ecma335 или переносимой таблице PDB; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>Определяет атрибуты тела метода.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>Инициализирует все локальные переменные, которые метод определяет как ноль, и динамически выделяет локальную память.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>Не выполняет инициализацию локальной памяти.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>Предоставляет кодировщик для потока тела метода.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Кодирует тело метода и добавляет его в поток тела метода, используя указанный размер кода, максимальный размер стека, число регионов исключения, параметр сигнатуры локальных переменных, атрибуты тела метода. Позволяет указать, должны ли области исключения быть закодированными в небольшом формате или нет.</summary>
      <param name="codeSize">Число байтов, которое должно быть зарезервировано для инструкций.</param>
      <param name="maxStack">Максимальный размер стека.</param>
      <param name="exceptionRegionCount">Число регионов исключений.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" />, если области исключений должны быть закодированы в небольшом формате; в противном случае <see langword="false" />.</param>
      <param name="localVariablesSignature">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes">Атрибуты тела метода.</param>
      <returns>Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Кодирует тело метода и добавляет его в поток тела метода, используя указанный размер кода, максимальный размер стека, число регионов исключения, параметр сигнатуры локальных переменных, атрибуты тела метода. Позволяет указать, должны ли области исключения быть закодированными в небольшом формате и должен ли метод выделять из пула динамической локальной памяти или нет.</summary>
      <param name="codeSize">Число байтов, которое должно быть зарезервировано для инструкций.</param>
      <param name="maxStack">Максимальный размер стека.</param>
      <param name="exceptionRegionCount">Число регионов исключений.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" />, если области исключений должны быть закодированы в небольшом формате; в противном случае <see langword="false" />.</param>
      <param name="localVariablesSignature">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes">Атрибуты тела метода.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" />, если метод выделяет из пула динамической локальной памяти (инструкция <see langword="localloc" />); в противном случае <see langword="false" />.</param>
      <returns>Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Кодирует тело метода и добавляет его в поток тела метода.</summary>
      <param name="instructionEncoder">Кодировщик инструкций.</param>
      <param name="maxStack">Максимальный размер стека.</param>
      <param name="localVariablesSignature">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes">Атрибуты тела метода.</param>
      <returns>Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Кодирует тело метода и добавляет его в поток тела метода, используя предоставленный кодировщик инструкций, максимальный размер стека, параметр сигнатуры локальных переменных, атрибуты тела метода. Позволяет указать, должен ли метод выделять из пула динамической локальной памяти или нет.</summary>
      <param name="instructionEncoder">Кодировщик инструкций.</param>
      <param name="maxStack">Максимальный размер стека.</param>
      <param name="localVariablesSignature">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes">Атрибуты тела метода.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" />, если метод выделяет из пула динамической локальной памяти (IL содержит инструкцию <see langword="localloc" />); в противном случае <see langword="false" />.</param>
      <returns>Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>Описывает тело метода. Этот класс предназначен для использования вместе с классом <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>Возвращает объект кодировщика, который можно использовать для кодирования областей исключений для тела метода.</summary>
      <returns>Экземпляр кодировщика области исключений.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>Возвращает большой двоичный объект, зарезервированный для инструкций.</summary>
      <returns>Большой двоичный объект, зарезервированный для инструкций.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>Возвращает смещение тела закодированного метода в потоке тела метода.</summary>
      <returns>Смещение тела закодированного метода в потоке тела метода.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>Предоставляет кодировщик для сигнатур методов.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>Кодирует предоставленный тип возвращаемого значения и параметры.</summary>
      <param name="parameterCount">Число параметров.</param>
      <param name="returnType">Метод, который вызывается первым для кодирования типа возвращаемого значения.</param>
      <param name="parameters">Метод, который вызывается вторым для кодирования параметров.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>Кодирует предоставленный тип возвращаемого значения и параметры, которые должны использоваться в том порядке, в котором они отображаются в списке параметров.</summary>
      <param name="parameterCount">Число параметров.</param>
      <param name="returnType">Метод, который вызывается первым для кодирования типов возвращаемых значений.</param>
      <param name="parameters">Метод, который вызывается вторым для кодирования параметров.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />.</summary>
      <param name="builder">Построитель для кодирования именованного аргумента.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>Кодирует именованный аргумент (поле или свойство).</summary>
      <param name="isField">
        <see langword="true" /> для кодирования поля; <see langword="false" /> для кодирования свойства.</param>
      <param name="type">Метод, вызываемый первым для кодирования типа аргумента.</param>
      <param name="name">Метод, вызываемый вторым для кодирования имени поля или свойства.</param>
      <param name="literal">Метод, вызываемый третьим для кодирования литерального значения аргумента.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>Кодирует именованный аргумент (поле или свойство) и возвращает три кодировщика, которые должны использоваться в порядке их следования в списке параметров.</summary>
      <param name="isField">
        <see langword="true" /> для кодирования поля; <see langword="false" /> для кодирования свойства.</param>
      <param name="type">Метод, вызываемый первым для кодирования типа аргумента.</param>
      <param name="name">Метод, вызываемый вторым для кодирования имени поля или свойства.</param>
      <param name="literal">Метод, вызываемый третьим для кодирования литерального значения аргумента.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>Представляет построитель образа переносимого PDB-файла.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>Создает построитель образа переносимого PDB-файла.</summary>
      <param name="tablesAndHeaps">Построитель заполнен сущностями метаданных отладки, хранящимися в таблицах, и значениями из куч. Сущности и значения перечисляются при сериализации образа переносимого PDB-файла.</param>
      <param name="typeSystemRowCounts">Количество строк всех таблиц, содержащихся в связанных метаданных системы типов. Каждый слот в массиве соответствует таблице (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). Длина массива должна быть равна <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.</param>
      <param name="entryPoint">Параметр определения метода точки входа.</param>
      <param name="idProvider">Функция, которая вычисляет идентификатор содержимого, представленного в виде последовательности больших двоичных объектов. Если не указано, используется функция по умолчанию, которая игнорирует содержимое и возвращает идентификатор содержимого на основе текущего времени (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Для создания детерминированного образа переносимого PDB-файла необходимо указать детерминированную функцию.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>Сериализует содержимое переносимого PDB-файла в заданный <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder">Построитель для записи.</param>
      <returns>Идентификатор сериализованного содержимого.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>Кодирует константный литерал.</summary>
      <param name="value">Константа типа <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (в кодировке двухбайтовых символов в Юникоде), <see cref="T:System.String" /> (в кодировке SerString) или <see cref="T:System.Enum" /> (в кодировке базового целого числа).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>Кодирует литерал <see langword="null" /> типа <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>Кодирует литерал типа <see cref="T:System.Type" /> (может иметь значение <see langword="null" />).</summary>
      <param name="serializedTypeName">Имя типа или значение <see langword="null" />.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>Декодирует большие двоичные объекты сигнатуры.</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>Создает новый экземпляр <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider">Поставщик, используемый для получения символов типа при декодировании сигнатуры.</param>
      <param name="metadataReader">Модуль чтения метаданных, из которого была получена сигнатура. Может иметь значение <see langword="null" />, если указанный поставщик разрешает это.</param>
      <param name="genericContext">Дополнительный контекст для разрешения универсальных параметров.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Декодирует большой двоичный объект сигнатуры поля и перемещает модуль чтения за сигнатуру.</summary>
      <param name="blobReader">Модуль чтения больших двоичных объектов, расположенный у сигнатуры поля.</param>
      <returns>Тип декодированного поля.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Декодирует большой двоичный объект сигнатуры локальной переменной и перемещает модуль чтения за сигнатуру.</summary>
      <param name="blobReader">Модуль чтения больших двоичных объектов, расположенный у сигнатуры локальной переменной.</param>
      <returns>Типы локальных переменных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Декодирует метод (определение, ссылка или автономный режим) или большой двоичный объект сигнатуры свойства.</summary>
      <param name="blobReader">Модуль чтения больших двоичных объектов, расположенный у сигнатуры метода.</param>
      <returns>Декодированная сигнатура метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Декодирует большой двоичный объект сигнатуры спецификации метода и перемещает модуль чтения за сигнатуру.</summary>
      <param name="blobReader">Модуль чтения больших двоичных объектов, расположенный у допустимой сигнатуры спецификации метода.</param>
      <returns>Типы, используемые для создания экземпляра универсального метода с помощью спецификации метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>Декодирует тип, встроенный в сигнатуру, и перемещает модуль чтения за тип.</summary>
      <param name="blobReader">Модуль чтения больших двоичных объектов, расположенный в начале <see cref="T:System.Reflection.Metadata.SignatureTypeCode" />.</param>
      <param name="allowTypeSpecifications">
        <see langword="true" />, чтобы позволить <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> следовать за (CLASS | VALUETYPE) в сигнатуре; в противном случае <see langword="false" />.</param>
      <returns>Расшифрованный тип.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>Кодирует тип массива.</summary>
      <param name="elementType">Вызывается первым, чтобы закодировать тип элемента.</param>
      <param name="arrayShape">Вызывается вторым, чтобы закодировать форму массива.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>Кодирует тип массива. Возвращает пару кодировщиков, которые должны использоваться в порядке их следования в списке параметров.</summary>
      <param name="elementType">Используйте первым для кодирования типа элемента.</param>
      <param name="arrayShape">Используйте вторым для кодирования формы массива.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>Запускает сигнатуру типа с пользовательскими модификаторами.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>Запускает сигнатуру указателя функции.</summary>
      <param name="convention">Соглашение о вызовах.</param>
      <param name="attributes">Атрибуты указателя функции.</param>
      <param name="genericParameterCount">Число универсальных параметров.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>Запускает сигнатуру универсального экземпляра.</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount">Число универсальных аргументов.</param>
      <param name="isValueType">
        <see langword="true" />, чтобы пометить тип как тип значения; <see langword="false" />, чтобы пометить его как ссылочный тип в сигнатуре.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>Кодирует ссылку на параметр типа содержащего универсального метода.</summary>
      <param name="parameterIndex">Индекс параметра.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>Кодирует ссылку на параметр типа содержащего универсального типа.</summary>
      <param name="parameterIndex">Индекс параметра.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>Запускает сигнатуру указателя.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Записывает код примитивного типа.</summary>
      <param name="type">Любой код примитивного типа, кроме <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> и <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>Запускает сигнатуру массива (вектора) SZ.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Кодирует ссылку на тип.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType">
        <see langword="true" />, чтобы пометить тип как тип значения; <see langword="false" />, чтобы пометить его как ссылочный тип в сигнатуре.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>Кодирует указатель void (void*).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>Представляет сущность метаданных (например, ссылку на тип, определение типа, спецификацию типа, определение метода или настраиваемый атрибут).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>Возвращает значение, указывающее, равен ли данный экземпляр указанному объекту.</summary>
      <param name="obj">Объект для сравнения с текущим экземпляром.</param>
      <returns>Значение <see langword="true" />, если <paramref name="obj" /> является <see cref="T:System.Reflection.Metadata.EntityHandle" /> равен текущему экземпляру; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>Возвращает значение, указывающее, равен ли текущий экземпляр указанному <see cref="T:System.Reflection.Metadata.EntityHandle" />.</summary>
      <param name="other">Значение для сравнения с текущим экземпляром.</param>
      <returns>Значение <see langword="true" />, если объект <paramref name="other" /> равен текущему экземпляру; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>Возвращает хэш-код данного экземпляра.</summary>
      <returns>Хэш-код данного экземпляра.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>Возвращает дескриптор TypeRef, TypeDef или TypeSpec, если область представляет блок catch, или токен nil в противном случае (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>Возвращает смещение IL начала блока фильтра или значение –1, если область не является фильтром.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>Возвращает длину обработчика исключений в байтах.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>Возвращает начальное смещение IL обработчика исключений.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>Возвращает длину блока try в байтах.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>Возвращает начальное смещение IL блока try.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>Возвращает дескриптор для разрешения реализации целевого типа.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />представление другого модуля в сборке.
<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />представление другой сборки, <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> если <see langword="true" />имеет значение.
<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />представление объявляющего экспортированного типа, в котором это был вложенный объект.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>Возвращает имя целевого типа или <see langword="default" />, если тип является вложенным либо определен в корневом пространстве имен.</summary>
      <returns>Экземпляр <see cref="T:System.Reflection.Metadata.StringHandle" /> структуры.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>Возвращает полное имя пространства имен, содержащего целевой тип, или <see langword="default" />, если тип является вложенным либо определен в корневом пространстве имен.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>Возвращает дескриптор определения пространства имен, содержащего целевой тип, или <see langword="default" />, если тип является вложенным либо определен в корневом пространстве имен.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>Представляет коллекцию экземпляров <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>Возвращает смещение поля макета или значение –1, если оно недоступно.</summary>
      <returns>Смещение определения поля или значение –1, если оно недоступно.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>Возвращает атрибуты, указывающие отклонения и ограничения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>Возвращает отсчитываемый от нуля индекс параметра внутри объявляющего универсального типа или объявления метода.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>Возвращает имя универсального параметра.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>Возвращает <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, представляющий родительский объект этого универсального параметра.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>Возвращает ограниченный <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>Возвращает дескриптор (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />), указывая, от какого типа этот универсальный параметр может быть производным или какой интерфейс этот универсальный параметр может реализовывать.</summary>
      <returns>Экземпляр <see cref="T:System.Reflection.Metadata.EntityHandle" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>Представляет коллекцию ограничений параметра универсального типа.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <param name="index" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>Представляет коллекцию параметров универсальных типов для метода или типа.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <param name="index" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>Представляет любую сущность метаданных (например, ссылку на тип, определение типа, спецификацию типа, определение метода или настраиваемый атрибут) или значение (строку, большой двоичный объект, GUID или пользовательскую строку).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Сравнивает два дескриптора сущности.</summary>
      <param name="x">Первый из сравниваемых дескрипторов сущности.</param>
      <param name="y">Второй из сравниваемых дескрипторов сущности.</param>
      <returns>Нуль, если два дескриптора сущности равны, и ненулевое значение в противном случае.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Сравнивает два дескриптора.</summary>
      <param name="x">Первый из сравниваемых дескрипторов.</param>
      <param name="y">Второй из сравниваемых дескрипторов.</param>
      <returns>Нуль, если два дескриптора равны, и ненулевое значение в противном случае.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="x" />
      <param name="y" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="x" />
      <param name="y" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <param name="obj" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>Возвращает символ типа для универсального массива с заданным типом элементов и формой.</summary>
      <param name="elementType">Тип элементов массива.</param>
      <param name="shape">Форма (ранг, размеры и нижние границы) массива.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>Возвращает символ типа для управляемого указателя на заданный тип элементов.</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Возвращает символ типа для универсального экземпляра заданного универсального типа с заданными аргументами типа.</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>Возвращает символ типа для неуправляемого указателя на заданный тип элементов.</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>Возвращает представление <typeparamref name="TType" /> для <see cref="T:System.Type" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>Возвращает символ типа для имени заданного сериализованного типа.</summary>
      <param name="name">Имя сериализованного типа в так называемом формате "нотации отражения" (как его понимает метод <see cref="M:System.Type.GetType(System.String)" />).</param>
      <returns>Экземпляр <typeparamref name="TType" />.</returns>
      <exception cref="T:System.BadImageFormatException">Имя имеет неправильный формат.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>Возвращает базовый тип заданного символа типа перечисления.</summary>
      <param name="type">Тип перечисления.</param>
      <returns>Код типа, указывающий базовый тип перечисления.</returns>
      <exception cref="T:System.BadImageFormatException">Символ заданного типа не представляет перечисление.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>Проверяет, представляет ли заданный тип <see cref="T:System.Type" />.</summary>
      <param name="type">Проверяемый тип.</param>
      <returns>Значение <see langword="true" />, если заданный тип является <see cref="T:System.Type" />, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>Вычисляет размер операнда инструкции указанной ветви.</summary>
      <param name="opCode">Код операции ветви.</param>
      <returns>1, если <paramref name="opCode" /> является короткой ветвью, или 4, если это длинная ветвь.</returns>
      <exception cref="T:System.ArgumentException">Указанный <paramref name="opCode" /> не является кодом операции ветви.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Возвращает длинную форму кода операции указанной ветви.</summary>
      <param name="opCode">Код операции ветви.</param>
      <returns>Длинная форма кода операции ветви.</returns>
      <exception cref="T:System.ArgumentException">Указанный <paramref name="opCode" /> не является кодом операции ветви.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Возвращает короткую форму кода операции указанной ветви.</summary>
      <param name="opCode">Код операции ветви.</param>
      <returns>Короткая форма кода операции ветви.</returns>
      <exception cref="T:System.ArgumentException">Указанный <paramref name="opCode" /> не является кодом операции ветви.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Проверяет, является ли указанный код операции ветвью для метки.</summary>
      <param name="opCode" />
      <returns>Значение <see langword="true" />, если указанный код операции является ветвью для метки, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>Исключение, порождаемое при попытке записи метаданных, превышающих предельное значение, заданное спецификацией формата. Например, если превышено ограничение размера кучи.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> с сериализованными данными.</summary>
      <param name="info">Объект, содержащий сериализованные данные объекта.</param>
      <param name="context">Контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> с заданным сообщением об ошибке и ссылкой на внутреннее исключение, которое стало причиной данного исключения.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="innerException">Исключение, вызвавшее текущее исключение, или значение <see langword="null" />, если внутреннее исключение не задано.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <exception cref="T:System.BadImageFormatException">Недопустимый формат BLOB-объекта.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>Предоставляет сведения о лексической области, в которой доступна группа операций импорта. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>Возвращает реализованный интерфейс (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>Получает символ типа для типа указателя на функцию заданного метода <paramref name="signature" />.</summary>
      <param name="signature" />
      <returns>Символ типа для типа указателя на функцию.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>Получает символ типа для параметра универсального метода в заданной отсчитываемой от нуля позиции <paramref name="index" />.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Символ типа для параметра универсального метода в позиции <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>Получает символ типа для параметра универсального типа в заданной отсчитываемой от нуля позиции <paramref name="index" />.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Символ типа для параметра универсального типа в заданной отсчитываемой от нуля позиции <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>Получает символ типа для типа с примененным пользовательским модификатором.</summary>
      <param name="modifier">Примененный тип модификатора.</param>
      <param name="unmodifiedType">Символ типа для базового типа без примененных модификаторов.</param>
      <param name="isRequired">
        <see langword="true" />, если модификатор является обязательным, <see langword="false" /> — если он необязателен.</param>
      <returns>Символ типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>Получает символ типа для типа локальной переменной, помеченный как закрепленный.</summary>
      <param name="elementType" />
      <returns>Символ типа для типа локальной переменной.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>Получает тип символа для спецификации типа.</summary>
      <param name="reader">Средство чтения метаданных, переданное декодеру подписи. Может иметь значение <see langword="null" />.</param>
      <param name="genericContext">Контекст, переданный декодеру подписи.</param>
      <param name="handle">Дескриптор спецификации типа.</param>
      <param name="rawTypeKind">Вид типа, как указано в подписи. Для интерпретации этого значения следует использовать <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Символ типа для спецификации типа.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Получает символ типа для типа-примитива.</summary>
      <param name="typeCode" />
      <returns>Символ типа для <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>Получает символ типа для определения типа.</summary>
      <param name="reader">Средство чтения метаданных, переданное декодеру подписи. Может иметь значение <see langword="null" />.</param>
      <param name="handle">Дескриптор определения типа.</param>
      <param name="rawTypeKind">Вид типа, как указано в подписи. Для интерпретации этого значения следует использовать <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Символ типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>Получает символ типа для ссылочного типа.</summary>
      <param name="reader">Средство чтения метаданных, переданное декодеру подписи. Может иметь значение <see langword="null" />.</param>
      <param name="handle">Дескриптор определения типа.</param>
      <param name="rawTypeKind">Вид типа, как указано в подписи. Для интерпретации этого значения следует использовать <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Символ типа.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>Возвращает символ типа для одномерного массива с заданным типом элементов, где нижняя граница равна нулю.</summary>
      <param name="elementType" />
      <returns>Экземпляр <typeparamref name="TType" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>Предоставляет сведения о локальных константах. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>Возвращает подпись константы.</summary>
      <returns>Сигнатура константы.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>Предоставляет сведения об области действия локальных переменных и констант. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>Предоставляет сведения о локальных переменных. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>Возвращает атрибуты ресурса манифеста.</summary>
      <returns>Побитовое сочетание значений перечисления, задающих атрибуты ресурса манифеста.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>Возвращает дескриптор сущности реализации.</summary>
      <returns>Экземпляр Ентитихандле. Если свойство <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> имеет значение <see langword="true" />, возвращаемый обработчик будет иметь значения по умолчанию.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>Возвращает имя ресурса.</summary>
      <returns>Имя ресурса.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>Возвращает смещение в байтах, с которого начинается эта запись ресурса в указанном файле.</summary>
      <returns>Смещение в байтах в упоминаемом файле, с которого начинается Эта запись ресурса.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>Представляет коллекцию экземпляров <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>Определяет, указывает ли ссылка на член на метод или поле.</summary>
      <returns>Одно из значений перечисления, обозначающее тип ссылки на член.</returns>
      <exception cref="T:System.BadImageFormatException">Сигнатура ссылки на член недопустима.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>Возвращает дескриптор родительской сущности.</summary>
      <returns>Экземпляр обработчика сущности. Если свойство <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> имеет значение <see langword="true" />, возвращаемый обработчик будет иметь значения по умолчанию.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>Возвращает дескриптор в BLOB-объект сигнатуры.</summary>
      <returns>Маркер для большого двоичного объекта сигнатуры.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>Представляет коллекцию экземпляров <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>Задает константы, указывающие, на что ссылается <see cref="T:System.Reflection.Metadata.MemberReference" />: на метод или поле.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> ссылается на поле.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> ссылается на метод.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>Метаданные CLI.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>Метаданные Windows, созданные управляемыми компиляторами.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Метаданные Windows.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>Считывает метаданные в соответствии с определением в спецификации CLI ECMA 335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataReader" /> на основе метаданных, хранящихся в указанном месте памяти.</summary>
      <param name="metadata">Указатель на первый байт в блоке метаданных.</param>
      <param name="length">Количество байтов в блоке.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataReader" /> на основе метаданных, хранящихся в указанном месте памяти.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataReader" /> на основе метаданных, хранящихся в указанном месте памяти.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> не является положительным числом.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="metadata" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Кодировка <paramref name="utf8Decoder" /> не является <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.BadImageFormatException">Неправильный заголовок метаданных.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>Возвращает декодированные данные из потока #Pdb или значение <see langword="null" />, если поток отсутствует.</summary>
      <returns>Сведения, декодированные из #Pdb потока или <see langword="null" />, если поток отсутствует.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>Возвращает значение, указывающее, представляют ли метаданные сборку.</summary>
      <returns>
        <see langword="true" />, если метаданные представляют сборку; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>Возвращает тип метаданных.</summary>
      <returns>Одно из значений перечисления, указывающее тип метаданных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>Возвращает длину базовых данных.</summary>
      <returns>Длина базовых данных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>Возвращает указатель на базовые данные.</summary>
      <returns>Указатель на базовые данные.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>Возвращает строку версии, считанную из заголовка метаданных.</summary>
      <returns>Строка версии, считанная из заголовка метаданных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>Возвращает объект <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />, переданный в конструктор.</summary>
      <returns>Побитовое сочетание значений перечисления, которое описывает значение перечисления <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>Возвращает функцию сравнения, которая используется для сравнения строк, хранящихся в метаданных.</summary>
      <returns>Функция сравнения, используемая для сравнения строк, хранящихся в метаданных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>Возвращает декодер, используемый средством чтения для создания экземпляров строк на основе последовательностей байтов в кодировке UTF8.</summary>
      <returns>Декодер, используемый модулем чтения для создания строковых экземпляров из последовательностей байтов в кодировке UTF8.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>Проекции среды выполнения Windows включены (по умолчанию).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>Параметры, используемые при получении <see cref="T:System.Reflection.Metadata.MetadataReader" /> с помощью перегрузки, которая не принимает аргумент <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>Все параметры отключены.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>Предоставляет <see cref="T:System.Reflection.Metadata.MetadataReader" /> для метаданных, хранящихся в массиве байтов, блоке памяти или потоке.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>Удаляет весь объем памяти, выделенный средством чтения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>Создает поставщик метаданных для образа, хранящегося в памяти.</summary>
      <param name="start">Указатель на начало BLOB-объекта метаданных.</param>
      <param name="size">Размер BLOB-объекта метаданных.</param>
      <returns>Новый поставщик метаданных.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="start" /> имеет значение <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Создает поставщик для массива байтов.</summary>
      <param name="image">Образ метаданных.</param>
      <returns>Новый поставщик.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Создает поставщик для потока указанного размера, начиная с его текущей позиции.</summary>
      <param name="stream">Экземпляр <see cref="T:System.IO.Stream" />.</param>
      <param name="options">Параметры, которые определяют способ считывания разделов образа из потока.</param>
      <param name="size">Размер BLOB-объекта метаданных в потоке. Если не указан, предполагается, что размер BLOB-объекта метаданных достигает конца потока.</param>
      <returns>Новый поставщик.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> не поддерживает операции чтения и поиска.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Размер является отрицательным или превышает длину потока.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из потока (только если указан <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>Создает поставщик метаданных переносимого PDB-файла для BLOB-объекта, хранящегося в памяти.</summary>
      <param name="start">Указатель на начало BLOB-объекта переносимого PDB-файла.</param>
      <param name="size">Размер BLOB-объекта переносимого PDB-файла.</param>
      <returns>Новый поставщик метаданных переносимого PDB-файла.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="start" /> имеет значение <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Создает поставщик метаданных переносимого PDB-файла для массива данных.</summary>
      <param name="image">Образ переносимого PDB-файла.</param>
      <returns>Новый поставщик метаданных переносимого PDB-файла.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Создает поставщик для потока указанного размера, начиная с его текущей позиции.</summary>
      <param name="stream">Поток.</param>
      <param name="options">Параметры, которые определяют способ считывания разделов образа из потока.</param>
      <param name="size">Размер BLOB-объекта метаданных в потоке. Если не указан, предполагается, что размер BLOB-объекта метаданных достигает конца потока.</param>
      <returns>Экземпляр <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> не поддерживает операции чтения и поиска.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Размер является отрицательным или превышает длину потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Получает <see cref="T:System.Reflection.Metadata.MetadataReader" /> из <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
      <param name="options">Битовая комбинация значений перечисления, которые определяют конфигурацию при чтении метаданных.</param>
      <param name="utf8Decoder">Используемая кодировка.</param>
      <returns>Экземпляр <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
      <exception cref="T:System.ArgumentException">Кодировка <paramref name="utf8Decoder" /> не является <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.ObjectDisposedException">Поставщик был удален.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>По умолчанию при удалении объекта <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> поток удаляется и разделы образа PE считываются в отложенном режиме.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>Сохраняет поток открытым при удалении объекта <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>Считывает метаданные PDB в память немедленно.
После создания <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> базовый файл может быть закрыт и даже удален. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> автоматически закрывает поток, когда конструктор возвращает управление, если не указан параметр <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>Предоставляет вспомогательные методы сравнения строк для запроса строк в метаданных, по возможности избегая выделения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>Предоставляет объект <see cref="T:System.Reflection.Metadata.MetadataReader" /> с пользовательским механизмом для декодирования последовательностей байтов в метаданных, представляющих текст.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> с использованием заданной кодировки.</summary>
      <param name="encoding">Используемая кодировка.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>Возвращает декодер по умолчанию, используемый объектом <see cref="T:System.Reflection.Metadata.MetadataReader" /> для расшифровки формата UTF-8, если декодер не указан в конструкторе.</summary>
      <returns>Декодер по умолчанию, используемый <see cref="T:System.Reflection.Metadata.MetadataReader" /> для декодирования UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>Возвращает кодировку, используемую этим экземпляром.</summary>
      <returns>Кодировка, используемая этим экземпляром.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>Получает строки для последовательностей байтов в метаданных. Переопределите, если необходимо кэшировать строки. В противном случае реализация будет выполнять переадресацию непосредственно в <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> и выделять новую строку для каждого вызова.</summary>
      <param name="bytes">Указатель на декодируемые байты.</param>
      <param name="byteCount">Число декодируемых байтов.</param>
      <returns>Декодированная строка.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>Возвращает размер тела метода, включая области заголовка, промежуточного языка и исключения.</summary>
      <returns>Размер тела метода.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>Предоставляет отладочную информацию, связанную с определением метода. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>Возвращает дескриптор отдельного документа, содержащий все точки последовательности метода.</summary>
      <returns>Маркер одного документа, содержащего все точки последовательности метода, или маркер, свойство <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> которого имеет значение <see langword="true" />, если метод не имеет точек следования или охватывает несколько документов.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>Возвращает коллекцию точек последовательности, декодированную из <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.</summary>
      <returns>Коллекция точек последовательности.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>Возвращает начальный метод конечного автомата.</summary>
      <returns>Начальный метод конечного автомата, если это метод <c>MoveNext</c> конечного автомата. В противном случае возвращает дескриптор, свойство <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> которого равно <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>Возвращает дескриптор локальной сигнатуры.</summary>
      <returns>Локальный обработчик сигнатур или обработчик, свойство <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> которого имеет значение <see langword="true" />, если метод не определяет никакие локальные переменные.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>Возвращает BLOB-объект, кодирующий точки последовательности.</summary>
      <returns>Точки последовательности кодирования BLOB-объектов или маркер, свойство <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> которого имеет значение <see langword="true" />, если у метода нет точек следования.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>Возвращает дескриптор в <see cref="T:System.Reflection.Metadata.MethodDefinition" />, соответствующий этому дескриптору.</summary>
      <returns>Дескриптор определения метода, соответствующий этому дескриптору.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>Возвращает дескриптор в <see cref="T:System.Reflection.Metadata.MethodDebugInformation" />, соответствующий этому дескриптору.</summary>
      <returns>Дескриптор отладочной информации метода, соответствующий этому дескриптору.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>Представляет метод (определение, ссылку и автономный) или сигнатуру свойства. В случае свойств сигнатура соответствует методу получения с отличительным заголовком <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <typeparam name="TType">Тип метода.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> с использованием заданных сведений о заголовке, типе возвращаемого значения и параметре.</summary>
      <param name="header">Сведения в начальном байте сигнатуры (вид, соглашение о вызовах, флаги).</param>
      <param name="returnType">Тип возвращаемых данных метода.</param>
      <param name="requiredParameterCount">Число обязательных параметров.</param>
      <param name="genericParameterCount">Число параметров универсального типа.</param>
      <param name="parameterTypes">Типы параметров.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>Получает число параметров универсального типа для метода.</summary>
      <returns>Число параметров универсального типа или 0 для методов, не являющихся универсальными.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>Получает сведения из начального байта сигнатуры (вид, соглашение о вызовах, флаги).</summary>
      <returns>Подпись заголовка.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>Получает типы параметров метода.</summary>
      <returns>Неизменяемая Коллекция типов параметров.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>Получает число необходимых для метода параметров.</summary>
      <returns>Число обязательных параметров.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>Получает возвращаемый тип метода.</summary>
      <returns>Тип возвращаемого значения.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>Возвращает дескриптор <see langword="MethodDef" /> или <see langword="MemberRef" />, указывая, на какой универсальный метод ссылается этот экземпляр (то есть экземпляром какого универсального метода он является).</summary>
      <returns>
        <see langword="MethodDef" /> или <see langword="MemberRef" />ный обработчик, указывающий, к какому универсальному методу относится этот экземпляр.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>Возвращает дескриптор в BLOB-объект сигнатуры.</summary>
      <returns>Маркер для большого двоичного объекта сигнатуры.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>Получает все экспортированные типы, которые находятся непосредственно в пространстве имен.</summary>
      <returns>Неизменяемый массив экспортируемых дескрипторов типа.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>Получает неполное имя определения пространства имен.</summary>
      <returns>Неполное имя определения пространства имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>Получает определения пространств имен, которые являются прямыми потомками текущего определения пространства имен.</summary>
      <returns>Неизменяемый массив определений пространств имен, которые являются прямыми дочерними элементами текущего определения пространства имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>Получает родительское пространство имен.</summary>
      <returns>Родительское пространство имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>Получает все определения типов, которые находятся непосредственно в пространстве имен.</summary>
      <returns>Неизменяемый массив дескрипторов определения типа.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>Предоставляет дескриптор для определения пространства имен.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>Содержит коллекцию параметров указанного метода.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>Получает <see cref="T:System.Reflection.Metadata.MetadataReader" /> из <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <returns>Средство чтения метаданных.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Возвращает модуль чтения метаданных с заданной конфигурацией чтения метаданных из <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="options">Значение перечисления, указывающее конфигурацию чтения метаданных.</param>
      <returns>Модуль чтения метаданных с заданной конфигурацией чтения метаданных.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Возвращает модуль чтения метаданных с заданной конфигурацией чтения метаданных и конфигурацией кодировки из <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="options">Значение перечисления, указывающее конфигурацию чтения метаданных.</param>
      <param name="utf8Decoder">Декодер строк метаданных с конфигурацией кодировки.</param>
      <returns>&gt;Модуль чтения метаданных с заданной конфигурацией чтения метаданных и конфигурацией кодировки.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Кодировка <paramref name="utf8Decoder" /> не является <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>Возвращает блок тела метода с указанным относительным виртуальным адресом.</summary>
      <param name="peReader">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="relativeVirtualAddress">Относительный виртуальный адрес.</param>
      <returns>Экземпляр блока тела метода.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException">Тело не найдено в метаданных или является недопустимым.</exception>
      <exception cref="T:System.InvalidOperationException">Раздел, где хранится метод, недоступен.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>Задает константы, определяющие коды типов, используемые для кодирования типов значений-примитивов в BLOB-объекте значений <see cref="T:System.Reflection.Metadata.CustomAttribute" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>Тип <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>Тип 1-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>Тип <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>Тип 8-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>Тип 2-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>Тип 4-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>Тип 8-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>Тип 1-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>Тип 4-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>Тип <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>Тип 2-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>Тип 4-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>Тип 8-байтового целого числа без знака.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>Задает константы, определяющие обнаруженные в сигнатурах метаданных типы-примитивы.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>Тип <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>Тип <see cref="T:System.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>Тип <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>Тип <see cref="T:System.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>Тип <see cref="T:System.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>Тип <see cref="T:System.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>Тип <see cref="T:System.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>Тип <see cref="T:System.IntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>Тип <see cref="T:System.Object" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>Тип <see cref="T:System.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>Тип <see cref="T:System.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>Тип <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>Типизированная ссылка.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>Тип <see cref="T:System.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>Тип <see cref="T:System.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>Тип <see cref="T:System.UInt64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>Тип <see cref="T:System.UIntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>Тип <see cref="T:System.Void" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>Представляет маркер и соответствующий BLOB-объект в куче метаданных, которая была зарезервирована для обновления содержимого в будущем.</summary>
      <typeparam name="THandle" />
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>Возвращает <see cref="T:System.Reflection.Metadata.BlobWriter" />, используемый для обновления содержимого.</summary>
      <returns>Модуль записи BLOB-объектов, используемый для обновления содержимого.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>Возвращает дескриптор зарезервированных BLOB-объектов.</summary>
      <returns>Зарезервированный маркер блока.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>Указывает коды типов, используемые для шифрования типов значений в BLOB-объекте <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>Аргумент атрибута — это экземпляр перечисления.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>Аргумент атрибута "упаковывается" (передается параметру, полю или свойству объекта типа) и содержит информацию о типе в BLOB-объекте атрибута.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>Аргумент атрибута — это экземпляр <see cref="T:System.Type" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>Задает дополнительные флаги, которые можно применить к сигнатурам метода. Базовые значения полей в этом типе соответствуют представлению в начальном байте сигнатуры, представленном структурой <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>Указывает на первый явным образом объявленный параметр, представляющий указатель на экземпляр.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>Универсальный метод.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>Метод экземпляра.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>Флаги отсутствуют.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>Указывает, как передаются аргументы в данной сигнатуре из вызывающего объекта в вызываемый. Базовые значения полей в этом типе соответствуют представлению в начальном байте сигнатуры, представленном структурой <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>Неуправляемое соглашение о вызовах в стиле C/C++, где стек вызовов очищается вызывающим объектом.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>Управляемое соглашение о вызовах со списком аргументов фиксированной длины.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>Неуправляемое соглашение о вызовах, в котором аргументы по возможности передаются в регистры.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>Неуправляемое соглашение о вызовах, где стек вызовов очищается вызываемым объектом.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>Неуправляемое соглашение о вызовах в стиле C/C++ для вызова функций элемента экземпляра с фиксированным списком аргументов.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>Управляемое соглашение о вызовах для передачи дополнительных аргументов.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>Представляет характеристики сигнатуры, заданные начальным байтом BLOB-объектов сигнатуры.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.SignatureHeader" /> с использованием заданного байтового значения.</summary>
      <param name="rawValue">Тип byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.SignatureHeader" /> с помощью указанного типа сигнатуры и атрибутов соглашения о вызовах и сигнатуры.</summary>
      <param name="kind">Тип сигнатуры.</param>
      <param name="convention">Соглашение о вызовах.</param>
      <param name="attributes">Атрибуты сигнатуры.</param>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>Получает атрибуты сигнатуры.</summary>
      <returns>Атрибуты.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>Получает соглашение о вызовах.</summary>
      <returns>Соглашение о вызовах.</returns>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>Получает значение маски для типа соглашения о вызовах или сигнатуры. Значение <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> по умолчанию — 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>Сравнивает заданный объект с этим <see cref="T:System.Reflection.Metadata.SignatureHeader" /> на равенство.</summary>
      <param name="obj">Объект для сравнения.</param>
      <returns>Значение <see langword="true" />, если объекты равны, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>Сравнивает два значения <see cref="T:System.Reflection.Metadata.SignatureHeader" /> на предмет их равенства.</summary>
      <param name="other">Значение для сравнения.</param>
      <returns>Значение <see langword="true" />, если значения равны; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>Получает хэш-код для текущего объекта.</summary>
      <returns>Хэш-код для текущего объекта.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>Получает значение, указывающее, имеет ли эта структура <see cref="T:System.Reflection.Metadata.SignatureHeader" /> атрибут сигнатуры <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />.</summary>
      <returns>
        <see langword="true" />значение , <see langword="false" /> если атрибут имеется; в противном случае —. <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>Получает значение, указывающее, имеет ли эта структура <see cref="T:System.Reflection.Metadata.SignatureHeader" /> атрибут сигнатуры <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />.</summary>
      <returns>
        <see langword="true" />значение , <see langword="false" /> если атрибут имеется; в противном случае —. <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>Получает значение, указывающее, имеет ли эта структура <see cref="T:System.Reflection.Metadata.SignatureHeader" /> атрибут сигнатуры <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />.</summary>
      <returns>
        <see langword="true" />значение , <see langword="false" /> если атрибут имеется; в противном случае —. <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>Получает тип сигнатуры.</summary>
      <returns>Тип сигнатуры.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Сравнивает два значения <see cref="T:System.Reflection.Metadata.SignatureHeader" /> на предмет их равенства.</summary>
      <param name="left">Первое сравниваемое значение.</param>
      <param name="right">Второе сравниваемое значение.</param>
      <returns>Значение <see langword="true" />, если значения равны; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Определяет неравенство двух значений <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="left">Первое сравниваемое значение.</param>
      <param name="right">Второе сравниваемое значение.</param>
      <returns>Значение <see langword="true" />, если значения неравны; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>Получает необработанное значение заголовка byte.</summary>
      <returns>Необработанное значение байта заголовка.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>Возвращает строку, представляющую текущий объект.</summary>
      <returns>Строка, представляющая текущий объект.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>Задает вид сигнатуры. Базовые значения полей в этом типе соответствуют представлению в начальном байте сигнатуры, представленном структурой <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>Сигнатура поля.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>Сигнатура локальных переменных.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>Сигнатура ссылки на метод, определения метода или автономного метода.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>Сигнатура спецификации метода.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>Сигнатура свойства.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>Задает константы, определяющие коды типов, используемые в шифровании сигнатур.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>Представляет обобщенный <see cref="T:System.Array" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>Представляет <see cref="T:System.Boolean" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>Представляет управляемые указатели (возвращаемые значения и параметры ByRef) в сигнатурах. За ним в BLOB-объекте следует кодировка сигнатуры базового типа.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>Представляет <see cref="T:System.Byte" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>Представляет <see cref="T:System.Char" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>Представляет <see cref="T:System.Double" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>Представляет типы указателей функции в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>Представляет параметр универсального метода, используемый в сигнатуре.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>Представляет экземпляр универсального типа в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>Представляет параметр универсального типа, используемый в сигнатуре.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>Представляет <see cref="T:System.Int16" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>Представляет <see cref="T:System.Int32" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>Представляет <see cref="T:System.Int64" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>Представляет <see cref="T:System.IntPtr" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>Представляет недопустимый или неинициализированный код типа. В допустимых сигнатурах не отображается.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>Представляет <see cref="T:System.Object" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>Представляет пользовательский модификатор, примененный к типу в сигнатуре, которую вызывающий объект может игнорировать.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>Представляет локальную переменную, которая закреплена сборщиком мусора.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>Представляет неуправляемый указатель в сигнатурах. За ним в BLOB-объекте следует кодировка сигнатуры базового типа.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>Представляет пользовательский модификатор, примененный к типу в сигнатуре, которую вызывающий объект обязан понять.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>Представляет <see cref="T:System.SByte" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>Представляет маркер для обозначения конца фиксированных аргументов и начала переменных аргументов.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>Представляет <see cref="T:System.Single" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>Представляет <see cref="T:System.String" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>Представляет одномерный <see cref="T:System.Array" /> с нижней границей, равной 0.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>Представляет типизированную ссылку в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>Предшествует типу <see cref="T:System.Reflection.Metadata.EntityHandle" /> в сигнатурах. В необработанных метаданных кодируется как ELEMENT_TYPE_CLASS (0x12) для ссылочных типов или ELEMENT_TYPE_VALUETYPE (0x11) для типов значений. Сворачивается до одного фрагмента кода, так как проекции среды выполнения Windows могут проецировать из класса в тип значения и наоборот, и необработанный код в таких случаях вводит в заблуждение.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>Представляет <see cref="T:System.UInt16" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>Представляет <see cref="T:System.UInt32" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>Представляет <see cref="T:System.UInt64" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>Представляет <see cref="T:System.UIntPtr" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>Представляет <see cref="T:System.Void" /> в сигнатурах.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>Указывает определение типа сигнатуры.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>Определение типа или ссылка относится к классу.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>В текущем контексте неизвестно, является ли ссылка на тип или определение классом или типом значения.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>Определение типа или ссылка относится к типу значения.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>Определяет тип сигнатуры, которая может быть <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> или <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />.</summary>
      <returns>Значение перечисления, указывающее тип сигнатуры.</returns>
      <exception cref="T:System.BadImageFormatException">Сигнатура недопустима.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>Возвращает дескриптор в BLOB-объект сигнатуры.</summary>
      <returns>Маркер для большого двоичного объекта сигнатуры.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>Указывает, представляет ли <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> сигнатуру изолированного метода или локальной переменной.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> ссылается на сигнатуру локальной переменной.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> представляет сигнатуру изолированного метода.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>Возвращает базовый тип определения типа: <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns>Базовый тип определения типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>Возвращает включающий тип заданного вложенного типа.</summary>
      <returns>Включающий тип заданного вложенного типа или дескриптор, свойство <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> которого равно <see langword="true" />, если тип не является вложенным.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>Возвращает массив типов, вложенных в указанный тип.</summary>
      <returns>Неизменяемый массив дескрипторов определения типа, которые представляют типы, вложенные в указанный тип.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>Возвращает значение, указывающее, является ли этот тип вложенным.</summary>
      <returns>
        <see langword="true" />значение, <see langword="false" /> если это вложенный тип; в противном случае —.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>Получение имени типа.</summary>
      <returns>Имя типа.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>Возвращает полное имя пространства имен, где определен тип.</summary>
      <returns>Полное имя пространства имен, в котором определен тип, или маркер, свойство которого <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> имеет <see langword="true" /> значение, если тип является вложенным или определен в корневом пространстве имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>Возвращает дескриптор определения пространства имен, где определен тип.</summary>
      <returns>Описатель определения пространства имен, в котором определен тип, или маркер, свойство которого <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> имеет <see langword="true" /> значение, если тип является вложенным или определен в корневом пространстве имен.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>Содержит коллекцию экземпляров класса <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>Возвращает имя типа целевого объекта.</summary>
      <returns>Имя типа целевого объекта.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>Возвращает полное имя пространства имен, где определен тип целевого объекта.</summary>
      <returns>Полное имя пространства имен, в котором определен целевой тип, или маркер, свойство <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> которого имеет значение <see langword="true" />, если тип является вложенным или определен в корневом пространстве имен,</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>Возвращает область разрешения, в которой тип целевого объекта определен и однозначно идентифицируется указанными <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> и <see cref="P:System.Reflection.Metadata.TypeReference.Name" />.</summary>
      <returns>Область разрешения, в которой тип целевого объекта определен уникальным образом.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>Содержит коллекцию экземпляров класса <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>Представляет дескриптор для кучи пользовательских строк.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>Используется для добавления обработчика для события. Соответствует флагу <see langword="AddOn" /> в спецификации CLI Ecma 335.
CLS-совместимые методы добавления имеют префикс <see langword="add_" />.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>Считывает значение свойства.
Имена CLS-совместимых методов получения имеют префикс `get_`.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>Другой метод для свойства (не метод получения или задания) или события (не метод добавления, удаления или порождения).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>Используется для указания на произошедшее событие. Соответствует флагу <see langword="Fire" /> в спецификации CLI Ecma 335.
 Имена CLS-совместимых методов порождения имеют префикс <see langword="raise_" />.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>Используется для удаления обработчика для события. Соответствует флагу <see langword="RemoveOn" /> в спецификации CLI Ecma 335.
Имена CLS-совместимых методов удаления имеют префикс <see langword="remove_" />.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>Используется для изменения значения свойства.
Имена CLS-совместимых методов задания имеют префикс <see langword="set_" />.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>Предоставляет сведения о файле базы данных отладки программы (PDB).</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>Итерация PDB-файла. Первая итерация — 1. Итерация увеличивается каждый раз, когда содержимое PDB-файла дополняется.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>Глобальный уникальный идентификатор (GUID) связанного PDB-файла.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>Путь к PDB-файлу, который содержит отладочную информацию для файла PE/COFF.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>Представляет заголовок COFF-файла.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>Возвращает флаги, указывающие атрибуты файла.</summary>
      <returns>Флаги, указывающие атрибуты файла.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>Возвращает тип целевого компьютера.</summary>
      <returns>Тип целевого компьютера.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>Возвращает количество разделов. Указывает размер таблицы разделов, которая сразу же следует за заголовками.</summary>
      <returns>Количество разделов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>Возвращает число записей в таблице символов. Эти данные можно использовать для размещения таблицы строк, которая сразу же следует за таблицей символов. Для PE-образа это значение должно быть равно нулю.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>Возвращает указатель файла на таблицу символов COFF.</summary>
      <returns>Указатель файла на таблицу символов COFF или нуль, если таблица символов COFF отсутствует. Для PE-образа это значение должно быть равно нулю.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>Возвращает размер необязательного заголовка, который необходим для исполняемых файлов, но не для объектных файлов. Для объектного файла это значение должно быть равно нулю.</summary>
      <returns>Размер необязательного заголовка.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>Возвращает значение, указывающее, когда был создан файл.</summary>
      <returns>Младшие 32 бита количества секунд с 00:00 1 января 1970, которое указывает на момент создания файла.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>Добавляет запись CodeView.</summary>
      <param name="pdbPath">Путь к PDB-файлу. Не должен быть пустым.</param>
      <param name="pdbContentId">Уникальный идентификатор содержимого PDB-файла.</param>
      <param name="portablePdbVersion">Версия формата переносимого PDB-файла (например, 0x0100 для версии 1.0) или значение 0, если PDB-файл не является переносимым.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> содержит символ NUL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="portablePdbVersion" /> меньше 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>Добавляет запись внедренного переносимого PDB-файла.</summary>
      <param name="debugMetadata">Построитель метаданных переносимого PDB-файла.</param>
      <param name="portablePdbVersion">Версия формата переносимого PDB-файла (например, 0x0100 для версии 1.0).</param>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="debugMetadata" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="portablePdbVersion" /> меньше 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>Добавляет запись указанного типа.</summary>
      <param name="type">Тип записи.</param>
      <param name="version">Версия записи.</param>
      <param name="stamp">Метка записи.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>Добавляет запись указанного типа и сериализует ее данные.</summary>
      <param name="type">Тип записи.</param>
      <param name="version">Версия записи.</param>
      <param name="stamp">Метка записи.</param>
      <param name="data">Данные, передаваемые в <paramref name="dataSerializer" />.</param>
      <param name="dataSerializer">Сериализатор для сериализации данных в <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
      <typeparam name="TData">Тип данных, передаваемых в <paramref name="dataSerializer" />.</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Добавляет запись контрольной суммы PDB.</summary>
      <param name="algorithmName">Имя хэш-алгоритма (например, SHA256).</param>
      <param name="checksum">Контрольная сумма.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="algorithmName" /> или <paramref name="checksum" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="algorithmName" /> или <paramref name="checksum" /> является пустым.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>Добавляет воспроизводимую запись.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>Определяет расположение, размер и формат блока отладочной информации.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>Возвращает указатель файла на данные отладки.</summary>
      <returns>Указатель файла на данные отладки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>Возвращает адрес данных отладки при загрузке относительно базового адреса образа.</summary>
      <returns>Адрес отладочных данных относительно базы образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>Возвращает размер данных отладки (не включая сам каталог отладки).</summary>
      <returns>Размер данных отладки (за исключением каталога отладки).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>Возвращает значение, определяющее, является ли запись записью <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" />, указывающей на переносимый PDB-файл.</summary>
      <returns>
        <see langword="true" />, если запись является записью <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" />, указывающей на переносимый PDB; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>Возвращает основной номер версии для формата данных отладки.</summary>
      <returns>Основной номер версии формата данных отладки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>Возвращает дополнительный номер версии для формата данных отладки.</summary>
      <returns>Дополнительный номер версии формата данных отладки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>Возвращает время и дату создания данных отладки, если файл PE/COFF не является детерминированным; в противном случае возвращает значение в соответствии с хэшем содержимого.</summary>
      <returns>для недетерминированного PE-или COFF-файла — время и Дата создания данных отладки; в противном случае — значение, основанное на хэш-значении содержимого.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>Возвращает формат отладочной информации.</summary>
      <returns>Формат отладочной информации.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType" />
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>Описание связанного PDB-файла.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>Отладочная информация COFF (номера строк, таблица символов и таблица строк). На отладочную информацию этого типа также указывают поля в заголовках файлов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>Запись указывает на большой двоичный объект, содержащий внедренный переносимый PDB-файл. Большой двоичный объект с внедренным переносимым PDB-файлом имеет следующий формат:- blob ::= uncompressed-size dataДанные содержатся в остальной части большого двоичного объекта. Они представляют собой сжатый алгоритмом Deflate переносимый PDB-файл.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>В записи хранится хэш шифрования для содержимого файла символов, с использованием которого был создан PE- или COFF-файл. Хэш можно использовать для проверки того, что данный PDB-файл был создан с использованием PE- или COFF-файла и не был изменен каким-либо образом. Если во время сборки PE- или COFF-файла было создано несколько PDB-файлов (например, с закрытыми и открытыми символами), записей также может быть несколько.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>Наличие этой записи указывает на детерминированный PE- или COFF-файл. Дополнительные сведения см. в разделе "Примечания".</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>Неизвестное значение, которое должно игнорироваться всеми средствами.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>Описывает характеристики библиотеки динамической компоновки.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>Образ должен выполняться внутри AppContainer.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>Библиотека DLL может быть перемещена.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>Образ может работать с 64-битным виртуальным адресным пространством с высокой энтропией.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>Не привязывайте этот образ.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>Он поддерживает изоляцию, поэтому привязка не требуется.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>Образ не использует структурированную обработку исключений (SEH). В этом образе не может быть структурированного обработчика исключений.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>Образ совместим с NX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>Образ поддерживает сервер терминалов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>Драйвер использует модель WDM.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>Указывает архитектуру ЦП целевого компьютера.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>Байтовый код EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>MIPS с FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>MIPS16 с FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>Целевой ЦП неизвестен или не указан.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>WCE версии 2 MIPS с прямым порядком байтов.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId},System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags)">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="deterministicIdProvider" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>Представляет запись каталога отладки для контрольной суммы PDB-файла.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>Имя хэш-алгоритма шифрования, используемого для вычисления контрольной суммы.</summary>
      <returns>Строка, представляющая имя хэш-алгоритма шифрования, используемого для вычисления контрольной суммы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>Контрольная сумма содержимого PDB-файла.</summary>
      <returns>Неизменяемый массив байтов, представляющий контрольную сумму содержимого PDB.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>Создает каталоги PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>Инициализирует экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>Адрес точки входа относительно базового адреса образа при загрузке PE-файла в память.</summary>
      <returns>Для образов программ это начальный адрес. Для драйверов устройств это адрес функции инициализации. Точка входа является необязательной для библиотек DLL. Если отсутствует точка входа, это поле должно быть равно нулю.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>Запись каталога с образом таблицы перемещений базового адреса.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>Запись каталога со связанным образом импорта.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>Запись каталога с образом архитектуры и сведений об авторских правах.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>Запись каталога с образом таблицы дескрипторов COM.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>Запись каталога с образом таблицы отладки.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>Запись каталога с образом таблицы отложенного импорта.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>Запись каталога с образом таблицы исключений.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>Запись каталога с образом таблицы экспорта.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>Запись каталога с образом таблицы глобальных указателей.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>Запись каталога с образом адресной таблицы импорта.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>Запись каталога с образом таблицы импорта.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>Запись каталога с образом таблицы конфигурации загрузки.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>Запись каталога с образом таблицы ресурсов.</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>Запись каталога с образом локальной по отношению к потоку таблицы (TLS).</summary>
      <returns>Экземпляр записи каталога.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>Возвращает адрес точки входа относительно базового адреса образа при загрузке PE-файла в память.</summary>
      <returns>Адрес точки входа относительно базы изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>Возвращает адрес раздела начала кода относительно базового адреса образа при загрузке образа в память.</summary>
      <returns>Адрес раздела начала кода относительно базы образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>Возвращает адрес раздела начала данных относительно базового адреса образа при загрузке образа в память.</summary>
      <returns>Адрес раздела начала данных относительно базы образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>Возвращает запись таблицы сертификатов, указывающую на таблицу сертификатов атрибутов.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>Возвращает контрольную сумму файла образа.</summary>
      <returns>Контрольная сумма файла образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>Возвращает коэффициент выравнивания (в байтах), используемый для выравнивания необработанных данных разделов в файле образа.</summary>
      <returns>Степень 2 в диапазоне от 512 до 64K включительно. Значение по умолчанию — 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>Возвращает предпочтительный адрес первого байта образа при его загрузке в память.</summary>
      <returns>Предпочтительный адрес, который является кратным 64 КБ.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>Возвращает значение, указывающее формат файла образа.</summary>
      <returns>Формат файла изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>Возвращает основной номер версии образа.</summary>
      <returns>Основной номер версии образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>Возвращает основной номер версии компоновщика.</summary>
      <returns>Основной номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>Возвращает основной номер версии требуемой операционной системы.</summary>
      <returns>Основной номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>Возвращает основной номер версии подсистемы.</summary>
      <returns>Основной номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>Возвращает дополнительный номер версии образа.</summary>
      <returns>Дополнительный номер версии образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>Возвращает дополнительный номер версии компоновщика.</summary>
      <returns>Дополнительный номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>Возвращает дополнительный номер версии требуемой операционной системы.</summary>
      <returns>Дополнительный номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>Возвращает дополнительный номер версии подсистемы.</summary>
      <returns>Дополнительный номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>Возвращает число записей каталога данных в оставшейся части <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Каждая из них описывает расположение и размер.</summary>
      <returns>Число записей каталога данных в оставшейся части <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>Возвращает выравнивание разделов (в байтах) при их загрузке в память.</summary>
      <returns>Число, которое больше или равно <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" />. Значением по умолчанию является размер страницы для архитектуры.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>Возвращает размер раздела кода (текста) или сумму всех разделов кода, если имеется несколько разделов.</summary>
      <returns>Размер раздела кода (текст) или сумма всех разделов кода, если имеется несколько разделов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>Возвращает общий размер заглушки MS DOS, заголовка PE и заголовков разделов, округленный до числа, кратного FileAlignment.</summary>
      <returns>Объединенный размер заголовков MS DOS, заголовка PE и разделов, округленных до кратного числа FileAlignment.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>Возвращает размер фиксируемого пространства в локальной куче.</summary>
      <returns>Размер пространства локальной кучи для фиксации.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>Возвращает размер резервируемого пространства в локальной куче. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns>Размер резервируемого пространства в локальной куче.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>Возвращает размер образа (в байтах), включая все заголовки, при его загрузке в память.</summary>
      <returns>Размер изображения (в байтах), кратного <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>Возвращает размер инициализированного раздела данных или сумму всех таких разделов, если имеется несколько разделов данных.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>Возвращает размер фиксируемого стека.</summary>
      <returns>Размер фиксируемого стека.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>Возвращает размер резервируемого стека. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns>Размер резервируемого стека.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>Возвращает размер неинициализированного раздела данных (BSS) или сумму всех таких разделов, если имеется несколько разделов BSS.</summary>
      <returns>Размер неинициализированного раздела данных (BSS) или сумма всех таких разделов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>Возвращает имя подсистемы, необходимой для выполнения этого образа.</summary>
      <returns>Имя подсистемы, необходимой для запуска этого образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>Определяет заголовок переносимого исполняемого файла (PE).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</summary>
      <param name="machine">Архитектура ЦП целевого компьютера.</param>
      <param name="sectionAlignment">Выравнивание разделов (в байтах) при загрузке в память. Должно быть больше или равно <paramref name="fileAlignment" />. Значением по умолчанию является размер страницы для архитектуры.</param>
      <param name="majorSubsystemVersion">Основной номер версии подсистемы.</param>
      <param name="minorSubsystemVersion">Дополнительный номер версии подсистемы.</param>
      <param name="subsystem">Подсистема, необходимая для выполнения образа.</param>
      <param name="dllCharacteristics">Объект, описывающий характеристики библиотеки динамической компоновки.</param>
      <param name="imageCharacteristics">Объект, описывающий характеристики образа.</param>
      <param name="sizeOfStackReserve">Размер резервируемого стека. Фиксируется только <paramref name="sizeOfStackCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</param>
      <param name="sizeOfStackCommit">Размер фиксируемого стека.</param>
      <param name="sizeOfHeapReserve">Размер резервируемого пространства в локальной куче. Фиксируется только <paramref name="sizeOfHeapCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</param>
      <param name="sizeOfHeapCommit">Размер фиксируемого пространства в локальной куче.</param>
      <param name="fileAlignment">Коэффициент выравнивания (в байтах), используемый для выравнивания необработанных данных разделов в файле образа. Значение должно быть степенью числа 2 в диапазоне от 512 до 64 000 включительно. Значение по умолчанию — 512. Если значение <paramref name="sectionAlignment" /> меньше размера страницы для архитектуры, то значение <paramref name="fileAlignment" /> должно совпадать с <paramref name="sectionAlignment" />.</param>
      <param name="imageBase">Предпочтительный адрес первого байта образа при загрузке в память; значение должно быть кратно 64 000.</param>
      <param name="majorLinkerVersion">Основной номер версии компоновщика.</param>
      <param name="minorLinkerVersion">Дополнительный номер версии компоновщика.</param>
      <param name="majorOperatingSystemVersion">Основной номер версии требуемой операционной системы.</param>
      <param name="minorOperatingSystemVersion">Дополнительный номер версии требуемой операционной системы.</param>
      <param name="majorImageVersion">Основной номер версии образа.</param>
      <param name="minorImageVersion">Дополнительный номер версии образа.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="fileAlignment" /> не является степенью числа 2 в диапазоне от 512 до 64 000.

или -

Значение <paramref name="sectionAlignment" /> не является степенью числа 2.

или -

Значение <paramref name="sectionAlignment" /> меньше <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>Создает заголовок исполняемого файла.</summary>
      <returns>Экземпляр <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />, представляющий заголовок исполняемого файла.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>Создает заголовок библиотеки.</summary>
      <returns>Экземпляр <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />, представляющий заголовок библиотеки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>Возвращает характеристики библиотеки динамической компоновки.</summary>
      <returns>Объект, описывающий характеристики библиотеки динамического компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>Коэффициент выравнивания (в байтах), используемый для выравнивания необработанных данных разделов в файле образа. Значение должно быть степенью числа 2 в диапазоне от 512 до 64 000 включительно. Значение по умолчанию — 512. Если выравнивание раздела меньше размера страницы для архитектуры, то выравнивание файла должно совпадать с выравниванием раздела.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>Предпочтительный адрес первого байта образа при загрузке в память; значение должно быть кратно 64 000.</summary>
      <returns>Число, представляющее предпочтительный адрес первого байта изображения, загружаемого в память.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>Возвращает характеристики образа.</summary>
      <returns>Объект, представляющий характеристики изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>Архитектура ЦП целевого компьютера.</summary>
      <returns>Одно из значений перечисления, представляющих различные архитектуры ЦП.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>Основной номер версии образа.</summary>
      <returns>Число <see cref="T:System.UInt16" />, представляющее основной номер версии образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>Основной номер версии компоновщика.</summary>
      <returns>Число, равное размеру <see cref="T:System.Byte" />, представляющему основной номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>Основной номер версии требуемой операционной системы.</summary>
      <returns>Число <see cref="T:System.UInt16" />, представляющее основной номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>Основной номер версии подсистемы.</summary>
      <returns>Число <see cref="T:System.UInt16" />, представляющее основной номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>Дополнительный номер версии образа.</summary>
      <returns>Число <see cref="T:System.UInt16" />, представляющее дополнительный номер версии изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>Дополнительный номер версии компоновщика.</summary>
      <returns>Число, равное размеру <see cref="T:System.Byte" />, представляющему дополнительный номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>Дополнительный номер версии требуемой операционной системы.</summary>
      <returns>Число <see cref="T:System.UInt16" />, представляющее дополнительный номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>Дополнительный номер версии подсистемы.</summary>
      <returns>Число <see cref="T:System.UInt16" />, представляющее дополнительный номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>Выравнивание разделов (в байтах) при загрузке в память.</summary>
      <returns>Число, представляющее выравнивание (в байтах) разделов при их загрузке в память. Оно должно быть больше или равно выравниванию файла. Значением по умолчанию является размер страницы для архитектуры.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>Размер фиксируемого пространства в локальной куче.</summary>
      <returns>Число, представляющее размер пространства локальной кучи для фиксации.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>Размер резервируемого пространства в локальной куче. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns>Число, представляющее размер пространства локальной кучи для резервирования.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>Размер фиксируемого стека.</summary>
      <returns>Число, представляющее размер стека для фиксации.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>Размер резервируемого стека. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns>Число, представляющее размер стека для резервирования.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>Подсистема, необходимая для выполнения этого образа.</summary>
      <returns>Экземпляр <see cref="T:System.Reflection.PortableExecutable.Subsystem" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>Определяет тип, который считывает заголовки PE и COFF из потока.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>Создает экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />, который считывает заголовки PE из текущего расположения в указанном потоке.</summary>
      <param name="peStream">Поток, содержащий образ PE начиная с текущей позиции потока и заканчивая его концом.</param>
      <exception cref="T:System.BadImageFormatException">Данные, считанные из потока, имеют недопустимый формат.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из потока.</exception>
      <exception cref="T:System.ArgumentException">Поток не поддерживает операции поиска.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>Создает экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />, который считывает заголовки PE из потока, представляющего образ PE указанного размера.</summary>
      <param name="peStream">Поток, содержащий образ PE указанного размера начиная с текущей позиции.</param>
      <param name="size">Размер образа PE.</param>
      <exception cref="T:System.BadImageFormatException">Данные, считанные из потока, имеют недопустимый формат.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из потока.</exception>
      <exception cref="T:System.ArgumentException">Поток не поддерживает операции поиска.</exception>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="peStream" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="size" /> является отрицательным или превышает длину потока.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>Создает экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />, который считывает заголовки PE из потока, представляющего образ PE заданного размера, и указывает, загружен ли образ PE в память.</summary>
      <param name="peStream">Поток, содержащий образ PE указанного размера начиная с текущей позиции.</param>
      <param name="size">Размер образа PE.</param>
      <param name="isLoadedImage">Значение <see langword="true" />, если образ PE был загружен в память загрузчиком ОС; в противном случае значение <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">Данные, считанные из потока, имеют недопустимый формат.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из потока.</exception>
      <exception cref="T:System.ArgumentException">Поток не поддерживает операции поиска.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="size" /> является отрицательным или превышает длину потока.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>Возвращает заголовок COFF образа.</summary>
      <returns>Заголовок COFF изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>Возвращает смещение в байтах от начала образа PE до начала заголовка COFF.</summary>
      <returns>Смещение в байтах от начала образа PE до начала заголовка COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>Возвращает заголовок COR.</summary>
      <returns>Заголовок COR или значение <see langword="null" />, если образ не имеет такого изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>Возвращает смещение в байтах от начала образа до заголовка COR.</summary>
      <returns>Смещение в байтах от начала изображения до заголовка COR или-1, если у изображения нет заголовка COR.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>Ищет среди разделов образа PE раздел, содержащий указанный относительный виртуальный адрес.</summary>
      <param name="relativeVirtualAddress">Искомый относительный виртуальный адрес.</param>
      <returns>Индекс раздела, содержащего <paramref name="relativeVirtualAddress" />, или значение –1, если поиск не дал результатов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>Возвращает значение, указывающее, является ли образ исключительно образом COFF.</summary>
      <returns>
        <see langword="true" />, если образ является только COFF; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>Возвращает значение, указывающее, представляет ли образ консольное приложение Windows.</summary>
      <returns>
        <see langword="true" />, если образ является консольным приложением Windows; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>Возвращает значение, указывающее, представляет ли образ библиотеку динамической компоновки.</summary>
      <returns>
        <see langword="true" />, если образ является библиотекой DLL; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>Возвращает значение, указывающее, представляет ли образ исполняемый файл.</summary>
      <returns>
        <see langword="true" />, если образ является исполняемым файлом; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>Возвращает размер метаданных CLI.</summary>
      <returns>размер метаданных CLI или значение 0, если образ не содержит метаданных.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>Возвращает смещение (в байтах) от начала образа PE до начала метаданных CLI.</summary>
      <returns>Смещение (в байтах) от начала образа PE до начала работы с метаданными CLI или значение-1, если образ не содержит метаданных.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>Возвращает заголовок PE образа.</summary>
      <returns>Заголовок PE изображения или значение <see langword="null" />, если изображение имеет только COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>Возвращает смещение заголовка в байтах от начала образа.</summary>
      <returns>Смещение в байтах заголовка от начала изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>Возвращает заголовки раздела PE.</summary>
      <returns>Массив, содержащий заголовки разделов PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>Возвращает смещение (в байтах) от начала образа до указанных данных каталога.</summary>
      <param name="directory">Запись каталога PE.</param>
      <param name="offset">Когда метод возвращает управление, содержит смещение от начала образа до указанных данных каталога.</param>
      <returns>Значение <see langword="true" />, если данные каталога найдены; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>Считывает содержимое всего блока в массив.</summary>
      <returns>Неизменяемый массив байтов.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>Считывает содержимое части блока в массив.</summary>
      <param name="start">Начальная позиция в блоке.</param>
      <param name="length">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns>Неизменяемый массив байтов.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">В блоке нет указанного диапазона.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>Создает <see cref="T:System.Reflection.Metadata.BlobReader" /> для большого двоичного объекта, охватывающего весь блок.</summary>
      <returns>Средство чтения для большого двоичного объекта, охватывающего весь блок.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>Создает <see cref="T:System.Reflection.Metadata.BlobReader" /> для большого двоичного объекта, охватывающего часть блока.</summary>
      <param name="start">Начальная позиция в блоке.</param>
      <param name="length">Количество байтов в части блока.</param>
      <returns>Средство чтения для большого двоичного объекта, охватывающего часть блока.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">В блоке нет указанного диапазона.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>Возвращает длину блока.</summary>
      <returns>Длина блока.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>Возвращает указатель на первый байт блока.</summary>
      <returns>Указатель на первый байт блока.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>Предоставляет средство чтения для переносимых исполняемых (PE) файлов.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в памяти.</summary>
      <param name="peImage">Указатель на начало образа PE.</param>
      <param name="size">Размер образа PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> — <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в памяти. Флаг указывает, был ли образ уже загружен в память.</summary>
      <param name="peImage">Указатель на начало образа PE.</param>
      <param name="size">Размер образа PE.</param>
      <param name="isLoadedImage">Значение <see langword="true" />, если образ PE был загружен в память загрузчиком ОС; в противном случае значение <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> — <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в массиве байтов.</summary>
      <param name="peImage">Неизменяемый массив байтов, представляющий образ PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в потоке.</summary>
      <param name="peStream">Поток образа PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>Создает средство чтения переносимых исполняемых файлов с использованием образа PE, который хранится в потоке, начиная с его текущей позиции и заканчивая концом потока.</summary>
      <param name="peStream">Поток образа PE.</param>
      <param name="options">Параметры, которые определяют способ считывания разделов образа PE из потока.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Недопустимое значение параметра <paramref name="options" />.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из потока (только при предварительном получении данных).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> указан, а PE-заголовки образа недопустимы.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>Создает средство чтения переносимых исполняемых файлов с использованием образа PE заданного размера, начиная с текущей позиции потока.</summary>
      <param name="peStream">Поток образа PE.</param>
      <param name="options">Параметры, которые определяют способ считывания разделов образа PE из потока.</param>
      <param name="size">Размер образа PE.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="size" /> является отрицательным или превышает длину потока.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из потока (только при предварительном получении данных).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> указан, а PE-заголовки образа недопустимы.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>Удаляет весь объем памяти, выделенный средством чтения.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>Возвращает объект <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" />, содержащий весь образ PE.</summary>
      <returns>Блок памяти, содержащий весь образ PE.</returns>
      <exception cref="T:System.InvalidOperationException">Весь образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>Загружает раздел PE, содержащий метаданные CLI.</summary>
      <returns>Блок памяти, содержащий метаданные CLI.</returns>
      <exception cref="T:System.InvalidOperationException">Образ PE не содержит метаданные (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> возвращает <see langword="false" />).</exception>
      <exception cref="T:System.BadImageFormatException">Заголовки PE содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>Загружает раздел PE, который содержит указанный относительный виртуальный адрес, в память и возвращает блок памяти, который начинается с этого адреса и заканчивается в конце содержащего его раздела.</summary>
      <param name="relativeVirtualAddress">Относительный виртуальный адрес данных для чтения.</param>
      <returns>Блок памяти, начинающийся с <paramref name="relativeVirtualAddress" /> и заканчивающийся в конце содержащего его раздела, или пустой блок, если <paramref name="relativeVirtualAddress" /> не представляет расположение ни в одном из разделов PE этого образа PE.</returns>
      <exception cref="T:System.BadImageFormatException">Заголовки PE содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException">Образ PE недоступен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>Загружает раздел PE с указанным именем в память и возвращает блок памяти, охватывающий этот раздел.</summary>
      <param name="sectionName">Имя раздела.</param>
      <returns>Блок памяти, охватывающий раздел, или пустой блок, если в этом образе PE не существует раздел заданного <paramref name="sectionName" />.</returns>
      <exception cref="T:System.ArgumentNullException">Свойство <paramref name="sectionName" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Образ PE недоступен.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>Возвращает значение, которое указывает, содержит ли образ PE метаданные CLI.</summary>
      <returns>
        <see langword="true" />, если образ PE содержит метаданные CLI; в противном случае <see langword="false" />.</returns>
      <exception cref="T:System.BadImageFormatException">Заголовки PE содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из базового потока.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>Возвращает значение, которое указывает, может ли средство чтения получить доступ ко всему образу PE.</summary>
      <returns>
        <see langword="true" />, если читатель может получить доступ ко всему образу PE; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>Возвращает значение, которое указывает, был ли образ PE загружен в память загрузчиком ОС.</summary>
      <returns>Значение <see langword="true" />, если образ PE был загружен в память загрузчиком ОС; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>Возвращает заголовки PE.</summary>
      <returns>Заголовки PE для этого образа PE.</returns>
      <exception cref="T:System.BadImageFormatException">Заголовки содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException">Ошибка при чтении из потока.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Считывает данные, на которые указывает заданная запись каталога отладки, и интерпретирует их как CodeView.</summary>
      <param name="entry">Экземпляр записи каталога отладки.</param>
      <returns>Экземпляр данных каталога отладки для представления кода.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> не является записью CodeView.</exception>
      <exception cref="T:System.BadImageFormatException">Неправильный формат данных.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>Считывает все записи в таблице каталога отладки.</summary>
      <returns>Массив записей в таблице каталога отладки.</returns>
      <exception cref="T:System.BadImageFormatException">Неправильный формат записи.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Считывает данные, на которые указывает заданная запись каталога отладки, и интерпретирует их как BLOB-объект внедренного переносимого PDB.</summary>
      <param name="entry">Запись каталога отладки, данные которой должны быть считаны.</param>
      <returns>Поставщик средства чтения метаданных для чтения образа переносимого PDB.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> не является записью <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />.</exception>
      <exception cref="T:System.BadImageFormatException">Неправильный формат данных.</exception>
      <exception cref="T:System.InvalidOperationException">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Считывает данные, на которые указывает заданная запись каталога отладки, и интерпретирует их как запись контрольной суммы PDB.</summary>
      <param name="entry">Запись каталога отладки, данные которой должны быть считаны.</param>
      <returns>Запись контрольной суммы PDB.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> не является записью контрольной суммы PDB.</exception>
      <exception cref="T:System.BadImageFormatException">Неправильный формат данных.</exception>
      <exception cref="T:System.IO.IOException">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>Открывает переносимый PDB, связанный с этим образом PE.</summary>
      <param name="peImagePath">Путь к образу PE. Этот путь используется для поиска PDB-файла, который находится в каталоге, содержащем PE-файл.</param>
      <param name="pdbFileStreamProvider">Если указан, вызывается для открытия <see cref="T:System.IO.Stream" /> для заданного пути к файлу. Поставщик должен возвращать либо доступный для чтения и поиска <see cref="T:System.IO.Stream" />, либо значение <see langword="null" />, если целевой файл не существует либо по какой-либо причине должен быть проигнорирован. Поставщик должен выдать <see cref="T:System.IO.IOException" />, если ему не удается открыть файл из-за непредвиденной ошибки ввода-вывода.</param>
      <param name="pdbReaderProvider">В случае успеха новый экземпляр <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> используется для чтения переносимого PDB.</param>
      <param name="pdbPath">Если операция выполнена успешно и PDB найден в файле, путь к файлу, либо <see langword="null" />, если PDB внедрен в сам образ PE.</param>
      <returns>Значение <see langword="true" />, если образ PE имеет связанный с ним PDB, который был успешно открыт; в противном случае значение <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="peImagePath" /> или <paramref name="pdbFileStreamProvider" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Поток, возвращенный из <paramref name="pdbFileStreamProvider" />, не поддерживает операции чтения и поиска.</exception>
      <exception cref="T:System.BadImageFormatException">Соответствующий PDB-файл не найден из-за ошибки: Недопустимый образ PE или PDB.</exception>
      <exception cref="T:System.IO.IOException">Соответствующий PDB-файл не найден из-за ошибки: При чтении образа PE или PDB произошла ошибка ввода-вывода.</exception>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>Предоставляет параметры, определяющие способ считывания разделов образа PE из потока.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>По умолчанию при удалении объекта <see cref="T:System.Reflection.PortableExecutable.PEReader" /> поток удаляется и разделы образа PE считываются в отложенном режиме.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>Указывает, что базовый образ PE был загружен в память загрузчиком ОС.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>Сохраняет поток открытым при удалении объекта <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>Немедленно считывает весь образ в память. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> автоматически закрывает поток, когда конструктор возвращает управление, если не указан параметр <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>Немедленно считывает раздел метаданных в память.Чтение из других разделов файла запрещено (<see cref="T:System.InvalidOperationException" /> выдается <see cref="T:System.Reflection.PortableExecutable.PEReader" />).<see cref="T:System.Reflection.PortableExecutable.PEReader" /> автоматически закрывает поток, когда конструктор возвращает управление, если не указан параметр <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />. После создания <see cref="T:System.Reflection.PortableExecutable.PEReader" /> базовый файл может быть закрыт и даже удален.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>Определяет базовый класс для построителя разделов ресурсов PE. Наследование от <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> для предоставления логики сериализации для собственных ресурсов.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>Сериализует указанный ресурс.</summary>
      <param name="builder">BLOB-объект, содержащий данные для сериализации.</param>
      <param name="location">Расположение, куда следует сериализовать <paramref name="builder" />.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>Предоставляет сведения о заголовке раздела файла PE/COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>Возвращает имя раздела.</summary>
      <returns>Имя раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>Возвращает количество записей номеров строк для раздела.</summary>
      <returns>Число записей номера строки для раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>Возвращает количество записей перемещения для раздела.</summary>
      <returns>Число записей перемещения для раздела. Его значение равно нулю для образов PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>Возвращает указатель файла на начало записей номеров строк для раздела.</summary>
      <returns>Указатель файла на начало записи номера строки для раздела или нуль, если нет номеров строк COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>Возвращает указатель файла на первую страницу раздела в файле COFF.</summary>
      <returns>Указатель файла на первую страницу раздела в COFF-файле.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>Возвращает указатель файла на начало записей перемещения для раздела.</summary>
      <returns>Указатель файла на начало записей перемещения для раздела. Для образов PE задано нулевое значение или если перемещения отсутствуют.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>Возвращает флаги, описывающие характеристики раздела.</summary>
      <returns>Флаги, описывающие характеристики раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>Возвращает размер раздела (для объектных файлов) или размер инициализированных данных на диске (для файлов образов).</summary>
      <returns>Размер раздела (для объектных файлов) или размера инициализированных данных на диске (для файлов изображений).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>Возвращает виртуальный адрес раздела.</summary>
      <returns>Виртуальный адрес раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>Возвращает общий размер раздела при загрузке в память.</summary>
      <returns>Общий размер раздела при загрузке в память.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>Описывает требования к подсистеме для образа.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>Приложение EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>Драйвер EFI со службами загрузки.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>Образ ПЗУ EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>Драйвер EFI со службами среды выполнения.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>Для образа не требуется наличие подсистемы.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>Образ является собственным драйвером Win9x.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>Образ выполняется в подсистеме символов OS/2.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>Образ выполняется в подсистеме символов POSIX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>Неизвестная подсистема.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>Приложение загрузки.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>Образ выполняется в подсистеме Windows CE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>Образ выполняется в подсистеме символов Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>Образ выполняется в подсистеме графического пользовательского интерфейса Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Система Xbox.</summary>
    </member>
  </members>
</doc>