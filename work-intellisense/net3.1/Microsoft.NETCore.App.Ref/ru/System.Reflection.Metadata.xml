<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary vsli:raw="Content type masked bits that correspond to values of &lt;see cref=&quot;T:System.Reflection.AssemblyContentType&quot; /&gt;.">Маскированные биты типа содержимого, соответствующие значениям <see cref="T:System.Reflection.AssemblyContentType" />.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary vsli:raw="Just-In-Time (JIT) compiler optimization is disabled for the assembly.">Для данной сборки отключена оптимизация JIT-компилятора.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary vsli:raw="Just-In-Time (JIT) compiler tracking is enabled for the assembly.">Для данной сборки отключено отслеживание JIT-компилятора.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary vsli:raw="The assembly reference holds the full (unhashed) public key. Not applicable on assembly definition.">Ссылка на сборку содержит полный (не хэшированный) открытый ключ. Неприменимо к определению сборки.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary vsli:raw="The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.">Реализация базовой сборки, используемой в среде выполнения, не должна совпадать с версией, видимой во время компиляции.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary vsli:raw="The assembly contains Windows Runtime code.">Сборка содержит код среды выполнения Windows.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary vsli:raw="Specifies the hash algorithms used for hashing assembly files and for generating the strong name.">Определяет хэш-алгоритмы, используемые для хэширования файлов сборки и создания строгого имени.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary vsli:raw="&lt;para&gt;Retrieves the MD5 message-digest algorithm.&lt;/para&gt;&lt;para&gt;Due to collision problems with MD5, Microsoft recommends SHA256.&lt;/para&gt;&lt;para&gt;MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and, while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.&lt;/para&gt;">Извлекает хэш-алгоритм MD5.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary vsli:raw="&lt;para&gt;A mask indicating that there is no hash algorithm.&lt;/para&gt;&lt;para&gt;If you specify &lt;see cref=&quot;F:System.Reflection.AssemblyHashAlgorithm.None&quot; /&gt; for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.&lt;/para&gt;">Маска, указывающая на отсутствие алгоритма хеширования.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary vsli:raw="&lt;para&gt;Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.&lt;/para&gt;&lt;para&gt;Due to collision problems with SHA1, Microsoft recommends SHA256.&lt;/para&gt;">Извлекает пересмотренный алгоритм SHA, исправляющий неопубликованный дефект в SHA.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.">Извлекает версию алгоритма SHA с размером хэша 256 бит.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.">Извлекает версию алгоритма SHA с размером хэша 384 бит.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.">Извлекает версию алгоритма SHA с размером хэша 512 бит.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary vsli:raw="Specifies the security actions that can be performed using declarative security.">Указывает действия безопасности, которые можно выполнить с помощью декларативной безопасности.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary vsli:raw="The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.">Вызывающий код может получить доступ к ресурсу, который определен текущим объектом разрешения, даже если вызывающие операторы, находящиеся выше в стеке вызовов, не имеют разрешения на доступ к ресурсу.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary vsli:raw="Check that all callers in the call chain have been granted the specified permission.">Убедитесь, что всем вызывающим объектам в цепочке вызовов предоставлено указанное разрешение.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary vsli:raw="Without further checks refuse Demand for the specified permission.">Без дополнительных проверок отклоните требование для указанного разрешения.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary vsli:raw="The derived class inheriting the class or overriding a method is required to have the specified permission.">Производному классу, наследующему класс или переопределяющему метод, требуется предоставить указанное разрешение.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary vsli:raw="Check that the immediate caller has been granted the specified permission.">Убедитесь, что непосредственно вызывающему объекту предоставлено указанное разрешение.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary vsli:raw="No declarative security action.">Нет декларативных действий безопасности.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary vsli:raw="Without further checks, refuse the demand for all permissions other than those specified.">Без дополнительных проверок отклоните требование для всех разрешений, кроме указанных.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary vsli:raw="Request the minimum permissions required for code to run. This action can only be used within the scope of the assembly.">Запрос на минимальный набор разрешений, необходимых для выполнения кода. Это действие может использоваться только в пределах сборки.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary vsli:raw="Request additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly.">Запрос дополнительных разрешений, которые не являются обязательными (не требуются для выполнения). Этот запрос неявно отклоняет все прочие разрешения, не запрошенные специально. Это действие может использоваться только в пределах сборки.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary vsli:raw="Request that permissions that might be misused not be granted to the calling code. This action can only be used within the scope of the assembly.">Запрос на непредоставление вызывающему коду разрешений, которые могут быть неправильно использованы. Это действие может использоваться только в пределах сборки.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary vsli:raw="The resource is not exported from the assembly.">Ресурс не экспортируется из сборки.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary vsli:raw="The resource is exported from the assembly.">Ресурс экспортируется из сборки.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary vsli:raw="Masks just the visibility-related attributes.">Маскирует только атрибуты, связанные с видимостью.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary vsli:raw="Represents the shape of an array type.">Представляет форму типа массива.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ArrayShape&quot; /&gt; structure.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.ArrayShape" />.</summary>
      <param name="rank" vsli:raw="The number of dimensions in the array.">Число измерений в массиве.</param>
      <param name="sizes" vsli:raw="The size of each dimension.">Размер каждого измерения.</param>
      <param name="lowerBounds" vsli:raw="The lower-bound of each dimension.">Нижняя граница каждого измерения.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary vsli:raw="Gets the lower-bounds of all dimensions. Length may be smaller than rank, in which case the trailing dimensions have unspecified lower bounds.">Получает нижние границы всех измерений. Длина может быть меньше, чем ранг, в этом случае нижние границы для конечных измерений не указаны.</summary>
      <returns vsli:raw="An array of lower-bounds.">Массив нижних границ.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary vsli:raw="Gets the number of dimensions in the array.">Получает число измерений в массиве.</summary>
      <returns vsli:raw="The number of dimensions.">Число измерений.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary vsli:raw="Gets the sizes of all dimensions.">Получает размеры всех измерений.</summary>
      <returns vsli:raw="An array of sizes.">Массив размеров.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary vsli:raw="Gets a value that indicates whether the file contains metadata.">Возвращает значение, которое указывает, содержит ли файл метаданные.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the file contains metadata, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, если файл содержит метаданные, в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary vsli:raw="Gets the hash value of the file content calculated using &lt;see cref=&quot;P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm&quot; /&gt;.">Возвращает хэш-значение содержимого файла, вычисленное с использованием <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; instance representing the hash value of the file content.">Экземпляр <see cref="T:System.Reflection.Metadata.BlobHandle" />, представляющий хэш-значение содержимого файла.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary vsli:raw="Gets the file name, including its extension.">Возвращает имя файла, включая расширение.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; instance representing the file name with its extension.">Экземпляр <see cref="T:System.Reflection.Metadata.StringHandle" />, представляющий имя файла с расширением.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;.">Представляет коллекцию <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary vsli:raw="A collection of assembly references.">Набор ссылок на сборки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Compares the current content of this writer with another one.">Сравнивает текущее содержимое данного средства чтения с содержимым другого средства чтения.</summary>
      <param name="other" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; instance to compare with this one.">Экземпляр <see cref="T:System.Reflection.Metadata.BlobBuilder" /> для сравнения с данным экземпляром.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если объекты равны; в противном случае — значение <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary vsli:raw="Returns a sequence of all blobs that represent the content of the builder.">Возвращает последовательность всех больших двоичных объектов, представляющих содержимое построителя.</summary>
      <returns vsli:raw="A sequence of blobs.">Последовательность больших двоичных объектов.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;prefix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="prefix" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;suffix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="suffix" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary vsli:raw="Reserves a contiguous block of bytes.">Резервирует непрерывный блок байтов.</summary>
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Attempts to write a sequence of bytes to the builder. A return value indicates the number of bytes successfully written.">Пытается записать последовательность байтов в построитель. Возвращаемое значение указывает количество успешно записанных байтов.</summary>
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <returns vsli:raw="The number of bytes successfully written from &lt;paramref name=&quot;source&quot; /&gt;.">Количество байтов, успешно записанных из <paramref name="source" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="source" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; value to the builder.">Записывает значение <see cref="T:System.Boolean" /> в построитель.</summary>
      <param name="value" vsli:raw="The value to write.">Значение для записи.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Byte&quot; /&gt; value to the builder.">Записывает значение <see cref="T:System.Byte" /> в построитель.</summary>
      <param name="value" vsli:raw="The value to write.">Значение для записи.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes from a buffer to the builder.">Записывает указанное число байтов из буфера в построитель.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">Количество записываемых байтов.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary vsli:raw="Writes a specified number of occurrences of a byte value to the builder.">Записывает указанное количество экземпляров байтового значения в построитель.</summary>
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of occurences of &lt;paramref name=&quot;value&quot; /&gt; to write.">Число экземпляров <paramref name="value" />, которые требуется записать.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary vsli:raw="Writes the contents of a byte array to the builder.">Записывает содержимое массива байтов в построитель.</summary>
      <param name="buffer" vsli:raw="The byte array to write.">Байтовый массив для записи.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index in a byte array to the builder.">Записывает указанное число байтов, начиная с заданного индекса в массиве байтов, в построитель.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">Количество записываемых байтов.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of &lt;paramref name=&quot;buffer&quot; /&gt;.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Writes the contents of an immutable byte array to the builder.">Записывает содержимое неизменяемого массива байтов в построитель.</summary>
      <param name="buffer" vsli:raw="The array to write.">Записываемый массив.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index of an immutable array to the builder.">Записывает указанное число байтов, начиная с заданного индекса в неизменяемом массиве, в построитель.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">Количество записываемых байтов.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Реализует кодировку сжатого целого числа без знака в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" vsli:raw="The value to write.">Значение для записи.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> невозможно представить как сжатое целое число без знака.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Реализует кодировку сжатого целого числа со знаком в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" vsli:raw="The value to write.">Значение для записи.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> невозможно представить как сжатое целое число со знаком.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">Записывает значение константы (см раздел 22.9 в части II документа ECMA-335) в текущей позиции.</summary>
      <param name="value" vsli:raw="The constant value to write.">Записываемое значение константы.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> не относится к типу константы.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is default (&lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt;).">
        <paramref name="destination" /> используется по умолчанию (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">Содержимое недоступно; построитель связан с другим содержимым.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">Записывает ссылку на кучу (смещение в куче) или таблицу (номер строки).</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">Смещение в куче или номер строки в таблице.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as a 16-bit integer; &lt;see langword=&quot;false&quot; /&gt; to encode it as a 32-bit integer.">
        <see langword="true" /> для кодирования ссылки в виде 16-битного целого числа; <see langword="false" /> для ее кодирования в виде 32-битного целого числа.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">Записывает строку в формате SerString (см. раздел 23.3 "Пользовательские атрибуты" в документе ECMA-335-II).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">Записывает строку в формате кучи User String (#US) (см. раздел 24.2.4 "Кучи #US и #Blob" в документе ECMA-335-II).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded character array at the current position.">Записывает массив символов в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary vsli:raw="Writes UTF16 (little-endian) encoded string at the current position.">Записывает строку в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">Записывает строку в кодировке UTF8 в текущей позиции.</summary>
      <param name="value" vsli:raw="Constant value.">Значение константы.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with a U+FFFD character.">
        <see langword="true" /> для кодирования суррогатов без пары указанным образом; <see langword="false" /> для их замены на символ U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" vsli:raw="" />
      <param name="stamp" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a reader of the specified memory block.">Создает средство чтения указанного блока памяти.</summary>
      <param name="buffer" vsli:raw="A pointer to the start of the memory block.">Указатель на начало блока памяти.</param>
      <param name="length" vsli:raw="Length in bytes of the memory block.">Длина блока памяти в байтах.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; is greater than zero.">
        <paramref name="buffer" /> имеет значение <see langword="null" />, а значение <paramref name="length" /> больше нуля.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is negative.">
        <paramref name="length" /> является отрицательным значением.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is not little-endian.">Текущая платформа не поддерживает прямой порядок байтов.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary vsli:raw="Repositions the reader forward by the number of bytes required to satisfy the given alignment.">Перемещает средство чтения вперед на количество байтов, необходимое в соответствии с заданным выравниванием.</summary>
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary vsli:raw="Gets a pointer to the byte at the current position of the reader.">Возвращает указатель на байт в текущей позиции средства чтения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary vsli:raw="Searches for a specified byte in the blob following the current position.">Ищет указанный байт в большом двоичном объекте после текущей позиции.</summary>
      <param name="value" vsli:raw="The byte value to find.">Искомое значение байта.</param>
      <returns vsli:raw="The index relative to the current position, or -1 if the byte is not found in the blob following the current position.">Индекс относительно текущей позиции или –1, если байт не найден в большом двоичном объекте после текущей позиции.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary vsli:raw="Gets the total length of the underlying memory block.">Возвращает общую длину базового блока памяти.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary vsli:raw="Gets or sets the offset from the start of the blob to the current position.">Возвращает или задает смещение от начала большого двоичного объекта до текущей позиции.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The offset is set outside the bounds of the underlying reader.">Задано смещение за пределами базового средства чтения.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary vsli:raw="Reads a Blob heap handle encoded as a compressed integer.">Считывает дескриптор кучи большого двоичного объекта, закодированный как сжатое целое число.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position.">Считывает байты начиная с текущей позиции.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns vsli:raw="The byte array.">Массив байтов.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position and writes them to the specified buffer starting at the specified offset.">Считывает байты начиная с текущей позиции и записывает их в указанный буфер начиная с заданного смещения.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Количество байтов, чтение которых необходимо выполнить.</param>
      <param name="buffer" vsli:raw="The destination buffer the bytes read will be written to.">Буфер назначения, в который будут записываться считанные байты.</param>
      <param name="bufferOffset" vsli:raw="The offset in the destination buffer where the bytes read will be written.">Смещение в буфере назначения, в который будут записываться считанные байты.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Считывает сжатое целое число без знака. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <returns vsli:raw="The value of the compressed integer that was read.">Значение считанного сжатого целого числа.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">Данные в текущей позиции не являлись допустимым сжатым целым числом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Считывает сжатое целое число со знаком. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <returns vsli:raw="The value of the compressed integer that was read.">Значение считанного сжатого целого числа.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">Данные в текущей позиции не являлись допустимым сжатым целым числом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary vsli:raw="Reads a constant value (see ECMA-335 Partition II section 22.9) from the current position.">Считывает значение константы (см раздел 22.9 в части II документа ECMA-335) в текущей позиции.</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="A boxed constant value. To avoid allocating the object use Read* methods directly.">Упакованное значение константы. Чтобы избежать выделения объекта, используйте методы Read* напрямую.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Error while reading from the blob.">Ошибка при чтении из большого двоичного объекта.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;typeCode&quot; /&gt; is not a valid &lt;see cref=&quot;T:System.Reflection.Metadata.ConstantTypeCode&quot; /&gt;.">
        <paramref name="typeCode" /> не является допустимым <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">Считывает число <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">Данные в текущей позиции не являлись допустимым числом <see cref="T:System.Decimal" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary vsli:raw="Reads a type code encoded in a serialized custom attribute value.">Считывает код типа, закодированный в сериализованном значении пользовательского атрибута.</summary>
      <returns vsli:raw="&lt;see cref=&quot;F:System.Reflection.Metadata.SerializationTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />, если кодировка недопустима.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary vsli:raw="Reads a string encoded as a compressed integer containing its length followed by its contents in UTF8. Null strings are encoded as a single 0xFF byte.">Считывает строку, которая закодирована как сжатое целое число, содержащее длину, за которой следует содержимое в формате UTF8. Строки NULL кодируются как один байт 0xFF.</summary>
      <returns vsli:raw="A string value, or &lt;see langword=&quot;null&quot; /&gt;.">Строковое значение или <see langword="null" />.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The encoding is invalid.">Кодировка недопустима.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary vsli:raw="Reads a type code encoded in a signature.">Считывает код типа, закодированный в сигнатуре.</summary>
      <returns vsli:raw="The type code encoded in the serialized custom attribute value if the encoding is valid, or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">Код типа, закодированный в сериализованном значении пользовательского атрибута, если кодировка допустима, или <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />, если кодировка недопустима.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary vsli:raw="Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).">Считывает дескриптор типа, закодированный в сигнатуре как TypeDefOrRefOrSpecEncoded (см. ECMA-335 II.23.2.8).</summary>
      <returns vsli:raw="The handle when the encoding is valid. Otherwise, a handle where the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">Дескриптор в случае допустимой кодировки. В противном случае дескриптор, свойство <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> которого равно <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary vsli:raw="Reads a UTF16 (little-endian) encoded string starting at the current position.">Считывает строку в кодировке UTF16 (прямой порядок байтов) начиная с текущей позиции.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns vsli:raw="The string.">Строка.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary vsli:raw="Reads a UTF8 encoded string starting at the current position.">Считывает строку в кодировке UTF8 начиная с текущей позиции.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns vsli:raw="The string.">Строка.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> байтов недоступно.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary vsli:raw="Gets the number of bytes remaining from current position to the end of the underlying memory block.">Считывает оставшееся количество байтов от текущей позиции до конца базового блока памяти.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary vsli:raw="Repositions the reader to the start of the underlying memory block.">Возвращает средство чтения в начало базового блока памяти.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary vsli:raw="Gets a pointer to the byte at the start of the underlying memory block.">Возвращает указатель на байт в начале базового блока памяти.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Считывает сжатое целое число без знака. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">Значение считанного сжатого целого числа.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">
        <see langword="true" /> при успешном считывании значения. <see langword="false" />, если данные в текущей позиции не являлись допустимым сжатым целым числом.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Считывает сжатое целое число со знаком. См. раздел II.23.2 спецификации метаданных: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">Значение считанного сжатого целого числа.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">
        <see langword="true" /> при успешном считывании значения. <see langword="false" />, если данные в текущей позиции не являлись допустимым сжатым целым числом.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="count" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary vsli:raw="Compares the current content of this writer with another one.">Сравнивает текущее содержимое данного средства чтения с содержимым другого средства чтения.</summary>
      <param name="other" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы содержимого буфера.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">Диапазон, который определяют <paramref name="start" /> и <paramref name="byteCount" />, выходит за пределы <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="source" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="source" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Реализует кодировку сжатого целого числа без знака в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> невозможно представить как сжатое целое число без знака.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Реализует кодировку сжатого целого числа со знаком в соответствии с определением в главе 23.2 документа ECMA-335-II: "Большие двоичные объекты и сигнатуры".</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> невозможно представить как сжатое целое число со знаком.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">Записывает значение константы (см раздел 22.9 в части II документа ECMA-335) в текущей позиции.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> не относится к типу константы.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">Записывает ссылку на кучу (смещение в куче) или таблицу (номер строки).</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">Смещение в куче или номер строки в таблице.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as 16-bit integer, &lt;see langword=&quot;false&quot; /&gt; to encode as 32-bit integer.">
        <see langword="true" /> для кодирования ссылки в виде 16-битного целого числа; <see langword="false" /> для кодирования в виде 32-битного целого числа.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">Записывает строку в формате SerString (см. раздел 23.3 "Пользовательские атрибуты" в документе ECMA-335-II).</summary>
      <param name="str" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">Записывает строку в формате кучи User String (#US) (см. раздел 24.2.4 "Кучи #US и #Blob" в документе ECMA-335-II).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Построитель недоступен для записи; он связан с другим объектом.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">Записывает строку в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">Записывает строку в кодировке UTF16 (прямой порядок байтов) в текущей позиции.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">Записывает строку в кодировке UTF8 в текущей позиции.</summary>
      <param name="value" vsli:raw="" />
      <param name="allowUnpairedSurrogates" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary vsli:raw="Gets the parent handle (&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;).">Возвращает родительский дескриптор (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary vsli:raw="Gets a type code that identifies the type of the constant value.">Возвращает код типа, определяющий тип значения константы.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary vsli:raw="Gets the constant value.">Возвращает значение константы.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary vsli:raw="Specifies values that represent types of metadata constants.">Задает значения, представляющие типы констант метаданных.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary vsli:raw="A Boolean type.">Тип Boolean.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer.">1-байтовое целое число без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary vsli:raw="A character type.">Тип символа.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">Тип 8-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">Тип 2-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">Тип 4-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">Тип 8-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary vsli:raw="An invalid type.">Недопустимый тип.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary vsli:raw="A null reference.">Пустая ссылка.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">Тип 1-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">Тип 4-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Тип <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">Тип 2-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">Тип 4-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">Тип 8-байтового целого числа без знака.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary vsli:raw="Gets the constructor (the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;) of the custom attribute type.">Возвращает конструктор (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) типа пользовательского атрибута.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary vsli:raw="Decodes the arguments encoded in the value blob.">Декодирует аргументы, закодированные в большом двоичном объекте значения.</summary>
      <param name="provider" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary vsli:raw="Gets the handle of the metadata entity the attribute is applied to.">Возвращает дескриптор сущности метаданных, к которой применяется атрибут.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary vsli:raw="Gets the value of the attribute.">Возвращает значение атрибута.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary vsli:raw="Represents a named argument decoded from a custom attribute signature.">Представляет именованный аргумент, декодированный из сигнатуры настраиваемого атрибута.</summary>
      <typeparam name="TType" vsli:raw="The type used to represent types of values decoded from the custom attribute signature.">Тип, используемый для представления типов значений, декодированных из сигнатуры настраиваемого атрибута.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeNamedArgument`1&quot; /&gt; structure using the specified name, kind, type, and value.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> с использованием заданного имени, вида, типа и значения.</summary>
      <param name="name" vsli:raw="The name of the argument.">Имя аргумента.</param>
      <param name="kind" vsli:raw="The kind of the argument.">Вид аргумента.</param>
      <param name="type" vsli:raw="The type of the argument.">Тип аргумента.</param>
      <param name="value" vsli:raw="The value of the argument.">Значение аргумента.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary vsli:raw="Gets the kind of argument.">Получает вид аргумента.</summary>
      <returns vsli:raw="The argument kind.">Тип аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary vsli:raw="Gets the name of the argument.">Получает имя аргумента.</summary>
      <returns vsli:raw="The argument name.">Имя аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">Получает тип аргумента.</summary>
      <returns vsli:raw="The argument type.">Тип аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">Возвращает значение аргумента.</summary>
      <returns vsli:raw="An object containing the argument value.">Объект, содержащий значение аргумента.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary vsli:raw="Specifies constants that define the kinds of arguments in a custom attribute signature.">Задает константы, определяющие типы аргументов в сигнатуре настраиваемого атрибута.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary vsli:raw="A field argument.">Аргумент field.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary vsli:raw="A property argument.">Аргумент property.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary vsli:raw="Represents a typed argument for a custom metadata attribute.">Представляет типизированный аргумент для настраиваемого атрибута метаданных.</summary>
      <typeparam name="TType" vsli:raw="The type of the argument.">Тип аргумента.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeTypedArgument`1&quot; /&gt; structure using the specified argument type and value.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> с использованием заданного типа и значения аргумента.</summary>
      <param name="type" vsli:raw="The type of the argument.">Тип аргумента.</param>
      <param name="value" vsli:raw="The argument value.">Значение аргумента.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">Получает тип аргумента.</summary>
      <returns vsli:raw="The argument type.">Тип аргумента.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">Возвращает значение аргумента.</summary>
      <returns vsli:raw="The argument value.">Значение аргумента.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary vsli:raw="Represents a custom attribute of the type specified by &lt;paramref name=&quot;TType&quot; /&gt;.">Представляет пользовательский атрибут типа, заданного параметром <paramref name="TType" />.</summary>
      <typeparam name="TType" vsli:raw="The attribute type.">Тип атрибута.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; structure using the specified fixed arguments and named arguments.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> с использованием заданного количества фиксированных и именованных аргументов.</summary>
      <param name="fixedArguments" vsli:raw="The fixed arguments.">Фиксированные аргументы.</param>
      <param name="namedArguments" vsli:raw="The named arguments.">Именованные аргументы.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary vsli:raw="Gets the fixed arguments for the custom attribute.">Получает фиксированные аргументы для пользовательского атрибута.</summary>
      <returns vsli:raw="An immutable array of arguments.">Неизменяемый массив аргументов.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary vsli:raw="Gets the named arguments for the custom attribute value.">Получает именованные аргументы для значения пользовательского атрибута.</summary>
      <returns vsli:raw="An immutable array of arguments.">Неизменяемый массив аргументов.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the metadata blob to the start of the &lt;see cref=&quot;P:System.Reflection.Metadata.DebugMetadataHeader.Id&quot; /&gt; blob.">Возвращает смещение (в байтах) от начала большого двоичного объекта метаданных до начала большого двоичного объекта <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Document">
      <summary vsli:raw="The source document in the debug metadata.">Исходный документ в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary vsli:raw="Gets the document content hash.">Возвращает хэш-код содержимого документа.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary vsli:raw="Gets the hash algorithm used to calculate the &lt;see cref=&quot;P:System.Reflection.Metadata.Document.Hash&quot; /&gt; (SHA1, SHA256, etc.).">Возвращает хэш-алгоритм, который используется для расчета <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256 и т. д.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary vsli:raw="Gets the source code language (C#, VB, F#, etc.).">Возвращает язык исходного кода (C#, VB, F# и т. д.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary vsli:raw="Gets the document name blob.">Возвращает большой двоичный объект с именем документа.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; representing a blob on #Blob heap in Portable PDB structured as Document Name.">Значение <see cref="T:System.Reflection.Metadata.BlobHandle" />, представляющее большой двоичный объект в куче #Blob в переносимом PDB-файле, структурированном как имя документа.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <param name="rank" vsli:raw="The number of dimensions in the array (shall be 1 or more)." />
      <param name="sizes" vsli:raw="Dimension sizes. The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer." />
      <param name="lowerBounds" vsli:raw="Dimension lower bounds, or default(&lt;see cref=&quot;T:System.Collections.Immutable.ImmutableArray`1&quot; /&gt;) to set all &lt;paramref name=&quot;rank&quot; /&gt; lower bounds to 0.&#xA; The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <param name="fixedArguments" vsli:raw="Called first, to encode fixed arguments." />
      <param name="namedArguments" vsli:raw="Called second, to encode named arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <param name="fixedArguments" vsli:raw="Use first, to encode fixed arguments." />
      <param name="namedArguments" vsli:raw="Use second, to encode named arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <param name="variableCount" vsli:raw="Number of local variables." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <param name="convention" vsli:raw="Calling convention." />
      <param name="genericParameterCount" vsli:raw="Number of generic parameters." />
      <param name="isInstanceMethod" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance method signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static method signature." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <param name="genericArgumentCount" vsli:raw="Number of generic arguments." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <param name="argumentCount" vsli:raw="Number of arguments in the set." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <param name="attributeCount" vsli:raw="Number of attributes in the set." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <param name="isInstanceProperty" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance property signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static property signature." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinition&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
      <param name="catchType" vsli:raw="The type of exception to be caught: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
      <param name="filterStart" vsli:raw="Label marking the first instruction of the filter block." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block." />
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block." />
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler." />
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
      <param name="isOptional" vsli:raw="Is optional modifier." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" vsli:raw="" />
      <param name="operation" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <param name="kind" vsli:raw="Clause kind." />
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or nil if &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Catch&quot; /&gt;." />
      <param name="filterOffset" vsli:raw="Offset of the filter block, or 0 if the &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Filter&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
      <param name="filterOffset" vsli:raw="Offset of the filter block." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" vsli:raw="Try block start offset." />
      <param name="tryLength" vsli:raw="Try block length." />
      <param name="handlerOffset" vsli:raw="Handler start offset." />
      <param name="handlerLength" vsli:raw="Handler length." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <param name="startOffset" vsli:raw="Start offset of the region." />
      <param name="length" vsli:raw="Length of the region." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <param name="exceptionRegionCount" vsli:raw="Number of exception regions." />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <param name="exportedType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <param name="codeBuilder" vsli:raw="Builder to write encoded instructions to." />
      <param name="controlFlowBuilder" vsli:raw="Builder tracking labels, branches and exception handlers.&#xA; Must be specified to be able to use some of the control-flow factory methods of &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.InstructionEncoder&quot; /&gt;, such as &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt; etc." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="code" vsli:raw="Branch instruction to encode." />
      <param name="label" vsli:raw="Label of the target location in instruction stream." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder" />
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="label" vsli:raw="Label to mark." />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <param name="argumentIndex" vsli:raw="Index of the argument." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <param name="slotIndex" vsli:raw="Index of the local variable slot." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary vsli:raw="1-based id identifying the label within the context of a &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder&quot; /&gt;.">Идентификатор на основе 1, определяющий метку в контексте <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary vsli:raw="Provides methods for encoding literals.">Предоставляет методы для кодирования литералов.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.LiteralEncoder&quot; /&gt; class with the specified blob builder.">Создает экземпляр класса <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> с использованием указанного построителя больших двоичных объектов.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary vsli:raw="Returns the encoder used to encode the literal value.">Возвращает кодировщик, используемый для кодирования литерального значения.</summary>
      <returns vsli:raw="The encoder of the literal value.">Кодировщик литерального значения.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary vsli:raw="Encodes the type and the value of a literal using the specified delegates.">Кодирует тип и значение литерала с помощью указанных делегатов.</summary>
      <param name="type" vsli:raw="A delegate used to encode the type of the literal. Called first by this method.">Делегат, используемый для кодирования типа литерала. Вызывается этим методом в первую очередь.</param>
      <param name="scalar" vsli:raw="A delegate used to encode the value of the literal. Called second by this method.">Делегат, используемый для кодирования значения литерала. Вызывается этим методом во вторую очередь.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and value of a literal in the order they appear in the parameter list.">Возвращает пару кодировщиков, которые должны использоваться для кодирования типа и значения литерала в порядке их следования в списке параметров.</summary>
      <param name="type" vsli:raw="When this method returns, a custom attribute element type encoder used to encode the type of the literal.">Когда этот метод возвращает управление, содержит кодировщик типа элемента настраиваемого атрибута, используемый для кодирования типа литерала.</param>
      <param name="scalar" vsli:raw="When this method returns, a scalar encoded used to encode the value of the literal.">Когда этот метод возвращает управление, содержит кодированный скаляр, используемый для кодирования значения литерала.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary vsli:raw="Encodes the type and the items of a vector literal using the specified delegates.">Кодирует тип и элементы векторного литерала с помощью указанных делегатов.</summary>
      <param name="arrayType" vsli:raw="A delegate used to encode the type of the vector. Called first by this method.">Делегат, используемый для кодирования типа вектора. Вызывается этим методом в первую очередь.</param>
      <param name="vector" vsli:raw="A delegate used to encode the items of the vector. Called second by this method.">Делегат, используемый для кодирования элементов вектора. Вызывается этим методом во вторую очередь.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and the items of a vector literal in the order they appear in the parameter list.">Возвращает пару кодировщиков, которые должны использоваться для кодирования типа и элементов векторного литерала в порядке их следования в списке параметров.</summary>
      <param name="arrayType" vsli:raw="When this method returns, a custom attribute array type encoder used to encode the type of the vector.">Когда этот метод возвращает управление, содержит кодировщик типа массива настраиваемого атрибута, используемый для кодирования типа вектора.</param>
      <param name="vector" vsli:raw="When this method returns, a vector encoder used to encode the items of the vector.">Когда этот метод возвращает управление, содержит кодировщик вектора, используемый для кодирования элементов вектора.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary vsli:raw="Gets a vector encoder used to encode the items of a vector.">Возвращает кодировщик вектора, используемый для кодирования элементов вектора.</summary>
      <returns vsli:raw="A vector encoder used to encode the items of a vector.">Кодировщик вектора, используемый для кодирования элементов вектора.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" vsli:raw="" />
      <param name="isPinned" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" vsli:raw="" />
      <param name="baseHeapSizes" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary vsli:raw="Calculates the handle of the entity within the metadata generation it is defined in, given a handle of an entity in an aggregate metadata.">Вычисляет дескриптор сущности в поколении метаданных, в котором она определена, по заданному маркеру сущности в агрегатных метаданных.</summary>
      <param name="handle" vsli:raw="Handle of an entity in an aggregate metadata.">Дескриптор сущности в агрегатных метаданных.</param>
      <param name="generation" vsli:raw="The generation the entity is defined in.">Поколение, в котором определена сущность.</param>
      <returns vsli:raw="Handle of the entity within the metadata &lt;paramref name=&quot;generation&quot; /&gt;.">Дескриптор сущности в метаданных <paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary vsli:raw="The MetadataBuilder class writes metadata for an assembly in a highly performant manner. It is designed for use by compilers and other assembly generation tools.">Класс MetadataBuilder считывает и записывает метаданные для сборки с высокой производительностью. Он предназначен для использования компиляторами и другими средствами создания сборок.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a builder for metadata tables and heaps.">Создает построитель для таблиц и куч метаданных.</summary>
      <param name="userStringHeapStartOffset" vsli:raw="The start offset of the User String heap. The cumulative size of User String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Начальное смещение кучи пользовательских строк. Совокупный размер куч пользовательских строк для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
      <param name="stringHeapStartOffset" vsli:raw="The start offset of the String heap. The cumulative size of String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Начальное смещение кучи строк. Совокупный размер куч строк для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
      <param name="blobHeapStartOffset" vsli:raw="The start offset of the Blob heap. The cumulative size of Blob heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Начальное смещение кучи больших двоичных объектов. Совокупный размер куч больших двоичных объектов для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
      <param name="guidHeapStartOffset" vsli:raw="The start offset of the Guid heap. The cumulative size of Guid heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Начальное смещение кучи идентификаторов GUID. Совокупный размер куч идентификаторов GUID для всех предыдущих поколений EnC должен быть равен 0, если только метаданные не являются разностными метаданными EnC.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKey" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashAlgorithm" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
      <param name="containsMetadata" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKeyOrToken" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary vsli:raw="Adds a default value for a parameter, field or property.">Добавляет значение по умолчанию для параметра, поля или свойства.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">Дескриптор родительской сущности, который может быть следующим: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value" vsli:raw="The constant value.">Значение константы.</param>
      <returns vsli:raw="A handle to the added constant.">Дескриптор добавляемой константы.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a custom attribute.">Добавляет настраиваемый атрибут.</summary>
      <param name="parent" vsli:raw="An entity to attach the custom attribute to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;.">Сущность, к которой необходимо присоединить настраиваемый атрибут: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> или <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor" vsli:raw="A custom attribute constructor: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Конструктор настраиваемого атрибута: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value" vsli:raw="A custom attribute value blob.">Большой двоичный объект со значением настраиваемого атрибута.</param>
      <returns vsli:raw="A handle to the added custom attribute.">Дескриптор добавляемого настраиваемого атрибута.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds custom debug information.">Добавляет пользовательскую отладочную информацию.</summary>
      <param name="parent" vsli:raw="An entity to attach the debug information to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;.">Сущность, к которой необходимо присоединить отладочную информацию: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> или <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind" vsli:raw="The information kind. Determines the structure of the &lt;paramref name=&quot;value&quot; /&gt; blob.">Тип информации. Определяет структуру большого двоичного объекта <paramref name="value" />.</param>
      <param name="value" vsli:raw="The custom debug information blob.">Большой двоичный объект с пользовательской отладочной информацией.</param>
      <returns vsli:raw="A handle to the added custom debug information.">Дескриптор добавляемой пользовательской отладочной информации.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a declarative security attribute to a type, method, or assembly.">Добавляет атрибут декларативной безопасности к типу, методу или сборке.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;.">Дескриптор родительской сущности, который может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action" vsli:raw="A declarative security action.">Декларативное действие безопасности.</param>
      <param name="permissionSet" vsli:raw="The permission set blob.">Большой двоичный объект с набором разрешений.</param>
      <returns vsli:raw="A handle to the added declarative security attribute.">Дескриптор добавляемого атрибута декларативной безопасности.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Adds document debug information.">Добавляет сведения об отладке документа.</summary>
      <param name="name" vsli:raw="The document name blob.">Большой двоичный объект с именем документа.</param>
      <param name="hashAlgorithm" vsli:raw="THe GUID of the hash algorithm used to calculate the value of &lt;paramref name=&quot;hash&quot; /&gt;.">Идентификатор GUID хэш-алгоритма, используемого для вычисления значения <paramref name="hash" />.</param>
      <param name="hash" vsli:raw="The hash of the document content.">Хэш-код содержимого документа.</param>
      <param name="language" vsli:raw="The GUID of the language.">Идентификатор GUID языка.</param>
      <returns vsli:raw="A handle to the added document.">Дескриптор добавляемого документа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" vsli:raw="" />
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an event definition.">Добавляет определение события.</summary>
      <param name="attributes" vsli:raw="The event attributes.">Атрибуты события.</param>
      <param name="name" vsli:raw="The event name.">Имя события.</param>
      <param name="type" vsli:raw="The type of the event: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Тип события: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns vsli:raw="A handle to the added event definition.">Дескриптор добавляемого определения события.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="eventList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary vsli:raw="Adds an exported type.">Добавляет экспортируемый тип.</summary>
      <param name="attributes" vsli:raw="The type attributes.">Атрибуты типа.</param>
      <param name="namespace" vsli:raw="The type namespace.">Пространство имен типа.</param>
      <param name="name" vsli:raw="The type name.">Имя типа.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: an &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;.">Дескриптор сущности реализации, который может быть следующим: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> или <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId" vsli:raw="The type definition ID.">Идентификатор определения типа.</param>
      <returns vsli:raw="A handle to the added exported type.">Дескриптор добавляемого экспортируемого типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a field definition.">Добавляет определение поля.</summary>
      <param name="attributes" vsli:raw="The field attributes.">Атрибуты поля.</param>
      <param name="name" vsli:raw="The field name.">Имя поля.</param>
      <param name="signature" vsli:raw="The field signature. Use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature&quot; /&gt; to construct the blob.">Подпись поля. Используйте <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> для создания большого двоичного объекта.</param>
      <returns vsli:raw="A handle to the added field definition.">Дескриптор добавляемого определения поля.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Defines a field layout of a field definition.">Определяет макет поля для определения поля.</summary>
      <param name="field" vsli:raw="The field definition handle.">Дескриптор определения поля.</param>
      <param name="offset" vsli:raw="The byte offset of the field within the declaring type instance.">Смещение поля в байтах внутри экземпляра объявляющего типа.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Adds a mapping from a field to its initial value stored in the PE image.">Добавляет сопоставление поля с его начальным значением, хранящимся в образе PE.</summary>
      <param name="field" vsli:raw="The field definition handle.">Дескриптор определения поля.</param>
      <param name="offset" vsli:raw="The offset within the block in the PE image that stores initial values of mapped fields (usually in the .text section).">Смещение внутри блока в образе PE, по которому хранятся начальные значения сопоставленных полей (обычно в разделе .text).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a generic parameter definition.">Добавляет определение универсального параметра.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be either a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;.">Дескриптор родительской сущности, который может быть <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes" vsli:raw="The generic parameter attributes.">Атрибуты универсального параметра.</param>
      <param name="name" vsli:raw="The parameter name.">Имя параметра.</param>
      <param name="index" vsli:raw="The zero-based parameter index.">Отсчитываемый от нуля индекс параметра.</param>
      <returns vsli:raw="A handle to the added generic parameter.">Дескриптор добавляемого универсального параметра.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds a type constraint to a generic parameter.">Добавляет ограничение типа к универсальному параметру.</summary>
      <param name="genericParameter" vsli:raw="The generic parameter to constrain.">Ограничиваемый универсальный параметр.</param>
      <param name="constraint" vsli:raw="The type constraint, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Ограничение типа, которое может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns vsli:raw="A handle to the added generic parameter constraint.">Дескриптор добавляемого ограничения универсального параметра.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local scope debug information.">Добавляет сведения об отладке локальной области.</summary>
      <param name="parentScope" vsli:raw="The parent scope handle.">Дескриптор родительской области.</param>
      <param name="imports" vsli:raw="The import scope handle.">Дескриптор области импорта.</param>
      <returns vsli:raw="A handle to the added import scope.">Дескриптор добавляемой области импорта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an interface implementation to a type.">Добавляет реализацию интерфейса к типу.</summary>
      <param name="type" vsli:raw="The type implementing the interface.">Тип, реализующий интерфейс.</param>
      <param name="implementedInterface" vsli:raw="The interface being implemented, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Реализуемый интерфейс, который может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns vsli:raw="A handle to the added interface implementation.">Дескриптор добавляемой реализации интерфейса.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local constant debug information.">Добавляет сведения об отладке локальной константы.</summary>
      <param name="name" vsli:raw="The name of the variable.">Имя переменной.</param>
      <param name="signature" vsli:raw="The LocalConstantSig blob.">Большой двоичный объект LocalConstantSig.</param>
      <returns vsli:raw="A handle to the added local constant.">Дескриптор добавляемой локальной константы.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary vsli:raw="Adds local scope debug information.">Добавляет сведения об отладке локальной области.</summary>
      <param name="method" vsli:raw="The containing method.">Содержащий метод.</param>
      <param name="importScope" vsli:raw="The handle of the associated import scope.">Дескриптор связанной области импорта.</param>
      <param name="variableList" vsli:raw="If the scope declares variables, set this to the handle of the first one. Otherwise, set this to the handle of the first variable declared by the next scope definition. If no scope defines any variables, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)&quot; /&gt;.">Если в области объявляются переменные, укажите дескриптор первой из них. В противном случае укажите дескриптор первой переменной, объявляемой в следующем определении области. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />, если переменные не объявляются ни в одной области.</param>
      <param name="constantList" vsli:raw="If the scope declares constants, set this the handle of the first one. Otherwise, set this to the handle of the first constant declared by the next scope definition. If no scope defines any constants, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)&quot; /&gt;.">Если в области объявляются константы, укажите дескриптор первой из них. В противном случае укажите дескриптор первой константы, объявляемой в следующем определении области. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />, если константы не объявляются ни в одной области.</param>
      <param name="startOffset" vsli:raw="The offset of the first instruction covered by the scope.">Смещение первой инструкции, входящей в область.</param>
      <param name="length" vsli:raw="The length (in bytes) of the scope.">Длина области (в байтах).</param>
      <returns vsli:raw="A handle to the added local scope.">Дескриптор добавляемой локальной области.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds local variable debug information.">Добавляет сведения об отладке локальной переменной.</summary>
      <param name="attributes" vsli:raw="The local variable attributes.">Атрибуты локальной переменной.</param>
      <param name="index" vsli:raw="The zero-base index of the local variable in the local signature.">Отсчитываемый от нуля индекс локальной переменной в локальной сигнатуре.</param>
      <param name="name" vsli:raw="The name of the variable.">Имя переменной.</param>
      <returns vsli:raw="A handle to the added local variable.">Дескриптор добавляемой локальной переменной.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary vsli:raw="Adds a manifest resource.">Добавляет ресурс манифеста.</summary>
      <param name="attributes" vsli:raw="The manifest resource attributes.">Атрибуты ресурса манифеста.</param>
      <param name="name" vsli:raw="The name of the manifest resource.">Имя ресурса манифеста.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">Дескриптор сущности реализации, который может быть следующим: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> или <see langword="null" />.</param>
      <param name="offset" vsli:raw="Specifies the byte offset within the referenced file at which this resource record begins.">Задает смещение в байтах, с которого начинается эта запись ресурса в указанном файле.</param>
      <returns vsli:raw="A handle to the added manifest resource.">Дескриптор добавляемого ресурса манифеста.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds marshalling information to a field or a parameter.">Добавляет сведения о маршалинге к полю или параметру.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;.">Дескриптор родительской сущности, который может быть следующим: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> или <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor" vsli:raw="The descriptor blob.">Большой двоичный объект дескриптора.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a MemberRef table row.">Добавляет строку в таблицу MemberRef.</summary>
      <param name="parent" vsli:raw="The containing entity, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Содержащая сущность, которая может быть следующей: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name" vsli:raw="The member name.">Имя элемента.</param>
      <param name="signature" vsli:raw="The member signature.">Сигнатура элемента.</param>
      <returns vsli:raw="A handle to the added member reference.">Дескриптор добавляемой ссылки на элемент.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds method debug information.">Добавляет сведения об отладке метода.</summary>
      <param name="document" vsli:raw="The handle of a single document containing all sequence points of the method, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">Дескриптор отдельного документа, содержащего все точки последовательности метода, или значение <see langword="null" />, если метод не имеет точек последовательности или охватывает несколько документов.</param>
      <param name="sequencePoints" vsli:raw="The sequence Points blob, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points.">Большой двоичный объект с точками последовательности или значение <see langword="null" />, если метод не имеет точек последовательности.</param>
      <returns vsli:raw="A handle to the added method debug information.">Дескриптор добавляемых сведений об отладке метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary vsli:raw="Adds a method definition.">Добавляет определение метода.</summary>
      <param name="attributes" vsli:raw="The method attributes.">Атрибуты метода.</param>
      <param name="implAttributes" vsli:raw="The method implementation attributes.">Атрибуты реализации метода.</param>
      <param name="name" vsli:raw="The method name.">Имя метода.</param>
      <param name="signature" vsli:raw="The method signature.">Сигнатура метода.</param>
      <param name="bodyOffset" vsli:raw="Offset within the block in the PE image that stores method bodies (the IL stream), or -1 if the method doesn't have a body.">Смещение внутри блока в образе PE, по которому хранятся тела методов (поток IL), или значение –1, если у метода нет тела.</param>
      <param name="parameterList" vsli:raw="If the method declares parameters in the Params table, set this to the handle of the first one. Otherwise, set this to the handle of the first parameter declared by the next method definition. If no parameters are declared in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)&quot; /&gt;.">Если метод объявляет параметры в таблице Params, укажите дескриптор первого из них. В противном случае укажите дескриптор первого параметра, объявляемого в следующем определении метода. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />, если в модуле не объявляются параметры.</param>
      <returns vsli:raw="A handle to the added method definition.">Дескриптор добавляемого определения метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Defines an implementation for a method declaration within a type.">Определяет реализацию объявления метода внутри типа.</summary>
      <param name="type" vsli:raw="The type definition.">Определение типа.</param>
      <param name="methodBody" vsli:raw="The method body entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Дескриптор сущности тела метода, который может быть следующим: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration" vsli:raw="The method declaration entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Дескриптор сущности объявления метода, который может быть следующим: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <returns vsli:raw="A handle to the added method implementation.">Дескриптор добавляемой реализации метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary vsli:raw="Adds import information to a method definition.">Добавляет сведения об импорте в определение метода.</summary>
      <param name="method" vsli:raw="The method definition handle.">Дескриптор определения метода.</param>
      <param name="attributes" vsli:raw="The method import attributes.">Атрибуты импорта метода.</param>
      <param name="name" vsli:raw="The unmanaged method name.">Имя неуправляемого метода.</param>
      <param name="module" vsli:raw="The module containing the unmanaged method.">Модуль, содержащий неуправляемый метод.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Associates a method (a getter, a setter, an adder, etc.) with a property or an event.">Связывает метод (получения, задания, добавления и т. д.) со свойством или событием.</summary>
      <param name="association" vsli:raw="The association entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">Дескриптор сущности связи, который может быть следующим: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics" vsli:raw="The method semantics attributes.">Атрибуты семантики метода.</param>
      <param name="methodDefinition" vsli:raw="The method definition.">Определение метода.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a method specification (an instantiation).">Добавляет спецификацию метода (для создания экземпляра).</summary>
      <param name="method" vsli:raw="The generic method entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Дескриптор сущности универсального метода, который может быть следующим: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation" vsli:raw="The instantiation blob encoding the generic arguments of the method.">Большой двоичный объект для создания экземпляра, который кодирует универсальные аргументы метода.</param>
      <returns vsli:raw="A handle to the added method specification.">Дескриптор добавляемой спецификации метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" vsli:raw="" />
      <param name="moduleName" vsli:raw="" />
      <param name="mvid" vsli:raw="" />
      <param name="encId" vsli:raw="" />
      <param name="encBaseId" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary vsli:raw="Defines a nesting relationship to specified type definitions.">Определяет отношение вложенности к указанным определениям типов.</summary>
      <param name="type" vsli:raw="The nested type definition handle.">Дескриптор определения вложенного типа.</param>
      <param name="enclosingType" vsli:raw="The enclosing type definition handle.">Дескриптор определения включающего типа.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a parameter definition.">Добавляет определение параметра.</summary>
      <param name="attributes" vsli:raw="The parameter attributes.">Атрибуты параметра.</param>
      <param name="name" vsli:raw="Optional. The parameter name.">Необязательный параметр. Имя параметра.</param>
      <param name="sequenceNumber" vsli:raw="The sequence number of the parameter. A value of 0 refers to the owner method's return type; its parameters are then numbered from 1 onward.">Порядковый номер параметра. Значение 0 указывает на тип возвращаемого значения метода-владельца; затем его параметры нумеруются от 1.</param>
      <returns vsli:raw="A handle to the added parameter.">Дескриптор добавляемого параметра.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a property definition.">Добавляет определение свойства.</summary>
      <param name="attributes" vsli:raw="The property attributes.">Атрибуты свойства.</param>
      <param name="name" vsli:raw="The property name.">Имя свойства.</param>
      <param name="signature" vsli:raw="The signature of the property.">Сигнатура свойства.</param>
      <returns vsli:raw="A handle to the added property definition.">Дескриптор добавляемого определения свойства.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="propertyList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds state machine method debug information.">Добавляет сведения об отладке метода конечного автомата.</summary>
      <param name="moveNextMethod" vsli:raw="The handle of the &lt;see langword=&quot;MoveNext&quot; /&gt; method of the state machine (the compiler-generated method).">Дескриптор метода <see langword="MoveNext" /> конечного автомата (метода, созданного компилятором).</param>
      <param name="kickoffMethod" vsli:raw="The handle of the kickoff method (the user defined iterator/async method).">Дескриптор начального метода (определенного пользователем метода-итератора или асинхронного метода).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds a type definition.">Добавляет определение типа.</summary>
      <param name="attributes" vsli:raw="The type attributes.">Атрибуты типа.</param>
      <param name="namespace" vsli:raw="The type namespace.">Пространство имен типа.</param>
      <param name="name" vsli:raw="The type name.">Имя типа.</param>
      <param name="baseType" vsli:raw="The base type entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">Дескриптор сущности базового типа, который может быть следующим: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> или <see langword="null" />.</param>
      <param name="fieldList" vsli:raw="If the type declares fields, set this to the handle of the first one. Otherwise, set this to the handle of the first field declared by the next type definition. If no type defines any fields in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)&quot; /&gt;.">Если в типе объявляются поля, укажите дескриптор первого из них. В противном случае укажите дескриптор первого поля, объявляемого в следующем определении типа. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />, если поля не объявляются ни в одном типе модуля.</param>
      <param name="methodList" vsli:raw="If the type declares methods, the handle of the first one. Otherwise, the handle of the first method declared by the next type definition. If no type defines any methods in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)&quot; /&gt;.">Если в типе объявляются методы, укажите дескриптор первого из них. В противном случае укажите дескриптор первого метода, объявляемого в следующем определении типа. <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />, если методы не объявляются ни в одном типе модуля.</param>
      <returns vsli:raw="A handle to the added type definition.">Дескриптор добавляемого определения типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary vsli:raw="Defines a type layout of a type definition.">Определяет макет типа для определения типа.</summary>
      <param name="type" vsli:raw="The type definition.">Определение типа.</param>
      <param name="packingSize" vsli:raw="Specifies that fields should be placed within the type instance at byte addresses which are a multiple of &lt;paramref name=&quot;packingSize&quot; /&gt;, or at natural alignment for that field type, whichever is smaller. Its value should be one of the following: 0, 1, 2, 4, 8, 16, 32, 64, or 128. A value of zero indicates that the packing size used should match the default for the current platform.">Указывает, что поля должны размещаться в экземпляре типа по байтовым адресам, кратным <paramref name="packingSize" />, или по естественному выравниванию для этого типа поля в зависимости от того, какое из этих значений меньше. Значение должно быть одним из следующих: 0, 1, 2, 4, 8, 16, 32, 64 или 128. Нулевое значение указывает, что используемый упаковочный размер должен соответствовать значению по умолчанию для текущей платформы.</param>
      <param name="size" vsli:raw="Indicates a minimum size of the type instance and is intended to allow for padding. The amount of memory allocated is the maximum of the size calculated from the layout and &lt;paramref name=&quot;size&quot; /&gt;. Note that if this directive applies to a value type, then the size will be less than 1 MB.">Указывает минимальный размер экземпляра типа; предназначен для обеспечения заполнения. Объем выделенной памяти равен размеру, вычисленному на основе макета, или <paramref name="size" /> в зависимости от того, какое из этих значений больше. Обратите внимание, что если эта директива применяется к типу значения, размер будет меньше 1 МБ.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds a type reference.">Добавляет ссылку на тип.</summary>
      <param name="resolutionScope" vsli:raw="The entity declaring the target type, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">Сущность, определяющая тип целевого объекта; может быть следующей: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see langword="null" />.</param>
      <param name="namespace" vsli:raw="The type reference namespace.">Пространство имен ссылки на тип.</param>
      <param name="name" vsli:raw="The type reference name.">Имя ссылки на тип.</param>
      <returns vsli:raw="A handle to the added type reference.">Дескриптор добавляемой ссылки на тип.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary vsli:raw="Adds the specified blob to the Blob heap, if it's not there already.">Добавляет указанный большой двоичный объект в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value" vsli:raw="The array containing the blob.">Массив, содержащий большой двоичный объект.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds the specified blob from a byte array to the Blob heap, if it's not there already.">Добавляет указанный большой двоичный объект из массива байтов в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value" vsli:raw="The array containing the blob.">Массив, содержащий большой двоичный объект.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Adds the specified blob from an immutable byte array to the Blob heap, if it's not there already.">Добавляет указанный большой двоичный объект из неизменяемого массива байтов в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value" vsli:raw="The blob builder instance containing the blob.">Экземпляр построителя больших двоичных объектов, содержащий большой двоичный объект.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary vsli:raw="Encodes a string using UTF16 encoding to a blob and adds it to the Blob heap, if it's not there already.">Кодирует строку в кодировке UTF16 в большой двоичный объект, а затем добавляет этот объект в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value" vsli:raw="The string to add.">Строка для добавления.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Encodes a string using UTF8 encoding to a blob and adds it to the Blob heap, if it's not there already.">Кодирует строку в кодировке UTF8 в большой двоичный объект, а затем добавляет этот объект в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value" vsli:raw="The value to add.">Значение для сложения.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with the U+FFFD character.">
        <see langword="true" /> для кодирования суррогатов без пары указанным образом; <see langword="false" /> для их замены на символ U+FFFD.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary vsli:raw="Encodes a constant value to a blob and adds it to the Blob heap, if it's not there already. Uses UTF16 to encode string constants.">Кодирует значение константы в большой двоичный объект, а затем добавляет этот объект в кучу больших двоичных объектов, если его еще нет в ней. Использует кодировку UTF16 для кодирования строковых констант.</summary>
      <param name="value" vsli:raw="The constant value to add.">Добавляемое значение константы.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Дескриптор добавляемого или существующего большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary vsli:raw="Encodes a debug document name and adds it to the Blob heap, if it's not there already.">Кодирует имя документа отладки и добавляет его в кучу больших двоичных объектов, если его еще нет в ней.</summary>
      <param name="value" vsli:raw="The document name to add.">Добавляемое имя документа.</param>
      <returns vsli:raw="A handle to the added or existing document name blob.">Дескриптор добавляемого или существующего большого двоичного объекта с именем документа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary vsli:raw="Adds the specified Guid to the Guid heap, if it's not there already.">Добавляет указанный идентификатор GUID в кучу идентификаторов GUID, если его еще нет в ней.</summary>
      <param name="guid" vsli:raw="The Guid to add.">Добавляемый идентификатор GUID.</param>
      <returns vsli:raw="A handle to the added or existing Guid.">Дескриптор добавляемого или существующего идентификатора GUID.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary vsli:raw="Adds the specified string to the string heap, if it's not there already.">Добавляет указанную строку в кучу строк, если ее еще нет в ней.</summary>
      <param name="value" vsli:raw="The string to add.">Строка для добавления.</param>
      <returns vsli:raw="A handle to the added or existing string.">Дескриптор добавляемой или существующей строки.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary vsli:raw="Adds the specified string to the user string heap, if it's not there already.">Добавляет указанную строку в кучу пользовательских строк, если ее еще нет в ней.</summary>
      <param name="value" vsli:raw="The string to add.">Строка для добавления.</param>
      <returns vsli:raw="A handle to the added or existing string. This value may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.">Дескриптор добавляемой или существующей строки. Это значение может использоваться в <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the current number of items in the specified table.">Возвращает текущее количество элементов в указанной таблице.</summary>
      <param name="table" vsli:raw="The table index.">Индекс таблицы.</param>
      <returns vsli:raw="The number of items in the table.">Количество элементов в таблице.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary vsli:raw="Returns the current number of items in each table.">Возвращает текущее количество элементов в каждой таблице.</summary>
      <returns vsli:raw="An array of size &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;, with each item filled with the current row count of the corresponding table.">Массив размера <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, в котором каждый элемент заполнен текущим числом строк в соответствующей таблице.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary vsli:raw="Reserves space on the Guid heap for a GUID.">Резервирует место для идентификатора GUID в куче идентификаторов GUID.</summary>
      <returns vsli:raw="A handle to the reserved Guid and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the GUID blob as stored on the heap.">Дескриптор резервируемого идентификатора GUID и объект <see cref="T:System.Reflection.Metadata.Blob" />, представляющий большой двоичный объект с идентификатором GUID, хранящийся в куче.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary vsli:raw="Reserves space on the user string heap for a string of the specified length.">Резервирует место в куче пользовательских строк для строки указанной длины.</summary>
      <param name="length" vsli:raw="The number of characters to reserve.">Число резервируемых символов.</param>
      <returns vsli:raw="A handle to the reserved user string and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the entire User String blob (including its length and terminal character). The handle may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.&#xA; Use &lt;see cref=&quot;M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)&quot; /&gt; to fill in the blob content.">Дескриптор резервируемой пользовательской строки и объект <see cref="T:System.Reflection.Metadata.Blob" />, представляющий весь большой двоичный объект с пользовательской строкой (включая ее длину и завершающий символ). Дескриптор может использоваться в <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
Используйте <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> для заполнения содержимого большого двоичного объекта.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified heap.">Задает емкость указанной кучи.</summary>
      <param name="heap" vsli:raw="The heap index.">Индекс кучи.</param>
      <param name="byteCount" vsli:raw="The number of bytes.">Число байтов.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified table.">Задает емкость указанной таблицы.</summary>
      <param name="table" vsli:raw="The table index.">Индекс таблицы.</param>
      <param name="rowCount" vsli:raw="The number of rows in the table.">Число строк в таблице.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary vsli:raw="Provides extension methods for working with certain raw elements of the ECMA-335 metadata tables and heaps.">Предоставляет методы расширения для работы с определенными необработанными элементами куч и таблиц метаданных ECMA-335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC log.">Перечисляет записи журнала EnC.</summary>
      <param name="reader" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC map.">Перечисляет записи схемы EnC.</summary>
      <param name="reader" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified heap.">Возвращает смещение от начала метаданных до указанной кучи.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the size of the specified heap.">Возвращает размер указанной кучи.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Returns the handle to the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; that follows the given one in the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; heap or a nil handle if it is the last one.">Возвращает маркер <see cref="T:System.Reflection.Metadata.Blob" />, следующий за заданным в <see cref="T:System.Reflection.Metadata.Blob" /> куче, или нулевой маркер, если он является последним.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Returns the a handle to the string that follows the given one in the string heap, or a nil handle if it is the last one.">Возвращает маркер строки, следующей за заданной строкой в куче строк, или нулевой маркер, если она является последней.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.">Возвращает маркер UserString, следующего за заданным значением в куче UserString, или нулевой маркер, если он является последним.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified table.">Возвращает смещение от начала метаданных до указанной таблицы.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the number of rows in the specified table.">Возвращает число строк в указанной таблице.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the size of a row in the specified table.">Возвращает размер строки в указанной таблице.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more events.">Перечисляет типы, определяющие одно или несколько событий.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in EventMap table, i.e. n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of EventMap.">Результирующая последовательность точно соответствует записям в таблице EventMap, т. е. n-й возвращенный <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> хранится в n-й строке EventMap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more properties.">Перечисляет типы, определяющие одно или несколько свойств.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in the property map table, that is, the n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of the property map.">Результирующая последовательность точно соответствует записям в таблице схему свойств, т. е. n-й возвращенный <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> хранится в n-й строке схемы свойств.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary vsli:raw="Given a type handle and a raw type kind found in a signature blob determines whether the target type is a value type or a reference type.">При наличии обработчика типа и вида необработанного типа, находящегося в BLOB-объекте сигнатуры, определяет, является ли целевой тип типом значения или ссылочным типом.</summary>
      <param name="reader" vsli:raw="" />
      <param name="typeHandle" vsli:raw="" />
      <param name="rawTypeKind" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary vsli:raw="Builder of a Metadata Root to be embedded in a Portable Executable image.">Построитель корней метаданных для внедрения в переносимый исполняемый образ.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary vsli:raw="Creates a builder of a metadata root.">Создает построитель корня метаданных.</summary>
      <param name="tablesAndHeaps" vsli:raw="Builder populated with metadata entities stored in tables and values stored in heaps. The entities and values will be enumerated when serializing the metadata root.">Построитель заполнен сущностями метаданных, хранящимися в таблицах, и значениями из куч. Сущности и значения перечисляются при сериализации корня метаданных.</param>
      <param name="metadataVersion" vsli:raw="The version string written to the metadata header. The default value is &quot;v4.0.30319&quot;.">Строка версии, записанная в заголовок метаданных. Значение по умолчанию: "v4.0.30319".</param>
      <param name="suppressValidation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables during serialization; otherwise, &lt;paramref name=&quot;false&quot; /&gt;.">
        <see langword="true" /> для подавления базовой проверки таблиц метаданных во время сериализации; в противном случае — <paramref name="false" />.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary vsli:raw="The metadata version.">Версия метаданных.</summary>
      <returns vsli:raw="A string that represents the metadata version.">Строка, представляющая версию метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary vsli:raw="Serializes metadata root content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Сериализует содержимое корня метаданных в заданный <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder" vsli:raw="Builder to write to.">Построитель для записи.</param>
      <param name="methodBodyStreamRva" vsli:raw="The relative virtual address of the start of the method body stream. Used to calculate the final value of RVA fields of MethodDef table.">Относительный виртуальный адрес начала потока тела метода. Используется для вычисления конечного значения полей RVA таблицы MethodDef.</param>
      <param name="mappedFieldDataStreamRva" vsli:raw="The relative virtual address of the start of the field init data stream. Used to calculate the final value of RVA fields of FieldRVA table.">Относительный виртуальный адрес начала потока данных инициализации поля. Используется для вычисления конечного значения полей RVA таблицы FieldRVA.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary vsli:raw="Returns sizes of various metadata structures.">Возвращает размеры различных структур метаданных.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary vsli:raw="Determines if basic validation of metadata tables should be suppressed. The validation verifies that entries in the tables were added in order required by the ECMA specification. It does not enforce all specification requirements on metadata tables.">Определяет, следует ли подавлять базовую проверку таблиц метаданных. Проверка подтверждает, что записи в таблицах были добавлены в порядке, требуемом спецификацией ECMA. Она не применяет все требования спецификации к таблицам метаданных.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> для подавления базовой проверки таблиц метаданных; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary vsli:raw="Provides information on sizes of various metadata structures.">Предоставляет сведения о размерах различных структур метаданных.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary vsli:raw="External table row count.">Число строк внешней таблицы.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns aligned size of the specified heap.">Возвращает выровненный размер указанной кучи.</summary>
      <param name="index" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary vsli:raw="Exact (unaligned) heap sizes.">Точные (невыровненные) размеры кучи.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary vsli:raw="Table row counts.">Число строк таблицы.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary vsli:raw="Creates an entity handle from a token value.">Создает дескриптор сущности на основе значения токена.</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">Создает <see cref="T:System.Reflection.Metadata.EntityHandle" /> на основе значения токена.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Отсчитываемое от нуля смещение или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" /> или <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="1-based index into the #Guid heap. Unlike other heaps, which are essentially byte arrays, the #Guid heap is an array of 16-byte GUIDs.">Отсчитываемый от 1 индекс в куче #Guid. В отличие от других куч, которые, по сути, представляют собой байтовые массивы, куча #Guid является массивом 16-байтовых идентификаторов GUID.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="An offset in the corresponding heap, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Смещение в соответствующей куче или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" /> или <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" /> в контексте <paramref name="reader" />, в куче метаданных.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; isn't a metadata heap handle.">Отсчитываемое от нуля смещение или -1, если <paramref name="handle" /> не является дескриптором кучи метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Отсчитываемое от нуля смещение или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" /> или <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает смещение данных, соответствующих указанному дескриптору <paramref name="handle" />, в куче метаданных.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset.">Отсчитываемое от нуля смещение.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает номер строки записи, соответствующей указанному дескриптору <paramref name="handle" />, в таблице метаданных.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.&#xA; See &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)&quot; /&gt;.">Отсчитываемый от 1 номер строки или -1, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" />.
См. раздел <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Возвращает номер строки записи, соответствующей указанному дескриптору <paramref name="handle" /> в контексте <paramref name="reader" />, в таблице метаданных.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number.">Отсчитываемый от 1 номер строки.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает токен метаданных для указанного дескриптора <paramref name="handle" />.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">Токен метаданных или 0, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Возвращает токен метаданных для указанного дескриптора <paramref name="handle" />.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">Токен метаданных или 0, если дескриптор <paramref name="handle" /> может интерпретироваться только в контексте определенного объекта <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Возвращает токен метаданных для указанного дескриптора <paramref name="handle" /> в контексте <paramref name="reader" />.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token.">Токен метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Возвращает токен метаданных для указанного дескриптора <paramref name="handle" /> в контексте <paramref name="reader" />.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token.">Токен метаданных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary vsli:raw="Creates a handle from a token value.">Создает дескриптор на основе значения токена.</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">Создает <see cref="T:System.Reflection.Metadata.EntityHandle" /> на основе значения токена.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Максимальное число таблиц, которые могут присутствовать в метаданных Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Максимальное число таблиц, которые могут присутствовать в метаданных Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.HeapIndex&quot; /&gt; of the heap corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">Возвращает индекс <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> кучи, соответствующей указанному <see cref="T:System.Reflection.Metadata.HandleKind" />.</summary>
      <param name="type" vsli:raw="Handle type.">Тип дескриптора.</param>
      <param name="index" vsli:raw="Heap index.">Индекс кучи.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 heap; &lt;see langword=&quot;false&quot; /&gt; otherwise.">Значение <see langword="true" />, если тип дескриптора соответствует куче Ecma335; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt; of the table corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">Возвращает индекс <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> таблицы, соответствующей указанному <see cref="T:System.Reflection.Metadata.HandleKind" />.</summary>
      <param name="type" vsli:raw="Handle type.">Тип дескриптора.</param>
      <param name="index" vsli:raw="Table index.">Индекс таблицы.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 or Portable PDB table; &lt;see langword=&quot;false&quot; /&gt; otherwise.">Значение <see langword="true" />, если тип дескриптора соответствует таблице Ecma335 или переносимой таблице PDB; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary vsli:raw="Defines method body attributes.">Определяет атрибуты тела метода.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary vsli:raw="Initializes any locals the method defines to zero and dynamically allocates local memory.">Инициализирует все локальные переменные, которые метод определяет как ноль, и динамически выделяет локальную память.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary vsli:raw="Performs no local memory initialization.">Не выполняет инициализацию локальной памяти.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary vsli:raw="Provides an encoder for a method body stream.">Предоставляет кодировщик для потока тела метода.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes and allowing to indicate whether the exception regions should be encoded in small format or not.">Кодирует тело метода и добавляет его в поток тела метода, используя указанный размер кода, максимальный размер стека, число регионов исключения, параметр сигнатуры локальных переменных, атрибуты тела метода. Позволяет указать, должны ли области исключения быть закодированными в небольшом формате или нет.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">Число байтов, которое должно быть зарезервировано для инструкций.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Максимальный размер стека.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">Число регионов исключений.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, если области исключений должны быть закодированы в небольшом формате; в противном случае <see langword="false" />.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Атрибуты тела метода.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes, allowing to indicate whether the exception regions should be encoded in small format or not, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">Кодирует тело метода и добавляет его в поток тела метода, используя указанный размер кода, максимальный размер стека, число регионов исключения, параметр сигнатуры локальных переменных, атрибуты тела метода. Позволяет указать, должны ли области исключения быть закодированными в небольшом формате и должен ли метод выделять из пула динамической локальной памяти или нет.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">Число байтов, которое должно быть зарезервировано для инструкций.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Максимальный размер стека.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">Число регионов исключений.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, если области исключений должны быть закодированы в небольшом формате; в противном случае <see langword="false" />.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Атрибуты тела метода.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, если метод выделяет из пула динамической локальной памяти (инструкция <see langword="localloc" />); в противном случае <see langword="false" />.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream.">Кодирует тело метода и добавляет его в поток тела метода.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">Кодировщик инструкций.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Максимальный размер стека.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Атрибуты тела метода.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided instruction encoder, maximum stack size, local variables' signature handle, method body attributes, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">Кодирует тело метода и добавляет его в поток тела метода, используя предоставленный кодировщик инструкций, максимальный размер стека, параметр сигнатуры локальных переменных, атрибуты тела метода. Позволяет указать, должен ли метод выделять из пула динамической локальной памяти или нет.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">Кодировщик инструкций.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Максимальный размер стека.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Параметр сигнатуры локальных переменных.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Атрибуты тела метода.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the IL contains the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, если метод выделяет из пула динамической локальной памяти (IL содержит инструкцию <see langword="localloc" />); в противном случае <see langword="false" />.</param>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Смещение закодированного тела в потоке тела метода.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary vsli:raw="Describes a method body. This class is meant to used along with the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder&quot; /&gt; class.">Описывает тело метода. Этот класс предназначен для использования вместе с классом <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary vsli:raw="Gets an encoder object that can be used to encode exception regions to the method body.">Возвращает объект кодировщика, который можно использовать для кодирования областей исключений для тела метода.</summary>
      <returns vsli:raw="An exception region encoder instance.">Экземпляр кодировщика области исключений.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary vsli:raw="Gets a blob reserved for instructions.">Возвращает большой двоичный объект, зарезервированный для инструкций.</summary>
      <returns vsli:raw="A blob reserved for instructions.">Большой двоичный объект, зарезервированный для инструкций.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary vsli:raw="Gets the offset of the encoded method body in the method body stream.">Возвращает смещение тела закодированного метода в потоке тела метода.</summary>
      <returns vsli:raw="The offset of the encoded method body in the method body stream.">Смещение тела закодированного метода в потоке тела метода.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary vsli:raw="Provides an encoder for method signatures.">Предоставляет кодировщик для сигнатур методов.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary vsli:raw="Encodes the provided return type and parameters.">Кодирует предоставленный тип возвращаемого значения и параметры.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">Число параметров.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return type.">Метод, который вызывается первым для кодирования типа возвращаемого значения.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">Метод, который вызывается вторым для кодирования параметров.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary vsli:raw="Encodes the provided return type and parameters, which must be used in the order they appear in the parameter list.">Кодирует предоставленный тип возвращаемого значения и параметры, которые должны использоваться в том порядке, в котором они отображаются в списке параметров.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">Число параметров.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return types.">Метод, который вызывается первым для кодирования типов возвращаемых значений.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">Метод, который вызывается вторым для кодирования параметров.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder&quot; /&gt; structure.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />.</summary>
      <param name="builder" vsli:raw="A builder for encoding the named argument.">Построитель для кодирования именованного аргумента.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary vsli:raw="Encodes a named argument (a field or property).">Кодирует именованный аргумент (поле или свойство).</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" /> для кодирования поля; <see langword="false" /> для кодирования свойства.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">Метод, вызываемый первым для кодирования типа аргумента.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">Метод, вызываемый вторым для кодирования имени поля или свойства.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">Метод, вызываемый третьим для кодирования литерального значения аргумента.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary vsli:raw="Encodes a named argument (a field or property) and returns three encoders that must be used in the order they appear in the parameter list.">Кодирует именованный аргумент (поле или свойство) и возвращает три кодировщика, которые должны использоваться в порядке их следования в списке параметров.</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" /> для кодирования поля; <see langword="false" /> для кодирования свойства.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">Метод, вызываемый первым для кодирования типа аргумента.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">Метод, вызываемый вторым для кодирования имени поля или свойства.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">Метод, вызываемый третьим для кодирования литерального значения аргумента.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary vsli:raw="Represents the builder of a Portable PDB image.">Представляет построитель образа переносимого PDB-файла.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary vsli:raw="Creates a builder of a Portable PDB image.">Создает построитель образа переносимого PDB-файла.</summary>
      <param name="tablesAndHeaps" vsli:raw="A builder populated with debug metadata entities stored in tables and values stored in heaps. The entities and values are enumerated when serializing the Portable PDB image.">Построитель заполнен сущностями метаданных отладки, хранящимися в таблицах, и значениями из куч. Сущности и значения перечисляются при сериализации образа переносимого PDB-файла.</param>
      <param name="typeSystemRowCounts" vsli:raw="The row counts of all tables that the associated type system metadata contain. Each slot in the array corresponds to a table (&lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt;). The length of the array must be equal &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;.">Количество строк всех таблиц, содержащихся в связанных метаданных системы типов. Каждый слот в массиве соответствует таблице (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). Длина массива должна быть равна <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.</param>
      <param name="entryPoint" vsli:raw="An entry point method definition handle.">Параметр определения метода точки входа.</param>
      <param name="idProvider" vsli:raw="A function that calculates the ID of content represented as a sequence of blobs. If not specified, a default function that ignores the content and returns a content ID based on the current time is used (&lt;see cref=&quot;M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider&quot; /&gt;). You must specify a deterministic function to produce a deterministic Portable PDB image.">Функция, которая вычисляет идентификатор содержимого, представленного в виде последовательности больших двоичных объектов. Если не указано, используется функция по умолчанию, которая игнорирует содержимое и возвращает идентификатор содержимого на основе текущего времени (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Для создания детерминированного образа переносимого PDB-файла необходимо указать детерминированную функцию.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Serializes portable PDB content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Сериализует содержимое переносимого PDB-файла в заданный <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder" vsli:raw="The builder to write to.">Построитель для записи.</param>
      <returns vsli:raw="The ID of the serialized content.">Идентификатор сериализованного содержимого.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary vsli:raw="Encodes a constant literal.">Кодирует константный литерал.</summary>
      <param name="value" vsli:raw="A constant of type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;, &lt;see cref=&quot;T:System.Byte&quot; /&gt;, &lt;see cref=&quot;T:System.SByte&quot; /&gt;, &lt;see cref=&quot;T:System.Int16&quot; /&gt;, &lt;see cref=&quot;T:System.UInt16&quot; /&gt;, &lt;see cref=&quot;T:System.Int32&quot; /&gt;, &lt;see cref=&quot;T:System.UInt32&quot; /&gt;, &lt;see cref=&quot;T:System.Int64&quot; /&gt;, &lt;see cref=&quot;T:System.UInt64&quot; /&gt;, &lt;see cref=&quot;T:System.Single&quot; /&gt;, &lt;see cref=&quot;T:System.Double&quot; /&gt;, &lt;see cref=&quot;T:System.Char&quot; /&gt; (encoded as a two-byte Unicode character), &lt;see cref=&quot;T:System.String&quot; /&gt; (encoded as SerString), or &lt;see cref=&quot;T:System.Enum&quot; /&gt; (encoded as the underlying integer value).">Константа типа <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (в кодировке двухбайтовых символов в Юникоде), <see cref="T:System.String" /> (в кодировке SerString) или <see cref="T:System.Enum" /> (в кодировке базового целого числа).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary vsli:raw="Encodes a &lt;see langword=&quot;null&quot; /&gt; literal of type &lt;see cref=&quot;T:System.Array&quot; /&gt;.">Кодирует литерал <see langword="null" /> типа <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary vsli:raw="Encodes a literal of type &lt;see cref=&quot;T:System.Type&quot; /&gt; (which can possibly be &lt;see langword=&quot;null&quot; /&gt;).">Кодирует литерал типа <see cref="T:System.Type" /> (может иметь значение <see langword="null" />).</summary>
      <param name="serializedTypeName" vsli:raw="The name of the type, or &lt;see langword=&quot;null&quot; /&gt;.">Имя типа или значение <see langword="null" />.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary vsli:raw="Decodes signature blobs.">Декодирует большие двоичные объекты сигнатуры.</summary>
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary vsli:raw="Creates a new &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2&quot; /&gt;.">Создает новый экземпляр <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider" vsli:raw="The provider used to obtain type symbols as the signature is decoded.">Поставщик, используемый для получения символов типа при декодировании сигнатуры.</param>
      <param name="metadataReader" vsli:raw="The metadata reader from which the signature was obtained. It may be &lt;see langword=&quot;null&quot; /&gt; if the given provider allows it.">Модуль чтения метаданных, из которого была получена сигнатура. Может иметь значение <see langword="null" />, если указанный поставщик разрешает это.</param>
      <param name="genericContext" vsli:raw="Additional context needed to resolve generic parameters.">Дополнительный контекст для разрешения универсальных параметров.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a field signature blob and advances the reader past the signature.">Декодирует большой двоичный объект сигнатуры поля и перемещает модуль чтения за сигнатуру.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a field signature.">Модуль чтения больших двоичных объектов, расположенный у сигнатуры поля.</param>
      <returns vsli:raw="The decoded field type.">Тип декодированного поля.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a local variable signature blob and advances the reader past the signature.">Декодирует большой двоичный объект сигнатуры локальной переменной и перемещает модуль чтения за сигнатуру.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a local variable signature.">Модуль чтения больших двоичных объектов, расположенный у сигнатуры локальной переменной.</param>
      <returns vsli:raw="The local variable types.">Типы локальных переменных.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method (definition, reference, or standalone) or a property signature blob.">Декодирует метод (определение, ссылка или автономный режим) или большой двоичный объект сигнатуры свойства.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a method signature.">Модуль чтения больших двоичных объектов, расположенный у сигнатуры метода.</param>
      <returns vsli:raw="The decoded method signature.">Декодированная сигнатура метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method specification signature blob and advances the reader past the signature.">Декодирует большой двоичный объект сигнатуры спецификации метода и перемещает модуль чтения за сигнатуру.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a valid method specification signature.">Модуль чтения больших двоичных объектов, расположенный у допустимой сигнатуры спецификации метода.</param>
      <returns vsli:raw="The types used to instantiate a generic method via the method specification.">Типы, используемые для создания экземпляра универсального метода с помощью спецификации метода.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary vsli:raw="Decodes a type embedded in a signature and advances the reader past the type.">Декодирует тип, встроенный в сигнатуру, и перемещает модуль чтения за тип.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at the leading &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureTypeCode&quot; /&gt;.">Модуль чтения больших двоичных объектов, расположенный в начале <see cref="T:System.Reflection.Metadata.SignatureTypeCode" />.</param>
      <param name="allowTypeSpecifications" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to allow a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt; to follow a (CLASS | VALUETYPE) in the signature; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, чтобы позволить <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> следовать за (CLASS | VALUETYPE) в сигнатуре; в противном случае <see langword="false" />.</param>
      <returns vsli:raw="The decoded type.">Расшифрованный тип.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; where the signature will be written." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary vsli:raw="Encodes an array type.">Кодирует тип массива.</summary>
      <param name="elementType" vsli:raw="Called first, to encode the type of the element.">Вызывается первым, чтобы закодировать тип элемента.</param>
      <param name="arrayShape" vsli:raw="Called second, to encode the shape of the array.">Вызывается вторым, чтобы закодировать форму массива.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary vsli:raw="Encodes an array type. Returns a pair of encoders that must be used in the order they appear in the parameter list.">Кодирует тип массива. Возвращает пару кодировщиков, которые должны использоваться в порядке их следования в списке параметров.</summary>
      <param name="elementType" vsli:raw="Use first, to encode the type of the element.">Используйте первым для кодирования типа элемента.</param>
      <param name="arrayShape" vsli:raw="Use second, to encode the shape of the array.">Используйте вторым для кодирования формы массива.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary vsli:raw="Starts a signature of a type with custom modifiers.">Запускает сигнатуру типа с пользовательскими модификаторами.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary vsli:raw="Starts a function pointer signature.">Запускает сигнатуру указателя функции.</summary>
      <param name="convention" vsli:raw="Calling convention.">Соглашение о вызовах.</param>
      <param name="attributes" vsli:raw="Function pointer attributes.">Атрибуты указателя функции.</param>
      <param name="genericParameterCount" vsli:raw="Generic parameter count.">Число универсальных параметров.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary vsli:raw="Starts a generic instantiation signature.">Запускает сигнатуру универсального экземпляра.</summary>
      <param name="genericType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount" vsli:raw="Generic argument count.">Число универсальных аргументов.</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" />, чтобы пометить тип как тип значения; <see langword="false" />, чтобы пометить его как ссылочный тип в сигнатуре.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic method.">Кодирует ссылку на параметр типа содержащего универсального метода.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">Индекс параметра.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic type.">Кодирует ссылку на параметр типа содержащего универсального типа.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">Индекс параметра.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary vsli:raw="Starts pointer signature.">Запускает сигнатуру указателя.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Writes primitive type code.">Записывает код примитивного типа.</summary>
      <param name="type" vsli:raw="Any primitive type code except for &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference&quot; /&gt; and &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.Void&quot; /&gt;.">Любой код примитивного типа, кроме <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> и <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary vsli:raw="Starts SZ array (vector) signature.">Запускает сигнатуру массива (вектора) SZ.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary vsli:raw="Encodes a reference to a type.">Кодирует ссылку на тип.</summary>
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" />, чтобы пометить тип как тип значения; <see langword="false" />, чтобы пометить его как ссылочный тип в сигнатуре.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary vsli:raw="Encodes a void pointer (&lt;c&gt;void*&lt;/c&gt;).">Кодирует указатель void (void*).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary vsli:raw="Represents a metadata entity (such as a type reference, type definition, type specification, method definition, or custom attribute).">Представляет сущность метаданных (например, ссылку на тип, определение типа, спецификацию типа, определение метода или настраиваемый атрибут).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified object are equal.">Возвращает значение, указывающее, равен ли данный экземпляр указанному объекту.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">Объект для сравнения с текущим экземпляром.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если <paramref name="obj" /> является <see cref="T:System.Reflection.Metadata.EntityHandle" /> равен текущему экземпляру; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; are equal.">Возвращает значение, указывающее, равен ли текущий экземпляр указанному <see cref="T:System.Reflection.Metadata.EntityHandle" />.</summary>
      <param name="other" vsli:raw="The value to compare with the current instance.">Значение для сравнения с текущим экземпляром.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance and &lt;paramref name=&quot;other&quot; /&gt; are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если объект <paramref name="other" /> равен текущему экземпляру; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Возвращает хэш-код данного экземпляра.</summary>
      <returns vsli:raw="The hash code for this instance.">Хэш-код данного экземпляра.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary vsli:raw="Gets a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, or a nil token otherwise (&lt;see langword=&quot;default&quot; /&gt;(&lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt;)).">Возвращает дескриптор TypeRef, TypeDef или TypeSpec, если область представляет блок catch, или токен nil в противном случае (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary vsli:raw="Gets the IL offset of the start of the filter block, or -1 if the region is not a filter.">Возвращает смещение IL начала блока фильтра или значение –1, если область не является фильтром.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary vsli:raw="Gets the length in bytes of the exception handler.">Возвращает длину обработчика исключений в байтах.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary vsli:raw="Gets the starting IL offset of the exception handler.">Возвращает начальное смещение IL обработчика исключений.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary vsli:raw="Gets the length in bytes of the try block.">Возвращает длину блока try в байтах.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary vsli:raw="Gets the starting IL offset of the try block.">Возвращает начальное смещение IL блока try.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary vsli:raw="Gets a handle to resolve the implementation of the target type.">Возвращает дескриптор для разрешения реализации целевого типа.</summary>
      <returns vsli:raw="&lt;list type=&quot;bullet&quot;&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt; representing another module in the assembly.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; representing another assembly if &lt;see cref=&quot;P:System.Reflection.Metadata.ExportedType.IsForwarder&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; representing the declaring exported type in which this was is nested.&lt;/description&gt;&lt;/item&gt;&lt;/list&gt;">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />представление другого модуля в сборке.
<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />представление другой сборки, <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> если <see langword="true" />имеет значение.
<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />представление объявляющего экспортированного типа, в котором это был вложенный объект.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary vsli:raw="Gets the name of the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Возвращает имя целевого типа или <see langword="default" />, если тип является вложенным либо определен в корневом пространстве имен.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; struct instance.">Экземпляр <see cref="T:System.Reflection.Metadata.StringHandle" /> структуры.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary vsli:raw="Gets the full name of the namespace that contains the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Возвращает полное имя пространства имен, содержащего целевой тип, или <see langword="default" />, если тип является вложенным либо определен в корневом пространстве имен.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the target type is defined, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Возвращает дескриптор определения пространства имен, содержащего целевой тип, или <see langword="default" />, если тип является вложенным либо определен в корневом пространстве имен.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">Представляет коллекцию экземпляров <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary vsli:raw="Returns the field layout offset, or -1 if it is not available.">Возвращает смещение поля макета или значение –1, если оно недоступно.</summary>
      <returns vsli:raw="The field definition offset, or -1 if it is not available.">Смещение определения поля или значение –1, если оно недоступно.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary vsli:raw="Gets the attributes specifying variance and constraints.">Возвращает атрибуты, указывающие отклонения и ограничения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary vsli:raw="Gets the zero-based index of the parameter within the declaring generic type or method declaration.">Возвращает отсчитываемый от нуля индекс параметра внутри объявляющего универсального типа или объявления метода.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary vsli:raw="Gets the name of the generic parameter.">Возвращает имя универсального параметра.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; that represents the parent of this generic parameter.">Возвращает <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> или <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, представляющий родительский объект этого универсального параметра.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary vsli:raw="Gets the constrained &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;.">Возвращает ограниченный <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary vsli:raw="Gets a handle (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;) &#xA;            specifying from which type this generic parameter is constrained to derive,&#xA;            or which interface this generic parameter is constrained to implement.">Возвращает дескриптор (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />), указывая, от какого типа этот универсальный параметр может быть производным или какой интерфейс этот универсальный параметр может реализовывать.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; instance.">Экземпляр <see cref="T:System.Reflection.Metadata.EntityHandle" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary vsli:raw="Represents a collection of constraints of a generic type parameter.">Представляет коллекцию ограничений параметра универсального типа.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <param name="index" vsli:raw="The zero-based index of the element to get." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary vsli:raw="Represents a collection of generic type parameters of a method or type.">Представляет коллекцию параметров универсальных типов для метода или типа.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <param name="index" vsli:raw="The zero-based index of the element to get." />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Handle">
      <summary vsli:raw="Represents any metadata entity (such as a type reference, a type definition, a type specification, a method definition, or a custom attribute) or value (a string, blob, guid, or user string).">Представляет любую сущность метаданных (например, ссылку на тип, определение типа, спецификацию типа, определение метода или настраиваемый атрибут) или значение (строку, большой двоичный объект, GUID или пользовательскую строку).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Compares two entity handles.">Сравнивает два дескриптора сущности.</summary>
      <param name="x" vsli:raw="The first entity handle to compare.">Первый из сравниваемых дескрипторов сущности.</param>
      <param name="y" vsli:raw="The second entity handle to compare.">Второй из сравниваемых дескрипторов сущности.</param>
      <returns vsli:raw="Zero if the two entity handles are equal, and a non-zero value of they are not.">Нуль, если два дескриптора сущности равны, и ненулевое значение в противном случае.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Compares two handles.">Сравнивает два дескриптора.</summary>
      <param name="x" vsli:raw="The first handle to compare.">Первый из сравниваемых дескрипторов.</param>
      <param name="y" vsli:raw="The second handle to compare.">Второй из сравниваемых дескрипторов.</param>
      <returns vsli:raw="Zero if the two handles are equal, and a non-zero value if they are not.">Нуль, если два дескриптора равны, и ненулевое значение в противном случае.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned." />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned." />
    </member>
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary vsli:raw="Gets the type symbol for a generalized array of the given element type and shape.">Возвращает символ типа для универсального массива с заданным типом элементов и формой.</summary>
      <param name="elementType" vsli:raw="The type of the elements in the array.">Тип элементов массива.</param>
      <param name="shape" vsli:raw="The shape (rank, sizes, and lower bounds) of the array.">Форма (ранг, размеры и нижние границы) массива.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary vsli:raw="Gets the type symbol for a managed pointer to the given element type.">Возвращает символ типа для управляемого указателя на заданный тип элементов.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Gets the type symbol for a generic instantiation of the given generic type with the given type arguments.">Возвращает символ типа для универсального экземпляра заданного универсального типа с заданными аргументами типа.</summary>
      <param name="genericType" vsli:raw="" />
      <param name="typeArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary vsli:raw="Gets the type symbol for an unmanaged pointer to the given element type.">Возвращает символ типа для неуправляемого указателя на заданный тип элементов.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary vsli:raw="Gets the &lt;typeparamref name=&quot;TType&quot; /&gt; representation for &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Возвращает представление <typeparamref name="TType" /> для <see cref="T:System.Type" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary vsli:raw="Gets the type symbol for the given serialized type name.">Возвращает символ типа для имени заданного сериализованного типа.</summary>
      <param name="name" vsli:raw="The serialized type name in so-called &quot;reflection notation&quot; format (as understood by the &lt;see cref=&quot;M:System.Type.GetType(System.String)&quot; /&gt; method.)">Имя сериализованного типа в так называемом формате "нотации отражения" (как его понимает метод <see cref="M:System.Type.GetType(System.String)" />).</param>
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">Экземпляр <typeparamref name="TType" />.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The name is malformed.">Имя имеет неправильный формат.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary vsli:raw="Gets the underlying type of the given enum type symbol.">Возвращает базовый тип заданного символа типа перечисления.</summary>
      <param name="type" vsli:raw="An enum type.">Тип перечисления.</param>
      <returns vsli:raw="A type code that indicates the underlying type of the enumeration.">Код типа, указывающий базовый тип перечисления.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The given type symbol does not represent an enum.">Символ заданного типа не представляет перечисление.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary vsli:raw="Verifies if the given type represents &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Проверяет, представляет ли заданный тип <see cref="T:System.Type" />.</summary>
      <param name="type" vsli:raw="The type to verify.">Проверяемый тип.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given type is a &lt;see cref=&quot;T:System.Type&quot; /&gt;, &lt;see langword=&quot;false&quot; /&gt; otherwise.">Значение <see langword="true" />, если заданный тип является <see cref="T:System.Type" />, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Calculates the size of the specified branch instruction operand.">Вычисляет размер операнда инструкции указанной ветви.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">Код операции ветви.</param>
      <returns vsli:raw="1 if &lt;paramref name=&quot;opCode&quot; /&gt; is a short branch, or 4 if it is a long branch.">1, если <paramref name="opCode" /> является короткой ветвью, или 4, если это длинная ветвь.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">Указанный <paramref name="opCode" /> не является кодом операции ветви.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a long form of the specified branch op-code.">Возвращает длинную форму кода операции указанной ветви.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">Код операции ветви.</param>
      <returns vsli:raw="The long form of the branch op-code.">Длинная форма кода операции ветви.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">Указанный <paramref name="opCode" /> не является кодом операции ветви.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a short form of the specified branch op-code.">Возвращает короткую форму кода операции указанной ветви.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">Код операции ветви.</param>
      <returns vsli:raw="The short form of the branch op-code.">Короткая форма кода операции ветви.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">Указанный <paramref name="opCode" /> не является кодом операции ветви.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Verifies if the specified op-code is a branch to a label.">Проверяет, является ли указанный код операции ветвью для метки.</summary>
      <param name="opCode" vsli:raw="" />
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified op-code is a branch to a label, &lt;see langword=&quot;false&quot; /&gt; otherwise.">Значение <see langword="true" />, если указанный код операции является ветвью для метки, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary vsli:raw="The exception that is thrown when an attempt to write metadata exceeds a limit given by the format specification. For example, when the heap size limit is exceeded.">Исключение, порождаемое при попытке записи метаданных, превышающих предельное значение, заданное спецификацией формата. Например, если превышено ограничение размера кучи.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with serialized data.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> с сериализованными данными.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Объект, содержащий сериализованные данные объекта.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> с указанным сообщением об ошибке.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">Сообщение об ошибке с объяснением причины исключения.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message and the exception that is the cause of this exception.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> с заданным сообщением об ошибке и ссылкой на внутреннее исключение, которое стало причиной данного исключения.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception, or &lt;see langword=&quot;null&quot; /&gt; if no inner exception is specified.">Исключение, вызвавшее текущее исключение, или значение <see langword="null" />, если внутреннее исключение не задано.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <exception cref="T:System.BadImageFormatException" vsli:raw="Invalid blob format.">Недопустимый формат BLOB-объекта.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary vsli:raw="Provides information about the lexical scope within which a group of imports are available. This information is stored in debug metadata.">Предоставляет сведения о лексической области, в которой доступна группа операций импорта. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary vsli:raw="Gets the interface that is implemented (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;).">Возвращает реализованный интерфейс (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary vsli:raw="Gets the type symbol for the function pointer type of the given method &lt;paramref name=&quot;signature&quot; /&gt;.">Получает символ типа для типа указателя на функцию заданного метода <paramref name="signature" />.</summary>
      <param name="signature" vsli:raw="" />
      <returns vsli:raw="The type symbol for the function pointer type.">Символ типа для типа указателя на функцию.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic method parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Получает символ типа для параметра универсального метода в заданной отсчитываемой от нуля позиции <paramref name="index" />.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic method parameter at &lt;paramref name=&quot;index&quot; /&gt;.">Символ типа для параметра универсального метода в позиции <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Получает символ типа для параметра универсального типа в заданной отсчитываемой от нуля позиции <paramref name="index" />.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Символ типа для параметра универсального типа в заданной отсчитываемой от нуля позиции <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary vsli:raw="Gets the type symbol for a type with a custom modifier applied.">Получает символ типа для типа с примененным пользовательским модификатором.</summary>
      <param name="modifier" vsli:raw="The modifier type applied.">Примененный тип модификатора.</param>
      <param name="unmodifiedType" vsli:raw="The type symbol of the underlying type without modifiers applied.">Символ типа для базового типа без примененных модификаторов.</param>
      <param name="isRequired" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the modifier is required, &lt;see langword=&quot;false&quot; /&gt; if it's optional.">
        <see langword="true" />, если модификатор является обязательным, <see langword="false" /> — если он необязателен.</param>
      <returns vsli:raw="The type symbol.">Символ типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary vsli:raw="Gets the type symbol for a local variable type that is marked as pinned.">Получает символ типа для типа локальной переменной, помеченный как закрепленный.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="The type symbol for the local variable type.">Символ типа для типа локальной переменной.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type specification.">Получает тип символа для спецификации типа.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">Средство чтения метаданных, переданное декодеру подписи. Может иметь значение <see langword="null" />.</param>
      <param name="genericContext" vsli:raw="The context that was passed to the signature decoder.">Контекст, переданный декодеру подписи.</param>
      <param name="handle" vsli:raw="The type specification handle.">Дескриптор спецификации типа.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">Вид типа, как указано в подписи. Для интерпретации этого значения следует использовать <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol for the type specification.">Символ типа для спецификации типа.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Gets the type symbol for a primitive type.">Получает символ типа для типа-примитива.</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="The type symbol for &lt;paramref name=&quot;typeCode&quot; /&gt;.">Символ типа для <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type definition.">Получает символ типа для определения типа.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">Средство чтения метаданных, переданное декодеру подписи. Может иметь значение <see langword="null" />.</param>
      <param name="handle" vsli:raw="The type definition handle.">Дескриптор определения типа.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">Вид типа, как указано в подписи. Для интерпретации этого значения следует использовать <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol.">Символ типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type reference.">Получает символ типа для ссылочного типа.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">Средство чтения метаданных, переданное декодеру подписи. Может иметь значение <see langword="null" />.</param>
      <param name="handle" vsli:raw="The type definition handle.">Дескриптор определения типа.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">Вид типа, как указано в подписи. Для интерпретации этого значения следует использовать <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol.">Символ типа.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary vsli:raw="Gets the type symbol for a single-dimensional array of the given element type with a lower bounds of zero.">Возвращает символ типа для одномерного массива с заданным типом элементов, где нижняя граница равна нулю.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">Экземпляр <typeparamref name="TType" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary vsli:raw="Provides information about local constants. This information is stored in debug metadata.">Предоставляет сведения о локальных константах. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary vsli:raw="Gets the constant signature.">Возвращает подпись константы.</summary>
      <returns vsli:raw="The constant signature.">Сигнатура константы.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary vsli:raw="Provides information about the scope of local variables and constants. This information is stored in debug metadata.">Предоставляет сведения об области действия локальных переменных и констант. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary vsli:raw="Provides information about local variables. This information is stored in debug metadata.">Предоставляет сведения о локальных переменных. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary vsli:raw="Gets the manifest resource attributes.">Возвращает атрибуты ресурса манифеста.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that specify the manifest resource attributes.">Побитовое сочетание значений перечисления, задающих атрибуты ресурса манифеста.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary vsli:raw="Gets the implementation entity handle.">Возвращает дескриптор сущности реализации.</summary>
      <returns vsli:raw="An EntityHandle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">Экземпляр Ентитихандле. Если свойство <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> имеет значение <see langword="true" />, возвращаемый обработчик будет иметь значения по умолчанию.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary vsli:raw="Gets the resource name.">Возвращает имя ресурса.</summary>
      <returns vsli:raw="The resource name.">Имя ресурса.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary vsli:raw="Gets the byte offset within the referenced file at which this resource record begins.">Возвращает смещение в байтах, с которого начинается эта запись ресурса в указанном файле.</summary>
      <returns vsli:raw="The byte offset within the referenced file at which this resource record begins.">Смещение в байтах в упоминаемом файле, с которого начинается Эта запись ресурса.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt; instances.">Представляет коллекцию экземпляров <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary vsli:raw="Determines if the member reference is to a method or field.">Определяет, указывает ли ссылка на член на метод или поле.</summary>
      <returns vsli:raw="One of the enumeration values that indicates the kind of member reference.">Одно из значений перечисления, обозначающее тип ссылки на член.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The member reference signature is invalid.">Сигнатура ссылки на член недопустима.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary vsli:raw="Gets the parent entity handle.">Возвращает дескриптор родительской сущности.</summary>
      <returns vsli:raw="An entity handle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">Экземпляр обработчика сущности. Если свойство <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> имеет значение <see langword="true" />, возвращаемый обработчик будет иметь значения по умолчанию.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Возвращает дескриптор в BLOB-объект сигнатуры.</summary>
      <returns vsli:raw="A handle to the signature blob.">Маркер для большого двоичного объекта сигнатуры.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt; instances.">Представляет коллекцию экземпляров <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary vsli:raw="Specifies constants that indicate whether a &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method or field.">Задает константы, указывающие, на что ссылается <see cref="T:System.Reflection.Metadata.MemberReference" />: на метод или поле.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a field.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> ссылается на поле.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> ссылается на метод.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary vsli:raw="CLI metadata.">Метаданные CLI.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary vsli:raw="Windows metadata generated by managed compilers.">Метаданные Windows, созданные управляемыми компиляторами.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary vsli:raw="Windows metadata.">Метаданные Windows.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary vsli:raw="Reads metadata as defined by the ECMA 335 CLI specification.">Считывает метаданные в соответствии с определением в спецификации CLI ECMA 335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataReader" /> на основе метаданных, хранящихся в указанном месте памяти.</summary>
      <param name="metadata" vsli:raw="A pointer to the first byte in a block of metadata.">Указатель на первый байт в блоке метаданных.</param>
      <param name="length" vsli:raw="The number of bytes in the block.">Количество байтов в блоке.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataReader" /> на основе метаданных, хранящихся в указанном месте памяти.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataReader" /> на основе метаданных, хранящихся в указанном месте памяти.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
      <param name="utf8Decoder" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is not positive.">
        <paramref name="length" /> не является положительным числом.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;metadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="metadata" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">Кодировка <paramref name="utf8Decoder" /> не является <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad metadata header.">Неправильный заголовок метаданных.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary vsli:raw="Gets the information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">Возвращает декодированные данные из потока #Pdb или значение <see langword="null" />, если поток отсутствует.</summary>
      <returns vsli:raw="The information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">Сведения, декодированные из #Pdb потока или <see langword="null" />, если поток отсутствует.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary vsli:raw="Gets a value that indicates whether the metadata represents an assembly.">Возвращает значение, указывающее, представляют ли метаданные сборку.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the metadata represents an assembly; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если метаданные представляют сборку; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary vsli:raw="Gets the metadata kind.">Возвращает тип метаданных.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the metadata kind.">Одно из значений перечисления, указывающее тип метаданных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary vsli:raw="Gets the length of the underlying data.">Возвращает длину базовых данных.</summary>
      <returns vsli:raw="The length of the underlying data.">Длина базовых данных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary vsli:raw="Gets the pointer to the underlying data.">Возвращает указатель на базовые данные.</summary>
      <returns vsli:raw="The pointer to the underlying data.">Указатель на базовые данные.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary vsli:raw="Gets the version string read from metadata header.">Возвращает строку версии, считанную из заголовка метаданных.</summary>
      <returns vsli:raw="The version string read from metadata header.">Строка версии, считанная из заголовка метаданных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; passed to the constructor.">Возвращает объект <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />, переданный в конструктор.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that describes the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; enum value.">Побитовое сочетание значений перечисления, которое описывает значение перечисления <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary vsli:raw="Gets the comparer used to compare strings stored in metadata.">Возвращает функцию сравнения, которая используется для сравнения строк, хранящихся в метаданных.</summary>
      <returns vsli:raw="The comparer used to compare strings stored in metadata.">Функция сравнения, используемая для сравнения строк, хранящихся в метаданных.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary vsli:raw="Gets the decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">Возвращает декодер, используемый средством чтения для создания экземпляров строк на основе последовательностей байтов в кодировке UTF8.</summary>
      <returns vsli:raw="The decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">Декодер, используемый модулем чтения для создания строковых экземпляров из последовательностей байтов в кодировке UTF8.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary vsli:raw="Windows Runtime projections are enabled (on by default).">Проекции среды выполнения Windows включены (по умолчанию).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary vsli:raw="The options that are used when a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; is obtained via an overload that does not take a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; argument.">Параметры, используемые при получении <see cref="T:System.Reflection.Metadata.MetadataReader" /> с помощью перегрузки, которая не принимает аргумент <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary vsli:raw="All options are disabled.">Все параметры отключены.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; for metadata stored in an array of bytes, a memory block, or a stream.">Предоставляет <see cref="T:System.Reflection.Metadata.MetadataReader" /> для метаданных, хранящихся в массиве байтов, блоке памяти или потоке.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">Удаляет весь объем памяти, выделенный средством чтения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a metadata provider over an image stored in memory.">Создает поставщик метаданных для образа, хранящегося в памяти.</summary>
      <param name="start" vsli:raw="Pointer to the start of the metadata blob.">Указатель на начало BLOB-объекта метаданных.</param>
      <param name="size" vsli:raw="The size of the metadata blob.">Размер BLOB-объекта метаданных.</param>
      <returns vsli:raw="The new metadata provider.">Новый поставщик метаданных.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">Свойство <paramref name="start" /> имеет значение <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a provider over a byte array.">Создает поставщик для массива байтов.</summary>
      <param name="image" vsli:raw="Metadata image.">Образ метаданных.</param>
      <returns vsli:raw="The new provider.">Новый поставщик.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">Создает поставщик для потока указанного размера, начиная с его текущей позиции.</summary>
      <param name="stream" vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; instance.">Экземпляр <see cref="T:System.IO.Stream" />.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">Параметры, которые определяют способ считывания разделов образа из потока.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">Размер BLOB-объекта метаданных в потоке. Если не указан, предполагается, что размер BLOB-объекта метаданных достигает конца потока.</param>
      <returns vsli:raw="The new provider.">Новый поставщик.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> не поддерживает операции чтения и поиска.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">Размер является отрицательным или превышает длину потока.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata&quot; /&gt; is specified).">Ошибка при чтении из потока (только если указан <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a portable PDB metadata provider over a blob stored in memory.">Создает поставщик метаданных переносимого PDB-файла для BLOB-объекта, хранящегося в памяти.</summary>
      <param name="start" vsli:raw="Pointer to the start of the portable PDB blob.">Указатель на начало BLOB-объекта переносимого PDB-файла.</param>
      <param name="size" vsli:raw="The size of the portable PDB blob.">Размер BLOB-объекта переносимого PDB-файла.</param>
      <returns vsli:raw="The new portable PDB metadata provider.">Новый поставщик метаданных переносимого PDB-файла.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">Свойство <paramref name="start" /> имеет значение <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a portable PDB metadata provider over a byte array.">Создает поставщик метаданных переносимого PDB-файла для массива данных.</summary>
      <param name="image" vsli:raw="A portable PDB image.">Образ переносимого PDB-файла.</param>
      <returns vsli:raw="The new portable PDB metadata provider .">Новый поставщик метаданных переносимого PDB-файла.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">Создает поставщик для потока указанного размера, начиная с его текущей позиции.</summary>
      <param name="stream" vsli:raw="The stream.">Поток.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">Параметры, которые определяют способ считывания разделов образа из потока.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">Размер BLOB-объекта метаданных в потоке. Если не указан, предполагается, что размер BLOB-объекта метаданных достигает конца потока.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; instance.">Экземпляр <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> не поддерживает операции чтения и поиска.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">Размер является отрицательным или превышает длину потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt;.">Получает <see cref="T:System.Reflection.Metadata.MetadataReader" /> из <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
      <param name="options" vsli:raw="A bitwise combination of the enumeration values that represent the configuration when reading the metadata.">Битовая комбинация значений перечисления, которые определяют конфигурацию при чтении метаданных.</param>
      <param name="utf8Decoder" vsli:raw="The encoding to use.">Используемая кодировка.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; instance.">Экземпляр <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">Кодировка <paramref name="utf8Decoder" /> не является <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="Provider has been disposed.">Поставщик был удален.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed and sections of the PE image are read lazily.">По умолчанию при удалении объекта <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> поток удаляется и разделы образа PE считываются в отложенном режиме.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed.">Сохраняет поток открытым при удалении объекта <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads PDB metadata into memory right away.&lt;/para&gt;&lt;para&gt;The underlying file may be closed and even deleted after the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is constructed. &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen&quot; /&gt; is specified.&lt;/para&gt;">Считывает метаданные PDB в память немедленно.
После создания <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> базовый файл может быть закрыт и даже удален. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> автоматически закрывает поток, когда конструктор возвращает управление, если не указан параметр <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary vsli:raw="Provides string comparison helpers to query strings in metadata while avoiding allocation if possible.">Предоставляет вспомогательные методы сравнения строк для запроса строк в метаданных, по возможности избегая выделения.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary vsli:raw="Provides the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; with a custom mechanism for decoding byte sequences in metadata that represent text.">Предоставляет объект <see cref="T:System.Reflection.Metadata.MetadataReader" /> с пользовательским механизмом для декодирования последовательностей байтов в метаданных, представляющих текст.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataStringDecoder&quot; /&gt; class using the given encoding.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> с использованием заданной кодировки.</summary>
      <param name="encoding" vsli:raw="The encoding to use.">Используемая кодировка.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary vsli:raw="Gets the default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8 when no decoder is provided to the constructor.">Возвращает декодер по умолчанию, используемый объектом <see cref="T:System.Reflection.Metadata.MetadataReader" /> для расшифровки формата UTF-8, если декодер не указан в конструкторе.</summary>
      <returns vsli:raw="The default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8.">Декодер по умолчанию, используемый <see cref="T:System.Reflection.Metadata.MetadataReader" /> для декодирования UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary vsli:raw="Gets the encoding used by this instance.">Возвращает кодировку, используемую этим экземпляром.</summary>
      <returns vsli:raw="The encoding used by this instance.">Кодировка, используемая этим экземпляром.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary vsli:raw="Obtains strings for byte sequences in metadata. Override this to cache strings if required. Otherwise, it is implemented by forwarding straight to &lt;see cref=&quot;P:System.Reflection.Metadata.MetadataStringDecoder.Encoding&quot; /&gt; and every call will allocate a new string.">Получает строки для последовательностей байтов в метаданных. Переопределите, если необходимо кэшировать строки. В противном случае реализация будет выполнять переадресацию непосредственно в <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> и выделять новую строку для каждого вызова.</summary>
      <param name="bytes" vsli:raw="Pointer to bytes to decode.">Указатель на декодируемые байты.</param>
      <param name="byteCount" vsli:raw="Number of bytes to decode.">Число декодируемых байтов.</param>
      <returns vsli:raw="The decoded string.">Декодированная строка.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" vsli:raw="The blob reader to read the method body." />
    </member>
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary vsli:raw="Gets the size of the method body, including the header, IL, and exception regions.">Возвращает размер тела метода, включая области заголовка, промежуточного языка и исключения.</summary>
      <returns vsli:raw="The size of the method body.">Размер тела метода.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary vsli:raw="Provides debug information associated with a method definition. This information is stored in debug metadata.">Предоставляет отладочную информацию, связанную с определением метода. Эта информация хранится в метаданных отладки.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary vsli:raw="Gets the handle of the single document containing all sequence points of the method.">Возвращает дескриптор отдельного документа, содержащий все точки последовательности метода.</summary>
      <returns vsli:raw="The handle of the single document containing all sequence points of the method, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.DocumentHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">Маркер одного документа, содержащего все точки последовательности метода, или маркер, свойство <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> которого имеет значение <see langword="true" />, если метод не имеет точек следования или охватывает несколько документов.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary vsli:raw="Returns a collection of sequence points decoded from &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob&quot; /&gt;.">Возвращает коллекцию точек последовательности, декодированную из <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.</summary>
      <returns vsli:raw="A collection of sequence points.">Коллекция точек последовательности.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary vsli:raw="Returns the kickoff method of the state machine.">Возвращает начальный метод конечного автомата.</summary>
      <returns vsli:raw="The kickoff method of the state machine, if the method is a &lt;c&gt;MoveNext&lt;/c&gt; method of a state machine. Otherwise, it returns a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">Начальный метод конечного автомата, если это метод <c>MoveNext</c> конечного автомата. В противном случае возвращает дескриптор, свойство <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> которого равно <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary vsli:raw="Returns a local signature handle.">Возвращает дескриптор локальной сигнатуры.</summary>
      <returns vsli:raw="A local signature handle, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't define any local variables.">Локальный обработчик сигнатур или обработчик, свойство <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> которого имеет значение <see langword="true" />, если метод не определяет никакие локальные переменные.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary vsli:raw="Returns a blob encoding sequence points.">Возвращает BLOB-объект, кодирующий точки последовательности.</summary>
      <returns vsli:raw="A blob encoding sequence points, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.BlobHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points.">Точки последовательности кодирования BLOB-объектов или маркер, свойство <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> которого имеет значение <see langword="true" />, если у метода нет точек следования.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt; that corresponds to this handle.">Возвращает дескриптор в <see cref="T:System.Reflection.Metadata.MethodDefinition" />, соответствующий этому дескриптору.</summary>
      <returns vsli:raw="A method definition handle that corresponds to this handle.">Дескриптор определения метода, соответствующий этому дескриптору.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDebugInformation&quot; /&gt; that corresponds to this handle.">Возвращает дескриптор в <see cref="T:System.Reflection.Metadata.MethodDebugInformation" />, соответствующий этому дескриптору.</summary>
      <returns vsli:raw="A method debug information handle that corresponds to this handle.">Дескриптор отладочной информации метода, соответствующий этому дескриптору.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary vsli:raw="Represents a method (definition, reference, or standalone) or property signature. In the case of properties, the signature matches that of a getter with a distinguishing &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt;.">Представляет метод (определение, ссылку и автономный) или сигнатуру свойства. В случае свойств сигнатура соответствует методу получения с отличительным заголовком <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <typeparam name="TType" vsli:raw="The method type.">Тип метода.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSignature`1&quot; /&gt; structure using the specified header, return type, and parameter information.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> с использованием заданных сведений о заголовке, типе возвращаемого значения и параметре.</summary>
      <param name="header" vsli:raw="The information in the leading byte of the signature (kind, calling convention, flags).">Сведения в начальном байте сигнатуры (вид, соглашение о вызовах, флаги).</param>
      <param name="returnType" vsli:raw="The return type of the method.">Тип возвращаемых данных метода.</param>
      <param name="requiredParameterCount" vsli:raw="The number of required parameters.">Число обязательных параметров.</param>
      <param name="genericParameterCount" vsli:raw="The number of generic type parameters.">Число параметров универсального типа.</param>
      <param name="parameterTypes" vsli:raw="The parameter types.">Типы параметров.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary vsli:raw="Gets the number of generic type parameters for the method.">Получает число параметров универсального типа для метода.</summary>
      <returns vsli:raw="The number of generic type parameters, or 0 for non-generic methods.">Число параметров универсального типа или 0 для методов, не являющихся универсальными.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary vsli:raw="Gets the information in the leading byte of the signature (kind, calling convention, flags).">Получает сведения из начального байта сигнатуры (вид, соглашение о вызовах, флаги).</summary>
      <returns vsli:raw="The header signature.">Подпись заголовка.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary vsli:raw="Gets the method's parameter types.">Получает типы параметров метода.</summary>
      <returns vsli:raw="An immutable collection of parameter types.">Неизменяемая Коллекция типов параметров.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary vsli:raw="Gets the number of parameters that are required for the method.">Получает число необходимых для метода параметров.</summary>
      <returns vsli:raw="The number of required parameters.">Число обязательных параметров.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary vsli:raw="Gets the return type of the method.">Получает возвращаемый тип метода.</summary>
      <returns vsli:raw="The return type.">Тип возвращаемого значения.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary vsli:raw="Gets a &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to (that is, which generic method it is an instantiation of).">Возвращает дескриптор <see langword="MethodDef" /> или <see langword="MemberRef" />, указывая, на какой универсальный метод ссылается этот экземпляр (то есть экземпляром какого универсального метода он является).</summary>
      <returns vsli:raw="A &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to.">
        <see langword="MethodDef" /> или <see langword="MemberRef" />ный обработчик, указывающий, к какому универсальному методу относится этот экземпляр.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Возвращает дескриптор в BLOB-объект сигнатуры.</summary>
      <returns vsli:raw="A handle to the signature blob.">Маркер для большого двоичного объекта сигнатуры.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary vsli:raw="Gets all exported types that reside directly in a namespace.">Получает все экспортированные типы, которые находятся непосредственно в пространстве имен.</summary>
      <returns vsli:raw="An immutable array of exported type handles.">Неизменяемый массив экспортируемых дескрипторов типа.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary vsli:raw="Gets the unqualified name of the namespace definition.">Получает неполное имя определения пространства имен.</summary>
      <returns vsli:raw="The unqualified name of the namespace definition.">Неполное имя определения пространства имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary vsli:raw="Gets the namespace definitions that are direct children of the current namespace definition.">Получает определения пространств имен, которые являются прямыми потомками текущего определения пространства имен.</summary>
      <returns vsli:raw="An immutable array of namespace definitions that are direct children of the current namespace definition.">Неизменяемый массив определений пространств имен, которые являются прямыми дочерними элементами текущего определения пространства имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary vsli:raw="Gets the parent namespace.">Получает родительское пространство имен.</summary>
      <returns vsli:raw="The parent namespace.">Родительское пространство имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary vsli:raw="Gets all type definitions that reside directly in a namespace.">Получает все определения типов, которые находятся непосредственно в пространстве имен.</summary>
      <returns vsli:raw="An immutable array of type definition handles.">Неизменяемый массив дескрипторов определения типа.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary vsli:raw="Provides a handle to a namespace definition.">Предоставляет дескриптор для определения пространства имен.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary vsli:raw="Contains a collection of parameters of a specified method.">Содержит коллекцию параметров указанного метода.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Получает <see cref="T:System.Reflection.Metadata.MetadataReader" /> из <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <returns vsli:raw="A metadata reader.">Средство чтения метаданных.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Возвращает модуль чтения метаданных с заданной конфигурацией чтения метаданных из <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">Значение перечисления, указывающее конфигурацию чтения метаданных.</param>
      <returns vsli:raw="A metadata reader with the specified metadata reading configuration.">Модуль чтения метаданных с заданной конфигурацией чтения метаданных.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration and encoding configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Возвращает модуль чтения метаданных с заданной конфигурацией чтения метаданных и конфигурацией кодировки из <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">Значение перечисления, указывающее конфигурацию чтения метаданных.</param>
      <param name="utf8Decoder" vsli:raw="A metadata string decoder with the encoding configuration.">Декодер строк метаданных с конфигурацией кодировки.</param>
      <returns vsli:raw="&amp;gt;A metadata reader with the specified metadata reading configuration and encoding configuration.">&gt;Модуль чтения метаданных с заданной конфигурацией чтения метаданных и конфигурацией кодировки.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">Кодировка <paramref name="utf8Decoder" /> не является <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Текущая платформа поддерживает обратный порядок байтов.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary vsli:raw="Returns a body block of a method with the specified Relative Virtual Address (RVA).">Возвращает блок тела метода с указанным относительным виртуальным адресом.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Текущий экземпляр <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</param>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address (RVA).">Относительный виртуальный адрес.</param>
      <returns vsli:raw="A method block body instance.">Экземпляр блока тела метода.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="peReader" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The body is not found in the metadata or is invalid.">Тело не найдено в метаданных или является недопустимым.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The section where the method is stored is not available.">Раздел, где хранится метод, недоступен.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error occurred while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary vsli:raw="Specifies constants that define the type codes used to encode types of primitive values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttribute&quot; /&gt; value blob.">Задает константы, определяющие коды типов, используемые для кодирования типов значений-примитивов в BLOB-объекте значений <see cref="T:System.Reflection.Metadata.CustomAttribute" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">Тип <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer type.">Тип 1-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">Тип <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">Тип 8-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">Тип 2-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">Тип 4-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">Тип 8-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">Тип 1-байтового целого числа со знаком.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">Тип 4-байтового числа с плавающей запятой.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Тип <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">Тип 2-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">Тип 4-байтового целого числа без знака.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">Тип 8-байтового целого числа без знака.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary vsli:raw="Specifies constants that define primitive types found in metadata signatures.">Задает константы, определяющие обнаруженные в сигнатурах метаданных типы-примитивы.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">Тип <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; type.">Тип <see cref="T:System.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">Тип <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Double&quot; /&gt; type.">Тип <see cref="T:System.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int16&quot; /&gt; type.">Тип <see cref="T:System.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">Тип <see cref="T:System.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int64&quot; /&gt; type.">Тип <see cref="T:System.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; type.">Тип <see cref="T:System.IntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; type.">Тип <see cref="T:System.Object" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.SByte&quot; /&gt; type.">Тип <see cref="T:System.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Single&quot; /&gt; type.">Тип <see cref="T:System.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Тип <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary vsli:raw="A typed reference.">Типизированная ссылка.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt16&quot; /&gt; type.">Тип <see cref="T:System.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt32&quot; /&gt; type.">Тип <see cref="T:System.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt64&quot; /&gt; type.">Тип <see cref="T:System.UInt64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; type.">Тип <see cref="T:System.UIntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">Тип <see cref="T:System.Void" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary vsli:raw="Represents a handle and a corresponding blob on a metadata heap that was reserved for future content update.">Представляет маркер и соответствующий BLOB-объект в куче метаданных, которая была зарезервирована для обновления содержимого в будущем.</summary>
      <typeparam name="THandle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt; to be used to update the content.">Возвращает <see cref="T:System.Reflection.Metadata.BlobWriter" />, используемый для обновления содержимого.</summary>
      <returns vsli:raw="A blob writer to be used to update the content.">Модуль записи BLOB-объектов, используемый для обновления содержимого.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary vsli:raw="Gets the reserved blob handle.">Возвращает дескриптор зарезервированных BLOB-объектов.</summary>
      <returns vsli:raw="The reserved bloc handle.">Зарезервированный маркер блока.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" vsli:raw="The object to compare with the current object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary vsli:raw="Specifies type codes used to encode the types of values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; blob.">Указывает коды типов, используемые для шифрования типов значений в BLOB-объекте <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Boolean&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Byte&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Char&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Double&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary vsli:raw="The attribute argument is an Enum instance.">Аргумент атрибута — это экземпляр перечисления.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int16&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int32&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int64&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SByte&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Single&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.String&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SZArray&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary vsli:raw="The attribute argument is &quot;boxed&quot; (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.">Аргумент атрибута "упаковывается" (передается параметру, полю или свойству объекта типа) и содержит информацию о типе в BLOB-объекте атрибута.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary vsli:raw="The attribute argument is a &lt;see cref=&quot;T:System.Type&quot; /&gt; instance.">Аргумент атрибута — это экземпляр <see cref="T:System.Type" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt16&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt32&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt64&quot; /&gt;.">Значение, эквивалентное <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary vsli:raw="Specifies additional flags that can be applied to method signatures. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Задает дополнительные флаги, которые можно применить к сигнатурам метода. Базовые значения полей в этом типе соответствуют представлению в начальном байте сигнатуры, представленном структурой <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary vsli:raw="Indicates the first explicitly declared parameter that represents the instance pointer.">Указывает на первый явным образом объявленный параметр, представляющий указатель на экземпляр.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary vsli:raw="A generic method.">Универсальный метод.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary vsli:raw="&lt;para&gt;An instance method.&lt;/para&gt;&lt;para&gt;The Ecma 335 CLI Specification refers to this flag as &lt;see langword=&quot;HAS_THIS&quot; /&gt;.&lt;/para&gt;">Метод экземпляра.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary vsli:raw="No flags.">Флаги отсутствуют.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary vsli:raw="Specifies how arguments in a given signature are passed from the caller to the callee. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Указывает, как передаются аргументы в данной сигнатуре из вызывающего объекта в вызываемый. Базовые значения полей в этом типе соответствуют представлению в начальном байте сигнатуры, представленном структурой <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary vsli:raw="An unmanaged C/C++ style calling convention where the call stack is cleaned by the caller.">Неуправляемое соглашение о вызовах в стиле C/C++, где стек вызовов очищается вызывающим объектом.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary vsli:raw="A managed calling convention with a fixed-length argument list.">Управляемое соглашение о вызовах со списком аргументов фиксированной длины.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary vsli:raw="An unmanaged calling convention where arguments are passed in registers when possible.">Неуправляемое соглашение о вызовах, в котором аргументы по возможности передаются в регистры.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary vsli:raw="An unmanaged calling convention where the call stack is cleaned up by the callee.">Неуправляемое соглашение о вызовах, где стек вызовов очищается вызываемым объектом.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary vsli:raw="An unmanaged C++ style calling convention for calling instance member functions with a fixed argument list.">Неуправляемое соглашение о вызовах в стиле C/C++ для вызова функций элемента экземпляра с фиксированным списком аргументов.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary vsli:raw="A managed calling convention for passing extra arguments.">Управляемое соглашение о вызовах для передачи дополнительных аргументов.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary vsli:raw="Represents the signature characteristics specified by the leading byte of signature blobs.">Представляет характеристики сигнатуры, заданные начальным байтом BLOB-объектов сигнатуры.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified byte value.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.SignatureHeader" /> с использованием заданного байтового значения.</summary>
      <param name="rawValue" vsli:raw="The byte.">Тип byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified signature kind, calling convention and signature attributes.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.Metadata.SignatureHeader" /> с помощью указанного типа сигнатуры и атрибутов соглашения о вызовах и сигнатуры.</summary>
      <param name="kind" vsli:raw="The signature kind.">Тип сигнатуры.</param>
      <param name="convention" vsli:raw="The calling convention.">Соглашение о вызовах.</param>
      <param name="attributes" vsli:raw="The signature attributes.">Атрибуты сигнатуры.</param>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary vsli:raw="Gets the signature attributes.">Получает атрибуты сигнатуры.</summary>
      <returns vsli:raw="The attributes.">Атрибуты.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary vsli:raw="Gets the calling convention.">Получает соглашение о вызовах.</summary>
      <returns vsli:raw="The calling convention.">Соглашение о вызовах.</returns>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary vsli:raw="Gets the mask value for the calling convention or signature kind. The default &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask&quot; /&gt; value is 15 (0x0F).">Получает значение маски для типа соглашения о вызовах или сигнатуры. Значение <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> по умолчанию — 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary vsli:raw="Compares the specified object with this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; for equality.">Сравнивает заданный объект с этим <see cref="T:System.Reflection.Metadata.SignatureHeader" /> на равенство.</summary>
      <param name="obj" vsli:raw="The object to compare.">Объект для сравнения.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если объекты равны, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">Сравнивает два значения <see cref="T:System.Reflection.Metadata.SignatureHeader" /> на предмет их равенства.</summary>
      <param name="other" vsli:raw="The value to compare.">Значение для сравнения.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если значения равны; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current object.">Получает хэш-код для текущего объекта.</summary>
      <returns vsli:raw="A hash code for the current object.">Хэш-код для текущего объекта.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; signature attribute.">Получает значение, указывающее, имеет ли эта структура <see cref="T:System.Reflection.Metadata.SignatureHeader" /> атрибут сигнатуры <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />значение , <see langword="false" /> если атрибут имеется; в противном случае —. <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; signature attribute.">Получает значение, указывающее, имеет ли эта структура <see cref="T:System.Reflection.Metadata.SignatureHeader" /> атрибут сигнатуры <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />значение , <see langword="false" /> если атрибут имеется; в противном случае —. <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; signature attribute.">Получает значение, указывающее, имеет ли эта структура <see cref="T:System.Reflection.Metadata.SignatureHeader" /> атрибут сигнатуры <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />значение , <see langword="false" /> если атрибут имеется; в противном случае —. <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /></returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary vsli:raw="Gets the signature kind.">Получает тип сигнатуры.</summary>
      <returns vsli:raw="The signature kind.">Тип сигнатуры.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">Сравнивает два значения <see cref="T:System.Reflection.Metadata.SignatureHeader" /> на предмет их равенства.</summary>
      <param name="left" vsli:raw="The first value to compare.">Первое сравниваемое значение.</param>
      <param name="right" vsli:raw="The second value to compare.">Второе сравниваемое значение.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если значения равны; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values are unequal.">Определяет неравенство двух значений <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="left" vsli:raw="The first value to compare.">Первое сравниваемое значение.</param>
      <param name="right" vsli:raw="The second value to compare.">Второе сравниваемое значение.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если значения неравны; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary vsli:raw="Gets the raw value of the header byte.">Получает необработанное значение заголовка byte.</summary>
      <returns vsli:raw="The raw value of the header byte.">Необработанное значение байта заголовка.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary vsli:raw="Returns a string that represents the current object.">Возвращает строку, представляющую текущий объект.</summary>
      <returns vsli:raw="A string that represents the current object.">Строка, представляющая текущий объект.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary vsli:raw="Specifies the signature kind. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Задает вид сигнатуры. Базовые значения полей в этом типе соответствуют представлению в начальном байте сигнатуры, представленном структурой <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary vsli:raw="A field signature.">Сигнатура поля.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary vsli:raw="A local variables signature.">Сигнатура локальных переменных.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary vsli:raw="A method reference, method definition, or standalone method signature.">Сигнатура ссылки на метод, определения метода или автономного метода.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary vsli:raw="A method specification signature.">Сигнатура спецификации метода.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary vsli:raw="A property signature.">Сигнатура свойства.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary vsli:raw="Specifies constants that define type codes used in signature encoding.">Задает константы, определяющие коды типов, используемые в шифровании сигнатур.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary vsli:raw="Represents a generalized &lt;see cref=&quot;T:System.Array&quot; /&gt; in signatures.">Представляет обобщенный <see cref="T:System.Array" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; in signatures.">Представляет <see cref="T:System.Boolean" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary vsli:raw="Represents managed pointers (byref return values and parameters) in signatures. It is followed in the blob by the signature encoding of the underlying type.">Представляет управляемые указатели (возвращаемые значения и параметры ByRef) в сигнатурах. За ним в BLOB-объекте следует кодировка сигнатуры базового типа.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Byte&quot; /&gt; in signatures.">Представляет <see cref="T:System.Byte" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Char&quot; /&gt; in signatures.">Представляет <see cref="T:System.Char" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Double&quot; /&gt; in signatures.">Представляет <see cref="T:System.Double" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary vsli:raw="Represents function pointer types in signatures.">Представляет типы указателей функции в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary vsli:raw="Represents a generic method parameter used within a signature.">Представляет параметр универсального метода, используемый в сигнатуре.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary vsli:raw="Represents the instantiation of a generic type in signatures.">Представляет экземпляр универсального типа в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary vsli:raw="Represents a generic type parameter used within a signature.">Представляет параметр универсального типа, используемый в сигнатуре.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int16&quot; /&gt; in signatures.">Представляет <see cref="T:System.Int16" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int32&quot; /&gt; in signatures.">Представляет <see cref="T:System.Int32" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int64&quot; /&gt; in signatures.">Представляет <see cref="T:System.Int64" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; in signatures.">Представляет <see cref="T:System.IntPtr" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary vsli:raw="Represents an invalid or uninitialized type code. It will not appear in valid signatures.">Представляет недопустимый или неинициализированный код типа. В допустимых сигнатурах не отображается.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Object&quot; /&gt; in signatures.">Представляет <see cref="T:System.Object" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller can ignore.">Представляет пользовательский модификатор, примененный к типу в сигнатуре, которую вызывающий объект может игнорировать.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary vsli:raw="Represents a local variable that is pinned by garbage collector.">Представляет локальную переменную, которая закреплена сборщиком мусора.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary vsli:raw="Represents an unmanaged pointer in signatures. It is followed in the blob by the signature encoding of the underlying type.">Представляет неуправляемый указатель в сигнатурах. За ним в BLOB-объекте следует кодировка сигнатуры базового типа.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller must understand.">Представляет пользовательский модификатор, примененный к типу в сигнатуре, которую вызывающий объект обязан понять.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.SByte&quot; /&gt; in signatures.">Представляет <see cref="T:System.SByte" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary vsli:raw="Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments.">Представляет маркер для обозначения конца фиксированных аргументов и начала переменных аргументов.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Single&quot; /&gt; in signatures.">Представляет <see cref="T:System.Single" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.String&quot; /&gt; in signatures.">Представляет <see cref="T:System.String" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary vsli:raw="Represents a single dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; with a lower bound of 0.">Представляет одномерный <see cref="T:System.Array" /> с нижней границей, равной 0.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary vsli:raw="Represents a typed reference in signatures.">Представляет типизированную ссылку в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary vsli:raw="Precedes a type &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; in signatures. In raw metadata, this is encoded as either ELEMENT_TYPE_CLASS (0x12) for reference types or ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single code because Windows Runtime projections can project from class to value type or vice-versa, and the raw code is misleading in those cases.">Предшествует типу <see cref="T:System.Reflection.Metadata.EntityHandle" /> в сигнатурах. В необработанных метаданных кодируется как ELEMENT_TYPE_CLASS (0x12) для ссылочных типов или ELEMENT_TYPE_VALUETYPE (0x11) для типов значений. Сворачивается до одного фрагмента кода, так как проекции среды выполнения Windows могут проецировать из класса в тип значения и наоборот, и необработанный код в таких случаях вводит в заблуждение.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; in signatures.">Представляет <see cref="T:System.UInt16" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; in signatures.">Представляет <see cref="T:System.UInt32" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; in signatures.">Представляет <see cref="T:System.UInt64" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; in signatures.">Представляет <see cref="T:System.UIntPtr" /> в сигнатурах.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary vsli:raw="Represents &lt;see cref=&quot;T:System.Void&quot; /&gt; in signatures.">Представляет <see cref="T:System.Void" /> в сигнатурах.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary vsli:raw="Indicates the type definition of the signature.">Указывает определение типа сигнатуры.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary vsli:raw="The type definition or reference refers to a class.">Определение типа или ссылка относится к классу.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary vsli:raw="It isn't known in the current context if the type reference or definition is a class or value type.">В текущем контексте неизвестно, является ли ссылка на тип или определение классом или типом значения.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary vsli:raw="The type definition or reference refers to a value type.">Определение типа или ссылка относится к типу значения.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary vsli:raw="Determines the kind of signature, which can be &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.Method&quot; /&gt; or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.LocalVariables&quot; /&gt;.">Определяет тип сигнатуры, которая может быть <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> или <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />.</summary>
      <returns vsli:raw="An enumeration value that indicates the signature kind.">Значение перечисления, указывающее тип сигнатуры.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The signature is invalid.">Сигнатура недопустима.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Возвращает дескриптор в BLOB-объект сигнатуры.</summary>
      <returns vsli:raw="A handle to the signature blob.">Маркер для большого двоичного объекта сигнатуры.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary vsli:raw="Indicates whether a &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method or local variable signature.">Указывает, представляет ли <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> сигнатуру изолированного метода или локальной переменной.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a local variable signature.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> ссылается на сигнатуру локальной переменной.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method signature.">
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> представляет сигнатуру изолированного метода.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary vsli:raw="Gets the base type of the type definition: either &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;.">Возвращает базовый тип определения типа: <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> или <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns vsli:raw="The base type of the type definition.">Базовый тип определения типа.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary vsli:raw="Returns the enclosing type of a specified nested type.">Возвращает включающий тип заданного вложенного типа.</summary>
      <returns vsli:raw="The enclosing type of the specified nested type, or a handle a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is not nested.">Включающий тип заданного вложенного типа или дескриптор, свойство <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> которого равно <see langword="true" />, если тип не является вложенным.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary vsli:raw="Returns an array of types nested in the specified type.">Возвращает массив типов, вложенных в указанный тип.</summary>
      <returns vsli:raw="An immutable array of type definition handles that represent types nested in the specified type.">Неизменяемый массив дескрипторов определения типа, которые представляют типы, вложенные в указанный тип.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary vsli:raw="Gets a value that indicates whether this is a nested type.">Возвращает значение, указывающее, является ли этот тип вложенным.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it is a nested type, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />значение, <see langword="false" /> если это вложенный тип; в противном случае —.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary vsli:raw="Gets the name of the type.">Получение имени типа.</summary>
      <returns vsli:raw="The name of the type.">Имя типа.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the type is defined.">Возвращает полное имя пространства имен, где определен тип.</summary>
      <returns vsli:raw="The full name of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">Полное имя пространства имен, в котором определен тип, или маркер, свойство которого <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> имеет <see langword="true" /> значение, если тип является вложенным или определен в корневом пространстве имен.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the type is defined.">Возвращает дескриптор определения пространства имен, где определен тип.</summary>
      <returns vsli:raw="The definition handle of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;  if the type is nested or defined in a root namespace.">Описатель определения пространства имен, в котором определен тип, или маркер, свойство которого <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> имеет <see langword="true" /> значение, если тип является вложенным или определен в корневом пространстве имен.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; instances.">Содержит коллекцию экземпляров класса <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" vsli:raw="" />
      <param name="packingSize" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary vsli:raw="Gets the name of the target type.">Возвращает имя типа целевого объекта.</summary>
      <returns vsli:raw="The name of the target type.">Имя типа целевого объекта.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the target type is defined.">Возвращает полное имя пространства имен, где определен тип целевого объекта.</summary>
      <returns vsli:raw="The full name of the namespace where the target type is defined, or a handle whose the &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">Полное имя пространства имен, в котором определен целевой тип, или маркер, свойство <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> которого имеет значение <see langword="true" />, если тип является вложенным или определен в корневом пространстве имен,</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary vsli:raw="Gets the resolution scope in which the target type is defined and is uniquely identified by the specified &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Namespace&quot; /&gt; and &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Name&quot; /&gt;.">Возвращает область разрешения, в которой тип целевого объекта определен и однозначно идентифицируется указанными <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> и <see cref="P:System.Reflection.Metadata.TypeReference.Name" />.</summary>
      <returns vsli:raw="The resolution scope in which the target type is uniquely defined.">Область разрешения, в которой тип целевого объекта определен уникальным образом.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">Содержит коллекцию экземпляров класса <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary vsli:raw="Represents a handle to the user string heap.">Представляет дескриптор для кучи пользовательских строк.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <param name="other" vsli:raw="An object to compare with this object." />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary vsli:raw="&lt;para&gt;Used to add a handler for an event. Corresponds to the &lt;see langword=&quot;AddOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant adders are named the with &lt;see langword=&quot;add_&quot; /&gt; prefix.&lt;/para&gt;">Используется для добавления обработчика для события. Соответствует флагу <see langword="AddOn" /> в спецификации CLI Ecma 335.
CLS-совместимые методы добавления имеют префикс <see langword="add_" />.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary vsli:raw="&lt;para&gt;Reads the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant getters are named with get_ prefix.&lt;/para&gt;">Считывает значение свойства.
Имена CLS-совместимых методов получения имеют префикс `get_`.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary vsli:raw="Other method for a property (not a getter or setter) or an event (not an adder, remover, or raiser).">Другой метод для свойства (не метод получения или задания) или события (не метод добавления, удаления или порождения).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary vsli:raw="&lt;para&gt;Used to indicate that an event has occurred. Corresponds to the &lt;see langword=&quot;Fire&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt; CLS-compliant raisers are named with the &lt;see langword=&quot;raise_&quot; /&gt; prefix.&lt;/para&gt;">Используется для указания на произошедшее событие. Соответствует флагу <see langword="Fire" /> в спецификации CLI Ecma 335.
 Имена CLS-совместимых методов порождения имеют префикс <see langword="raise_" />.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary vsli:raw="&lt;para&gt;Used to remove a handler for an event. Corresponds to the &lt;see langword=&quot;RemoveOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant removers are named with the &lt;see langword=&quot;remove_&quot; /&gt; prefix.&lt;/para&gt;">Используется для удаления обработчика для события. Соответствует флагу <see langword="RemoveOn" /> в спецификации CLI Ecma 335.
Имена CLS-совместимых методов удаления имеют префикс <see langword="remove_" />.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary vsli:raw="&lt;para&gt;Used to modify the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant setters are named with the &lt;see langword=&quot;set_&quot; /&gt; prefix.&lt;/para&gt;">Используется для изменения значения свойства.
Имена CLS-совместимых методов задания имеют префикс <see langword="set_" />.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary vsli:raw="Provides information about a Program Debug Database (PDB) file.">Предоставляет сведения о файле базы данных отладки программы (PDB).</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary vsli:raw="The iteration of the PDB. The first iteration is 1. The iteration is incremented each time the PDB content is augmented.">Итерация PDB-файла. Первая итерация — 1. Итерация увеличивается каждый раз, когда содержимое PDB-файла дополняется.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary vsli:raw="The Globally Unique Identifier (GUID) of the associated PDB.">Глобальный уникальный идентификатор (GUID) связанного PDB-файла.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary vsli:raw="The path to the .pdb file that contains debug information for the PE/COFF file.">Путь к PDB-файлу, который содержит отладочную информацию для файла PE/COFF.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary vsli:raw="Represents the header of a COFF file.">Представляет заголовок COFF-файла.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary vsli:raw="Gets the flags that indicate the attributes of the file.">Возвращает флаги, указывающие атрибуты файла.</summary>
      <returns vsli:raw="The flags that indicate the attributes of the file.">Флаги, указывающие атрибуты файла.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary vsli:raw="Gets the type of the target machine.">Возвращает тип целевого компьютера.</summary>
      <returns vsli:raw="The type of the target machine.">Тип целевого компьютера.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary vsli:raw="Gets the number of sections. This indicates the size of the section table, which immediately follows the headers.">Возвращает количество разделов. Указывает размер таблицы разделов, которая сразу же следует за заголовками.</summary>
      <returns vsli:raw="The number of sections.">Количество разделов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary vsli:raw="Gets the number of entries in the symbol table. This data can be used to locate the string table, which immediately follows the symbol table. This value should be zero for a PE image.">Возвращает число записей в таблице символов. Эти данные можно использовать для размещения таблицы строк, которая сразу же следует за таблицей символов. Для PE-образа это значение должно быть равно нулю.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary vsli:raw="Gets the file pointer to the COFF symbol table.">Возвращает указатель файла на таблицу символов COFF.</summary>
      <returns vsli:raw="The file pointer to the COFF symbol table, or zero if no COFF symbol table is present. This value should be zero for a PE image.">Указатель файла на таблицу символов COFF или нуль, если таблица символов COFF отсутствует. Для PE-образа это значение должно быть равно нулю.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary vsli:raw="Gets the size of the optional header, which is required for executable files but not for object files. This value should be zero for an object file.">Возвращает размер необязательного заголовка, который необходим для исполняемых файлов, но не для объектных файлов. Для объектного файла это значение должно быть равно нулю.</summary>
      <returns vsli:raw="The size of the optional header.">Размер необязательного заголовка.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary vsli:raw="Gets a value that indicates when the file was created.">Возвращает значение, указывающее, когда был создан файл.</summary>
      <returns vsli:raw="The low 32 bits of the number of seconds since 00:00 January 1, 1970, which indicates when the file was created.">Младшие 32 бита количества секунд с 00:00 1 января 1970, которое указывает на момент создания файла.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryBuilder&quot; /&gt; class.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary vsli:raw="Adds a CodeView entry.">Добавляет запись CodeView.</summary>
      <param name="pdbPath" vsli:raw="The path to the PDB. It should not be empty.">Путь к PDB-файлу. Не должен быть пустым.</param>
      <param name="pdbContentId" vsli:raw="The unique id of the PDB content.">Уникальный идентификатор содержимого PDB-файла.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0), or 0 if the PDB is not portable.">Версия формата переносимого PDB-файла (например, 0x0100 для версии 1.0) или значение 0, если PDB-файл не является переносимым.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="pdbPath" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; contains a NUL character.">
        <paramref name="pdbPath" /> содержит символ NUL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">Значение <paramref name="portablePdbVersion" /> меньше 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary vsli:raw="Adds an Embedded Portable PDB entry.">Добавляет запись внедренного переносимого PDB-файла.</summary>
      <param name="debugMetadata" vsli:raw="A Portable PDB metadata builder.">Построитель метаданных переносимого PDB-файла.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0).">Версия формата переносимого PDB-файла (например, 0x0100 для версии 1.0).</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;debugMetadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="debugMetadata" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">Значение <paramref name="portablePdbVersion" /> меньше 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary vsli:raw="Adds an entry of the specified type.">Добавляет запись указанного типа.</summary>
      <param name="type" vsli:raw="The entry type.">Тип записи.</param>
      <param name="version" vsli:raw="The entry version.">Версия записи.</param>
      <param name="stamp" vsli:raw="The entry stamp.">Метка записи.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary vsli:raw="Adds an entry of the specified type and serializes its data.">Добавляет запись указанного типа и сериализует ее данные.</summary>
      <param name="type" vsli:raw="The entry type.">Тип записи.</param>
      <param name="version" vsli:raw="The entry version.">Версия записи.</param>
      <param name="stamp" vsli:raw="The entry stamp.">Метка записи.</param>
      <param name="data" vsli:raw="The data to pass to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">Данные, передаваемые в <paramref name="dataSerializer" />.</param>
      <param name="dataSerializer" vsli:raw="A serializer for serializing data to a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Сериализатор для сериализации данных в <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
      <typeparam name="TData" vsli:raw="The type of the data passed to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">Тип данных, передаваемых в <paramref name="dataSerializer" />.</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds PDB checksum entry.">Добавляет запись контрольной суммы PDB.</summary>
      <param name="algorithmName" vsli:raw="The hash algorithm name (for example, &quot;SHA256&quot;).">Имя хэш-алгоритма (например, SHA256).</param>
      <param name="checksum" vsli:raw="The checksum.">Контрольная сумма.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Значение параметра <paramref name="algorithmName" /> или <paramref name="checksum" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is empty.">Параметр <paramref name="algorithmName" /> или <paramref name="checksum" /> является пустым.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary vsli:raw="Adds a reproducible entry.">Добавляет воспроизводимую запись.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary vsli:raw="Identifies the location, size and format of a block of debug information.">Определяет расположение, размер и формат блока отладочной информации.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntry&quot; /&gt; structure.">Инициализирует новый экземпляр структуры <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
      <param name="stamp" vsli:raw="" />
      <param name="majorVersion" vsli:raw="" />
      <param name="minorVersion" vsli:raw="" />
      <param name="type" vsli:raw="" />
      <param name="dataSize" vsli:raw="" />
      <param name="dataRelativeVirtualAddress" vsli:raw="" />
      <param name="dataPointer" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary vsli:raw="Gets the file pointer to the debug data.">Возвращает указатель файла на данные отладки.</summary>
      <returns vsli:raw="The file pointer to the debug data.">Указатель файла на данные отладки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary vsli:raw="Gets the address of the debug data when loaded, relative to the image base.">Возвращает адрес данных отладки при загрузке относительно базового адреса образа.</summary>
      <returns vsli:raw="The address of the debug data relative to the image base.">Адрес отладочных данных относительно базы образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary vsli:raw="Gets the size of the debug data (not including the debug directory itself).">Возвращает размер данных отладки (не включая сам каталог отладки).</summary>
      <returns vsli:raw="the size of the debug data (excluding the debug directory).">Размер данных отладки (за исключением каталога отладки).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary vsli:raw="Gets a value that indicates if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry that points to a Portable PDB.">Возвращает значение, определяющее, является ли запись записью <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" />, указывающей на переносимый PDB-файл.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry pointing to a Portable PDB; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если запись является записью <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" />, указывающей на переносимый PDB; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary vsli:raw="Gets the major version number of the debug data format.">Возвращает основной номер версии для формата данных отладки.</summary>
      <returns vsli:raw="The major version number of the debug data format.">Основной номер версии формата данных отладки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary vsli:raw="Gets the minor version number of the debug data format.">Возвращает дополнительный номер версии для формата данных отладки.</summary>
      <returns vsli:raw="The minor version number of the debug data format.">Дополнительный номер версии формата данных отладки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary vsli:raw="Get the time and date that the debug data was created if the PE/COFF file is not deterministic; otherwise, gets a value based on the hash of the content.">Возвращает время и дату создания данных отладки, если файл PE/COFF не является детерминированным; в противном случае возвращает значение в соответствии с хэшем содержимого.</summary>
      <returns vsli:raw="for a non-deterministic PE/COFF file, the time and date that the debug data was created; otherwise, a value based on the hash of the content.">для недетерминированного PE-или COFF-файла — время и Дата создания данных отладки; в противном случае — значение, основанное на хэш-значении содержимого.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary vsli:raw="Gets the format of the debugging information.">Возвращает формат отладочной информации.</summary>
      <returns vsli:raw="The format of the debugging information.">Формат отладочной информации.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType" />
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary vsli:raw="Associated PDB file description. For more information, see the specification.">Описание связанного PDB-файла.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary vsli:raw="The COFF debug information (line numbers, symbol table, and string table). This type of debug information is also pointed to by fields in the file headers.">Отладочная информация COFF (номера строк, таблица символов и таблица строк). На отладочную информацию этого типа также указывают поля в заголовках файлов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary vsli:raw="&lt;para&gt;The entry points to a blob containing Embedded Portable PDB. The Embedded Portable PDB blob has the following format:&lt;/para&gt;&lt;para&gt;- blob ::= uncompressed-size data&lt;/para&gt;&lt;para&gt;- Data spans the remainder of the blob and contains a Deflate-compressed Portable PDB.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">Запись указывает на большой двоичный объект, содержащий внедренный переносимый PDB-файл. Большой двоичный объект с внедренным переносимым PDB-файлом имеет следующий формат:- blob ::= uncompressed-size dataДанные содержатся в остальной части большого двоичного объекта. Они представляют собой сжатый алгоритмом Deflate переносимый PDB-файл.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary vsli:raw="The entry stores a crypto hash of the content of the symbol file the PE/COFF file was built with. The hash can be used to validate that a given PDB file was built with the PE/COFF file and not altered in any way. More than one entry can be present if multiple PDBs were produced during the build of the PE/COFF file (for example, private and public symbols). For more information, see the specification.">В записи хранится хэш шифрования для содержимого файла символов, с использованием которого был создан PE- или COFF-файл. Хэш можно использовать для проверки того, что данный PDB-файл был создан с использованием PE- или COFF-файла и не был изменен каким-либо образом. Если во время сборки PE- или COFF-файла было создано несколько PDB-файлов (например, с закрытыми и открытыми символами), записей также может быть несколько.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary vsli:raw="&lt;para&gt;The presence of this entry indicates a deterministic PE/COFF file. See the Remarks section for more information.&lt;/para&gt;&lt;para&gt;The tool that produced the deterministic PE/COFF file guarantees that the entire content of the file is based solely on documented inputs given to the tool (such as source files, resource files, and compiler options) rather than ambient environment variables (such as the current time, the operating system, and the bitness of the process running the tool).&#xA;          The value of field TimeDateStamp in COFF File Header of a deterministic PE/COFF file does not indicate the date and time when the file was produced and should not be interpreted that way. Instead, the value of the field is derived from a hash of the file content. The algorithm to calculate this value is an implementation detail of the tool that produced the file.&#xA;          The debug directory entry of type &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible&quot; /&gt; must have all fields, except for Type zeroed.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">Наличие этой записи указывает на детерминированный PE- или COFF-файл. Дополнительные сведения см. в разделе "Примечания".</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary vsli:raw="An unknown value that should be ignored by all tools.">Неизвестное значение, которое должно игнорироваться всеми средствами.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="size" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary vsli:raw="Describes the characteristics of a dynamic link library.">Описывает характеристики библиотеки динамической компоновки.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary vsli:raw="The image must run inside an AppContainer.">Образ должен выполняться внутри AppContainer.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary vsli:raw="The DLL can be relocated.">Библиотека DLL может быть перемещена.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary vsli:raw="The image can handle a high entropy 64-bit virtual address space.">Образ может работать с 64-битным виртуальным адресным пространством с высокой энтропией.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary vsli:raw="Do not bind this image.">Не привязывайте этот образ.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary vsli:raw="The image understands isolation and doesn't want it.">Он поддерживает изоляцию, поэтому привязка не требуется.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary vsli:raw="The image does not use SEH. No SE handler may reside in this image.">Образ не использует структурированную обработку исключений (SEH). В этом образе не может быть структурированного обработчика исключений.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary vsli:raw="The image is NX compatible.">Образ совместим с NX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary vsli:raw="Reserved.">Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary vsli:raw="Reserved.">Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary vsli:raw="The image is Terminal Server aware.">Образ поддерживает сервер терминалов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary vsli:raw="Reserved.">Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary vsli:raw="Reserved.">Зарезервировано.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary vsli:raw="The driver uses the WDM model.">Драйвер использует модель WDM.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary vsli:raw="Specifies the target machine's CPU architecture.">Указывает архитектуру ЦП целевого компьютера.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary vsli:raw="Alpha.">Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary vsli:raw="ALPHA64.">ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary vsli:raw="Matsushita AM33.">Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary vsli:raw="AMD64 (K8).">AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary vsli:raw="ARM little endian.">ARM с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary vsli:raw="ARM64.">ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary vsli:raw="ARM Thumb-2 little endian.">ARM Thumb-2 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary vsli:raw="EFI Byte Code.">Байтовый код EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary vsli:raw="Intel 386.">Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary vsli:raw="Intel 64.">Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary vsli:raw="M32R little-endian.">M32R с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary vsli:raw="MIPS.">MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary vsli:raw="MIPS with FPU.">MIPS с FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary vsli:raw="MIPS16 with FPU.">MIPS16 с FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary vsli:raw="IBM PowerPC little endian.">IBM PowerPC с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary vsli:raw="PowerPCFP.">PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary vsli:raw="Hitachi SH3 DSP.">Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary vsli:raw="Hitachi SH4 little endian.">Hitachi SH4 с прямым порядком байтов.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary vsli:raw="Hitachi SH5.">Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary vsli:raw="Thumb.">Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary vsli:raw="Infineon.">Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary vsli:raw="The target CPU is unknown or not specified.">Целевой ЦП неизвестен или не указан.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary vsli:raw="MIPS little-endian WCE v2.">WCE версии 2 MIPS с прямым порядком байтов.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId},System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags)">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="deterministicIdProvider" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" vsli:raw="" />
      <param name="signatureProvider" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary vsli:raw="Represents a PDB Checksum debug directory entry.">Представляет запись каталога отладки для контрольной суммы PDB-файла.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary vsli:raw="The name of the crypto hash algorithm used to calculate the checksum.">Имя хэш-алгоритма шифрования, используемого для вычисления контрольной суммы.</summary>
      <returns vsli:raw="A string representing the name of the crypto hash algorithm used to calculate the checksum.">Строка, представляющая имя хэш-алгоритма шифрования, используемого для вычисления контрольной суммы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary vsli:raw="The checksum of the PDB content.">Контрольная сумма содержимого PDB-файла.</summary>
      <returns vsli:raw="An immutable array of bytes representing the checksum of the PDB content.">Неизменяемый массив байтов, представляющий контрольную сумму содержимого PDB.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" vsli:raw="" />
      <param name="deterministicIdProvider" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" vsli:raw="" />
      <param name="characteristics" vsli:raw="" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary vsli:raw="Builds PE directories.">Создает каталоги PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary vsli:raw="Initializes an instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEDirectoriesBuilder&quot; /&gt; class.">Инициализирует экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary vsli:raw="The address of the entry point relative to the image base when the PE file is loaded into memory.">Адрес точки входа относительно базового адреса образа при загрузке PE-файла в память.</summary>
      <returns vsli:raw="For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero.">Для образов программ это начальный адрес. Для драйверов устройств это адрес функции инициализации. Точка входа является необязательной для библиотек DLL. Если отсутствует точка входа, это поле должно быть равно нулю.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary vsli:raw="The base relocation table image directory entry.">Запись каталога с образом таблицы перемещений базового адреса.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary vsli:raw="The bound import image directory entry.">Запись каталога со связанным образом импорта.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary vsli:raw="The copyright/architecture image directory entry.">Запись каталога с образом архитектуры и сведений об авторских правах.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary vsli:raw="The COM descriptortable image directory entry.">Запись каталога с образом таблицы дескрипторов COM.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary vsli:raw="The debug table image directory entry.">Запись каталога с образом таблицы отладки.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary vsli:raw="The delay import table image directory entry.">Запись каталога с образом таблицы отложенного импорта.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary vsli:raw="The exception table image directory entry.">Запись каталога с образом таблицы исключений.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary vsli:raw="The export table image directory entry.">Запись каталога с образом таблицы экспорта.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary vsli:raw="The global pointer table image directory entry.">Запись каталога с образом таблицы глобальных указателей.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary vsli:raw="The import address table (IAT) image directory entry.">Запись каталога с образом адресной таблицы импорта.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary vsli:raw="The import table image directory entry.">Запись каталога с образом таблицы импорта.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary vsli:raw="The load configuration table image directory entry.">Запись каталога с образом таблицы конфигурации загрузки.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary vsli:raw="The resource table image directory entry.">Запись каталога с образом таблицы ресурсов.</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary vsli:raw="The thread local storage (TLS) table image directory entry.">Запись каталога с образом локальной по отношению к потоку таблицы (TLS).</summary>
      <returns vsli:raw="A directory entry instance.">Экземпляр записи каталога.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary vsli:raw="Gets the address of the entry point relative to the image base when the PE file is loaded into memory.">Возвращает адрес точки входа относительно базового адреса образа при загрузке PE-файла в память.</summary>
      <returns vsli:raw="The address of the entry point relative to the image base.">Адрес точки входа относительно базы изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary vsli:raw="Gets the address of the beginning-of-code section relative to the image base when the image is loaded into memory.">Возвращает адрес раздела начала кода относительно базового адреса образа при загрузке образа в память.</summary>
      <returns vsli:raw="The address of the beginning-of-code section relative to the image base.">Адрес раздела начала кода относительно базы образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary vsli:raw="Gets the address of the beginning-of-data section relative to the image base when the image is loaded into memory.">Возвращает адрес раздела начала данных относительно базового адреса образа при загрузке образа в память.</summary>
      <returns vsli:raw="The address of the beginning-of-data section relative to the image base.">Адрес раздела начала данных относительно базы образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary vsli:raw="Gets the Certificate Table entry, which points to a table of attribute certificates.">Возвращает запись таблицы сертификатов, указывающую на таблицу сертификатов атрибутов.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary vsli:raw="Gets the image file checksum.">Возвращает контрольную сумму файла образа.</summary>
      <returns vsli:raw="The image file checksum.">Контрольная сумма файла образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary vsli:raw="Gets the alignment factor (in bytes) that is used to align the raw data of sections in the image file.">Возвращает коэффициент выравнивания (в байтах), используемый для выравнивания необработанных данных разделов в файле образа.</summary>
      <returns vsli:raw="A power of 2 between 512 and 64K, inclusive. The default is 512.">Степень 2 в диапазоне от 512 до 64K включительно. Значение по умолчанию — 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary vsli:raw="Gets the preferred address of the first byte of the image when it is loaded into memory.">Возвращает предпочтительный адрес первого байта образа при его загрузке в память.</summary>
      <returns vsli:raw="The preferred address, which is a multiple of 64K.">Предпочтительный адрес, который является кратным 64 КБ.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary vsli:raw="Gets a value that identifies the format of the image file.">Возвращает значение, указывающее формат файла образа.</summary>
      <returns vsli:raw="The format of the image file.">Формат файла изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary vsli:raw="Gets the major version number of the image.">Возвращает основной номер версии образа.</summary>
      <returns vsli:raw="The major version number of the image.">Основной номер версии образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary vsli:raw="Gets the linker major version number.">Возвращает основной номер версии компоновщика.</summary>
      <returns vsli:raw="The linker major version number.">Основной номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary vsli:raw="Gets the major version number of the required operating system.">Возвращает основной номер версии требуемой операционной системы.</summary>
      <returns vsli:raw="The major version number of the required operating system.">Основной номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary vsli:raw="Gets the major version number of the subsystem.">Возвращает основной номер версии подсистемы.</summary>
      <returns vsli:raw="The major version number of the subsystem.">Основной номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary vsli:raw="Gets the minor version number of the image.">Возвращает дополнительный номер версии образа.</summary>
      <returns vsli:raw="The minor version number of the image.">Дополнительный номер версии образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary vsli:raw="Gets the linker minor version number.">Возвращает дополнительный номер версии компоновщика.</summary>
      <returns vsli:raw="The linker minor version number.">Дополнительный номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary vsli:raw="Gets the minor version number of the required operating system.">Возвращает дополнительный номер версии требуемой операционной системы.</summary>
      <returns vsli:raw="The minor version number of the required operating system.">Дополнительный номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary vsli:raw="Gets the minor version number of the subsystem.">Возвращает дополнительный номер версии подсистемы.</summary>
      <returns vsli:raw="The minor version number of the subsystem.">Дополнительный номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary vsli:raw="Gets the number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;. Each describes a location and size.">Возвращает число записей каталога данных в оставшейся части <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Каждая из них описывает расположение и размер.</summary>
      <returns vsli:raw="The number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;.">Число записей каталога данных в оставшейся части <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary vsli:raw="Gets the alignment (in bytes) of sections when they are loaded into memory.">Возвращает выравнивание разделов (в байтах) при их загрузке в память.</summary>
      <returns vsli:raw="A number greater than or equal to &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.FileAlignment&quot; /&gt;. The default is the page size for the architecture.">Число, которое больше или равно <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" />. Значением по умолчанию является размер страницы для архитектуры.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary vsli:raw="Gets the size of the code (text) section, or the sum of all code sections if there are multiple sections.">Возвращает размер раздела кода (текста) или сумму всех разделов кода, если имеется несколько разделов.</summary>
      <returns vsli:raw="the size of the code (text) section, or the sum of all code sections if there are multiple sections.">Размер раздела кода (текст) или сумма всех разделов кода, если имеется несколько разделов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary vsli:raw="Gets the combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">Возвращает общий размер заглушки MS DOS, заголовка PE и заголовков разделов, округленный до числа, кратного FileAlignment.</summary>
      <returns vsli:raw="The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">Объединенный размер заголовков MS DOS, заголовка PE и разделов, округленных до кратного числа FileAlignment.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary vsli:raw="Gets the size of the local heap space to commit.">Возвращает размер фиксируемого пространства в локальной куче.</summary>
      <returns vsli:raw="the size of the local heap space to commit.">Размер пространства локальной кучи для фиксации.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary vsli:raw="Gets the size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Возвращает размер резервируемого пространства в локальной куче. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns vsli:raw="The size of the local heap space to reserve.">Размер резервируемого пространства в локальной куче.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary vsli:raw="Gets the size (in bytes) of the image, including all headers, as the image is loaded in memory.">Возвращает размер образа (в байтах), включая все заголовки, при его загрузке в память.</summary>
      <returns vsli:raw="The size (in bytes) of the image, which is a multiple of &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment&quot; /&gt;.">Размер изображения (в байтах), кратного <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary vsli:raw="Gets the size of the initialized data section, or the sum of all such sections if there are multiple data sections.">Возвращает размер инициализированного раздела данных или сумму всех таких разделов, если имеется несколько разделов данных.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary vsli:raw="Gets the size of the stack to commit.">Возвращает размер фиксируемого стека.</summary>
      <returns vsli:raw="The size of the stack to commit.">Размер фиксируемого стека.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary vsli:raw="Gets the size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Возвращает размер резервируемого стека. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns vsli:raw="The size of the stack to reserve.">Размер резервируемого стека.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary vsli:raw="Gets the size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.">Возвращает размер неинициализированного раздела данных (BSS) или сумму всех таких разделов, если имеется несколько разделов BSS.</summary>
      <returns vsli:raw="The size of the uninitialized data section (BSS) or the sum of all such sections.">Размер неинициализированного раздела данных (BSS) или сумма всех таких разделов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary vsli:raw="Gets the name of the subsystem that is required to run this image.">Возвращает имя подсистемы, необходимой для выполнения этого образа.</summary>
      <returns vsli:raw="The name of the subsystem that is required to run this image.">Имя подсистемы, необходимой для запуска этого образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary vsli:raw="Defines the header for a portable executable (PE) file.">Определяет заголовок переносимого исполняемого файла (PE).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</summary>
      <param name="machine">Архитектура ЦП целевого компьютера.</param>
      <param name="sectionAlignment">Выравнивание разделов (в байтах) при загрузке в память. Должно быть больше или равно <paramref name="fileAlignment" />. Значением по умолчанию является размер страницы для архитектуры.</param>
      <param name="majorSubsystemVersion">Основной номер версии подсистемы.</param>
      <param name="minorSubsystemVersion">Дополнительный номер версии подсистемы.</param>
      <param name="subsystem">Подсистема, необходимая для выполнения образа.</param>
      <param name="dllCharacteristics">Объект, описывающий характеристики библиотеки динамической компоновки.</param>
      <param name="imageCharacteristics">Объект, описывающий характеристики образа.</param>
      <param name="sizeOfStackReserve">Размер резервируемого стека. Фиксируется только <paramref name="sizeOfStackCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</param>
      <param name="sizeOfStackCommit">Размер фиксируемого стека.</param>
      <param name="sizeOfHeapReserve">Размер резервируемого пространства в локальной куче. Фиксируется только <paramref name="sizeOfHeapCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</param>
      <param name="sizeOfHeapCommit">Размер фиксируемого пространства в локальной куче.</param>
      <param name="fileAlignment">Коэффициент выравнивания (в байтах), используемый для выравнивания необработанных данных разделов в файле образа. Значение должно быть степенью числа 2 в диапазоне от 512 до 64 000 включительно. Значение по умолчанию — 512. Если значение <paramref name="sectionAlignment" /> меньше размера страницы для архитектуры, то значение <paramref name="fileAlignment" /> должно совпадать с <paramref name="sectionAlignment" />.</param>
      <param name="imageBase">Предпочтительный адрес первого байта образа при загрузке в память; значение должно быть кратно 64 000.</param>
      <param name="majorLinkerVersion">Основной номер версии компоновщика.</param>
      <param name="minorLinkerVersion">Дополнительный номер версии компоновщика.</param>
      <param name="majorOperatingSystemVersion">Основной номер версии требуемой операционной системы.</param>
      <param name="minorOperatingSystemVersion">Дополнительный номер версии требуемой операционной системы.</param>
      <param name="majorImageVersion">Основной номер версии образа.</param>
      <param name="minorImageVersion">Дополнительный номер версии образа.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="fileAlignment" /> не является степенью числа 2 в диапазоне от 512 до 64 000.

или -

Значение <paramref name="sectionAlignment" /> не является степенью числа 2.

или -

Значение <paramref name="sectionAlignment" /> меньше <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary vsli:raw="Creates an executable header.">Создает заголовок исполняемого файла.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the executable header.">Экземпляр <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />, представляющий заголовок исполняемого файла.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary vsli:raw="Creates a library header.">Создает заголовок библиотеки.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the library header.">Экземпляр <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />, представляющий заголовок библиотеки.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary vsli:raw="Returns the dynamic linker library characteristics.">Возвращает характеристики библиотеки динамической компоновки.</summary>
      <returns vsli:raw="An object that describes the dynamic linker library characteristics.">Объект, описывающий характеристики библиотеки динамического компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary vsli:raw="The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. If the section alignment is less than the architecture's page size, then file alignment must match the section alignment.">Коэффициент выравнивания (в байтах), используемый для выравнивания необработанных данных разделов в файле образа. Значение должно быть степенью числа 2 в диапазоне от 512 до 64 000 включительно. Значение по умолчанию — 512. Если выравнивание раздела меньше размера страницы для архитектуры, то выравнивание файла должно совпадать с выравниванием раздела.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary vsli:raw="The preferred address of the first byte of image when loaded into memory; must be a multiple of 64K.">Предпочтительный адрес первого байта образа при загрузке в память; значение должно быть кратно 64 000.</summary>
      <returns vsli:raw="A number representing the preferred address of the first byte of image when loaded into memory.">Число, представляющее предпочтительный адрес первого байта изображения, загружаемого в память.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary vsli:raw="Returns the image characteristics.">Возвращает характеристики образа.</summary>
      <returns vsli:raw="An object representing the image characteristics.">Объект, представляющий характеристики изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary vsli:raw="The target machine's CPU architecture.">Архитектура ЦП целевого компьютера.</summary>
      <returns vsli:raw="One of the enumeration values representing the different CPU architectures.">Одно из значений перечисления, представляющих различные архитектуры ЦП.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary vsli:raw="The major version number of the image.">Основной номер версии образа.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the image.">Число <see cref="T:System.UInt16" />, представляющее основной номер версии образа.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary vsli:raw="The linker major version number.">Основной номер версии компоновщика.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker major version number.">Число, равное размеру <see cref="T:System.Byte" />, представляющему основной номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary vsli:raw="The major version number of the required operating system.">Основной номер версии требуемой операционной системы.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the required operating system.">Число <see cref="T:System.UInt16" />, представляющее основной номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary vsli:raw="The major version number of the subsystem.">Основной номер версии подсистемы.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the subsystem.">Число <see cref="T:System.UInt16" />, представляющее основной номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary vsli:raw="The minor version number of the image.">Дополнительный номер версии образа.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the image.">Число <see cref="T:System.UInt16" />, представляющее дополнительный номер версии изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary vsli:raw="The linker minor version number.">Дополнительный номер версии компоновщика.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker minor version number.">Число, равное размеру <see cref="T:System.Byte" />, представляющему дополнительный номер версии компоновщика.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary vsli:raw="The minor version number of the required operating system.">Дополнительный номер версии требуемой операционной системы.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the required operating system.">Число <see cref="T:System.UInt16" />, представляющее дополнительный номер версии требуемой операционной системы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary vsli:raw="The minor version number of the subsystem.">Дополнительный номер версии подсистемы.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the subsystem.">Число <see cref="T:System.UInt16" />, представляющее дополнительный номер версии подсистемы.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary vsli:raw="The alignment (in bytes) of sections when they are loaded into memory.">Выравнивание разделов (в байтах) при загрузке в память.</summary>
      <returns vsli:raw="A number representing the alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to the file alignment. The default is the page size for the architecture.">Число, представляющее выравнивание (в байтах) разделов при их загрузке в память. Оно должно быть больше или равно выравниванию файла. Значением по умолчанию является размер страницы для архитектуры.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary vsli:raw="The size of the local heap space to commit.">Размер фиксируемого пространства в локальной куче.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to commit.">Число, представляющее размер пространства локальной кучи для фиксации.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary vsli:raw="The size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Размер резервируемого пространства в локальной куче. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to reserve.">Число, представляющее размер пространства локальной кучи для резервирования.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary vsli:raw="The size of the stack to commit.">Размер фиксируемого стека.</summary>
      <returns vsli:raw="A number representing the size of the stack to commit.">Число, представляющее размер стека для фиксации.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary vsli:raw="The size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Размер резервируемого стека. Фиксируется только <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />. Остальная часть предоставляется по одной странице, пока не будет достигнут зарезервированный размер.</summary>
      <returns vsli:raw="A number representing the size of the stack to reserve.">Число, представляющее размер стека для резервирования.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary vsli:raw="The subsystem that is required to run this image.">Подсистема, необходимая для выполнения этого образа.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.Subsystem&quot; /&gt; instance.">Экземпляр <see cref="T:System.Reflection.PortableExecutable.Subsystem" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary vsli:raw="Defines a type that reads PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.">Определяет тип, который считывает заголовки PE и COFF из потока.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from the current location in the specified stream.">Создает экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />, который считывает заголовки PE из текущего расположения в указанном потоке.</summary>
      <param name="peStream" vsli:raw="A stream containing the PE image starting at the stream's current position and ending at the end of the stream.">Поток, содержащий образ PE начиная с текущей позиции потока и заканчивая его концом.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">Данные, считанные из потока, имеют недопустимый формат.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Ошибка при чтении из потока.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">Поток не поддерживает операции поиска.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size.">Создает экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />, который считывает заголовки PE из потока, представляющего образ PE указанного размера.</summary>
      <param name="peStream" vsli:raw="A stream containing PE image of the given size starting at its current position.">Поток, содержащий образ PE указанного размера начиная с текущей позиции.</param>
      <param name="size" vsli:raw="The size of the PE image.">Размер образа PE.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">Данные, считанные из потока, имеют недопустимый формат.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Ошибка при чтении из потока.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">Поток не поддерживает операции поиска.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="peStream" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">Параметр <paramref name="size" /> является отрицательным или превышает длину потока.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size and indicates whether the PE image has been loaded into memory.">Создает экземпляр класса <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />, который считывает заголовки PE из потока, представляющего образ PE заданного размера, и указывает, загружен ли образ PE в память.</summary>
      <param name="peStream" vsli:raw="The stream containing PE image of the given size starting at its current position.">Поток, содержащий образ PE указанного размера начиная с текущей позиции.</param>
      <param name="size" vsli:raw="The size of the PE image.">Размер образа PE.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если образ PE был загружен в память загрузчиком ОС; в противном случае значение <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has invalid format.">Данные, считанные из потока, имеют недопустимый формат.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Ошибка при чтении из потока.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">Поток не поддерживает операции поиска.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">Параметр <paramref name="size" /> является отрицательным или превышает длину потока.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary vsli:raw="Gets the COFF header of the image.">Возвращает заголовок COFF образа.</summary>
      <returns vsli:raw="The COFF header of the image.">Заголовок COFF изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the PE image to the start of the COFF header.">Возвращает смещение в байтах от начала образа PE до начала заголовка COFF.</summary>
      <returns vsli:raw="The byte offset from the start of the PE image to the start of the COFF header.">Смещение в байтах от начала образа PE до начала заголовка COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary vsli:raw="Gets the COR header.">Возвращает заголовок COR.</summary>
      <returns vsli:raw="The COR header, or &lt;see langword=&quot;null&quot; /&gt; if the image does not have one.">Заголовок COR или значение <see langword="null" />, если образ не имеет такого изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the image to the COR header.">Возвращает смещение в байтах от начала образа до заголовка COR.</summary>
      <returns vsli:raw="The byte offset from the start of the image to the COR header, or -1 if the image does not have a COR header.">Смещение в байтах от начала изображения до заголовка COR или-1, если у изображения нет заголовка COR.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary vsli:raw="Searches sections of the PE image for the section that contains the specified Relative Virtual Address.">Ищет среди разделов образа PE раздел, содержащий указанный относительный виртуальный адрес.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The relative virtual address to search for.">Искомый относительный виртуальный адрес.</param>
      <returns vsli:raw="The index of the section that contains &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt;, or -1 if there the search is unsuccessful.">Индекс раздела, содержащего <paramref name="relativeVirtualAddress" />, или значение –1, если поиск не дал результатов.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary vsli:raw="Gets a value that indicates whether the image is Coff only.">Возвращает значение, указывающее, является ли образ исключительно образом COFF.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is Coff only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если образ является только COFF; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary vsli:raw="Gets a value that indicates whether the image represents a Windows console application.">Возвращает значение, указывающее, представляет ли образ консольное приложение Windows.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a Windows console applications; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если образ является консольным приложением Windows; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary vsli:raw="Gets a value that indicates whether the image represents a dynamic link library.">Возвращает значение, указывающее, представляет ли образ библиотеку динамической компоновки.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a DLL; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если образ является библиотекой DLL; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary vsli:raw="Gets a value that indicates whether the image represents an executable.">Возвращает значение, указывающее, представляет ли образ исполняемый файл.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is an executable; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если образ является исполняемым файлом; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary vsli:raw="Gets the size of the CLI metadata.">Возвращает размер метаданных CLI.</summary>
      <returns vsli:raw="the size of the CLI metadata, or 0 if the image does not contain metadata.">размер метаданных CLI или значение 0, если образ не содержит метаданных.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.">Возвращает смещение (в байтах) от начала образа PE до начала метаданных CLI.</summary>
      <returns vsli:raw="The offset (in bytes) from the start of the PE image to the start of the CLI metadata, or -1 if the image does not contain metadata.">Смещение (в байтах) от начала образа PE до начала работы с метаданными CLI или значение-1, если образ не содержит метаданных.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary vsli:raw="Gets the image's PE header.">Возвращает заголовок PE образа.</summary>
      <returns vsli:raw="The image's PE header, or &lt;see langword=&quot;null&quot; /&gt; if the image is COFF only.">Заголовок PE изображения или значение <see langword="null" />, если изображение имеет только COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset of the header from the start of the image.">Возвращает смещение заголовка в байтах от начала образа.</summary>
      <returns vsli:raw="The byte offset of the header from the start of the image.">Смещение в байтах заголовка от начала изображения.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary vsli:raw="Gets the PE section headers.">Возвращает заголовки раздела PE.</summary>
      <returns vsli:raw="An array containing the PE section headers.">Массив, содержащий заголовки разделов PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the image to the given directory data.">Возвращает смещение (в байтах) от начала образа до указанных данных каталога.</summary>
      <param name="directory" vsli:raw="The PE directory entry.">Запись каталога PE.</param>
      <param name="offset" vsli:raw="When the method returns, contains the offset from the start of the image to the given directory data.">Когда метод возвращает управление, содержит смещение от начала образа до указанных данных каталога.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the directory data is found; &lt;see langword=&quot;false&quot; /&gt; otherwise.">Значение <see langword="true" />, если данные каталога найдены; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary vsli:raw="Reads the contents of the entire block into an array.">Считывает содержимое всего блока в массив.</summary>
      <returns vsli:raw="An immutable byte array.">Неизменяемый массив байтов.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary vsli:raw="Reads the contents of a part of the block into an array.">Считывает содержимое части блока в массив.</summary>
      <param name="start" vsli:raw="The starting position in the block.">Начальная позиция в блоке.</param>
      <param name="length" vsli:raw="The number of bytes to read.">Количество байтов, чтение которых необходимо выполнить.</param>
      <returns vsli:raw="An immutable array of bytes.">Неизменяемый массив байтов.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">В блоке нет указанного диапазона.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning the entire block.">Создает <see cref="T:System.Reflection.Metadata.BlobReader" /> для большого двоичного объекта, охватывающего весь блок.</summary>
      <returns vsli:raw="A reader for a blob spanning the entire block.">Средство чтения для большого двоичного объекта, охватывающего весь блок.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning a part of the block.">Создает <see cref="T:System.Reflection.Metadata.BlobReader" /> для большого двоичного объекта, охватывающего часть блока.</summary>
      <param name="start" vsli:raw="The starting position in the block.">Начальная позиция в блоке.</param>
      <param name="length" vsli:raw="The number of bytes in the portion of the block.">Количество байтов в части блока.</param>
      <returns vsli:raw="A reader for a blob spanning a portion of the block.">Средство чтения для большого двоичного объекта, охватывающего часть блока.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">В блоке нет указанного диапазона.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary vsli:raw="Gets the length of the block.">Возвращает длину блока.</summary>
      <returns vsli:raw="The length of the block.">Длина блока.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary vsli:raw="Gets a pointer to the first byte of the block.">Возвращает указатель на первый байт блока.</summary>
      <returns vsli:raw="A pointer to the first byte of the block.">Указатель на первый байт блока.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary vsli:raw="Provides a reader for Portable Executable format (PE) files.">Предоставляет средство чтения для переносимых исполняемых (PE) файлов.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory.">Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в памяти.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">Указатель на начало образа PE.</param>
      <param name="size" vsli:raw="The size of the PE image.">Размер образа PE.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> — <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory. A flag indicates whether the image has already been loaded into memory.">Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в памяти. Флаг указывает, был ли образ уже загружен в память.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">Указатель на начало образа PE.</param>
      <param name="size" vsli:raw="The size of the PE image.">Размер образа PE.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если образ PE был загружен в память загрузчиком ОС; в противном случае значение <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> — <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a byte array.">Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в массиве байтов.</summary>
      <param name="peImage" vsli:raw="An immutable array of bytes representing the PE image.">Неизменяемый массив байтов, представляющий образ PE.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImage" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream.">Создает средство чтения переносимых исполняемых файлов с использованием образа PE, хранящегося в потоке.</summary>
      <param name="peStream" vsli:raw="PE image stream.">Поток образа PE.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.">Создает средство чтения переносимых исполняемых файлов с использованием образа PE, который хранится в потоке, начиная с его текущей позиции и заканчивая концом потока.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">Поток образа PE.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">Параметры, которые определяют способ считывания разделов образа PE из потока.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> — <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;options&quot; /&gt; has an invalid value.">Недопустимое значение параметра <paramref name="options" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">Ошибка при чтении из потока (только при предварительном получении данных).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> указан, а PE-заголовки образа недопустимы.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.">Создает средство чтения переносимых исполняемых файлов с использованием образа PE заданного размера, начиная с текущей позиции потока.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">Поток образа PE.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">Параметры, которые определяют способ считывания разделов образа PE из потока.</param>
      <param name="size" vsli:raw="The PE image size.">Размер образа PE.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">Параметр <paramref name="size" /> является отрицательным или превышает длину потока.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">Ошибка при чтении из потока (только при предварительном получении данных).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> указан, а PE-заголовки образа недопустимы.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">Удаляет весь объем памяти, выделенный средством чтения.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEMemoryBlock&quot; /&gt; object containing the entire PE image.">Возвращает объект <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" />, содержащий весь образ PE.</summary>
      <returns vsli:raw="A memory block that contains the entire PE image.">Блок памяти, содержащий весь образ PE.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The entire PE image is not available.">Весь образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary vsli:raw="Loads a PE section that contains CLI metadata.">Загружает раздел PE, содержащий метаданные CLI.</summary>
      <returns vsli:raw="A memory block that contains the CLI metadata.">Блок памяти, содержащий метаданные CLI.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image doesn't contain metadata (&lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEReader.HasMetadata&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;).">Образ PE не содержит метаданные (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> возвращает <see langword="false" />).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Заголовки PE содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary vsli:raw="Loads the PE section that contains the specified relative virtual address into memory and returns a memory block that starts at that address and ends at the end of the containing section.">Загружает раздел PE, который содержит указанный относительный виртуальный адрес, в память и возвращает блок памяти, который начинается с этого адреса и заканчивается в конце содержащего его раздела.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address of the data to read.">Относительный виртуальный адрес данных для чтения.</param>
      <returns vsli:raw="A memory block that starts at &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; and ends at the end of the containing section, or an empty block if &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; doesn't represent a location in any of the PE sections of this PE image.">Блок памяти, начинающийся с <paramref name="relativeVirtualAddress" /> и заканчивающийся в конце содержащего его раздела, или пустой блок, если <paramref name="relativeVirtualAddress" /> не представляет расположение ни в одном из разделов PE этого образа PE.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Заголовки PE содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="An IO error occurred while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Образ PE недоступен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; is negative.">
        <paramref name="relativeVirtualAddress" /> является отрицательным значением.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary vsli:raw="Loads the PE section with the specified name into memory and returns a memory block that spans the section.">Загружает раздел PE с указанным именем в память и возвращает блок памяти, охватывающий этот раздел.</summary>
      <param name="sectionName" vsli:raw="The name of the section.">Имя раздела.</param>
      <returns vsli:raw="A memory block that spans the section, or an empty block if no section of the given &lt;paramref name=&quot;sectionName&quot; /&gt; exists in this PE image.">Блок памяти, охватывающий раздел, или пустой блок, если в этом образе PE не существует раздел заданного <paramref name="sectionName" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;sectionName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Свойство <paramref name="sectionName" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Образ PE недоступен.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary vsli:raw="Gets a value that indicates if the PE image contains CLI metadata.">Возвращает значение, которое указывает, содержит ли образ PE метаданные CLI.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image contains CLI metadata; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если образ PE содержит метаданные CLI; в противном случае <see langword="false" />.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Заголовки PE содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the underlying stream.">Ошибка при чтении из базового потока.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary vsli:raw="Gets a value that indicates if the reader can access the entire PE image.">Возвращает значение, которое указывает, может ли средство чтения получить доступ ко всему образу PE.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader can access the entire PE image; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, если читатель может получить доступ ко всему образу PE; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary vsli:raw="Gets a value that indicates if the PE image has been loaded into memory by the OS loader.">Возвращает значение, которое указывает, был ли образ PE загружен в память загрузчиком ОС.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если образ PE был загружен в память загрузчиком ОС; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary vsli:raw="Gets the PE headers.">Возвращает заголовки PE.</summary>
      <returns vsli:raw="The PE headers for this PE image.">Заголовки PE для этого образа PE.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The headers contain invalid data.">Заголовки содержат недопустимые данные.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Ошибка при чтении из потока.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as CodeView.">Считывает данные, на которые указывает заданная запись каталога отладки, и интерпретирует их как CodeView.</summary>
      <param name="entry" vsli:raw="A Debug Directory entry instance.">Экземпляр записи каталога отладки.</param>
      <returns vsli:raw="A code view debug directory data instance.">Экземпляр данных каталога отладки для представления кода.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a CodeView entry.">
        <paramref name="entry" /> не является записью CodeView.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Неправильный формат данных.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary vsli:raw="Reads all Debug Directory table entries.">Считывает все записи в таблице каталога отладки.</summary>
      <returns vsli:raw="An array of Debug Directory table entries.">Массив записей в таблице каталога отладки.</returns>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the entry.">Неправильный формат записи.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as an Embedded Portable PDB blob.">Считывает данные, на которые указывает заданная запись каталога отладки, и интерпретирует их как BLOB-объект внедренного переносимого PDB.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">Запись каталога отладки, данные которой должны быть считаны.</param>
      <returns vsli:raw="The provider of a metadata reader for reading a Portable PDB image.">Поставщик средства чтения метаданных для чтения образа переносимого PDB.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb&quot; /&gt; entry.">
        <paramref name="entry" /> не является записью <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Неправильный формат данных.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="PE image not available.">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as a PDB Checksum entry.">Считывает данные, на которые указывает заданная запись каталога отладки, и интерпретирует их как запись контрольной суммы PDB.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">Запись каталога отладки, данные которой должны быть считаны.</param>
      <returns vsli:raw="The PDB Checksum entry.">Запись контрольной суммы PDB.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a PDB Checksum entry.">
        <paramref name="entry" /> не является записью контрольной суммы PDB.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Неправильный формат данных.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Ошибка ввода-вывода при чтении из базового потока.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Образ PE недоступен.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary vsli:raw="Opens a Portable PDB associated with this PE image.">Открывает переносимый PDB, связанный с этим образом PE.</summary>
      <param name="peImagePath" vsli:raw="The path to the PE image. The path is used to locate the PDB file located in the directory containing the PE file.">Путь к образу PE. Этот путь используется для поиска PDB-файла, который находится в каталоге, содержащем PE-файл.</param>
      <param name="pdbFileStreamProvider" vsli:raw="If specified, called to open a &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; for a given file path. The provider is expected to either return a readable and seekable &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if the target file doesn't exist or should be ignored for some reason. The provider should throw &lt;see cref=&quot;T:System.IO.IOException&quot; /&gt; if it fails to open the file due to an unexpected IO error.">Если указан, вызывается для открытия <see cref="T:System.IO.Stream" /> для заданного пути к файлу. Поставщик должен возвращать либо доступный для чтения и поиска <see cref="T:System.IO.Stream" />, либо значение <see langword="null" />, если целевой файл не существует либо по какой-либо причине должен быть проигнорирован. Поставщик должен выдать <see cref="T:System.IO.IOException" />, если ему не удается открыть файл из-за непредвиденной ошибки ввода-вывода.</param>
      <param name="pdbReaderProvider" vsli:raw="If successful, a new instance of &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; to be used to read the Portable PDB.">В случае успеха новый экземпляр <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> используется для чтения переносимого PDB.</param>
      <param name="pdbPath" vsli:raw="If successful and the PDB is found in a file, the path to the file, or &lt;see langword=&quot;null&quot; /&gt; if the PDB is embedded in the PE image itself.">Если операция выполнена успешно и PDB найден в файле, путь к файлу, либо <see langword="null" />, если PDB внедрен в сам образ PE.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has a PDB associated with it and the PDB has been successfully opened; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Значение <see langword="true" />, если образ PE имеет связанный с ним PDB, который был успешно открыт; в противном случае значение <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImagePath&quot; /&gt; or &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Значение параметра <paramref name="peImagePath" /> или <paramref name="pdbFileStreamProvider" /> — <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The stream returned from &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; doesn't support read and seek operations.">Поток, возвращенный из <paramref name="pdbFileStreamProvider" />, не поддерживает операции чтения и поиска.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="No matching PDB file was found due to an error: The PE image or the PDB is invalid.">Соответствующий PDB-файл не найден из-за ошибки: Недопустимый образ PE или PDB.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="No matching PDB file was found due to an error: An IO error occurred while reading the PE image or the PDB.">Соответствующий PDB-файл не найден из-за ошибки: При чтении образа PE или PDB произошла ошибка ввода-вывода.</exception>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary vsli:raw="Provides options that specify how sections of a PE image are read from a stream.">Предоставляет параметры, определяющие способ считывания разделов образа PE из потока.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed, and sections of the PE image are read lazily.">По умолчанию при удалении объекта <see cref="T:System.Reflection.PortableExecutable.PEReader" /> поток удаляется и разделы образа PE считываются в отложенном режиме.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary vsli:raw="Indicates that the underlying PE image has been loaded into memory by the OS loader.">Указывает, что базовый образ PE был загружен в память загрузчиком ОС.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed.">Сохраняет поток открытым при удалении объекта <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary vsli:raw="Reads the entire image into memory right away. &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified.">Немедленно считывает весь образ в память. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> автоматически закрывает поток, когда конструктор возвращает управление, если не указан параметр <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads the metadata section into memory right away.&lt;/para&gt;&lt;para&gt;Reading from other sections of the file is not allowed (&lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown by the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;).&lt;/para&gt;&lt;para&gt;&lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified. The underlying file may be closed and even deleted after &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is constructed.&lt;/para&gt;">Немедленно считывает раздел метаданных в память.Чтение из других разделов файла запрещено (<see cref="T:System.InvalidOperationException" /> выдается <see cref="T:System.Reflection.PortableExecutable.PEReader" />).<see cref="T:System.Reflection.PortableExecutable.PEReader" /> автоматически закрывает поток, когда конструктор возвращает управление, если не указан параметр <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />. После создания <see cref="T:System.Reflection.PortableExecutable.PEReader" /> базовый файл может быть закрыт и даже удален.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary vsli:raw="Defines the base class for a PE resource section builder. Derive from &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; to provide serialization logic for native resources.">Определяет базовый класс для построителя разделов ресурсов PE. Наследование от <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> для предоставления логики сериализации для собственных ресурсов.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; class.">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary vsli:raw="Serializes the specified resource.">Сериализует указанный ресурс.</summary>
      <param name="builder" vsli:raw="A blob that contains the data to serialize.">BLOB-объект, содержащий данные для сериализации.</param>
      <param name="location" vsli:raw="The location to which to serialize &lt;paramref name=&quot;builder&quot; /&gt;.">Расположение, куда следует сериализовать <paramref name="builder" />.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary vsli:raw="Provides information about the section header of a PE/COFF file.">Предоставляет сведения о заголовке раздела файла PE/COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary vsli:raw="Gets the name of the section.">Возвращает имя раздела.</summary>
      <returns vsli:raw="The name of the section.">Имя раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary vsli:raw="Gets the number of line-number entries for the section.">Возвращает количество записей номеров строк для раздела.</summary>
      <returns vsli:raw="The number of line-number entries for the section.">Число записей номера строки для раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary vsli:raw="Gets the number of relocation entries for the section.">Возвращает количество записей перемещения для раздела.</summary>
      <returns vsli:raw="The number of relocation entries for the section. Its value is zero for PE images.">Число записей перемещения для раздела. Его значение равно нулю для образов PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary vsli:raw="Gets the file pointer to the beginning of line-number entries for the section.">Возвращает указатель файла на начало записей номеров строк для раздела.</summary>
      <returns vsli:raw="The file pointer to the beginning of line-number entries for the section, or zero if there are no COFF line numbers.">Указатель файла на начало записи номера строки для раздела или нуль, если нет номеров строк COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary vsli:raw="Gets the file pointer to the first page of the section within the COFF file.">Возвращает указатель файла на первую страницу раздела в файле COFF.</summary>
      <returns vsli:raw="The file pointer to the first page of the section within the COFF file.">Указатель файла на первую страницу раздела в COFF-файле.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary vsli:raw="Gets the file pointer to the beginning of relocation entries for the section.">Возвращает указатель файла на начало записей перемещения для раздела.</summary>
      <returns vsli:raw="The file pointer to the beginning of relocation entries for the section. It is set to zero for PE images or if there are no relocations.">Указатель файла на начало записей перемещения для раздела. Для образов PE задано нулевое значение или если перемещения отсутствуют.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary vsli:raw="Gets the flags that describe the characteristics of the section.">Возвращает флаги, описывающие характеристики раздела.</summary>
      <returns vsli:raw="The flags that describe the characteristics of the section.">Флаги, описывающие характеристики раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary vsli:raw="Gets the size of the section (for object files) or the size of the initialized data on disk (for image files).">Возвращает размер раздела (для объектных файлов) или размер инициализированных данных на диске (для файлов образов).</summary>
      <returns vsli:raw="The size of the section (for object files) or the size of the initialized data on disk (for image files).">Размер раздела (для объектных файлов) или размера инициализированных данных на диске (для файлов изображений).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary vsli:raw="Gets the virtual addess of the section.">Возвращает виртуальный адрес раздела.</summary>
      <returns vsli:raw="The virtual address of the section.">Виртуальный адрес раздела.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary vsli:raw="Gets the total size of the section when loaded into memory.">Возвращает общий размер раздела при загрузке в память.</summary>
      <returns vsli:raw="The total size of the section when loaded into memory.">Общий размер раздела при загрузке в память.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="pointerToRawData" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary vsli:raw="Describes the subsystem requirement for the image.">Описывает требования к подсистеме для образа.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary vsli:raw="Extensible Firmware Interface (EFI) application.">Приложение EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary vsli:raw="EFI driver with boot services.">Драйвер EFI со службами загрузки.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary vsli:raw="EFI ROM image.">Образ ПЗУ EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary vsli:raw="EFI driver with run-time services.">Драйвер EFI со службами среды выполнения.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary vsli:raw="The image doesn't require a subsystem.">Для образа не требуется наличие подсистемы.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary vsli:raw="The image is a native Win9x driver.">Образ является собственным драйвером Win9x.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary vsli:raw="The image runs in the OS/2 character subsystem.">Образ выполняется в подсистеме символов OS/2.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary vsli:raw="The image runs in the Posix character subsystem.">Образ выполняется в подсистеме символов POSIX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary vsli:raw="Unknown subsystem.">Неизвестная подсистема.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary vsli:raw="Boot application.">Приложение загрузки.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary vsli:raw="The image runs in the Windows CE subsystem.">Образ выполняется в подсистеме Windows CE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary vsli:raw="The image runs in the Windows character subsystem.">Образ выполняется в подсистеме символов Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary vsli:raw="The image runs in the Windows GUI subsystem.">Образ выполняется в подсистеме графического пользовательского интерфейса Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary vsli:raw="Xbox system.">Система Xbox.</summary>
    </member>
  </members>
</doc>