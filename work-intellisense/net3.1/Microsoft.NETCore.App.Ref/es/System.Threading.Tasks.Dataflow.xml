<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Threading.Tasks.Dataflow</name>
  </assembly>
  <members>
    <member name="T:System.Threading.Tasks.Dataflow.ActionBlock`1">
      <summary vsli:raw="Provides a dataflow block that invokes a provided &lt;see cref=&quot;T:System.Action`1&quot; /&gt; delegate for every data element received.">Proporciona un bloque de flujo de datos que invoca un delegado proporcionado de <see cref="T:System.Action`1" /> para cada elemento de datos recibido.</summary>
      <typeparam name="TInput" vsli:raw="The type of data that this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt; operates on.">El tipo de datos en el que este <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> funciona.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Action{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt; class with the specified action.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción especificada.</summary>
      <param name="action" vsli:raw="The action to invoke with each data element received.">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;action&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="action" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Action{`0},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt; class with the specified action and configuration options.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción y opciones de configuración especificadas.</summary>
      <param name="action" vsli:raw="The action to invoke with each data element received.">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;action&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="action" /> es <see langword="null" />.
O bien
<paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Func{`0,System.Threading.Tasks.Task})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt; class with the specified action.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción especificada.</summary>
      <param name="action" vsli:raw="The action to invoke with each data element received.">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;action&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="action" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Func{`0,System.Threading.Tasks.Task},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt; class with the specified action and configuration options.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> con la acción y opciones de configuración especificadas.</summary>
      <param name="action" vsli:raw="The action to invoke with each data element received.">Acción que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;action&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="action" /> es <see langword="null" />.
o bien
<paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.Complete">
      <summary vsli:raw="Signals to the dataflow block  that it shouldn't accept or produce any more messages and shouldn't consume any more postponed messages.">Indica al bloque de flujo de datos que no debe aceptar o generar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ActionBlock`1.Completion">
      <summary vsli:raw="Gets a  &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; object that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The completed task.">Tarea completada.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ActionBlock`1.InputCount">
      <summary vsli:raw="Gets the number of input items waiting to be processed by this block.">Obtiene el número de elementos de entrada en espera de ser procesados por este bloque.</summary>
      <returns vsli:raw="The number of input items waiting to be processed by this block.">El número de elementos de entrada en espera de ser procesados por este bloque.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.Post(`0)">
      <summary vsli:raw="Posts an item to the target dataflow block.">Publica un elemento en el bloque de flujo de datos de destino.</summary>
      <param name="item" vsli:raw="The item being offered to the target.">Elemento que se va a ofrecer al destino.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the item is posted to the dataflow block; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el elemento se envía al bloque de flujo de datos; si no, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the dataflow block to complete in a faulted state.">Hace que el bloque de flujo de datos se completar con errores.</summary>
      <param name="exception" vsli:raw="The exception that caused the faulting.">Excepción que provocó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the dataflow block, and gives it the opportunity to consume or postpone the message.">Proporciona un mensaje para el bloque de flujo de datos y le ofrece la posibilidad de utilizarlo o posponerlo.</summary>
      <param name="messageHeader" vsli:raw="The header of the message being offered.">Encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The dataflow block that is offering the message. This may be &lt;see langword=&quot;null&quot; /&gt;.">Bloque de flujo de datos que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to instruct the target to call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar al destino que llama a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> de manera sincrónica durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para consumir el mensaje; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="The status of the offered message.  If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, because it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed message, but source was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido.  Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino hubiera pospuesto de otra forma el mensaje, pero el origen fuera <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or- &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may be &lt;see langword=&quot;true&quot; /&gt; only if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien <paramref name="consumeToAccept" /> puede ser <see langword="true" /> solo si se proporciona un valor <paramref name="source" /> que no es NULL.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ActionBlock`1.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BatchBlock`1">
      <summary vsli:raw="Provides a dataflow block that batches inputs into arrays.">Proporciona un bloque de flujo de datos que procesa las entradas en las matrices por lotes.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of data put into batches.">Especifica el tipo de datos guardados en lotes.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchBlock`1&quot; /&gt; with the specified batch size.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> con el tamaño de lote especificado.</summary>
      <param name="batchSize" vsli:raw="The number of items to group into a batch.">Número de elementos que se van a agrupar en un lote.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;batchSize&quot; /&gt; must be positive.">
        <paramref name="batchSize" /> debe ser positivo.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchBlock`1&quot; /&gt; with the specified batch size, declining option, and block options.">Inicializa una nueva <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> con el tamaño de lote especificado, la opción de rechazo y las opciones de bloque.</summary>
      <param name="batchSize" vsli:raw="The number of items to group into a batch.">Número de elementos que se van a agrupar en un lote.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchBlock`1&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;batchSize&quot; /&gt; must be positive.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;batchSize&quot; /&gt; must be smaller than the value of the &lt;see cref=&quot;P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity&quot; /&gt; option if a non-default value has been set.">
        <paramref name="batchSize" /> debe ser positivo.
O bien
<paramref name="batchSize" /> debe ser menor que el valor de la opción <see cref="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity" /> si se ha establecido un valor no predeterminado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize">
      <summary vsli:raw="Gets the size of the batches generated by this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchBlock`1&quot; /&gt;.">Obtiene el tamaño de los lotes generados por <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</summary>
      <returns vsli:raw="The batch size.">Tamaño del lote.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchBlock`1.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchBlock`1.OutputCount">
      <summary vsli:raw="Gets the number of output items available to be received from this block.">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns vsli:raw="The number of output items.">Número de elementos de salida.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a  &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T[]}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Boolean@)">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to accept and consume a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; previously offered by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; .">Lo llama una <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y consumir una <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being consumed.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; consuming the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The value of the consumed message. This may correspond to a different &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance than was previously reserved and passed as the &lt;paramref name=&quot;messageHeader&quot; /&gt; to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt;. The consuming &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; must use the returned value instead of the value passed as messageValue through &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;.  &#xA;  &#xA; If the message requested is not available, the return value will be &lt;see langword=&quot;null&quot; /&gt;.">Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como messageValue mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The  &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T[]}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to release a previously reserved &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message being released.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; releasing the message it previously reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; did not have the message reserved.">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T[]}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to reserve a previously offered &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; reserving the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully reserved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, giving the target the opportunity to consume or postpone the message.">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance that represents the header of the message being offered.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; offering the message. This may be null.">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Éste puede ser null.</param>
      <param name="consumeToAccept" vsli:raw="Set to &lt;see langword=&quot;true&quot; /&gt; to instruct the target to call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message.">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <returns vsli:raw="The status of the offered message. If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, because it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed message, but &lt;paramref name=&quot;source&quot; /&gt; was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is instead returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The  &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or- &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may only be true if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TriggerBatch">
      <summary vsli:raw="Triggers the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchBlock`1&quot; /&gt; to initiate a batching operation even if the number of currently queued or postponed items is less than the &lt;see cref=&quot;P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize&quot; /&gt;.">Desencadena <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> para iniciar una operación de procesamiento por lotes incluso si el número de elementos actualmente en cola o pospuestos es menor que <see cref="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceive(System.Predicate{`0[]},`0[]@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate a value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0[]}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2">
      <summary vsli:raw="Provides a dataflow block that batches a specified number of inputs of potentially differing types provided to one or more of its targets.">Proporciona un bloque de flujo de datos que procesa por lotes un número especificado de entradas de tipos potencialmente distintos que se suministran a uno o más de sus destinos.</summary>
      <typeparam name="T1" vsli:raw="Specifies the type of data accepted by the block's first target.">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies the type of data accepted by the block's second target.">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2&quot; /&gt; with the specified configuration.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" /> con la configuración especificada.</summary>
      <param name="batchSize" vsli:raw="The number of items to group into a batch.">Número de elementos que se van a agrupar en un lote.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;batchSize&quot; /&gt; must be positive.">
        <paramref name="batchSize" /> debe ser positivo.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2&quot; /&gt; with the specified configuration.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" /> con la configuración especificada.</summary>
      <param name="batchSize" vsli:raw="The number of items to group into a batch.">Número de elementos que se van a agrupar en un lote.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;batchSize&quot; /&gt; is less than one.">
        <paramref name="batchSize" /> es menor que uno.</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.BatchSize">
      <summary vsli:raw="Gets the size of the batches generated by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2&quot; /&gt;.">Obtiene el tamaño de los lotes generados por <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" />.</summary>
      <returns vsli:raw="The batch size.">Tamaño del lote.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.OutputCount">
      <summary vsli:raw="Gets the number of output items available to be received from this block.">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns vsli:raw="The number of output items.">Número de elementos de salida.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a  &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}},System.Boolean@)">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be consumed." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be consumed." />
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed. &lt;see langword=&quot;false&quot; /&gt; otherwise." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; that currently holds the reservation." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be reserved." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be reserved." />
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Target1">
      <summary vsli:raw="Gets a target that may be used to offer messages of the first type.">Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.Target2">
      <summary vsli:raw="Gets a target that may be used to offer messages of the second type.">Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.TryReceive(System.Predicate{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}},System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate a value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1}}}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3">
      <summary vsli:raw="Provides a dataflow block that batches a specified number of inputs of potentially differing types provided to one or more of its targets.">Proporciona un bloque de flujo de datos que procesa por lotes un número especificado de entradas de tipos potencialmente distintos proporcionados a uno o más de sus destinos.</summary>
      <typeparam name="T1" vsli:raw="Specifies the type of data accepted by the block's first target.">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies the type of data accepted by the block's second target.">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
      <typeparam name="T3" vsli:raw="Specifies the type of data accepted by the block's third target.">Especifica el tipo de datos aceptados por el tercer destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3&quot; /&gt; with the specified configuration.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> con la configuración especificada.</summary>
      <param name="batchSize" vsli:raw="The number of items to group into a batch.">Número de elementos que se van a agrupar en un lote.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;batchSize&quot; /&gt; must be positive.">
        <paramref name="batchSize" /> debe ser positivo.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3&quot; /&gt; with the specified configuration.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> con la configuración especificada.</summary>
      <param name="batchSize" vsli:raw="The number of items to group into a batch.">Número de elementos que se van a agrupar en un lote.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;batchSize&quot; /&gt; must be positive.">
        <paramref name="batchSize" /> debe ser positivo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.BatchSize">
      <summary vsli:raw="Gets the size of the batches generated by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3&quot; /&gt;.">Obtiene el tamaño de los lotes generados por <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />.</summary>
      <returns vsli:raw="The batch size.">Tamaño del lote.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the source should unlink from the target after successfully propagating a single message; &lt;see langword=&quot;false&quot; /&gt; to remain connected even after a single message has been propagated.">
        <see langword="true" /> si el origen debe desvincularse del destino después de propagarse correctamente un único mensaje; <see langword="false" /> para seguir conectado incluso después de que se haya propagado un único mensaje.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.OutputCount">
      <summary vsli:raw="Gets the number of output items available to be received from this block.">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns vsli:raw="The number of output items.">Número de elementos de salida.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a  &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}@System#Collections#Generic#IList{T3}}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Boolean@)">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be consumed." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be consumed." />
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed. &lt;see langword=&quot;false&quot; /&gt; otherwise." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}@System#Collections#Generic#IList{T3}}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; that currently holds the reservation." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{System#Collections#Generic#IList{T1}@System#Collections#Generic#IList{T2}@System#Collections#Generic#IList{T3}}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be reserved." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be reserved." />
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target1">
      <summary vsli:raw="Gets a target that may be used to offer messages of the first type.">Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target2">
      <summary vsli:raw="Gets a target that may be used to offer messages of the second type.">Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target3">
      <summary vsli:raw="Gets a target that may be used to offer messages of the third type.">Obtiene un destino que se puede usar para ofrecer mensajes del tercer tipo.</summary>
      <returns vsli:raw="The target.">El destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceive(System.Predicate{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate a value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt; in which case all items will pass.">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1">
      <summary vsli:raw="Provides a buffer for storing at most one element at time, overwriting each message with the next as it arrives.">Proporciona un búfer para almacenar a lo sumo un elemento cada vez, sobrescribiendo cada mensaje con el siguiente a medida que llegan.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of the data buffered by this dataflow block.">Especifica el tipo de los datos almacenados en el búfer por este bloque de flujo de datos.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.#ctor(System.Func{`0,`0})">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BroadcastBlock`1&quot; /&gt; with the specified cloning function.">Inicializa la instancia <see cref="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1" /> con la función de clonación especificada.</summary>
      <param name="cloningFunction" vsli:raw="The function to use to clone the data when offered to other blocks.">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.#ctor(System.Func{`0,`0},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BroadcastBlock`1&quot; /&gt; with the specified cloning function and  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowBlockOptions&quot; /&gt;.">Inicializa <see cref="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1" /> con la función de clonación y <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> especificados.</summary>
      <param name="cloningFunction" vsli:raw="The function to use to clone the data when offered to other blocks.">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BroadcastBlock`1&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BroadcastBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BroadcastBlock`1.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;.">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que la interfaz <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> .</summary>
      <param name="exception" vsli:raw="The  &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#IReceivableSourceBlock{T}#TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to accept and consume a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; previously offered by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being consumed.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; consuming the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The value of the consumed message. This may correspond to a different  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance than was previously reserved and passed as the &lt;paramref name=&quot;messageHeader&quot; /&gt; to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt;. The consuming &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; must use the returned value instead of the value passed as &lt;paramref name=&quot;messageValue&quot; /&gt; through &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;.  &#xA;  &#xA; If the message requested is not available, the return value will be &lt;see langword=&quot;null&quot; /&gt;.">Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to release a previously reserved &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message being released.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; releasing the message it previously reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; did not have the message reserved.">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to reserve a previously offered &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; reserving the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully reserved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, giving the target the opportunity to consume or postpone the message.">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance that represents the header of the message being offered.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; offering the message. This may be null.">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Éste puede ser null.</param>
      <param name="consumeToAccept" vsli:raw="Set to &lt;see langword=&quot;true&quot; /&gt; to instruct the target to call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message.">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <returns vsli:raw="The status of the offered message. If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, because it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed message, but &lt;paramref name=&quot;source&quot; /&gt; was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is instead returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The  &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or- &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may only be true if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BroadcastBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate a value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">Predicado que un valor debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.BufferBlock`1">
      <summary vsli:raw="Provides a buffer for storing data for a Dataflow.">Proporciona un búfer para almacenar datos de un Dataflow.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of the data buffered by this dataflow block.">Especifica el tipo de los datos almacenados en el búfer por este bloque de flujo de datos.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.#ctor">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BufferBlock`1&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.BufferBlock`1" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.#ctor(System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BufferBlock`1&quot; /&gt; with the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowBlockOptions&quot; /&gt;.">Inicializa un <see cref="T:System.Threading.Tasks.Dataflow.BufferBlock`1" /> nuevo con las <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> especificadas.</summary>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BufferBlock`1&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BufferBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BufferBlock`1.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.BufferBlock`1.Count">
      <summary vsli:raw="Gets the number of items currently stored in the buffer.">Obtiene el número de elementos actual almacenados en el búfer.</summary>
      <returns vsli:raw="The number of items.">Número de elementos.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;.">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The  &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to accept and consume a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; previously offered by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being consumed.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; consuming the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The value of the consumed message. This may correspond to a different  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance than was previously reserved and passed as the &lt;paramref name=&quot;messageHeader&quot; /&gt; to  &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt;. The consuming &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; must use the returned value instead of the value passed as &lt;paramref name=&quot;messageValue&quot; /&gt; through &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;.  &#xA;  &#xA; If the message requested is not available, the return value will be &lt;see langword=&quot;null&quot; /&gt;.">Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to release a previously reserved &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message being released.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; releasing the message it previously reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; did not have the message reserved.">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to reserve a previously offered &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; reserving the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully reserved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, giving the target the opportunity to consume or postpone the message.">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance that represents the header of the message being offered.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; offering the message. This may be &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept" vsli:raw="Set to true to instruct the target to call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message.">Se establece en true para indicar al destino que llame a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> de manera sincrónica durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para consumir el mensaje.</param>
      <returns vsli:raw="The status of the offered message. If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, because it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed message, but &lt;paramref name=&quot;source&quot; /&gt; was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is instead returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The  &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or- &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may only be true if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate value must successfully pass in order for it to be received. &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">El valor del predicado debe pasar correctamente para que se reciba. <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.BufferBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowBlock">
      <summary vsli:raw="Provides a set of static (Shared in Visual Basic) methods for working with dataflow blocks.">Proporciona un conjunto de métodos estáticos (Shared en Visual Basic) para que funcionen con bloques de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary vsli:raw="Creates a new &lt;see cref=&quot;T:System.IObservable`1&quot; /&gt; abstraction over the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Crea una nueva abstracción de la interfaz <see cref="T:System.IObservable`1" /> sobre la interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="source" vsli:raw="The source to wrap.">El origen para ajustar.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.IObservable`1&quot; /&gt; that enables observers to be subscribed to the source.">
        <see cref="T:System.IObservable`1" /> que permite a los observadores que se suscriban al origen.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0})">
      <summary vsli:raw="Creates a new &lt;see cref=&quot;T:System.IObserver`1&quot; /&gt; abstraction over the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;.">Crea una abstracción de <see cref="T:System.IObserver`1" /> sobre <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="target" vsli:raw="The target to wrap.">Destino que se va a incluir.</param>
      <typeparam name="TInput" vsli:raw="Specifies the type of input accepted by the target block.">Especifica el tipo de entrada aceptado por el bloque de destino.</typeparam>
      <returns vsli:raw="An observer that wraps the target block.">Un observador que contiene el bloque de destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1})">
      <summary vsli:raw="Monitors two dataflow sources, invoking the provided handler for whichever source makes data available first.">Supervisa dos orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1" vsli:raw="The first source.">El primer origen.</param>
      <param name="action1" vsli:raw="The handler to execute on data from the first source.">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2" vsli:raw="The second source.">El segundo origen.</param>
      <param name="action2" vsli:raw="The handler to execute on data from the second source.">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <typeparam name="T1" vsli:raw="Specifies type of data contained in the first source.">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies type of data contained in the second source.">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <returns vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that represents the asynchronous choice. If both sources are completed prior to the choice completing, the resulting task will be canceled. When one of the sources has data available and successfully propagates it to the choice, the resulting task will complete when the handler completes; if the handler throws an exception, the task will end in the &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state and will contain the unhandled exception. Otherwise, the task will end with its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; set to either 0 or 1 to represent the first or second source, respectively.  &#xA;  &#xA; This method will only consume an element from one of the two data sources, never both.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si ambos orígenes se completan antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en 0 o 1 para representar el primer o el segundo origen, respectivamente.
Este método solo consumirá un elemento de uno de los dos orígenes de datos, nunca de ambos.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The  &lt;paramref name=&quot;action1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;source2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source1" /> es <see langword="null" />.
O bien
El valor de <paramref name="action1" /> es <see langword="null" />.
o bien
El valor de <paramref name="source2" /> es <see langword="null" />.
o bien
El valor de <paramref name="action2" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary vsli:raw="Monitors two dataflow sources, invoking the provided handler for whichever source makes data available first.">Supervisa dos orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1" vsli:raw="The first source.">El primer origen.</param>
      <param name="action1" vsli:raw="The handler to execute on data from the first source.">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2" vsli:raw="The second source.">El segundo origen.</param>
      <param name="action2" vsli:raw="The handler to execute on data from the second source.">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this choice.">Las opciones con las que se van a configurar esta opción.</param>
      <typeparam name="T1" vsli:raw="Specifies type of data contained in the first source.">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies type of data contained in the second source.">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <returns vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that represents the asynchronous choice. If both sources are completed prior to the choice completing, or if the &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; provided as part of &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is canceled prior to the choice completing, the resulting task will be canceled. When one of the sources has data available and successfully propagates it to the choice, the resulting task will complete when the handler completes; if the handler throws an exception, the task will end in the &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state and will contain the unhandled exception. Otherwise, the task will end with its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; set to either 0 or 1 to represent the first or second source, respectively.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si ambos orígenes se completan antes de completar la selección o si el <see cref="T:System.Threading.CancellationToken" /> proporcionado como parte de <paramref name="dataflowBlockOptions" /> se cancela antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en 0 o 1 para representar el primer o el segundo origen, respectivamente.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;source2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source1" /> es <see langword="null" />.
O bien
El valor de <paramref name="action1" /> es <see langword="null" />.
O bien
El valor de <paramref name="source2" /> es <see langword="null" />.
O bien
El valor de <paramref name="action2" /> es <see langword="null" />.
O bien
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2})">
      <summary vsli:raw="Monitors three dataflow sources, invoking the provided handler for whichever source makes data available first.">Supervisa tres orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1" vsli:raw="The first source.">El primer origen.</param>
      <param name="action1" vsli:raw="The handler to execute on data from the first source.">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2" vsli:raw="The second source.">El segundo origen.</param>
      <param name="action2" vsli:raw="The handler to execute on data from the second source.">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <param name="source3" vsli:raw="The third source.">El tercer origen.</param>
      <param name="action3" vsli:raw="The handler to execute on data from the third source.">Controlador que se va a ejecutar en datos del tercer origen.</param>
      <typeparam name="T1" vsli:raw="Specifies type of data contained in the first source.">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies type of data contained in the second source.">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <typeparam name="T3" vsli:raw="Specifies type of data contained in the third source.">Especifica el tipo de datos contenidos en el tercer origen.</typeparam>
      <returns vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that represents the asynchronous choice. If all sources are completed prior to the choice completing, the resulting task will be canceled. When one of the sources has data available and successfully propagates it to the choice, the resulting task will complete when the handler completes; if the handler throws an exception, the task will end in the &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state and will contain the unhandled exception. Otherwise, the task will end with its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; set to the 0-based index of the source.  &#xA;  &#xA; This method will only consume an element from one of the data sources, never more than one.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si todos los orígenes se completan antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en el índice de base 0 del origen.
Este método solo consumirá un elemento de uno de los orígenes de datos, nunca de más de uno.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;source2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;source3&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action3&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source1" /> es <see langword="null" />.
o bien
El valor de <paramref name="action1" /> es <see langword="null" />.
o bien
El valor de <paramref name="source2" /> es <see langword="null" />.
O bien
El valor de <paramref name="action2" /> es <see langword="null" />.
O bien
El valor de <paramref name="source3" /> es <see langword="null" />.
o bien
El valor de <paramref name="action3" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary vsli:raw="Monitors three dataflow sources, invoking the provided handler for whichever source makes data available first.">Supervisa tres orígenes de flujo de datos, invocando el controlador proporcionado para cualquier origen que haga que los datos se encuentren disponibles en primer lugar.</summary>
      <param name="source1" vsli:raw="The first source.">El primer origen.</param>
      <param name="action1" vsli:raw="The handler to execute on data from the first source.">Controlador que se va a ejecutar en datos del primer origen.</param>
      <param name="source2" vsli:raw="The second source.">El segundo origen.</param>
      <param name="action2" vsli:raw="The handler to execute on data from the second source.">Controlador que se va a ejecutar en datos del segundo origen.</param>
      <param name="source3" vsli:raw="The third source.">El tercer origen.</param>
      <param name="action3" vsli:raw="The handler to execute on data from the third source.">Controlador que se va a ejecutar en datos del tercer origen.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this choice.">Las opciones con las que se van a configurar esta opción.</param>
      <typeparam name="T1" vsli:raw="Specifies type of data contained in the first source.">Especifica el tipo de datos contenidos en el primer origen.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies type of data contained in the second source.">Especifica el tipo de datos contenidos en el segundo origen.</typeparam>
      <typeparam name="T3" vsli:raw="Specifies type of data contained in the third source.">Especifica el tipo de datos contenidos en el tercer origen.</typeparam>
      <returns vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that represents the asynchronous choice. If all sources are completed prior to the choice completing, or if the &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; provided as part of &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is canceled prior to the choice completing, the resulting task will be canceled. When one of the sources has data available and successfully propagates it to the choice, the resulting task will complete when the handler completes; if the handler throws an exception, the task will end in the &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state and will contain the unhandled exception. Otherwise, the task will end with its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; set to the 0-based index of the source.  &#xA;  &#xA; This method will only consume an element from one of the data sources, never more than one. If cancellation is requested after an element has been received, the cancellation request will be ignored, and the relevant handler will be allowed to execute.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa la elección asincrónica. Si todos los orígenes se completan antes de completar la selección o si el <see cref="T:System.Threading.CancellationToken" /> proporcionado como parte de <paramref name="dataflowBlockOptions" /> se cancela antes de completar la selección, la tarea resultante se cancelará. Cuando uno de los orígenes tiene datos disponibles y los propaga correctamente a la opción, la tarea resultante se completará cuando se complete el controlador; si el controlador produce una excepción, la tarea finalizará en el estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> y contendrá la excepción no controlada. En caso contrario, la tarea finalizará con la propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> establecida en el índice de base 0 del origen.
Este método solo consumirá un elemento de uno de los orígenes de datos, nunca de más de uno. Si se solicita la cancelación una vez recibido un elemento, la solicitud de cancelación se omitirá y se permitirá que el controlador pertinente se ejecute.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action1&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;source2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action2&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;source3&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;action3&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source1" /> es <see langword="null" />.
o bien
El valor de <paramref name="action1" /> es <see langword="null" />.
o bien
El valor de <paramref name="source2" /> es <see langword="null" />.
O bien
El valor de <paramref name="action2" /> es <see langword="null" />.
o bien
El valor de <paramref name="source3" /> es <see langword="null" />.
o bien
El valor de <paramref name="action3" /> es <see langword="null" />.
O bien
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate``2(System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1})">
      <summary vsli:raw="Encapsulates a target and a source into a single propagator.">Encapsula un destino y un origen en un único propagador.</summary>
      <param name="target" vsli:raw="The target to encapsulate.">Destino que se va a encapsular.</param>
      <param name="source" vsli:raw="The source to encapsulate.">Origen que se va a encapsular.</param>
      <typeparam name="TInput" vsli:raw="Specifies the type of input expected by the target.">Especifica el tipo de entrada que se espera en el destino.</typeparam>
      <typeparam name="TOutput" vsli:raw="Specifies the type of output produced by the source.">Especifica el tipo de salida generado por el origen.</typeparam>
      <returns vsli:raw="The encapsulated target and source.">Destino y origen encapsulados.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0})">
      <summary vsli:raw="Links the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;.">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="source" vsli:raw="The source from which to link.">El origen desde el que se va a vincular.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect the source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con la que conectar el origen.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.IDisposable&quot; /&gt; that, upon calling &lt;see langword=&quot;Dispose&quot; /&gt;, will unlink the source from the target.">
        <see cref="T:System.IDisposable" /> que, tras llamar a <see langword="Dispose" />, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source" /> es <see langword="null" />.
o bien
El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Predicate{``0})">
      <summary vsli:raw="Links the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; using the specified filter.">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado con el filtro especificado.</summary>
      <param name="source" vsli:raw="The source from which to link.">El origen desde el que se va a vincular.</param>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect the source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> al que conectar el origen.</param>
      <param name="predicate" vsli:raw="The filter a message must pass in order for it to propagate from the source to the target.">Filtro que un mensaje debe pasar para que se propague del origen al destino.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.IDisposable&quot; /&gt; that, upon calling &lt;see langword=&quot;Dispose&quot; /&gt;, will unlink the source from the target.">
        <see cref="T:System.IDisposable" /> que, tras llamar a <see langword="Dispose" />, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;predicate&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source" /> es <see langword="null" />.
O bien
El valor de <paramref name="target" /> es <see langword="null" />.
O bien
El valor de <paramref name="predicate" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.DataflowLinkOptions,System.Predicate{``0})">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; using the specified filter.">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado con el filtro especificado.</summary>
      <param name="source" vsli:raw="The source from which to link.">El origen desde el que se va a vincular.</param>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect the source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> al que conectar el origen.</param>
      <param name="linkOptions" vsli:raw="One of the enumeration values that specifies how to configure a link between dataflow blocks.">Uno de los valores de enumeración que especifica cómo configurar un vínculo entre bloques de flujo de datos.</param>
      <param name="predicate" vsli:raw="The filter a message must pass in order for it to propagate from the source to the target.">Filtro que un mensaje debe pasar para que se propague del origen al destino.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.IDisposable&quot; /&gt; that, upon calling &lt;see langword=&quot;Dispose&quot; /&gt;, will unlink the source from the target.">
        <see cref="T:System.IDisposable" /> que, tras llamar a <see langword="Dispose" />, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The  &lt;paramref name=&quot;source&quot; /&gt; is null (Nothing in Visual Basic).  &#xA;  &#xA; -or-  &#xA;  &#xA; The  &lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic).  &#xA;  &#xA; -or-  &#xA;  &#xA; The  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).  &#xA;  &#xA; -or-  &#xA;  &#xA; The  &lt;paramref name=&quot;predicate&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="source" /> es NULL (Nothing en Visual Basic).
O bien
<paramref name="target" /> es NULL (Nothing en Visual Basic).
o bien
<paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).
O bien
<paramref name="predicate" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget``1">
      <summary vsli:raw="Gets a target block that synchronously accepts all messages offered to it and drops them.">Obtiene un bloque de destino que acepta sincrónicamente todos los mensajes que se le proporcionan y los coloca.</summary>
      <typeparam name="TInput" vsli:raw="The type of the messages this block can accept.">El tipo de mensajes que este bloque puede aceptar.</typeparam>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; that accepts and subsequently drops all offered messages.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que acepta y quita posteriormente todos los mensajes proporcionados.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that asynchronously monitors the source for available output.">Proporciona un objeto <see cref="T:System.Threading.Tasks.Task`1" /> que supervisa de forma asincrónica el origen de salida disponible.</summary>
      <param name="source" vsli:raw="The source to monitor.">El origen para supervisar.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that informs of whether and when more output is available. If, when the task completes, its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, more output is available in the source (though another consumer of the source may retrieve the data).  &#xA;  &#xA; If it returns &lt;see langword=&quot;false&quot; /&gt;, more output is not and will never be available, due to the source completing prior to output being available.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que informa si la salida está disponible y cuándo. Si, cuando la tarea se completa, el <see cref="P:System.Threading.Tasks.Task`1.Result" /> es <see langword="true" />, hay más salida disponible en el origen (aunque otro consumidor del origen puede recuperar los datos).
Si devuelve <see langword="false" />, no hay más resultados y nunca estarán disponibles, debido a que el origen se completa antes de que los resultados estén disponibles.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)">
      <summary vsli:raw="Provides a  &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that asynchronously monitors the source for available output.">Proporciona una <see cref="T:System.Threading.Tasks.Task`1" /> que supervisa de manera asincrónica la salida disponible en el origen.</summary>
      <param name="source" vsli:raw="The source to monitor.">El origen para supervisar.</param>
      <param name="cancellationToken" vsli:raw="The cancellation token with which to cancel the asynchronous operation.">El token de cancelación con el que cancelar la operación asincrónica.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that informs of whether and when more output is available. If, when the task completes, its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, more output is available in the source (though another consumer of the source may retrieve the data). If it returns &lt;see langword=&quot;false&quot; /&gt;, more output is not and will never be available, due to the source completing prior to output being available.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que informa si la salida está disponible y cuándo. Si, cuando la tarea se completa, el <see cref="P:System.Threading.Tasks.Task`1.Result" /> es <see langword="true" />, hay más salida disponible en el origen (aunque otro consumidor del origen puede recuperar los datos). Si devuelve <see langword="false" />, no hay más resultados y nunca estarán disponibles, debido a que el origen se completa antes de que los resultados estén disponibles.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Post``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)">
      <summary vsli:raw="Posts an item to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;.">Publica un elemento a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
      <param name="target" vsli:raw="The target block.">Bloque de destino.</param>
      <param name="item" vsli:raw="The item being offered to the target.">Elemento que se va a ofrecer al destino.</param>
      <typeparam name="TInput" vsli:raw="Specifies the type of data accepted by the target block.">Especifica el tipo de datos aceptados por el bloque de destino.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the item was accepted by the target block; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el bloque de destino aceptó el elemento; si no, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary vsli:raw="Synchronously receives a value from a specified source.">Recibe de forma sincrónica un valor de un origen especificado.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <typeparam name="TOutput" vsli:raw="The type of data contained in the source.">El tipo de los datos contenido del origen de datos.</typeparam>
      <returns vsli:raw="The received value.">El valor recibido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No item could be received from the source.">No se pudo recibir ningún elemento del origen.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)">
      <summary vsli:raw="Synchronously receives a value from a specified source and provides a token to cancel the operation.">De forma sincrónica recibe un valor de un origen especificado y proporciona un token para cancelar la operación.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <param name="cancellationToken" vsli:raw="The token to use to cancel the receive operation.">El token que se va a utilizar para cancelar la selección la operación de recepción.</param>
      <typeparam name="TOutput" vsli:raw="The type of data contained in the source.">El tipo de los datos contenido del origen de datos.</typeparam>
      <returns vsli:raw="The received value.">El valor recibido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No item could be received from the source.">No se pudo recibir ningún elemento del origen.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The operation was canceled before an item was received from the source.">Se canceló la operación antes de que se recibiera un elemento del origen.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)">
      <summary vsli:raw="Synchronously receives a value from a specified source, observing an optional time-out period.">De forma sincrónica recibe un valor de un origen especificado, observando un tiempo de espera opcional.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <param name="timeout" vsli:raw="The maximum time interval, in milliseconds, to wait for the synchronous operation to complete, or an interval that represents -1 milliseconds to wait indefinitely.">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <typeparam name="TOutput" vsli:raw="The type of data contained in the source.">El tipo de los datos contenido del origen de datos.</typeparam>
      <returns vsli:raw="The received value.">El valor recibido.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out period.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No item could be received from the source.">No se pudo recibir ningún elemento del origen.</exception>
      <exception cref="T:System.TimeoutException" vsli:raw="The specified time-out expired before an item was received from the source.">El tiempo de espera especificado expiró antes de que se recibiera un elemento del origen.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Synchronously receives a value from a specified source, providing a token to cancel the operation and observing an optional time-out interval.">De forma sincrónica recibe un valor de un origen especificado, proporcionando un token para cancelar la operación y observando un intervalo de tiempo de espera opcional.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <param name="timeout" vsli:raw="The maximum time interval, in milliseconds, to wait for the synchronous operation to complete, or an interval that represents -1 milliseconds to wait indefinitely.">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The token to use to cancel the receive operation.">El token que se va a utilizar para cancelar la selección la operación de recepción.</param>
      <typeparam name="TOutput" vsli:raw="The type of data contained in the source.">El tipo de los datos contenido del origen de datos.</typeparam>
      <returns vsli:raw="The received value.">El valor recibido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out period.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="No item could be received from the source.">No se pudo recibir ningún elemento del origen.</exception>
      <exception cref="T:System.TimeoutException" vsli:raw="The specified time-out expired before an item was received from the source.">El tiempo de espera especificado expiró antes de que se recibiera un elemento del origen.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="The operation was canceled before an item was received from the source.">Se canceló la operación antes de que se recibiera un elemento del origen.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})">
      <summary vsli:raw="Asynchronously receives a value from a specified source.">Recibe de forma asincrónica un valor de un origen especificado.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <typeparam name="TOutput" vsli:raw="The type of data contained in the source.">El tipo de los datos contenido del origen de datos.</typeparam>
      <returns vsli:raw="A task that represents the asynchronous receive operation. When an item value is successfully received from the source, the returned task is completed and its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; returns the received value. If an item value cannot be retrieved because the source is empty and completed , an &lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; exception is thrown in the returned task.">Tarea que representa la operación de recepción asincrónica. Cuando un valor del elemento se recibe correctamente del origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor del elemento recibido. Si el valor de un elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously receives a value from a specified source and provides a token to cancel the operation.">De forma asincrónica recibe un valor de un origen especificado y proporciona un token para cancelar la operación.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <param name="cancellationToken" vsli:raw="The token to use to cancel the receive operation.">El token que se va a utilizar para cancelar la selección la operación de recepción.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="A task that represents the asynchronous receive operation. When a value is successfully received from the source, the returned task is completed and its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; returns the value. If a value cannot be retrieved because cancellation was requested, the returned task is canceled. If the value cannot be retrieved because the source is empty and completed , an &lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; exception is thrown in the returned task.">Tarea que representa la operación de recepción asincrónica. Cuando un valor se recibe correctamente desde el origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor. Si un valor no se puede recuperar porque se solicitó la cancelación, la tarea devuelta se cancelará. Si el valor del elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)">
      <summary vsli:raw="Asynchronously receives a value from a specified source, observing an optional time-out period.">De forma asincrónica recibe un valor de un origen especificado, observando un tiempo de espera opcional.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <param name="timeout" vsli:raw="The maximum time interval, in milliseconds, to wait for the synchronous operation to complete, or an interval that represents -1 milliseconds to wait indefinitely.">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <typeparam name="TOutput" vsli:raw="The type of data contained in the source.">El tipo de los datos contenido del origen de datos.</typeparam>
      <returns vsli:raw="A task that represents the asynchronous receive operation. When a value is successfully received from the source, the returned task is completed and its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; returns the value. If a value cannot be retrieved because the time-out expired, the returned task is canceled. If the value cannot be retrieved because the source is empty and completed , an &lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; exception is thrown in the returned task.">Tarea que representa la operación de recepción asincrónica. Cuando un valor se recibe correctamente desde el origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor. Si un valor no se puede recuperar porque el tiempo de espera ha expirado, la tarea devuelta se cancelará. Si el valor del elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out period.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously receives a value from a specified source, providing a token to cancel the operation and observing an optional time-out interval.">De forma asincrónica recibe un valor de un origen especificado, proporcionando un símbolo para anular la operación y observando un intervalo de tiempo de espera opcional.</summary>
      <param name="source" vsli:raw="The source from which to receive the value.">Origen del que se va a recibir el valor.</param>
      <param name="timeout" vsli:raw="The maximum time interval, in milliseconds, to wait for the synchronous operation to complete, or an interval that represents -1 milliseconds to wait indefinitely.">El intervalo de tiempo máximo, en milisegundos, para esperar la operación síncrona para completar, o un intervalo que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The token which may be used to cancel the receive operation.">El token que se puede usar para cancelar la operación de recepción.</param>
      <typeparam name="TOutput" vsli:raw="The type of data contained in the source.">El tipo de los datos contenido del origen de datos.</typeparam>
      <returns vsli:raw="A task that represents the asynchronous receive operation. When a value is successfully received from the source, the returned task is completed and its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; returns the value. If a value cannot be retrieved because the time-out expired or cancellation was requested, the returned task is canceled. If the value cannot be retrieved because the source is empty and completed, an &lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; exception is thrown in the returned task.">Tarea que representa la operación de recepción asincrónica. Cuando un valor se recibe correctamente desde el origen, la tarea devuelta se completa y su <see cref="P:System.Threading.Tasks.Task`1.Result" /> devuelve el valor. Si un valor no se puede recuperar porque el tiempo de espera expirado o se solicitó cancelación, la tarea devuelta se cancelará. Si el valor del elemento no se puede recuperar porque el origen está vacío y completo, se inicia una excepción <see cref="T:System.InvalidOperationException" /> en la tarea devuelta.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out period.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo que representa un período de espera infinito.
O bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)">
      <summary vsli:raw="Asynchronously offers a message to the target message block, allowing for postponement.">De forma asincrónica proporciona un mensaje al bloque de mensajes de destino, teniendo en cuenta el aplazamiento.</summary>
      <param name="target" vsli:raw="The target to which to post the data.">El destino en el que se van a exponer los datos.</param>
      <param name="item" vsli:raw="The item being offered to the target.">Elemento que se va a ofrecer al destino.</param>
      <typeparam name="TInput" vsli:raw="Specifies the type of the data to post to the target.">Especifica el tipo de los datos que se van a enviar al destino.</typeparam>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that represents the asynchronous send. If the target accepts and consumes the offered element during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)&quot; /&gt;, upon return from the call the resulting &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; will be completed and its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; property will return &lt;see langword=&quot;true&quot; /&gt;. If the target declines the offered element during the call, upon return from the call the resulting &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; will be completed and its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; property will return &lt;see langword=&quot;false&quot; /&gt;. If the target postpones the offered element, the element will be buffered until such time that the target consumes or releases it, at which point the task will complete, with its &lt;see cref=&quot;P:System.Threading.Tasks.Task`1.Result&quot; /&gt; indicating whether the message was consumed. If the target never attempts to consume or release the message, the returned task will never complete.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa el envío asincrónico. Si el destino acepta y usa el elemento proporcionado durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> devolverá <see langword="true" />. Si el destino rechaza el elemento proporcionado durante la llamada, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> devolverá <see langword="false" />. Si el destino pospone el elemento proporcionado, el elemento se almacenará en búfer hasta el momento en que el destino lo utilice o lo lance, momento en el que la tarea se completará, con el <see cref="P:System.Threading.Tasks.Task`1.Result" /> que indica si el mensaje se ha utilizado. Si el destino nunca intenta utilizar o lanzar el mensaje, la tarea devuelta nunca se completará.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously offers a message to the target message block, allowing for postponement.">De forma asincrónica proporciona un mensaje al bloque de mensajes de destino, teniendo en cuenta el aplazamiento.</summary>
      <param name="target" vsli:raw="The target to which to post the data.">El destino en el que se van a exponer los datos.</param>
      <param name="item" vsli:raw="The item being offered to the target.">Elemento que se va a ofrecer al destino.</param>
      <param name="cancellationToken" vsli:raw="The cancellation token with which to request cancellation of the send operation.">El token de cancelación con el que solicitar la cancelación de la operación de envío.</param>
      <typeparam name="TInput" vsli:raw="Specifies the type of the data to post to the target.">Especifica el tipo de los datos que se van a enviar al destino.</typeparam>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; that represents the asynchronous send.  If the target accepts and consumes the offered element during the call to SendAsync, upon return from the call the resulting &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; will be completed and its &lt;c&gt;Result&lt;/c&gt; property will return true.  If the target declines the offered element during the call, upon return from the call the resulting &lt;see cref=&quot;T:System.Threading.Tasks.Task`1&quot; /&gt; will be completed and its &lt;c&gt;Result&lt;/c&gt; property will return false. If the target postpones the offered element, the element will be buffered until such time that the target consumes or releases it, at which point the Task will complete, with its &lt;c&gt;Result&lt;/c&gt; indicating whether the message was consumed. If the target never attempts to consume or release the message, the returned task will never complete.  &#xA;  &#xA; If cancellation is requested before the target has successfully consumed the sent data, the returned task will complete in the Canceled state and the data will no longer be available to the target.">
        <see cref="T:System.Threading.Tasks.Task`1" /> que representa el envío asincrónico.  Si el destino acepta y usa el elemento proporcionado durante la llamada a SendAsync, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <c>Result</c> devolverá true.  Si el destino rechaza el elemento proporcionado durante la llamada, al volver de la llamada se completará el <see cref="T:System.Threading.Tasks.Task`1" /> resultante y su propiedad <c>Result</c> devolverá false. Si el destino pospone el elemento proporcionado, el elemento se almacenará en búfer hasta que el destino lo consuma o lo libere, momento en el que la tarea se completará, y <c>Result</c> indicará si el mensaje se ha consumido. Si el destino nunca intenta utilizar o lanzar el mensaje, la tarea devuelta nunca se completará.
Si se solicita la cancelación antes de que el destino haya consumido correctamente los datos enviados, la tarea devuelta completará al estado cancelado y datos dejarán de estar disponibles para el destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The  &lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive``1(System.Threading.Tasks.Dataflow.IReceivableSourceBlock{``0},``0@)">
      <summary vsli:raw="Attempts to synchronously receive an item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Se intenta recibir sincrónicamente un elemento de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="source" vsli:raw="The source from which to receive.">Origen del que se va a recibir.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data contained in the source.">Especifica el tipo de datos contenidos en el origen.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions">
      <summary vsli:raw="Provides options used to configure the processing performed by dataflow blocks.">Proporciona las opciones usadas para configurar el procesamiento que realizan los bloques de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowBlockOptions.#ctor">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowBlockOptions&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity">
      <summary vsli:raw="Gets or sets the maximum number of messages that may be buffered by the block.">Obtiene o establece el número de mensajes máximo que el bloque puede almacenar en el búfer simultáneamente.</summary>
      <returns vsli:raw="The maximum number of messages. The default is -1, which indicates an unlimited number of messages.">Número máximo de mensajes. El valor predeterminado es -1, que indica un número ilimitado de mensajes.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken">
      <summary vsli:raw="Gets or sets the  &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to monitor for cancellation requests.">Obtiene o establece <see cref="T:System.Threading.CancellationToken" /> para supervisar las solicitudes de cancelación.</summary>
      <returns vsli:raw="The token.">Token.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.EnsureOrdered">
      <summary vsli:raw="Gets or sets a value that indicates whether ordered processing should be enforced on a block's handling of messages.">Obtiene o establece un valor que indica si se debe exigir el procesamiento ordenado en el control de mensajes de un bloque.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if ordered processing should be enforced; otherwise, &lt;see langword=&quot;false&quot; /&gt;. The default value is &lt;see langword=&quot;true&quot; /&gt;.">
        <see langword="true" />Si se debe aplicar el procesamiento ordenado; en caso <see langword="false" />contrario,. El valor predeterminado es <see langword="true" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask">
      <summary vsli:raw="Gets or sets the maximum number of messages that may be processed per task.">Obtiene o establece el número máximo de mensajes que se pueden procesar por tarea.</summary>
      <returns vsli:raw="The maximum number of messages. The default is -1, which indicates an unlimited number of messages.">Número máximo de mensajes. El valor predeterminado es -1, que indica un número ilimitado de mensajes.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat">
      <summary vsli:raw="Gets or sets the format string to use when a block is queried for its name.">Obtiene o establece la cadena de formato que se va a utilizar cuando un bloque se consulta para conocer su nombre.</summary>
      <returns vsli:raw="The format string to use when a block is queried for its name.">Cadena de formato que se va a usar cuando se consulte el nombre de un bloque.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler">
      <summary vsli:raw="Gets or sets the &lt;see cref=&quot;T:System.Threading.Tasks.TaskScheduler&quot; /&gt; to use for scheduling tasks.">Obtiene o establece el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se usará para las tareas de programación.</summary>
      <returns vsli:raw="The task scheduler.">Programador de tareas.</returns>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded">
      <summary vsli:raw="A constant used to specify an unlimited quantity for  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowBlockOptions&quot; /&gt; members that provide an upper bound. This field is constant.">Constante que se usa para especificar una cantidad ilimitada para los miembros de <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> que proporcionan un límite superior. Este campo es constante.</summary>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions">
      <summary vsli:raw="Provides options used to configure a link between dataflow blocks.">Proporciona las opciones usadas para configurar un vínculo entre bloques de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowLinkOptions.#ctor">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt;.">Inicializa el <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowLinkOptions.Append">
      <summary vsli:raw="Gets or sets whether the link should be appended to the source's list of links, or whether it should be prepended.">Obtiene o establece si el vínculo se debe anexar a la lista de vínculos del origen o si debe anteponerse.</summary>
      <returns vsli:raw="Returns  &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.">Devuelve <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowLinkOptions.MaxMessages">
      <summary vsli:raw="Gets or sets the maximum number of messages that may be consumed across the link.">Obtiene o establece el número máximo de mensajes que se pueden utilizar a través del vínculo.</summary>
      <returns vsli:raw="Returns  &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">Devuelve <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowLinkOptions.PropagateCompletion">
      <summary vsli:raw="Gets or sets whether the linked target will have completion and faulting notification propagated to it automatically.">Obtiene o establece si la finalización y notificación de desplazamiento se propagarán al destino vinculado automáticamente.</summary>
      <returns vsli:raw="Returns  &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.">Devuelve <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader">
      <summary vsli:raw="Provides a container of data attributes for passing between dataflow blocks.">Proporciona un contenedor de atributos de datos para pasarlo entre los bloques de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.#ctor(System.Int64)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; with the specified attributes.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> con los atributos especificados.</summary>
      <param name="id" vsli:raw="The ID of the message. Must be unique within the originating source block. It does not need to be globally unique.">Identificador del mensaje. Debe ser único dentro del bloque de origen. No necesita ser globalmente único.</param>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.Equals(System.Object)">
      <summary vsli:raw="Checks boxed &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instances for equality by ID.">Comprueba la igualdad de las instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del cuadro por identificador.</summary>
      <param name="obj" vsli:raw="A boxed &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Una instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> a la que se ha aplicado la conversión boxing.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las instancias son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.Equals(System.Threading.Tasks.Dataflow.DataflowMessageHeader)">
      <summary vsli:raw="Checks two  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instances for equality by ID without boxing.">Comprueba la igualdad de dos instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> por identificador sin la conversión boxing.</summary>
      <param name="other" vsli:raw="Another  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Otra instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si las instancias son iguales; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.GetHashCode">
      <summary vsli:raw="Generates a hash code for the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Genera un código hash para esta instancia <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</summary>
      <returns vsli:raw="The hash code.">Código hash.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowMessageHeader.Id">
      <summary vsli:raw="Gets the ID of the message within the source.">Obtiene el identificador de mensaje dentro del origen.</summary>
      <returns vsli:raw="The ID contained in the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Identificador contenido en la <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> instancia de.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.DataflowMessageHeader.IsValid">
      <summary vsli:raw="Gets the validity of the message.">Obtiene la validez del mensaje.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the ID of the message is different from 0. &lt;see langword=&quot;false&quot; /&gt; if the ID of the message is 0.">
        <see langword="true" /> si el identificador del mensaje es distinto de 0. <see langword="false" /> si el identificador del mensaje es 0.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.op_Equality(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.DataflowMessageHeader)">
      <summary vsli:raw="Checks two  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instances for equality by ID.">Comprueba la igualdad de dos instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> por identificador.</summary>
      <param name="left" vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <param name="right" vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las instancias son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.DataflowMessageHeader.op_Inequality(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.DataflowMessageHeader)">
      <summary vsli:raw="Checks two  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instances for non-equality by ID.">Comprueba la desigualdad de dos instancias de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> por identificador.</summary>
      <param name="left" vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <param name="right" vsli:raw="A  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the instances are not equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las instancias no son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.DataflowMessageStatus">
      <summary vsli:raw="Represents the status of a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; when passed between dataflow blocks.">Representa el estado de un elemento <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> cuando se pasa entre bloques de flujo de datos.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted">
      <summary vsli:raw="Indicates that the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; accepted the message. Once a target has accepted a message, it is wholly owned by the target.">Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> aceptó el mensaje. Una vez que un destino ha aceptado un mensaje, se convierte en su propietario.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined">
      <summary vsli:raw="Indicates that the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; declined the message. The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; still owns the message.">Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> rechazó el mensaje. <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> todavía posee el mensaje.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently">
      <summary vsli:raw="Indicates that the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; declined the message. The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; still owns the message.  &#xA;  &#xA; Additionally, the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; will decline all future messages sent by the source.">Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> rechazó el mensaje. <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> todavía posee el mensaje.
Además, <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> rechazará todos los mensajes futuros enviados por el origen.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable">
      <summary vsli:raw="Indicates that the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; tried to accept the message from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;, but the message was no longer available.">Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> intentó aceptar el mensaje de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />, pero el mensaje ya no estaba disponible.</summary>
    </member>
    <member name="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed">
      <summary vsli:raw="Indicates that the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; postponed the message for potential consumption at a later time.  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; still owns the message.">Indica que <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> pospuso el mensaje para el consumo potencial en otro momento.
<see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> todavía posee el mensaje.</summary>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions">
      <summary vsli:raw="Provides options used to configure the processing performed by dataflow blocks that process each message through the invocation of a user-provided delegate. These are dataflow blocks such as  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ActionBlock`1&quot; /&gt; and  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt;.">Proporciona las opciones utilizadas para configurar el procesamiento realizado por los bloques de flujo de datos que procesan cada mensaje mediante la invocación de un delegado proporcionado por el usuario. Estos son bloques de flujo de datos como <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> y <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.#ctor">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism">
      <summary vsli:raw="Gets the maximum number of messages that may be processed by the block concurrently.">Obtiene el número de mensajes máximo que el bloque puede procesar simultáneamente.</summary>
      <returns vsli:raw="The maximum number of messages.">Número máximo de mensajes.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.SingleProducerConstrained">
      <summary vsli:raw="Gets whether code using the dataflow block is constrained to one producer at a time.">Obtiene si el código que usa el bloque de flujo de datos está restringido a un productor al mismo tiempo.</summary>
      <returns vsli:raw="Returns  &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.">Devuelve <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions">
      <summary vsli:raw="Provides options used to configure the processing performed by dataflow blocks that group together multiple messages. These are dataflow blocks such as &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.JoinBlock`2&quot; /&gt; and  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.BatchBlock`1&quot; /&gt;.">Proporciona las opciones utilizadas para configurar el procesamiento realizado por los bloques de flujo de datos que agrupan varios mensajes. Estos son bloques de flujo de datos como <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" /> y <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.#ctor">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy">
      <summary vsli:raw="Gets or sets the Boolean value to use to determine whether to greedily consume offered messages.">Obtiene o establece el valor booleano que se va a usar para determinar si se realiza el consumo expansivo de mensajes ofrecidos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to greedily consume offered messages; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para usar de forma expansiva mensajes ofrecidos; si no, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.MaxNumberOfGroups">
      <summary vsli:raw="Gets or sets the maximum number of groups that should be generated by the block.">Obtiene o establece el número máximo de grupos que debe generar el bloque.</summary>
      <returns vsli:raw="The maximum number of groups.">Número máximo de grupos.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.IDataflowBlock">
      <summary vsli:raw="Represents a dataflow block.">Representa un bloque de flujo de datos.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion">
      <summary vsli:raw="Gets a  &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene una <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a  &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The  &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2">
      <summary vsli:raw="Represents a dataflow block that is both a target for data and a source of data.">Representa un bloque de flujo de datos que es tanto un destino como un origen de datos.</summary>
      <typeparam name="TInput" vsli:raw="Specifies the type of data accepted by the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2&quot; /&gt;.">Especifica el tipo de datos que acepta <see cref="T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2" />.</typeparam>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data supplied by the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2&quot; /&gt;.">Especifica el tipo de datos suministrado por el <see cref="T:System.Threading.Tasks.Dataflow.IPropagatorBlock`2" />.</typeparam>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1">
      <summary vsli:raw="Represents a dataflow block that supports receiving messages without linking.">Representa un bloque de flujo de datos que admite la recepción de mensajes sin vincular.</summary>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data supplied by the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Especifica el tipo de datos que suministra <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.ISourceBlock`1">
      <summary vsli:raw="Represents a dataflow block that is a source of data.">Representa un bloque de flujo de datos que es un origen de datos.</summary>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data supplied by the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Especifica el tipo de datos suministrado por el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to accept and consume a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; previously offered by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being consumed.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; consuming the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The value of the consumed message. This may correspond to a different  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance than was previously reserved and passed as the &lt;paramref name=&quot;messageHeader&quot; /&gt; to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt;. The consuming &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; must use the returned value instead of the value passed as &lt;paramref name=&quot;messageValue&quot; /&gt; through &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;.  &#xA;  &#xA; If the message requested is not available, the return value will be null.">Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.
Si el mensaje solicitado no está disponible, el valor devuelto será NULL.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The messageHeader is not valid.">messageHeader no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The target is &lt;see langword=&quot;null&quot; /&gt;.">El destino es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;.">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to release a previously reserved &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message being released.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; releasing the message it previously reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; did not have the message reserved.">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to reserve a previously offered &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; reserving the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully reserved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.ITargetBlock`1">
      <summary vsli:raw="Represents a dataflow block that is a target for data.">Representa un bloque de flujo de datos que es un destino de datos.</summary>
      <typeparam name="TInput" vsli:raw="Specifies the type of data accepted by the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;.">Especifica el tipo de datos que acepta <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, giving the target the opportunity to consume or postpone the message.">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance that represents the header of the message being offered.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; offering the message. This may be null.">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Éste puede ser null.</param>
      <param name="consumeToAccept" vsli:raw="Set to &lt;see langword=&quot;true&quot; /&gt; to instruct the target to call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message.">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <returns vsli:raw="The status of the offered message. If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, because it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed message, but source was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is instead returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino hubiera pospuesto de otra forma el mensaje, pero el origen fuera <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The  &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or- &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may only be true if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.JoinBlock`2">
      <summary vsli:raw="Provides a dataflow block that joins across multiple dataflow sources, not necessarily of the same type, waiting for one item to arrive for each type before they're all released together as a tuple consisting of one item per type.">Proporciona un bloque de flujo de datos que combina varios orígenes de flujo de datos, no necesariamente del mismo tipo, donde se espera a que llegue un elemento de cada tipo antes de que todos se liberen de forma conjunta como una tupla que consta de un elemento por tipo.</summary>
      <typeparam name="T1" vsli:raw="Specifies the type of data accepted by the block's first target.">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies the type of data accepted by the block's second target.">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.#ctor">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.JoinBlock`2&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.#ctor(System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.JoinBlock`2&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</summary>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.JoinBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.OutputCount">
      <summary vsli:raw="Gets the number of output items available to be received from this block.">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns vsli:raw="The number of output items.">Número de elementos de salida.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que la interfaz <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> .</summary>
      <param name="exception" vsli:raw="The  &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}},System.Boolean@)">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be consumed." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be consumed." />
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed. &lt;see langword=&quot;false&quot; /&gt; otherwise." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; that currently holds the reservation." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be reserved." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be reserved." />
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Target1">
      <summary vsli:raw="Gets a target that may be used to offer messages of the first type.">Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Target2">
      <summary vsli:raw="Gets a target that may be used to offer messages of the second type.">Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.TryReceive(System.Predicate{System.Tuple{`0,`1}},System.Tuple{`0,`1}@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`2.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{`0,`1}}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.JoinBlock`3">
      <summary vsli:raw="Provides a dataflow block that joins across multiple dataflow sources, which are not necessarily of the same type, waiting for one item to arrive for each type before they're all released together as a tuple that contains one item per type.">Proporciona un bloque de flujo de datos que combina varios orígenes de flujo de datos, que no son necesariamente del mismo tipo, donde se espera a que llegue un elemento de cada tipo antes de que todos queden libres de forma conjunta como una tupla que contiene un elemento por tipo.</summary>
      <typeparam name="T1" vsli:raw="Specifies the type of data accepted by the block's first target.">Especifica el tipo de datos aceptados por el primer destino del bloque.</typeparam>
      <typeparam name="T2" vsli:raw="Specifies the type of data accepted by the block's second target.">Especifica el tipo de datos aceptados por el segundo destino del bloque.</typeparam>
      <typeparam name="T3" vsli:raw="Specifies the type of data accepted by the block's third target.">Especifica el tipo de datos aceptados por el tercer destino del bloque.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.#ctor">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.JoinBlock`3&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.#ctor(System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.JoinBlock`3&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</summary>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.JoinBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the   source block to the specified target block.">Vincula el bloque de origen al bloque de destino especificado.</summary>
      <param name="target" vsli:raw="The target block to which to connect this source.">El bloque de destino al que se va a conectar este origen.</param>
      <param name="linkOptions" vsli:raw="An object that configures the link.">Objeto que configura el vínculo.</param>
      <returns vsli:raw="A disposable object that unlinks the source from the target when its &lt;see cref=&quot;M:System.IDisposable.Dispose&quot; /&gt; method is called.">Objeto descartable que desvincula el origen del destino cuando se llama a su método <see cref="M:System.IDisposable.Dispose" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;linkOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="target" /> es <see langword="null" />.
O bien
<paramref name="linkOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.OutputCount">
      <summary vsli:raw="Gets the number of output items available to be received from this block.">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns vsli:raw="The number of output items.">Número de elementos de salida.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a  &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The  &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2@T3}}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}},System.Boolean@)">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be consumed." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be consumed." />
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed. &lt;see langword=&quot;false&quot; /&gt; otherwise." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2@T3}}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; that currently holds the reservation." />
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock{System#Tuple{T1@T2@T3}}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}})">
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message that is to be reserved." />
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; for which the message is to be reserved." />
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target1">
      <summary vsli:raw="Gets a target that may be used to offer messages of the first type.">Obtiene un destino que se puede usar para ofrecer mensajes del primer tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target2">
      <summary vsli:raw="Gets a target that may be used to offer messages of the second type.">Obtiene un destino que se puede usar para ofrecer mensajes del segundo tipo.</summary>
      <returns vsli:raw="The target.">Destino.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target3">
      <summary vsli:raw="Gets a target that may be used to offer messages of the third type.">Obtiene un destino que se puede usar para ofrecer mensajes del tercer tipo.</summary>
      <returns vsli:raw="The target.">El destino.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.TryReceive(System.Predicate{System.Tuple{`0,`1,`2}},System.Tuple{`0,`1,`2}@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.JoinBlock`3.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{`0,`1,`2}}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.TransformBlock`2">
      <summary vsli:raw="Provides a dataflow block that invokes a provided &lt;see cref=&quot;T:System.Func`2&quot; /&gt; delegate for every data element received.">Proporciona un bloque de flujo de datos que invoca un delegado proporcionado de <see cref="T:System.Func`2" /> para cada elemento de datos recibido.</summary>
      <typeparam name="TInput" vsli:raw="Specifies the type of data received and operated on by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt;.">Especifica el tipo de datos recibidos y con los que opera <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</typeparam>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data output by this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt;.">Especifica el tipo de resultado de datos de este <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,`1})">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt; with the specified  &lt;see cref=&quot;T:System.Func`2&quot; /&gt;.">Inicializa un <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> nuevo con las <see cref="T:System.Func`2" /> especificadas.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received.">Función que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,`1},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt; with the specified  &lt;see cref=&quot;T:System.Func`2&quot; /&gt; and &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions&quot; /&gt;.">Inicializa un nuevo <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> con el <see cref="T:System.Func`2" /> y las <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received.">Función que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.
o bien
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}})">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt; with the specified &lt;see cref=&quot;T:System.Func`2&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> con el <see cref="T:System.Func`2" /> especificado.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received.">Función que se va a invocar con cada elemento de datos recibido.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt; with the specified  &lt;see cref=&quot;T:System.Func`2&quot; /&gt; and &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions&quot; /&gt;.">Inicializa un nuevo <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" /> con el <see cref="T:System.Func`2" /> y las <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received.">Función que se va a invocar con cada elemento de datos recibido.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.
o bien
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformBlock`2.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformBlock`2.InputCount">
      <summary vsli:raw="Gets the number of input items waiting to be processed by this block.">Obtiene el número de elementos de entrada en espera de ser procesados por este bloque.</summary>
      <returns vsli:raw="The number of input items.">Número de elementos de entrada.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformBlock`2.OutputCount">
      <summary vsli:raw="Gets the number of output items available to be received from this block.">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns vsli:raw="The number of output items.">Número de elementos de salida.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a  &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Boolean@)">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to accept and consume a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; previously offered by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being consumed.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; consuming the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The value of the consumed message. This may correspond to a different &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance than was previously reserved and passed as the &lt;paramref name=&quot;messageHeader&quot; /&gt; to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt;. The consuming &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; must use the returned value instead of the value passed as &lt;paramref name=&quot;messageValue&quot; /&gt; through &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;.  &#xA;  &#xA; If the message requested is not available, the return value will be &lt;see langword=&quot;null&quot; /&gt;.">Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to release a previously reserved &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama un <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculado para liberar un <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservado previamente por este <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message being released.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; releasing the message it previously reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; did not have the message reserved.">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to reserve a previously offered &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama un <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculado para reservar un <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecido previamente por este <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; reserving the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully reserved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, giving the target the opportunity to consume or postpone the message.">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance that represents the header of the message being offered.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; offering the message. This may be &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the target must call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message.">
        <see langword="true" /> si el destino debe llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada al <see cref="M:System.Threading.Tasks.Dataflow.TransformBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <returns vsli:raw="The status of the offered message. If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, because it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed but source was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is instead returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino se hubiera pospuesto de otra forma, pero el origen era <see langword="null" />, se devolvería <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or- &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may only be true if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.TryReceive(System.Predicate{`1},`1@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformBlock`2.TryReceiveAll(System.Collections.Generic.IList{`1}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2">
      <summary vsli:raw="Provides a dataflow block that invokes a provided &lt;see cref=&quot;T:System.Func`2&quot; /&gt; delegate for every data element received.">Proporciona un bloque de flujo de datos que invoca un delegado proporcionado de <see cref="T:System.Func`2" /> para cada elemento de datos recibido.</summary>
      <typeparam name="TInput" vsli:raw="Specifies the type of data received and operated on by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Especifica el tipo de datos recibidos y con los que opera <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</typeparam>
      <typeparam name="TOutput" vsli:raw="Specifies the type of data output by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Especifica el tipo de salida de datos de <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt; with the specified function.">Inicializa una nueva <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función especificada.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received. All of the data from the returned &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; will be made available as output from this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt; with the specified function and &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función y el <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received. All of the data from the returned in the &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; will be made available as output from this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.
O bien
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{`1}}})">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt; with the specified function.">Inicializa una nueva <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función especificada.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received. All of the data asynchronously returned in the &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; will be made available as output from this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos de forma asincrónica en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{`1}}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt; with the specified function and &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions&quot; /&gt;.">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> con la función y el <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" /> especificados.</summary>
      <param name="transform" vsli:raw="The function to invoke with each data element received. All of the data asynchronously returned in the &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; will be made available as output from this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Función que se va a invocar con cada elemento de datos recibido. Todos los datos devueltos de forma asincrónica en <see cref="T:System.Collections.Generic.IEnumerable`1" /> estarán disponibles como resultado de este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.TransformManyBlock`2&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;transform&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="transform" /> es <see langword="null" />.
o bien
El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.InputCount">
      <summary vsli:raw="Gets the number of input items waiting to be processed by this block.">Obtiene el número de elementos de entrada en espera de ser procesados por este bloque.</summary>
      <returns vsli:raw="The number of input items.">Número de elementos de entrada.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.OutputCount">
      <summary vsli:raw="Gets the number of output items available to be received from this block.">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</summary>
      <returns vsli:raw="The number of output items.">Número de elementos de salida.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a  &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</summary>
      <param name="exception" vsli:raw="The &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Boolean@)">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to accept and consume a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; previously offered by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being consumed.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; consuming the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The value of the consumed message. This may correspond to a different &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance than was previously reserved and passed as the &lt;paramref name=&quot;messageHeader&quot; /&gt; to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt;. The consuming &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; must use the returned value instead of the value passed as &lt;paramref name=&quot;messageValue&quot; /&gt; through OfferMessage &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;  &#xA;  &#xA; If the message requested is not available, the return value will be &lt;see langword=&quot;null&quot; /&gt;.">Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> OfferMessage.
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to release a previously reserved &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message being released.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; releasing the message it previously reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; did not have the message reserved.">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock{TOutput}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to reserve a previously offered &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama un <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculado para reservar un <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecido previamente por este <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; reserving the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully reserved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, giving the target the opportunity to consume or postpone the message.">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance that represents the header of the message being offered.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; offering the message. This may be &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the target must call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message.">
        <see langword="true" /> si el destino debe llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <returns vsli:raw="The status of the offered message. If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, as it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed but source was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is instead returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino se hubiera pospuesto de otra forma, pero el origen era <see langword="null" />, se devolvería <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may only be true if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien
<paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de null.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.TryReceive(System.Predicate{`1},`1@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.TryReceiveAll(System.Collections.Generic.IList{`1}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1">
      <summary vsli:raw="Provides a buffer for receiving and storing at most one element in a network of dataflow blocks.">Proporciona un búfer para recibir y almacenar a lo sumo un elemento en una red de bloques de flujo de datos.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of the data buffered by this dataflow block.">Especifica el tipo de los datos almacenados en el búfer por este bloque de flujo de datos.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.#ctor(System.Func{`0,`0})">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1&quot; /&gt;.">Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1" />.</summary>
      <param name="cloningFunction" vsli:raw="The function to use to clone the data when offered to other blocks.">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.#ctor(System.Func{`0,`0},System.Threading.Tasks.Dataflow.DataflowBlockOptions)">
      <summary vsli:raw="Initializes a new &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1&quot; /&gt; with the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowBlockOptions&quot; /&gt;.">Inicializa un <see cref="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1" /> nuevo con las <see cref="T:System.Threading.Tasks.Dataflow.DataflowBlockOptions" /> especificadas.</summary>
      <param name="cloningFunction" vsli:raw="The function to use to clone the data when offered to other blocks.">Función que se va a usar para clonar los datos cuando se ofrezcan a otros bloques.</param>
      <param name="dataflowBlockOptions" vsli:raw="The options with which to configure this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1&quot; /&gt;.">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.WriteOnceBlock`1" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;dataflowBlockOptions&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.Complete">
      <summary vsli:raw="Signals to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; that it should not accept nor produce any more messages nor consume any more postponed messages.">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</summary>
    </member>
    <member name="P:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.Completion">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.Tasks.Task&quot; /&gt; that represents the asynchronous operation and completion of the dataflow block.">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</summary>
      <returns vsli:raw="The task.">Tarea.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)">
      <summary vsli:raw="Links the  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; to the specified  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; .">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</summary>
      <param name="target" vsli:raw="The  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to which to connect this source.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</param>
      <param name="linkOptions" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowLinkOptions&quot; /&gt; instance that configures the link.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</param>
      <returns vsli:raw="An IDisposable that, upon calling Dispose, will unlink the source from the target.">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;target&quot; /&gt; is null (Nothing in Visual Basic) or  &lt;paramref name=&quot;linkOptions&quot; /&gt; is null (Nothing in Visual Basic).">
        <paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)">
      <summary vsli:raw="Causes the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; to complete in a &lt;see cref=&quot;F:System.Threading.Tasks.TaskStatus.Faulted&quot; /&gt; state.">Hace que la interfaz <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> .</summary>
      <param name="exception" vsli:raw="The  &lt;see cref=&quot;T:System.Exception&quot; /&gt; that caused the faulting.">
        <see cref="T:System.Exception" /> que causó el error.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;exception&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="exception" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#IReceivableSourceBlock{T}#TryReceiveAll(System.Collections.Generic.IList{`0}@)">
      <summary vsli:raw="Attempts to synchronously receive all available items from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="items" vsli:raw="The items received from the source.">Elementos recibidos del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if one or more items could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to accept and consume a &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; previously offered by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y usar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being consumed.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; consuming the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</param>
      <param name="messageConsumed" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully consumed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</param>
      <returns vsli:raw="The value of the consumed message. This may correspond to a different  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance than was previously reserved and passed as the &lt;paramref name=&quot;messageHeader&quot; /&gt; to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt;. The consuming &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; must use the returned value instead of the value passed as &lt;paramref name=&quot;messageValue&quot; /&gt; through &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;.  &#xA;  &#xA; If the message requested is not available, the return value will be &lt;see langword=&quot;null&quot; /&gt;.">Valor del mensaje consumido. Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />. La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como <paramref name="messageValue" /> mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.
Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to release a previously reserved &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the reserved message being released.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; releasing the message it previously reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; did not have the message reserved.">
        <paramref name="target" /> no tiene el mensaje reservado.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock{T}#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})">
      <summary vsli:raw="Called by a linked &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; to reserve a previously offered &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; by this &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt;.">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
      <param name="messageHeader" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; of the message being reserved.">
        <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</param>
      <param name="target" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt; reserving the message.">
        <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the message was successfully reserved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.">
        <paramref name="messageHeader" /> no es válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;target&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">El valor de <paramref name="target" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock{T}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)">
      <summary vsli:raw="Offers a message to the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ITargetBlock`1&quot; /&gt;, giving the target the opportunity to consume or postpone the message.">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</summary>
      <param name="messageHeader" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.DataflowMessageHeader&quot; /&gt; instance that represents the header of the message being offered.">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</param>
      <param name="messageValue" vsli:raw="The value of the message being offered.">Valor del mensaje que se va a ofrecer.</param>
      <param name="source" vsli:raw="The &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.ISourceBlock`1&quot; /&gt; offering the message. This may be &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje. Puede ser <see langword="null" />.</param>
      <param name="consumeToAccept" vsli:raw="Set to &lt;see langword=&quot;true&quot; /&gt; to instruct the target to call &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)&quot; /&gt; synchronously during the call to &lt;see cref=&quot;M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)&quot; /&gt;, prior to returning &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt;, in order to consume the message.">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</param>
      <returns vsli:raw="The status of the offered message. If the message was accepted by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted&quot; /&gt; is returned, and the source should no longer use the offered message, because it is now owned by the target. If the message was postponed by the target, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed&quot; /&gt; is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.  &#xA;  &#xA; If the target would have otherwise postponed message, but &lt;paramref name=&quot;source&quot; /&gt; was &lt;see langword=&quot;null&quot; /&gt;, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is instead returned.  &#xA;  &#xA; If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable&quot; /&gt; is returned.  &#xA;  &#xA; If the target chose not to accept the message, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined&quot; /&gt; is returned. If the target chose not to accept the message and will never accept another message from this source, &lt;see cref=&quot;F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently&quot; /&gt; is returned.">Estado del mensaje ofrecido. Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino. Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.
Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.
Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.
Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />. Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="The  &lt;paramref name=&quot;messageHeader&quot; /&gt; is not valid.  &#xA;  &#xA; -or- &lt;paramref name=&quot;consumeToAccept&quot; /&gt; may only be true if provided with a non-null &lt;paramref name=&quot;source&quot; /&gt;.">
        <paramref name="messageHeader" /> no es válido.
O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.ToString">
      <summary vsli:raw="Returns a string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</summary>
      <returns vsli:raw="A string that represents the formatted name of this  &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IDataflowBlock&quot; /&gt; instance.">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Dataflow.WriteOnceBlock`1.TryReceive(System.Predicate{`0},`0@)">
      <summary vsli:raw="Attempts to synchronously receive an available output item from the &lt;see cref=&quot;T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&quot; /&gt;.">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</summary>
      <param name="filter" vsli:raw="The predicate value must successfully pass in order for it to be received.  &lt;paramref name=&quot;filter&quot; /&gt; may be &lt;see langword=&quot;null&quot; /&gt;, in which case all items will pass.">El valor del predicado debe pasar correctamente para que se reciba.  <paramref name="filter" /> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</param>
      <param name="item" vsli:raw="The item received from the source.">Elemento recibido del origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if an item could be received; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</returns>
    </member>
  </members>
</doc>