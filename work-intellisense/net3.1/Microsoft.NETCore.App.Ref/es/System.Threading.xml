<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary vsli:raw="The exception that is thrown when one thread acquires a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that another thread has abandoned by exiting without releasing it.">Excepción que se produce cuando un subproceso adquiere un objeto <see cref="T:System.Threading.Mutex" /> que otro subproceso ha abandonado al salir sin liberarlo.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with default values.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con valores predeterminados.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un índice especificado para la exclusión mutua abandonada, si es aplicable, y un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua.</summary>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Índice de la exclusión mutua abandonada en la matriz de identificadores de espera si la excepción se produce para el método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, o -1 si la excepción se produce para los métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> o <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with serialized data.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con datos serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto sobre la excepción iniciada.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con el mensaje de error especificado.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Mensaje de error que explica la razón de la excepción.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message and inner exception.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un mensaje de error y una excepción interna especificados.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Mensaje de error que explica la razón de la excepción.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="inner" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the inner exception, the index for the abandoned mutex, if applicable, and a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the mutex.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un mensaje de error especificado, la excepción interna, el índice para la exclusión mutua abandonada, si es aplicable, y un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Mensaje de error que explica la razón de la excepción.</param>
      <param name="inner" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;inner&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="inner" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Índice de la exclusión mutua abandonada en la matriz de identificadores de espera si la excepción se produce para el método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, o -1 si la excepción se produce para los métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> o <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AbandonedMutexException&quot; /&gt; class with a specified error message, the index of the abandoned mutex, if applicable, and the abandoned mutex.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un mensaje de error especificado, el índice de la exclusión mutua abandonada, si es aplicable, y la exclusión mutua abandonada.</summary>
      <param name="message" vsli:raw="An error message that explains the reason for the exception.">Mensaje de error que explica la razón de la excepción.</param>
      <param name="location" vsli:raw="The index of the abandoned mutex in the array of wait handles if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, or -1 if the exception is thrown for the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitOne&quot; /&gt; or &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAll&quot; /&gt; methods.">Índice de la exclusión mutua abandonada en la matriz de identificadores de espera si la excepción se produce para el método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, o -1 si la excepción se produce para los métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> o <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle" vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex.">Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary vsli:raw="Gets the abandoned mutex that caused the exception, if known.">Obtiene la exclusión mutua abandonada que produjo la excepción, si se conoce.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or &lt;see langword=&quot;null&quot; /&gt; if the abandoned mutex could not be identified.">Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada o <see langword="null" /> si no se han podido identificar las exclusiones mutuas abandonadas.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary vsli:raw="Gets the index of the abandoned mutex that caused the exception, if known.">Obtiene el índice de la exclusión mutua abandonada que produjo la excepción, si se conoce.</summary>
      <returns vsli:raw="The index, in the array of wait handles passed to the &lt;see cref=&quot;Overload:System.Threading.WaitHandle.WaitAny&quot; /&gt; method, of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the abandoned mutex, or -1 if the index of the abandoned mutex could not be determined.">Índice de la matriz de identificadores de espera pasados al <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> método <see cref="T:System.Threading.Mutex" /> del objeto que representa la exclusión mutua abandonada, o-1 si no se pudo determinar el índice de la exclusión mutua abandonada.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary vsli:raw="Provides the functionality to restore the migration, or flow, of the execution context between threads.">Proporciona la funcionalidad para restaurar la migración, o el flujo, del contexto de ejecución entre los subprocesos.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">La estructura <see cref="T:System.Threading.AsyncFlowControl" /> no se utiliza en el subproceso donde fue creado.
O bien
La estructura <see cref="T:System.Threading.AsyncFlowControl" /> ya se ha utilizado para llamar a <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary vsli:raw="Determines whether the specified object is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Determina si el objeto especificado es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</summary>
      <param name="obj" vsli:raw="An object to compare with the current structure.">Objeto que se va a comparar con la estructura actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure and is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <paramref name="obj" /> es una estructura <see cref="T:System.Threading.AsyncFlowControl" /> y es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Determines whether the specified &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Determina si la estructura <see cref="T:System.Threading.AsyncFlowControl" /> especificada es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</summary>
      <param name="obj" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure to compare with the current structure.">Estructura <see cref="T:System.Threading.AsyncFlowControl" /> para comparar con la estructura actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <paramref name="obj" /> es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Obtiene código hash para la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</summary>
      <returns vsli:raw="A hash code for the current &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Código hash para la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are equal.">Compara dos estructuras <see cref="T:System.Threading.AsyncFlowControl" /> para determinar si son iguales.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two structures are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si las dos estructuras son iguales; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structures to determine whether they are not equal.">Compara dos estructuras <see cref="T:System.Threading.AsyncFlowControl" /> para determinar si no son iguales.</summary>
      <param name="a" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b" vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure.">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the structures are not equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si las estructuras no son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary vsli:raw="Restores the flow of the execution context between threads.">Restaura el flujo del contexto de ejecución entre los subprocesos.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure is not used on the thread where it was created.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure has already been used to call &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Dispose&quot; /&gt; or &lt;see cref=&quot;M:System.Threading.AsyncFlowControl.Undo&quot; /&gt;.">La estructura <see cref="T:System.Threading.AsyncFlowControl" /> no se utiliza en el subproceso donde fue creado.
o bien
La estructura <see cref="T:System.Threading.AsyncFlowControl" /> ya se ha utilizado para llamar a <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary vsli:raw="Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.">Representa datos ambiente locales de un flujo de control asincrónico determinado, por ejemplo, un método asincrónico.</summary>
      <typeparam name="T" vsli:raw="The type of the ambient data.">Tipo de los datos ambiente.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instance that does not receive change notifications.">Crea una instancia <see cref="T:System.Threading.AsyncLocal`1" /> que no recibe las notificaciones de cambio.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary vsli:raw="Instantiates an &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; local instance that receives change notifications.">Crea una instancia <see cref="T:System.Threading.AsyncLocal`1" /> local que recibe notificaciones de cambio.</summary>
      <param name="valueChangedHandler" vsli:raw="The delegate that is called whenever the current value changes on any thread.">Delegado al que se llama cuando cambia el valor actual en cualquier subproceso.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of the ambient data.">Obtiene o establece el valor de los datos ambiente.</summary>
      <returns vsli:raw="The value of the ambient data. If no value has been set, the returned value is &lt;c&gt;default(T)&lt;/c&gt;.">Valor de los datos ambiente. Si no se ha establecido ningún valor, el valor devuelto es <c>default (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary vsli:raw="The class that provides data change information to &lt;see cref=&quot;T:System.Threading.AsyncLocal`1&quot; /&gt; instances that register for change notifications.">Clase que proporciona información de cambio de datos a las instancias <see cref="T:System.Threading.AsyncLocal`1" /> que se registran para las notificaciones de cambios.</summary>
      <typeparam name="T" vsli:raw="The type of the data.">Tipo de los datos.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary vsli:raw="Gets the data's current value.">Obtiene el valor actual de los datos.</summary>
      <returns vsli:raw="The data's current value.">Valor actual de los datos.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary vsli:raw="Gets the data's previous value.">Obtiene el valor anterior de los datos.</summary>
      <returns vsli:raw="The data's previous value.">Valor anterior de los datos.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary vsli:raw="Returns a value that indicates whether the value changes because of a change of execution context.">Devuelve un valor que indica si el valor cambia debido a un cambio de contexto de ejecución.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value changed because of a change of execution context; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />Si el valor cambió debido a un cambio de contexto de ejecución; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, resets automatically after releasing a single waiting thread. This class cannot be inherited.">Representa un evento de sincronización de subprocesos que cuando se señala, se restablece automáticamente después de liberar un único subproceso en espera. Esta clase no puede heredarse.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.AutoResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AutoResetEvent" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to non-signaled.">
        <see langword="true" /> para establecer el estado inicial en señalado; <see langword="false" /> para establecer el estado inicial en no señalado.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary vsli:raw="Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.">Habilita varias tareas para que colaboren en un algoritmo en paralelo en varias fases.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Número de subprocesos que participan.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> es menor que 0 o mayor que 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount" vsli:raw="The number of participating threads.">Número de subprocesos que participan.</param>
      <param name="postPhaseAction" vsli:raw="The &lt;see cref=&quot;T:System.Action`1&quot; /&gt; to be executed after each phase. null (Nothing in Visual Basic) may be passed to indicate no action is taken.">Objeto <see cref="T:System.Action`1" /> que se va a ejecutar después de cada fase. Se puede pasar null (Nothing en Visual Basic) para indicar que no se realiza ninguna acción.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0 or greater than 32,767.">
        <paramref name="participantCount" /> es menor que 0 o mayor que 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be an additional participant.">Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber un participante adicional.</summary>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Número de fase de la barrera en la que primero participarán los nuevos participantes.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Adding a participant would cause the barrier's participant count to exceed 32,767.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">Agregar un participante haría que el recuento de participantes de la barrera superase los 32.767.
o bien
El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be additional participants.">Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber participantes adicionales.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to add to the barrier.">Número de participantes adicionales que se van a agregar a la barrera.</param>
      <returns vsli:raw="The phase number of the barrier in which the new participants will first participate.">Número de fase de la barrera en la que primero participarán los nuevos participantes.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;participantCount&quot; /&gt; is less than 0.  &#xA;  &#xA; -or-  &#xA;  &#xA; Adding &lt;paramref name=&quot;participantCount&quot; /&gt; participants would cause the barrier's participant count to exceed 32,767.">
        <paramref name="participantCount" /> es menor que 0.
o bien
Agregar <paramref name="participantCount" /> haría que el recuento de participantes de la barrera superase los 32.767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary vsli:raw="Gets the number of the barrier's current phase.">Obtiene el número de la fase actual de la barrera.</summary>
      <returns vsli:raw="Returns the number of the barrier's current phase.">Devuelve el número de la fase actual de la barrera.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action.">El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt;, and optionally releases the managed resources.">Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.Barrier" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true para liberar tanto los recursos administrados como los no administrados; false para liberar únicamente los recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary vsli:raw="Gets the total number of participants in the barrier.">Obtiene el número total de participantes de la barrera.</summary>
      <returns vsli:raw="Returns the total number of participants in the barrier.">Devuelve el número total de participantes de la barrera.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary vsli:raw="Gets the number of participants in the barrier that haven't yet signaled in the current phase.">Obtiene el número de participantes en la barrera que aún no se han señalado en la fase actual.</summary>
      <returns vsli:raw="Returns the number of participants in the barrier that haven't yet signaled in the current phase.">Devuelve el número de participantes en la barrera que todavía no se han señalado en la fase actual.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be one less participant.">Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber un participante menos.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.">La barrera ya tiene 0 participantes.
o bien
El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; that there will be fewer participants.">Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber menos participantes.</summary>
      <param name="participantCount" vsli:raw="The number of additional participants to remove from the barrier.">Número de participantes adicionales que se van a quitar de la barrera.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The total participant count is less than the specified &lt;paramref name=&quot;participantCount&quot; /&gt;">El total de participantes es menor que el <paramref name="participantCount" /> especificado.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The barrier already has 0 participants.  &#xA;  &#xA; -or-  &#xA;  &#xA; The method was invoked from within a post-phase action.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current participant count is less than the specified participantCount.">La barrera ya tiene 0 participantes.
O bien
El método se invocó desde dentro de una acción posterior a la fase.
o bien
el recuento del participante actual es menor que el participantCount especificado</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well.">Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen también la barrera.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Si una excepción se produce de la acción de fase de envío de una barrera después de todos los subprocesos hayan llamado a SignalAndWait, la excepción se ajustará en una BarrierPostPhaseException y se producirá en todos los subprocesos que participan.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout.">Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen también la barrera usando un entero de 32 bits con signo para medir el tiempo de espera.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si todos los participantes han alcanzado la barrera dentro del tiempo especificado; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException" vsli:raw="If an exception is thrown from the post phase action of a Barrier after all participating threads have called SignalAndWait, the exception will be wrapped in a BarrierPostPhaseException and be thrown on all participating threads.">Si una excepción se produce de la acción de fase de envío de una barrera después de todos los subprocesos hayan llamado a SignalAndWait, la excepción se ajustará en una BarrierPostPhaseException y se producirá en todos los subprocesos que participan.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout, while observing a cancellation token.">Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes la alcancen también usando un entero de 32 bits con signo para medir el tiempo de espera mientras se observa un token de cancelación.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all participants reached the barrier within the specified time; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">si todos los participantes alcanzaron la barrera dentro del tiempo especificado; de lo contrario, es false.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier, while observing a cancellation token.">Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen la barrera mientras se observa un token de cancelación.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval.">Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen también la barrera usando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si todos los demás participantes han alcanzado la barrera; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out, or it is greater than 32,767.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o es mayor de 32 767.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; object to measure the time interval, while observing a cancellation token.">Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes la alcancen también usando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo, mientras se observa un token de cancelación.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if all other participants reached the barrier; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si todos los demás participantes han alcanzado la barrera; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method was invoked from within a post-phase action, the barrier currently has 0 participants, or the barrier is signaled by more threads than are registered as participants.">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary vsli:raw="The exception that is thrown when the post-phase action of a &lt;see cref=&quot;T:System.Threading.Barrier&quot; /&gt; fails.">La excepción que se inicia cuando se produce un error en la acción posterior a la fase de <see cref="T:System.Threading.Barrier" />.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a system-supplied message that describes the error.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con un mensaje proporcionado por el sistema que describe el error.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with the specified inner exception.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con la excepción interna especificada.</summary>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception.">Excepción que es la causa de la excepción actual.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with serialized data.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con datos serializados.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Objeto que contiene los datos del objeto serializados.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Información contextual acerca del origen o del destino.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified message that describes the error.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con un mensaje especificado que describe el error.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Mensaje que describe la excepción. El autor de llamada de este constructor debe asegurarse de que la cadena se haya adaptado para la referencia cultural actual del sistema.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.BarrierPostPhaseException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.">Mensaje que describe la excepción. El autor de llamada de este constructor debe asegurarse de que la cadena se haya adaptado para la referencia cultural actual del sistema.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary vsli:raw="Represents a method to be called within a new context.">Representa un método al que se va a llamar dentro de un nuevo contexto.</summary>
      <param name="state" vsli:raw="An object containing information to be used by the callback method each time it executes.">Objeto que contiene la información que va a utilizar el método de devolución de llamadas cada vez que se ejecute.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary vsli:raw="Represents a synchronization primitive that is signaled when its count reaches zero.">Representa una primitiva de sincronización que está señalada cuando su recuento alcanza el valor cero.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class with the specified count.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.CountdownEvent" /> con el recuento especificado.</summary>
      <param name="initialCount" vsli:raw="The number of signals initially required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Número de señales necesarias inicialmente para establecer <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by one.">Incrementa en uno el recuento actual de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">La instancia actual ya está establecida.
O bien
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> es igual o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary vsli:raw="Increments the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;'s current count by a specified value.">Incrementa en un valor especificado el recuento actual de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Valor en que se va a aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> es menor o igual que 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.&#xA;&#xA; -or-&#xA;&#xA; &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; after count is incremented by &lt;paramref name=&quot;signalCount&quot; /&gt;.">La instancia actual ya está establecida.
O bien
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> es igual o mayor que <see cref="F:System.Int32.MaxValue" /> después de incrementar la cuenta en <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary vsli:raw="Gets the number of remaining signals required to set the event.">Obtiene el número de señales restantes necesario para establecer el evento.</summary>
      <returns vsli:raw="The number of remaining signals required to set the event.">El número de señales restantes necesario para establecer el evento.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, and optionally releases the managed resources.">Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.CountdownEvent" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true para liberar tanto los recursos administrados como los no administrados; false para liberar únicamente los recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary vsli:raw="Gets the numbers of signals initially required to set the event.">Obtiene los números de señales que se necesitan inicialmente para establecer el evento.</summary>
      <returns vsli:raw="The number of signals initially required to set the event.">El número de señales que se necesitan inicialmente para establecer el evento.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary vsli:raw="Indicates whether the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; object's current count has reached zero.">Indica si el recuento actual del objeto <see cref="T:System.Threading.CountdownEvent" /> ha llegado a cero.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current count is zero; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el recuento actual es cero; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; to the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt;.">Restablece <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> en el valor de <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary vsli:raw="Resets the &lt;see cref=&quot;P:System.Threading.CountdownEvent.InitialCount&quot; /&gt; property to a specified value.">Restablece la propiedad <see cref="P:System.Threading.CountdownEvent.InitialCount" /> según un valor especificado.</summary>
      <param name="count" vsli:raw="The number of signals required to set the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;.">Número de señales necesario para establecer <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is less than 0.">
        <paramref name="count" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary vsli:raw="Registers a signal with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Registra una señal con <see cref="T:System.Threading.CountdownEvent" /> y disminuye el valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signal caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la señal ha provocado que el recuento alcanzara el valor cero y se estableciera el evento; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set.">La instancia actual ya está establecida.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary vsli:raw="Registers multiple signals with the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt;, decrementing the value of &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by the specified amount.">Registra varias señales con <see cref="T:System.Threading.CountdownEvent" /> reduciendo el valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> según la cantidad especificada.</summary>
      <param name="signalCount" vsli:raw="The number of signals to register.">Número de señales que se va a registrar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the signals caused the count to reach zero and the event was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las señales han provocado que el recuento alcanzara el valor cero y se estableciera el evento; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than 1.">
        <paramref name="signalCount" /> es menor que 1.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The current instance is already set. -or- Or &lt;paramref name=&quot;signalCount&quot; /&gt; is greater than &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">La instancia actual ya está establecida. -o bien- <paramref name="signalCount" /> es mayor que <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by one.">Intenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> en uno.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero, this method will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el incremento se ha realizado correctamente; en caso contrario, es false. Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> ya está en el valor cero, este método devolverá <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is equal to &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> es igual a <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary vsli:raw="Attempts to increment &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; by a specified value.">Intenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> en un valor especificado.</summary>
      <param name="signalCount" vsli:raw="The value by which to increase &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt;.">Valor en que se va a aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the increment succeeded; otherwise, false. If &lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; is already at zero this will return &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el incremento se ha realizado correctamente; en caso contrario, es false. Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> ya está en el valor cero, se devolverá <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;signalCount&quot; /&gt; is less than or equal to 0.">
        <paramref name="signalCount" /> es menor o igual que 0.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Threading.CountdownEvent.CurrentCount&quot; /&gt; + &lt;paramref name=&quot;signalCount&quot; /&gt; is equal to or greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> es igual o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un entero de 32 bits con signo para medir el tiempo de espera.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a 32-bit signed integer to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un entero de 32 bits con signo para medir el tiempo de espera, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Ya se ha eliminado la instancia actual. o bien, <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> sido eliminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Ya se ha eliminado la instancia actual. o bien, <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> sido eliminado.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un objeto <see cref="T:System.TimeSpan" /> para medir el tiempo de espera.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un objeto <see cref="T:System.TimeSpan" /> para medir el tiempo de espera, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.CountdownEvent&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; has been canceled.">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed. -or- The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Ya se ha eliminado la instancia actual. o bien, <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> sido eliminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Obtiene un objeto <see cref="T:System.Threading.WaitHandle" /> que se usa para esperar a que se establezca el evento.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that is used to wait for the event to be set.">Objeto <see cref="T:System.Threading.WaitHandle" /> que se usa para esperar a que se establezca el evento.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary vsli:raw="Indicates whether an &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; is reset automatically or manually after receiving a signal.">Indica si un objeto <see cref="T:System.Threading.EventWaitHandle" /> se restablece automática o manualmente después de recibir una señal.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; resets automatically after releasing a single thread. If no threads are waiting, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; remains signaled until a thread blocks, and resets after releasing the thread.">El objeto <see cref="T:System.Threading.EventWaitHandle" />, cuando está señalado, se restablece automáticamente después de haber liberado un único subproceso. Si hay ningún subproceso en espera, el objeto <see cref="T:System.Threading.EventWaitHandle" /> permanece señalado hasta que un subproceso se bloquea y se restablece después de haber liberado el subproceso.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary vsli:raw="When signaled, the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; releases all waiting threads and remains signaled until it is manually reset.">El objeto <see cref="T:System.Threading.EventWaitHandle" />, cuando está señalado, libera todos los subprocesos en espera y permanece señalado hasta que se restablece manualmente.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary vsli:raw="Represents a thread synchronization event.">Representa un evento de sincronización de subprocesos.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente y si se restablece automática o manualmente.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">Es <see langword="true" /> para establecer el estado inicial en señalado; es <see langword="false" /> para establecerlo en no señalado.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente cuando se crea como resultado de esta llamada, si se restablece automática o manualmente y el nombre de un evento de sincronización del sistema.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre de un evento de sincronización de todo el sistema.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente si se crea como resultado de esta llamada, si se restablece automática o manualmente, el nombre de un evento de sincronización del sistema y una variable booleana cuyo valor después de la llamada indica si se creó el evento del sistema con nombre.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state to signaled if the named event is created as a result of this call; &lt;see langword=&quot;false&quot; /&gt; to set it to nonsignaled.">
        <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</param>
      <param name="mode" vsli:raw="One of the &lt;see cref=&quot;T:System.Threading.EventResetMode&quot; /&gt; values that determines whether the event resets automatically or manually.">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre de un evento de sincronización de todo el sistema.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local event was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system event was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system event already existed. This parameter is passed uninitialized.">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se ha creado un evento local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se ha creado el evento del sistema con nombre especificado; es <see langword="false" /> si el evento del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.EventWaitHandleRights.FullControl&quot; /&gt;.">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          The &lt;paramref name=&quot;mode&quot; /&gt; enum value was out of legal range.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists.">Abre el evento de sincronización con nombre especificado, si ya existe.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre del evento de sincronización del sistema que se va a abrir.</param>
      <returns vsli:raw="An object that represents the named system event.">Objeto que representa el evento del sistema con nombre.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be opened. It may not exist, or a synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">El evento del sistema con nombre no existe.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the security access required to use it.">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad exigido para utilizarlo.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, causing threads to block.">Establece el estado del evento en no señalado, haciendo que los subprocesos se bloqueen.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">El método <see cref="M:System.Threading.WaitHandle.Close" /> se llamó previamente en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary vsli:raw="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">Establece el estado del evento en señalado, permitiendo que uno o varios subprocesos en espera continúen.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the operation succeeds; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;M:System.Threading.WaitHandle.Close&quot; /&gt; method was previously called on this &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt;.">El método <see cref="M:System.Threading.WaitHandle.Close" /> se llamó previamente en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary vsli:raw="Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.">Abre el evento de sincronización con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre del evento de sincronización del sistema que se va a abrir.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.EventWaitHandle&quot; /&gt; object that represents the named synchronization event if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa el evento de sincronización con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named synchronization event was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">Es <see langword="true" /> si el evento de sincronización con nombre se abrió correctamente; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named event exists, but the user does not have the desired security access.">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary vsli:raw="Manages the execution context for the current thread. This class cannot be inherited.">Administra el contexto de ejecución del subproceso actual. Esta clase no puede heredarse.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary vsli:raw="Captures the execution context from the current thread.">Captura el contexto de ejecución del subproceso actual.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the execution context for the current thread.">Objeto <see cref="T:System.Threading.ExecutionContext" /> que representa el contexto de ejecución del subproceso actual.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current execution context.">Crea una copia del contexto de ejecución actual.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; object representing the current execution context.">Objeto <see cref="T:System.Threading.ExecutionContext" /> que representa el contexto de ejecución actual.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="This context cannot be copied because it is used. Only newly captured contexts can be copied.">Este contexto no se puede copiar porque se utiliza. Sólo se pueden copiar contextos recién capturados.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Sets the specified &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object with the logical context information needed to recreate an instance of the current execution context.">Establece el objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> especificado con la información de contexto lógica necesaria para volver a crear una instancia del contexto de ejecución actual.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object to be populated with serialization information.">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que se debe llenar con información de serialización.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; structure representing the destination context of the serialization.">Estructura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que representa el contexto de destino de la serialización.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;info&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="info" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary vsli:raw="Indicates whether the flow of the execution context is currently suppressed.">Indica si el flujo del contexto de ejecución está suprimido en este momento.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the flow is suppressed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el flujo está suprimido; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary vsli:raw="Restores the flow of the execution context across asynchronous threads.">Restaura el flujo del contexto de ejecución entre subprocesos asincrónicos.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow cannot be restored because it is not being suppressed.">El flujo del contexto no se puede restaurar porque no se está suprimiendo.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary vsli:raw="Runs a method in a specified execution context on the current thread.">Ejecuta un método en un contexto de ejecución especificado en el subproceso actual.</summary>
      <param name="executionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ExecutionContext&quot; /&gt; to set.">Objeto <see cref="T:System.Threading.ExecutionContext" /> que se va a establecer.</param>
      <param name="callback" vsli:raw="A &lt;see cref=&quot;T:System.Threading.ContextCallback&quot; /&gt; delegate that represents the method to be run in the provided execution context.">Delegado <see cref="T:System.Threading.ContextCallback" /> que representa el método que se va a ejecutar en el contexto de ejecución proporcionado.</param>
      <param name="state" vsli:raw="The object to pass to the callback method.">Objeto que se pasa al método de devolución de llamada.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;executionContext&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;executionContext&quot; /&gt; has already been used as the argument to a &lt;see cref=&quot;M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)&quot; /&gt; call.">
        <paramref name="executionContext" /> es <see langword="null" />.
O bien
<paramref name="executionContext" /> no se adquirió a través de una operación de captura.
o bien
<paramref name="executionContext" /> ya se ha utilizado como argumento de una llamada a <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary vsli:raw="Suppresses the flow of the execution context across asynchronous threads.">Suprime el flujo del contexto de ejecución entre subprocesos asincrónicos.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Threading.AsyncFlowControl&quot; /&gt; structure for restoring the flow.">Estructura <see cref="T:System.Threading.AsyncFlowControl" /> para restaurar el flujo.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The context flow is already suppressed.">El flujo del contexto ya se ha suprimido.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary vsli:raw="Encapsulates and propagates the host execution context across threads.">Encapsula y difunde el contexto de ejecución del host en todos los subprocesos.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class using the specified state.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.HostExecutionContext" /> utilizando el estado especificado.</summary>
      <param name="state" vsli:raw="An object representing the host execution context state.">Objeto que representa el estado del contexto de ejecución del host.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary vsli:raw="Creates a copy of the current host execution context.">Crea una copia del contexto de ejecución del host actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host context for the current thread.">Objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa el contexto del host del subproceso actual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary vsli:raw="When overridden in a derived class, releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt;, and optionally releases the managed resources.">Cuando se reemplaza en una clase derivada, libera los recursos no administrados que usa <see cref="T:System.Threading.WaitHandle" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary vsli:raw="Gets or sets the state of the host execution context.">Obtiene o establece el estado del contexto de ejecución del host.</summary>
      <returns vsli:raw="An object representing the host execution context state.">Objeto que representa el estado del contexto de ejecución del host.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary vsli:raw="Provides the functionality that allows a common language runtime host to participate in the flow, or migration, of the execution context.">Proporciona la funcionalidad que permite que un host de Common Language Runtime participe en el flujo, o migración, del contexto de ejecución.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.HostExecutionContextManager&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary vsli:raw="Captures the host execution context from the current thread.">Captura el contexto de ejecución del host en el subproceso actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; object representing the host execution context of the current thread.">Objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa el contexto de ejecución del host del subproceso actual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary vsli:raw="Restores the host execution context to its prior state.">Restaura el contexto de ejecución del host a su estado anterior.</summary>
      <param name="previousState" vsli:raw="The previous context state to revert to.">Estado del contexto anterior que se va a recuperar.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;previousState&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; was not created on the current thread.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;previousState&quot; /&gt; is not the last state for the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt;.">
        <paramref name="previousState" /> es <see langword="null" />.
o bien
<paramref name="previousState" /> no se ha creado en el subproceso actual.
o bien
<paramref name="previousState" /> no es el último estado del <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary vsli:raw="Sets the current host execution context to the specified host execution context.">Establece el contexto de ejecución del host actual en el contexto de ejecución del host especificado.</summary>
      <param name="hostExecutionContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to be set.">
        <see cref="T:System.Threading.HostExecutionContext" /> que hay que establecer.</param>
      <returns vsli:raw="An object for restoring the &lt;see cref=&quot;T:System.Threading.HostExecutionContext&quot; /&gt; to its previous state.">Objeto para restaurar el <see cref="T:System.Threading.HostExecutionContext" /> a su estado anterior.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;hostExecutionContext&quot; /&gt; was not acquired through a capture operation.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;hostExecutionContext&quot; /&gt; has been the argument to a previous &lt;see cref=&quot;M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)&quot; /&gt; method call.">
        <paramref name="hostExecutionContext" /> no se adquirió a través de una operación de captura.
O bien
<paramref name="hostExecutionContext" /> ha sido el argumento de una llamada anterior al método <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" />.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary vsli:raw="Provides atomic operations for variables that are shared by multiple threads.">Proporciona operaciones atómicas para las variables compartidas por varios subprocesos.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary vsli:raw="Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.">Agrega dos enteros de 32 bits y reemplaza el primer entero por la suma, como una operación atómica.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Variable que contiene el primer valor que se va a agregar. La suma de los dos valores se almacena en <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Valor que se va a agregar al entero en <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">Nuevo valor almacenado en <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary vsli:raw="Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.">Agrega dos enteros de 64 bits y reemplaza el primer entero por la suma, como operación atómica.</summary>
      <param name="location1" vsli:raw="A variable containing the first value to be added. The sum of the two values is stored in &lt;paramref name=&quot;location1&quot; /&gt;.">Variable que contiene el primer valor que se va a agregar. La suma de los dos valores se almacena en <paramref name="location1" />.</param>
      <param name="value" vsli:raw="The value to be added to the integer at &lt;paramref name=&quot;location1&quot; /&gt;.">Valor que se va a agregar al entero en <paramref name="location1" />.</param>
      <returns vsli:raw="The new value that was stored at &lt;paramref name=&quot;location1&quot; /&gt; by this operation.">Nuevo valor almacenado en <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary vsli:raw="Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.">Compara dos números de punto flotante de precisión doble para comprobar si son iguales y, si lo son, reemplaza el primero de los valores.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary vsli:raw="Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.">Compara dos enteros de 32 bits con signo para comprobar si son iguales y, si lo son, reemplaza el primer valor.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary vsli:raw="Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.">Compara dos enteros de 64 bits con signo para comprobar si son iguales y, si lo son, reemplaza el primer valor.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary vsli:raw="Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.">Compara dos identificadores o punteros específicos de la plataforma en términos de igualdad y, si son iguales, reemplaza el primero.</summary>
      <param name="location1" vsli:raw="The destination &lt;see cref=&quot;T:System.IntPtr&quot; /&gt;, whose value is compared with the value of &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced by &lt;paramref name=&quot;value&quot; /&gt;.">Estructura <see cref="T:System.IntPtr" /> de destino, cuyo valor se compara con el valor de <paramref name="comparand" /> y que posiblemente se reemplace por <paramref name="value" />.</param>
      <param name="value" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that replaces the destination value if the comparison results in equality.">Estructura <see cref="T:System.IntPtr" /> que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand" vsli:raw="The &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Estructura <see cref="T:System.IntPtr" /> que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary vsli:raw="Compares two objects for reference equality and, if they are equal, replaces the first object.">Compara dos objetos en términos de igualdad de referencia y, si son iguales, reemplaza el primero.</summary>
      <param name="location1" vsli:raw="The destination object that is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Objeto de destino que se compara por referencia con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value" vsli:raw="The object that replaces the destination object if the reference comparison results in equality.">Objeto que reemplaza el objeto de destino si la comparación de referencia da como resultado la igualdad de ambos parámetros.</param>
      <param name="comparand" vsli:raw="The object that is compared by reference to the object at &lt;paramref name=&quot;location1&quot; /&gt;.">Objeto que se compara por referencia con el objeto que hay en <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary vsli:raw="Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.">Compara dos números de punto flotante de precisión sencilla para comprobar si son iguales y, si lo son, reemplaza el primero de los valores.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced.">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison results in equality.">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand" vsli:raw="The value that is compared to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary vsli:raw="Compares two instances of the specified reference type &lt;paramref name=&quot;T&quot; /&gt; for reference equality and, if they are equal, replaces the first one.">Compara dos instancias del tipo de referencia especificado <paramref name="T" /> para comprobar si las referencias son iguales y, si lo son, reemplaza la primera.</summary>
      <param name="location1" vsli:raw="The destination, whose value is compared by reference with &lt;paramref name=&quot;comparand&quot; /&gt; and possibly replaced. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Destino cuyo valor se compara por referencia con <paramref name="comparand" /> y que posiblemente se reemplace. Este es un parámetro de referencia (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
      <param name="value" vsli:raw="The value that replaces the destination value if the comparison by reference results in equality.">Valor que reemplaza el valor de destino si la comparación por referencia da como resultado una igualdad.</param>
      <param name="comparand" vsli:raw="The value that is compared by reference to the value at &lt;paramref name=&quot;location1&quot; /&gt;.">Valor que se compara por referencia con el que hay en <paramref name="location1" />.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt;, &lt;paramref name=&quot;value&quot; /&gt;, and &lt;paramref name=&quot;comparand&quot; /&gt;. This type must be a reference type.">Tipo que se va a utilizar para <paramref name="location1" />, <paramref name="value" /> y <paramref name="comparand" />. Este tipo debe ser un tipo de referencia.</typeparam>
      <returns vsli:raw="The original value in &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a null pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary vsli:raw="Decrements a specified variable and stores the result, as an atomic operation.">Disminuye el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Variable cuyo valor se va a reducir.</param>
      <returns vsli:raw="The decremented value.">Valor reducido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary vsli:raw="Decrements the specified variable and stores the result, as an atomic operation.">Disminuye el valor de la variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be decremented.">Variable cuyo valor se va a reducir.</param>
      <returns vsli:raw="The decremented value.">Valor reducido.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary vsli:raw="Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.">Establece un número de punto flotante de precisión doble en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable que se va a establecer en el valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary vsli:raw="Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.">Establece un entero de 32 bits con signo en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable que se va a establecer en el valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary vsli:raw="Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.">Establece un entero de 64 bits con signo en un valor especificado y devuelve el valor original, como operación atómica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable que se va a establecer en el valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.">Establece un puntero o identificador específico de plataforma en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable que se va a establecer en el valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary vsli:raw="Sets an object to a specified value and returns a reference to the original object, as an atomic operation.">Establece un objeto en un valor especificado y devuelve una referencia al objeto original, como una operación atómica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable que se va a establecer en el valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary vsli:raw="Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.">Establece un número de punto flotante de precisión sencilla en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value.">Variable que se va a establecer en el valor especificado.</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary vsli:raw="Sets a variable of the specified type &lt;paramref name=&quot;T&quot; /&gt; to a specified value and returns the original value, as an atomic operation.">Establece una variable del tipo <paramref name="T" /> especificado en un valor determinado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1" vsli:raw="The variable to set to the specified value. This is a reference parameter (&lt;see langword=&quot;ref&quot; /&gt; in C#, &lt;see langword=&quot;ByRef&quot; /&gt; in Visual Basic).">Variable que se va a establecer en el valor especificado. Este es un parámetro de referencia (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
      <param name="value" vsli:raw="The value to which the &lt;paramref name=&quot;location1&quot; /&gt; parameter is set.">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <typeparam name="T" vsli:raw="The type to be used for &lt;paramref name=&quot;location1&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt;. This type must be a reference type.">Tipo que se va a usar para <paramref name="location1" /> y <paramref name="value" />. Este tipo debe ser un tipo de referencia.</typeparam>
      <returns vsli:raw="The original value of &lt;paramref name=&quot;location1&quot; /&gt;.">Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location1&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Aumenta el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Variable cuyo valor se va a incrementar.</param>
      <returns vsli:raw="The incremented value.">Valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary vsli:raw="Increments a specified variable and stores the result, as an atomic operation.">Aumenta el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location" vsli:raw="The variable whose value is to be incremented.">Variable cuyo valor se va a incrementar.</param>
      <returns vsli:raw="The incremented value.">Valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;location&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; pointer.">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary vsli:raw="Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt; execute after memory accesses that follow the call to &lt;see cref=&quot;M:System.Threading.Interlocked.MemoryBarrier&quot; /&gt;.">Sincroniza el acceso a la memoria de la siguiente forma: El procesador que ejecuta el subproceso actual no puede reordenar las instrucciones de forma que los accesos a la memoria anteriores a la llamada a <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> se ejecuten después de los accesos a memoria posteriores a la llamada a <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary vsli:raw="Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.">Proporciona una barrera de memoria para todo el proceso con el fin de asegurar que las operaciones de lectura y escritura desde cualquier CPU no puedan superar la barrera.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary vsli:raw="Returns a 64-bit value, loaded as an atomic operation.">Devuelve un valor de 64 bits, cargado como una operación atómica.</summary>
      <param name="location" vsli:raw="The 64-bit value to be loaded.">Valor de 64 bits que se va a cargar.</param>
      <returns vsli:raw="The loaded value.">Valor cargado.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary vsli:raw="Provides lazy initialization routines.">Proporciona rutinas de inicialización diferida.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary vsli:raw="Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.">Inicializa un tipo de referencia de destino con su constructor sin parámetros si aún no se ha inicializado el destino.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Referencia que se va a inicializar si aún no se ha inicializado.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo de referencia que se va a inicializar.</typeparam>
      <returns vsli:raw="The initialized object.">Objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary vsli:raw="Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.">Inicializa un tipo de valor o referencia de destino con su constructor sin parámetros si aún no se ha inicializado.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Referencia o valor de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Referencia a un valor booleano que determina si ya se ha inicializado el destino.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />. Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo de referencia que se va a inicializar.</typeparam>
      <returns vsli:raw="The initialized object.">Objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference or value type by using a specified function if it hasn't already been initialized.">Inicializa un tipo de referencia de destino o tipo de valor utilizando la función especificada si aún no se ha inicializado.</summary>
      <param name="target" vsli:raw="A reference or value of type &lt;c&gt;T&lt;/c&gt; to initialize if it hasn't already been initialized.">Referencia o valor de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</param>
      <param name="initialized" vsli:raw="A reference to a Boolean value that determines whether the target has already been initialized.">Referencia a un valor booleano que determina si ya se ha inicializado el destino.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />. Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference or value.">Función que se llama para inicializar la referencia o el valor.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo de referencia que se va a inicializar.</typeparam>
      <returns vsli:raw="The initialized object.">Objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException" vsli:raw="Permissions to access the constructor of type &lt;paramref name=&quot;T&quot; /&gt; were missing.">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type by using a specified function if it hasn't already been initialized.">Inicializa un tipo de referencia de destino utilizando la función especificada si aún no se ha inicializado.</summary>
      <param name="target" vsli:raw="The reference to initialize if it hasn't already been initialized.">Referencia que se va a inicializar si aún no se ha inicializado.</param>
      <param name="valueFactory" vsli:raw="The function that is called to initialize the reference.">Función que se llama para inicializar la referencia.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo de referencia que se va a inicializar.</typeparam>
      <returns vsli:raw="The initialized object.">Objeto inicializado.</returns>
      <exception cref="T:System.MissingMemberException" vsli:raw="Type &lt;paramref name=&quot;T&quot; /&gt; does not have a parameterless constructor.">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; returned null (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> devuelve un valor NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary vsli:raw="Initializes a target reference type with a specified function if it has not already been initialized.">Inicializa un tipo de referencia de destino con una función especificada si aún no se ha inicializado.</summary>
      <param name="target" vsli:raw="A reference to initialize if it has not already been initialized. If it is &lt;see langword=&quot;null&quot; /&gt;, it is considered not initialized; otherwise, it's considered initialized.">Referencia que se va a inicializar si aún no se ha inicializado.</param>
      <param name="syncLock" vsli:raw="A reference to an object used as the mutually exclusive lock for initializing&#xA;            &lt;paramref name=&quot;target&quot; /&gt;. If &lt;paramref name=&quot;syncLock&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a new object will be instantiated.">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />. Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</param>
      <param name="valueFactory" vsli:raw="The method to invoke to initialize &lt;paramref name=&quot;target&quot; /&gt;.">Método que se va a invocar para inicializar <paramref name="target" />.</param>
      <typeparam name="T" vsli:raw="The type of the reference to be initialized.">Tipo de referencia que se va a inicializar.</typeparam>
      <returns vsli:raw="The initialized object.">Objeto inicializado.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary vsli:raw="Defines the lock that implements single-writer/multiple-reader semantics. This is a value type.">Define el bloqueo que implementa la semántica de un sistema de escritura y varios sistemas de lectura. Se trata de un tipo de valor.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary vsli:raw="Indicates whether a specified object is a &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; and is equal to the current instance.">Indica si un objeto especificado es un <see cref="T:System.Threading.LockCookie" /> y es igual a la instancia actual.</summary>
      <param name="obj" vsli:raw="The object to compare to the current instance.">Objeto que se va a comparar con la actual instancia.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value of &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el valor de <paramref name="obj" /> es igual al de la instancia actual; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether the current instance is equal to the specified &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt;.">Indica si la instancia actual es igual al objeto <see cref="T:System.Threading.LockCookie" /> especificado.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to the current instance.">
        <see cref="T:System.Threading.LockCookie" /> que se va a comparar con la instancia actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is equal to the value of the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="obj" /> es igual al valor de la instancia actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Devuelve el código hash de esta instancia.</summary>
      <returns vsli:raw="A 32-bit signed integer hash code.">Código hash de un entero de 32 bits con signo.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are equal.">Indica si dos estructuras de <see cref="T:System.Threading.LockCookie" /> son iguales.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="a" /> es igual a <paramref name="b" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary vsli:raw="Indicates whether two &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; structures are not equal.">Indica si dos estructuras de <see cref="T:System.Threading.LockCookie" /> no son iguales.</summary>
      <param name="a" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;b&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="b" />.</param>
      <param name="b" vsli:raw="The &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; to compare to &lt;paramref name=&quot;a&quot; /&gt;.">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="a" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;a&quot; /&gt; is not equal to &lt;paramref name=&quot;b&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si <paramref name="a" /> no es igual a <paramref name="b" />; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary vsli:raw="The exception that is thrown when recursive entry into a lock is not compatible with the recursion policy for the lock.">Excepción que se inicia cuando la entrada recursiva en un bloqueo no es compatible con la directiva de recursividad del bloqueo.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a system-supplied message that describes the error.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con un mensaje proporcionado por el sistema que describe el error.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with serialized data.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con datos serializados.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Objeto que contiene los datos del objeto serializados.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Información contextual acerca del origen o del destino.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified message that describes the error.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con un mensaje especificado que describe el error.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Mensaje que describe la excepción. El llamador de este constructor debe asegurarse de que la cadena se ha traducido para la referencia cultural actual del sistema.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.LockRecursionException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message" vsli:raw="The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.">Mensaje que describe la excepción. El llamador de este constructor debe asegurarse de que la cadena se ha traducido para la referencia cultural actual del sistema.</param>
      <param name="innerException" vsli:raw="The exception that caused the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Excepción que ha producido la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary vsli:raw="Specifies whether a lock can be entered multiple times by the same thread.">Especifica si el mismo subproceso puede entrar varias veces en un bloqueo.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary vsli:raw="If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.">Si un subproceso intenta entrar en un bloqueo de forma recursiva, se inicia una excepción. Algunas clases pueden permitir cierta recursividad cuando se aplica esta configuración.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary vsli:raw="A thread can enter a lock recursively. Some classes may restrict this capability.">Un subproceso puede entrar en un bloqueo de forma recursiva. Algunas clases pueden limitar esta posibilidad.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class cannot be inherited.">Representa un evento de sincronización de subprocesos que, cuando se señale, se debe restablecer manualmente. Esta clase no puede heredarse.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ManualResetEvent" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado.</summary>
      <param name="initialState" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to set the initial state signaled; &lt;see langword=&quot;false&quot; /&gt; to set the initial state to nonsignaled.">
        <see langword="true" /> para establecer el estado inicial de señalado; <see langword="false" /> para establecer el estado inicial en no señalado.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary vsli:raw="Represents a thread synchronization event that, when signaled, must be reset manually. This class is a lightweight alternative to &lt;see cref=&quot;T:System.Threading.ManualResetEvent&quot; /&gt;.">Representa un evento de sincronización de subprocesos que, cuando se señale, se debe restablecer manualmente. Esta clase es una alternativa ligera a <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with an initial state of nonsignaled.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ManualResetEventSlim" /> con el estado inicial establecido en nonsignaled.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ManualResetEventSlim" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado.</summary>
      <param name="initialState" vsli:raw="true to set the initial state signaled; false to set the initial state to nonsignaled.">Es true para establecer el estado inicial en señalado; es false para establecer el estado inicial en no señalado.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class with a Boolean value indicating whether to set the initial state to signaled and a specified spin count.">Inicializa una instancia nueva de la clase <see cref="T:System.Threading.ManualResetEventSlim" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado y un recuento circular especificado.</summary>
      <param name="initialState" vsli:raw="true to set the initial state to signaled; false to set the initial state to nonsignaled.">Es true para establecer el estado inicial en señalado; es false para establecer el estado inicial en no señalado.</param>
      <param name="spinCount" vsli:raw="The number of spin waits that will occur before falling back to a kernel-based wait operation.">Número de esperas circulares que se van a producir antes de una operación de espera basada en kernel.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;spinCount&quot; /&gt; is less than 0 or greater than the maximum allowed value.">
        <paramref name="spinCount" /> es menor que 0 o mayor que el máximo valor permitido.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;, and optionally releases the managed resources.">Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing" vsli:raw="true to release both managed and unmanaged resources; false to release only unmanaged resources.">true para liberar tanto los recursos administrados como los no administrados; false para liberar únicamente los recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary vsli:raw="Gets whether the event is set.">Obtiene un valor que indica si se ha establecido el evento.</summary>
      <returns vsli:raw="true if the event is set; otherwise, false.">Es true si se establece el evento; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary vsli:raw="Sets the state of the event to nonsignaled, which causes threads to block.">Establece el estado del evento en no señalado, por lo que se bloquean los subprocesos.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary vsli:raw="Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.">Establece el estado del evento en señalado, lo que permite la continuación de uno o varios subprocesos que están esperando en el evento.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary vsli:raw="Gets the number of spin waits that will occur before falling back to a kernel-based wait operation.">Obtiene el número de esperas circulares que se van a producir antes de una operación de espera basada en kernel.</summary>
      <returns vsli:raw="Returns the number of spin waits that will occur before falling back to a kernel-based wait operation.">Devuelve el número de esperas circulares que se van a producir antes de una operación de espera basada en kernel.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, usando un entero de 32 bits con signo para medir el intervalo de tiempo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, usando un entero de 32 bits con signo para medir el intervalo de tiempo, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">El objeto ya se ha eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> se ha eliminado.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; receives a signal, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual reciba una señal, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">El objeto ya se ha eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> se ha eliminado.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was&#xA;            canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, utilizando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.
o bien
El número de milisegundos en <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed.">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until the current &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; is set, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, usando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt; was set; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out.  &#xA;  &#xA; -or-  &#xA;  &#xA; The number of milliseconds in &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.
o bien
El número de milisegundos en <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The maximum number of waiters has been exceeded.">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The object has already been disposed or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">El objeto ya se ha eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> se ha eliminado.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Obtiene el objeto <see cref="T:System.Threading.WaitHandle" /> subyacente de este objeto <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns vsli:raw="The underlying &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; event object for this &lt;see cref=&quot;T:System.Threading.ManualResetEventSlim&quot; /&gt;.">Objeto de evento <see cref="T:System.Threading.WaitHandle" /> subyacente de este objeto <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary vsli:raw="Provides a mechanism that synchronizes access to objects.">Proporciona un mecanismo que sincroniza el acceso a los objetos.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object.">Adquiere un bloqueo exclusivo en el objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the monitor lock.">Objeto en el que se va a adquirir el bloqueo de monitor.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary vsli:raw="Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Adquiere un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objeto en el que se va a esperar.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.  &#xA;  &#xA; Note   If no exception occurs, the output of this method is always &lt;see langword=&quot;true&quot; /&gt;.">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.
Nota   Si no se produce ninguna excepción, el resultado de este método siempre es <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary vsli:raw="Releases an exclusive lock on the specified object.">Libera un bloqueo exclusivo en el objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to release the lock.">Objeto en el que se va a liberar el bloqueo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread does not own the lock for the specified object.">El subproceso actual no posee el bloqueo para el objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary vsli:raw="Determines whether the current thread holds the lock on the specified object.">Determina si el subproceso actual mantiene el bloqueo en el objeto especificado.</summary>
      <param name="obj" vsli:raw="The object to test.">El objeto que se va a probar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the lock on &lt;paramref name=&quot;obj&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual mantiene el bloqueo en <paramref name="obj" />; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;obj&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary vsli:raw="Gets the number of times there was contention when trying to take the monitor's lock.">Obtiene el número de veces que ha habido contención al intentar tomar el bloqueo del monitor.</summary>
      <returns vsli:raw="The number of times there was contention when trying to take the monitor's lock.">Número de veces que se ha producido una contención al intentar realizar el bloqueo del monitor.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary vsli:raw="Notifies a thread in the waiting queue of a change in the locked object's state.">Notifica un cambio de estado del objeto bloqueado al subproceso que se encuentra en la cola de espera.</summary>
      <param name="obj" vsli:raw="The object a thread is waiting for.">Objeto que está esperando un subproceso.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary vsli:raw="Notifies all waiting threads of a change in the object's state.">Notifica un cambio de estado del objeto a todos los subprocesos que se encuentran en espera.</summary>
      <param name="obj" vsli:raw="The object that sends the pulse.">Objeto que envía el pulso.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object.">Intenta adquirir un bloqueo exclusivo en el objeto especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objeto en el que se va a adquirir el bloqueo.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Intenta adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.">Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el número de segundos especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Intenta, durante el número especificado de milisegundos, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait for the lock.">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, and not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">
        <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.">Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el período de tiempo especificado.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">
        <see cref="T:System.TimeSpan" /> que representa el período de tiempo que se va a esperar para adquirir el bloqueo. Un valor de -1 milisegundo especifica una espera infinita.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread acquires the lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.">Intenta, durante el periodo de tiempo indicado, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj" vsli:raw="The object on which to acquire the lock.">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="timeout" vsli:raw="The amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.">Tiempo que se va a esperar el bloqueo. Un valor de -1 milisegundo especifica una espera infinita.</param>
      <param name="lockTaken" vsli:raw="The result of the attempt to acquire the lock, passed by reference. The input must be &lt;see langword=&quot;false&quot; /&gt;. The output is &lt;see langword=&quot;true&quot; /&gt; if the lock is acquired; otherwise, the output is &lt;see langword=&quot;false&quot; /&gt;. The output is set even if an exception occurs during the attempt to acquire the lock.">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The input to &lt;paramref name=&quot;lockTaken&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; in milliseconds is negative and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock.">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objeto en el que se va a esperar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.">
        <see langword="true" /> si la llamada fue devuelta porque el llamador volvió a adquirir el bloqueo para el objeto especificado. Este método no devuelve ningún resultado si el bloqueo no vuelve a adquirirse.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objeto en el que se va a esperar.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos. Este método también especifica si el dominio de sincronización del contexto (si se trata de un contexto sincronizado) sale antes de la espera y vuelve a adquirir el bloqueo después.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objeto en el que se va a esperar.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait before the thread enters the ready queue.">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; parameter is negative, and is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;.">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objeto en el que se va a esperar.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">
        <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The calling thread does not own the lock for the specified object.">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes &lt;see langword=&quot;Wait&quot; /&gt; is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of the &lt;paramref name=&quot;timeout&quot; /&gt; parameter in milliseconds is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">El valor del parámetro <paramref name="timeout" /> en milisegundos es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundo) o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary vsli:raw="Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos. De modo opcional, sale del dominio de sincronización del contexto sincronizado antes de la espera y vuelve a adquirir el dominio después.</summary>
      <param name="obj" vsli:raw="The object on which to wait.">Objeto en el que se va a esperar.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; representing the amount of time to wait before the thread enters the ready queue.">
        <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <param name="exitContext" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the lock was reacquired before the specified time elapsed; &lt;see langword=&quot;false&quot; /&gt; if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;obj&quot; /&gt; parameter is &lt;see langword=&quot;null&quot; /&gt;.">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see langword=&quot;Wait&quot; /&gt; is not invoked from within a synchronized block of code.">
        <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException" vsli:raw="The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's &lt;see cref=&quot;M:System.Threading.Thread.Interrupt&quot; /&gt; method.">El subproceso que invoca a Wait se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;timeout&quot; /&gt; parameter is negative and does not represent &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1 millisecond), or is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">El parámetro <paramref name="timeout" /> es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundo), o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary vsli:raw="A synchronization primitive that can also be used for interprocess synchronization.">Primitiva de sincronización que puede usarse también para la sincronización entre procesos.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with default properties.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con propiedades predeterminadas.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the mutex; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para otorgar la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada, en caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua y una cadena que representa el nombre de la exclusión mutua.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, una cadena que es el nombre de la exclusión mutua y un valor booleano que, cuando se devuelva el método, indicará si se concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada.</summary>
      <param name="initiallyOwned" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains a Boolean that is &lt;see langword=&quot;true&quot; /&gt; if a local mutex was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system mutex was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system mutex already existed. This parameter is passed uninitialized.">Cuando se devuelve este método, contiene un valor booleano que es <see langword="true" /> si se creó una exclusión mutua local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía. Este parámetro se pasa sin inicializar.</param>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists and has access control security, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.MutexRights.FullControl&quot; /&gt;.">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&#xA;          .NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists.">Abre la exclusión mutua con nombre especificada, si ya existe.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
      <returns vsli:raw="An object that represents the named system mutex.">Objeto que representa la exclusión mutua del sistema con nombre.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">La excepción mutua con nombre no existe.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; once.">Libera una vez la instancia de <see cref="T:System.Threading.Mutex" />.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The calling thread does not own the mutex.">El subproceso que realiza la llamada no posee la exclusión mutua.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary vsli:raw="Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.">Abre la exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Mutex&quot; /&gt; object that represents the named mutex if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada. Este parámetro se trata como sin inicializar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named mutex was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named mutex exists, but the user does not have the security access required to use it.">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary vsli:raw="Defines a lock that supports single writers and multiple readers.">Define un bloqueo que admite un escritor y varios lectores.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLock&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary vsli:raw="Acquires a reader lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Tiempo de espera en milisegundos.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary vsli:raw="Acquires a reader lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</summary>
      <param name="timeout" vsli:raw="A &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">Un <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary vsli:raw="Acquires the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Tiempo de espera en milisegundos.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary vsli:raw="Acquires the writer lock, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; value for the time-out.">Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary vsli:raw="Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.">Indica si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia.</summary>
      <param name="seqNum" vsli:raw="The sequence number.">Número de secuencia.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt; was called.">Recupera el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)&quot; /&gt;.">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">El subproceso no dispone del bloqueo de escritor.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds a reader lock.">Obtiene un valor que indica si el subproceso actual tiene un bloqueo de lector.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds a reader lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso actual tiene un bloqueo de lector; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary vsli:raw="Gets a value indicating whether the current thread holds the writer lock.">Obtiene un valor que indica si el subproceso actual tiene el bloqueo de escritor.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread holds the writer lock; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso actual tiene el bloqueo de escritor; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary vsli:raw="Releases the lock, regardless of the number of times the thread acquired the lock.">Libera el bloqueo, independientemente del número de veces que el subproceso haya adquirido el bloqueo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value representing the released lock.">Un valor <see cref="T:System.Threading.LockCookie" /> que representa el bloqueo liberado.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary vsli:raw="Decrements the lock count.">Reduce el recuento de bloqueos.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have any reader or writer locks.">El subproceso no tiene ningún bloqueo de lector o escritor.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary vsli:raw="Decrements the lock count on the writer lock.">Reduce el recuento de bloqueos del bloqueo de escritor.</summary>
      <exception cref="T:System.ApplicationException" vsli:raw="The thread does not have the writer lock.">El subproceso no dispone del bloqueo de escritor.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary vsli:raw="Restores the lock status of the thread to what it was before calling &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Restaura el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie" vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; returned by &lt;see cref=&quot;M:System.Threading.ReaderWriterLock.ReleaseLock&quot; /&gt;.">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException" vsli:raw="The address of &lt;paramref name=&quot;lockCookie&quot; /&gt; is a null pointer.">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using an &lt;see cref=&quot;T:System.Int32&quot; /&gt; value for the time-out.">Actualiza un bloqueo de lector al bloqueo de escritor, utilizando un valor <see langword="Int32" /> para el tiempo de espera.</summary>
      <param name="millisecondsTimeout" vsli:raw="The time-out in milliseconds.">Tiempo de espera en milisegundos.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary vsli:raw="Upgrades a reader lock to the writer lock, using a &lt;see langword=&quot;TimeSpan&quot; /&gt; value for the time-out.">Actualiza un bloqueo de lector al bloqueo de escritor utilizando un valor <see langword="TimeSpan" /> para el tiempo de espera.</summary>
      <param name="timeout" vsli:raw="The &lt;see langword=&quot;TimeSpan&quot; /&gt; specifying the time-out period.">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.LockCookie&quot; /&gt; value.">Valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; expires before the lock request is granted.">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; specifies a negative value other than -1 milliseconds.">
        <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary vsli:raw="Gets the current sequence number.">Obtiene el número de secuencia actual.</summary>
      <returns vsli:raw="The current sequence number.">Número de secuencia actual.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary vsli:raw="Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.">Representa un bloqueo que se utiliza para administrar el acceso a un recurso y que permite varios subprocesos para la lectura o acceso exclusivo para la escritura.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class with default property values.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> con los valores de propiedad predeterminados.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class, specifying the lock recursion policy.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> especificando la directiva de recursividad de bloqueo.</summary>
      <param name="recursionPolicy" vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary vsli:raw="Gets the total number of unique threads that have entered the lock in read mode.">Obtiene el número total de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</summary>
      <returns vsli:raw="The number of unique threads that have entered the lock in read mode.">Número de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="&lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingReadCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount&quot; /&gt; is greater than zero.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount&quot; /&gt; is greater than zero.">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> es mayor que cero.
O bien
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> es mayor que cero.
O bien
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> es mayor que cero.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary vsli:raw="Tries to enter the lock in read mode.">Intenta entrar en el bloqueo en modo de lectura.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the read lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt;, and the current thread has attempted to acquire the read lock when it already holds the write lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ha intentado adquirir el bloqueo de lectura cuando ya lo tenía.
o bien
La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ha intentado adquirir el bloqueo de lectura cuando ya tenía el bloqueo de escritura.
O bien
El número de recursividad superaría la capacidad del contador. Este límite es tan grande que en las aplicaciones no debe aparecer nunca esta excepción.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode.">Intenta entrar en el bloqueo en modo de actualización.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo.
o bien
El subproceso actual ha entrado en modo de lectura, por lo que, al intentar entrar en modo de actualización, existiría la posibilidad de interbloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary vsli:raw="Tries to enter the lock in write mode.">Intenta entrar en el bloqueo en modo de escritura.</summary>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock in any mode.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo.
o bien
El subproceso actual ha entrado en modo de lectura y ya no posee un bloqueo de escritura, por lo que, si se intenta entrar en el bloqueo en modo de escritura, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary vsli:raw="Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).">Reduce el recuento de recursividad para el modo de lectura y sale del modo de lectura si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in read mode.">El subproceso actual no ha entrado en el bloqueo en modo de lectura.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary vsli:raw="Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).">Reduce el recuento de recursividad para el modo de actualización y sale del modo de actualización si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in upgradeable mode.">El subproceso actual no ha entrado en el bloqueo en modo de actualización.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary vsli:raw="Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).">Reduce el recuento de recursividad para el modo de escritura y sale del modo de escritura si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="The current thread has not entered the lock in write mode.">El subproceso actual no ha entrado en el bloqueo en modo de escritura.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in read mode.">Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de lectura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered read mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso actual ha entrado en modo de lectura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.">Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de actualización.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered upgradeable mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso actual ha entrado en modo de actualización; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary vsli:raw="Gets a value that indicates whether the current thread has entered the lock in write mode.">Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de escritura.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread has entered write mode; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso actual ha entrado en modo de escritura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary vsli:raw="Gets a value that indicates the recursion policy for the current &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object.">Obtiene un valor que indica la directiva de recursividad del objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> actual.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the lock recursion policy.">Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.">Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de lectura, como una indicación de recursividad.</summary>
      <returns vsli:raw="0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.">0 (cero) si el subproceso actual no entró en modo Lectura, 1 si el subproceso entró en modo Lectura pero no lo hizo de forma recursiva o n si el subproceso entró de forma recursiva en el bloqueo n - 1 veces.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.">Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de actualización, como una indicación de recursividad.</summary>
      <returns vsli:raw="0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.">0 (cero) si el subproceso actual no entró en modo de actualización, 1 si el subproceso entró en modo de actualización pero no lo hizo de forma recursiva o n si el subproceso entró de forma recursiva en el modo de actualización n - 1 veces.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary vsli:raw="Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.">Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de escritura, como una indicación de recursividad.</summary>
      <returns vsli:raw="0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.">0 (cero) si el subproceso actual no entró en modo de escritura, 1 si el subproceso entró en modo de escritura pero no lo hizo de forma recursiva o n si el subproceso entró de forma recursiva en el modo de escritura n - 1 veces.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional integer time-out.">Intenta entrar en el bloqueo en modo de lectura, con un tiempo de espera entero opcional.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de lectura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in read mode, with an optional time-out.">Intenta entrar en el bloqueo en modo de lectura, con tiempo de espera opcional.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered read mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de lectura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.
o bien
El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de actualización, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
O bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in upgradeable mode, with an optional time-out.">Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered upgradeable mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de actualización, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
o bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.
O bien
El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or -1 (&lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;) to wait indefinitely.">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
o bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is negative, but it is not equal to &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1), which is the only negative value allowed.">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary vsli:raw="Tries to enter the lock in write mode, with an optional time-out.">Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</summary>
      <param name="timeout" vsli:raw="The interval to wait, or -1 milliseconds to wait indefinitely.">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the calling thread entered write mode, otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ReaderWriterLockSlim.RecursionPolicy&quot; /&gt; property is &lt;see cref=&quot;F:System.Threading.LockRecursionPolicy.NoRecursion&quot; /&gt; and the current thread has already entered the lock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  &#xA;  &#xA; -or-  &#xA;  &#xA; The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
o bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The value of &lt;paramref name=&quot;timeout&quot; /&gt; is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  &#xA;  &#xA; -or-  &#xA;  &#xA; The value of &lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.
O bien
El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ReaderWriterLockSlim&quot; /&gt; object has been disposed.">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in read mode.">Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de lectura.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter read mode.">Número total de subprocesos que están a la espera de entrar en modo de lectura.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in upgradeable mode.">Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de actualización.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter upgradeable mode.">Número total de subprocesos que están a la espera de entrar en modo de actualización.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary vsli:raw="Gets the total number of threads that are waiting to enter the lock in write mode.">Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de escritura.</summary>
      <returns vsli:raw="The total number of threads that are waiting to enter write mode.">Número total de subprocesos que están a la espera de entrar en modo de escritura.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary vsli:raw="Limits the number of threads that can access a resource or pool of resources concurrently.">Limita el número de subprocesos que pueden tener acceso a un recurso o grupo de recursos simultáneamente.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.">
        <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> es menor que 1.
O bien
<paramref name="initialCount" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas y, de forma opcional, especifica el nombre de un objeto semáforo del sistema.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre de un objeto de semáforo del sistema con nombre.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> es menor que 1.
o bien
<paramref name="initialCount" /> es menor que 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.">Inicializa una instancia nueva de la clase <see cref="T:System.Threading.Semaphore" />, especificando el número inicial de entradas y el número máximo de entradas simultáneas, especificando de forma opcional el nombre de un objeto semáforo de sistema y especificando una variable que recibe un valor que indica si se creó un semáforo del sistema nuevo.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be satisfied concurrently.">Número inicial de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
      <param name="maximumCount" vsli:raw="The maximum number of requests for the semaphore that can be satisfied concurrently.">Número máximo de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
      <param name="name" vsli:raw="The name, if the synchronization object is to be shared with other processes; otherwise, &lt;see langword=&quot;null&quot; /&gt; or an empty string. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre de un objeto de semáforo del sistema con nombre.</param>
      <param name="createdNew" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if a local semaphore was created (that is, if &lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or an empty string) or if the specified named system semaphore was created; &lt;see langword=&quot;false&quot; /&gt; if the specified named system semaphore already existed. This parameter is passed uninitialized.">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un semáforo local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó el semáforo del sistema con nombre especificado; es <see langword="false" /> si el semáforo del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maximumCount&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.
O bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maximumCount&quot; /&gt; is less than 1.  &#xA;  &#xA; -or-  &#xA;  &#xA; &lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="maximumCount" /> es menor que 1.
o bien
<paramref name="initialCount" /> es menor que 0.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists and has access control security, and the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.FullControl&quot; /&gt;.">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name.">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists.">Abre el semáforo con nombre especificado, si ya existe.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre del semáforo del sistema que se va a abrir.</param>
      <returns vsli:raw="An object that represents the named system semaphore.">Objeto que representa el semáforo del sistema con nombre.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> es una cadena vacía.
O bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException" vsli:raw="A synchronization object with the provided &lt;paramref name=&quot;name&quot; /&gt; cannot be created. A synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names.">El semáforo con nombre no existe.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary vsli:raw="Exits the semaphore and returns the previous count.">Sale del semáforo y devuelve el recuento anterior.</summary>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">El recuento del semáforo ya está en el valor máximo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Error de Win32 con un semáforo con nombre.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt;.">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
O bien
El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary vsli:raw="Exits the semaphore a specified number of times and returns the previous count.">Sale del semáforo un número especificado de veces y devuelve el recuento anterior.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">Número de veces que se abandona el semáforo.</param>
      <returns vsli:raw="The count on the semaphore before the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method was called.">Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> es menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The semaphore count is already at the maximum value.">El recuento del semáforo ya está en el valor máximo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="A Win32 error occurred with a named semaphore.">Error de Win32 con un semáforo con nombre.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The current semaphore represents a named system semaphore, but the user does not have &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.  &#xA;  &#xA; -or-  &#xA;  &#xA; The current semaphore represents a named system semaphore, but it was not opened with &lt;see cref=&quot;F:System.Security.AccessControl.SemaphoreRights.Modify&quot; /&gt; rights.">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
O bien
El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary vsli:raw="Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.">Abre el semáforo con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="name" vsli:raw="The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character (\) is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name.">Nombre del semáforo del sistema que se va a abrir.</param>
      <param name="result" vsli:raw="When this method returns, contains a &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; object that represents the named semaphore if the call succeeded, or &lt;see langword=&quot;null&quot; /&gt; if the call failed. This parameter is treated as uninitialized.">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Semaphore" /> que representa el semáforo con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the named semaphore was opened successfully; otherwise, &lt;see langword=&quot;false&quot; /&gt;. In some cases, &lt;see langword=&quot;false&quot; /&gt; may be returned for invalid names.">
        <see langword="true" /> si el semáforo con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is an empty string.&#xA;&#xA;-or-&#xA;&#xA;.NET Framework only: &lt;paramref name=&quot;name&quot; /&gt; is longer than MAX_PATH (260 characters).">
        <paramref name="name" /> es una cadena vacía.
O bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="&lt;paramref name=&quot;name&quot; /&gt; is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes &quot;Global\&quot; and &quot;Local\&quot; are case-sensitive. For some invalid names, the method may return &lt;see langword=&quot;false&quot; /&gt; instead.&#xA;&#xA;-or-&#xA;&#xA;There was some other error. The HResult property may provide more information.">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException" vsli:raw="The named semaphore exists, but the user does not have the security access required to use it.">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary vsli:raw="The exception that is thrown when the &lt;see cref=&quot;Overload:System.Threading.Semaphore.Release&quot; /&gt; method is called on a semaphore whose count is already at the maximum.">Excepción que se produce cuando se llama al método <see cref="Overload:System.Threading.Semaphore.Release" /> en un semáforo cuyo recuento ya ha alcanzado el valor máximo.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with default values.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con valores predeterminados.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with serialized data.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con datos serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto sobre la excepción iniciada.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con el mensaje de error especificado.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Mensaje de error que explica el motivo de la excepción.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreFullException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Mensaje de error que explica el motivo de la excepción.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary vsli:raw="Represents a lightweight alternative to &lt;see cref=&quot;T:System.Threading.Semaphore&quot; /&gt; that limits the number of threads that can access a resource or pool of resources concurrently.">Representa una alternativa ligera a <see cref="T:System.Threading.Semaphore" /> que limita el número de subprocesos que pueden tener acceso a un recurso o grupo de recursos simultáneamente.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial number of requests that can be granted concurrently.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreSlim" />, especificando el número inicial de solicitudes que se pueden conceder simultáneamente.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0.">
        <paramref name="initialCount" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class, specifying the initial and maximum number of requests that can be granted concurrently.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreSlim" />, especificando el número inicial y máximo de solicitudes que se pueden conceder simultáneamente.</summary>
      <param name="initialCount" vsli:raw="The initial number of requests for the semaphore that can be granted concurrently.">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="maxCount" vsli:raw="The maximum number of requests for the semaphore that can be granted concurrently.">El número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;initialCount&quot; /&gt; is less than 0, or &lt;paramref name=&quot;initialCount&quot; /&gt; is greater than &lt;paramref name=&quot;maxCount&quot; /&gt;, or &lt;paramref name=&quot;maxCount&quot; /&gt; is equal to or less than 0.">
        <paramref name="initialCount" /> es menor que 0, <paramref name="initialCount" /> es mayor que <paramref name="maxCount" />, o <paramref name="maxCount" /> es igual o menor que 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">Devuelve un objeto <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar en el semáforo.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.WaitHandle&quot; /&gt; that can be used to wait on the semaphore.">
        <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar en el semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary vsli:raw="Gets the number of remaining threads that can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object.">Obtiene el número de subprocesos restantes que puede introducir el objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="The number of remaining threads that can enter the semaphore.">Obtiene el número de subprocesos restantes que pueden entrar en el semáforo.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the unmanaged resources used by the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, and optionally releases the managed resources.">Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.SemaphoreSlim" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object once.">Libera una vez el objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Recuento anterior de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">
        <see cref="T:System.Threading.SemaphoreSlim" /> ya ha alcanzado su tamaño máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary vsli:raw="Releases the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; object a specified number of times.">Libera el objeto <see cref="T:System.Threading.SemaphoreSlim" /> el número de veces especificado.</summary>
      <param name="releaseCount" vsli:raw="The number of times to exit the semaphore.">El número de veces que sale del semáforo.</param>
      <returns vsli:raw="The previous count of the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Recuento anterior de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;releaseCount&quot; /&gt; is less than 1.">
        <paramref name="releaseCount" /> es menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has already reached its maximum size.">
        <see cref="T:System.Threading.SemaphoreSlim" /> ya ha alcanzado su tamaño máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout.">Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits con signo que especifica el tiempo de espera.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" />(-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits con signo que especifica el tiempo de espera mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt;(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" />(-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="millisecondsTimeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; instance has been disposed, or the &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has been disposed.">Se ha eliminado la instancia <see cref="T:System.Threading.SemaphoreSlim" /> o se ha eliminado el <see cref="T:System.Threading.CancellationTokenSource" /> que ha creado <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />, mientras se observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.&#xA;&#xA; -or-&#xA;&#xA; The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">Ya se ha eliminado la instancia actual.
o bien
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to specify the timeout.">Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando <see cref="T:System.TimeSpan" /> para especificar el tiempo de espera.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.">La instancia de semaphoreSlim se ha eliminado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Blocks the current thread until it can enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that specifies the timeout, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando un <see cref="T:System.TimeSpan" /> que especifica el tiempo de espera mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-.&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
O bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The semaphoreSlim instance has been disposed.&#xA;&#xA;-or-&#xA;&#xA;The &lt;see cref=&quot;T:System.Threading.CancellationTokenSource&quot; /&gt; that created &lt;paramref name=&quot;cancellationToken&quot; /&gt; has already been disposed.">La instancia de semaphoreSlim se ha eliminado.
o bien
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;.">De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Tarea que se completará cuando se entre en el semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval.">De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, utilizando un entero de 32 bits para medir el intervalo de tiempo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="millisecondsTimeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a 32-bit signed integer to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, utilizando un entero de 32 bits para medir el intervalo de tiempo, mientras observa <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; to observe.">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="millisecondsTimeout" /> es un número distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="millisecondsTimeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, mientras observa <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="A task that will complete when the semaphore has been entered.">Una tarea que se completará cuando se especifica el semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval.">De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, mediante <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The current instance has already been disposed.">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary vsli:raw="Asynchronously waits to enter the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, using a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; to measure the time interval, while observing a &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt;.">De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, mediante <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo, mientras observa <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents 0 milliseconds to test the wait handle and return immediately.">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken" vsli:raw="The &lt;see cref=&quot;T:System.Threading.CancellationToken&quot; /&gt; token to observe.">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns vsli:raw="A task that will complete with a result of &lt;see langword=&quot;true&quot; /&gt; if the current thread successfully entered the &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt;, otherwise with a result of &lt;see langword=&quot;false&quot; /&gt;.">Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1, which represents an infinite timeout.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;timeout&quot; /&gt; is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException" vsli:raw="&lt;paramref name=&quot;cancellationToken&quot; /&gt; was canceled.">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SemaphoreSlim&quot; /&gt; has been disposed.">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary vsli:raw="Represents a method to be called when a message is to be dispatched to a synchronization context.">Representa el método al que hay que llamar cuando se va a enviar un mensaje a un contexto de sincronización.</summary>
      <param name="state" vsli:raw="The object passed to the delegate.">Objeto que se ha pasado al delegado.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary vsli:raw="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.">Proporciona una primitiva de bloqueo de exclusión mutua donde un subproceso que intenta adquirir el bloqueo espera en un bucle y realiza comprobaciones repetidamente hasta que haya un bloqueo disponible.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SpinLock&quot; /&gt; structure with the option to track thread IDs to improve debugging.">Inicializa una nueva instancia de la estructura <see cref="T:System.Threading.SpinLock" /> con la opción de realizar el seguimiento de los identificadores de subprocesos para mejorar la depuración.</summary>
      <param name="enableThreadOwnerTracking" vsli:raw="Whether to capture and use thread IDs for debugging purposes.">Indica si se han de capturar y utilizar identificadores de subprocesos con fines de depuración.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary vsli:raw="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Adquiere el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling Enter.">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary vsli:raw="Releases the lock.">Libera el bloqueo.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual no es el propietario de este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary vsli:raw="Releases the lock.">Libera el bloqueo.</summary>
      <param name="useMemoryBarrier" vsli:raw="A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.">Valor booleano que indica si una barrera de memoria debe emitirse para publicar inmediatamente la operación de salida a otros subprocesos.</param>
      <exception cref="T:System.Threading.SynchronizationLockException" vsli:raw="Thread ownership tracking is enabled, and the current thread is not the owner of this lock.">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual no es el propietario de este bloqueo.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary vsli:raw="Gets whether the lock is currently held by any thread.">Obtiene un valor que indica si un subproceso mantiene actualmente el bloqueo.</summary>
      <returns vsli:raw="true if the lock is currently held by any thread; otherwise false.">Es true si cualquier subproceso mantiene actualmente el bloqueo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary vsli:raw="Gets whether the lock is held by the current thread.">Obtiene un valor que indica si el subproceso actual mantiene actualmente el bloqueo.</summary>
      <returns vsli:raw="true if the lock is held by the current thread; otherwise false.">Es true si el subproceso actual mantiene el bloqueo; de lo contrario, es false.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Thread ownership tracking is disabled.">El seguimiento de propiedad de subprocesos está deshabilitado.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary vsli:raw="Gets whether thread ownership tracking is enabled for this instance.">Obtiene un valor que indica si el seguimiento de propiedad de subprocesos está habilitado para esta instancia.</summary>
      <returns vsli:raw="true if thread ownership tracking is enabled for this instance; otherwise false.">Es true si se ha habilitado el seguimiento de propiedad de subprocesos para esta instancia; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Intenta adquirir el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Intenta adquirir el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary vsli:raw="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, &lt;paramref name=&quot;lockTaken&quot; /&gt; can be examined reliably to determine whether the lock was acquired.">Intenta adquirir el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="lockTaken" vsli:raw="True if the lock is acquired; otherwise, false. &lt;paramref name=&quot;lockTaken&quot; /&gt; must be initialized to false prior to calling this method.">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt; milliseconds.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;lockTaken&quot; /&gt; argument must be initialized to false prior to calling TryEnter.">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException" vsli:raw="Thread ownership tracking is enabled, and the current thread has already acquired this lock.">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary vsli:raw="Provides support for spin-based waiting.">Proporciona compatibilidad para la espera basada en ciclos.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary vsli:raw="Gets the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Obtiene el número de veces que se ha llamado a <see cref="M:System.Threading.SpinWait.SpinOnce" /> en esta instancia.</summary>
      <returns vsli:raw="Returns an integer that represents the number of times &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; has been called on this instance.">Devuelve un entero que representa el número de veces que <see cref="M:System.Threading.SpinWait.SpinOnce" /> se ha llamado en esta instancia.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary vsli:raw="Gets whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Obtiene si la llamada siguiente a <see cref="M:System.Threading.SpinWait.SpinOnce" /> da paso al procesador, lo que activa un cambio de contexto forzado.</summary>
      <returns vsli:raw="Whether the next call to &lt;see cref=&quot;M:System.Threading.SpinWait.SpinOnce&quot; /&gt; will yield the processor, triggering a forced context switch.">Si la llamada siguiente a <see cref="M:System.Threading.SpinWait.SpinOnce" /> da paso al procesador, lo que activa un cambio de contexto forzado.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary vsli:raw="Resets the spin counter.">Restablece el contador de ciclos.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary vsli:raw="Performs a single spin.">Realiza un único ciclo.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary vsli:raw="Performs a single spin and calls &lt;see cref=&quot;M:System.Threading.Thread.Sleep(System.Int32)&quot; /&gt; after a minimum spin count.">Realiza una sola rotación y llama a <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> después de un recuento de rotación mínimo.</summary>
      <param name="sleep1Threshold" vsli:raw="A minimum spin count after which &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt; may be used. A value of -1 disables the use of &lt;see langword=&quot;Thread.Sleep(1)&quot; /&gt;.">Recuento de rotación mínima después del cual puede utilizarse <see langword="Thread.Sleep(1)" />. El valor -1 deshabilita el uso de <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sleep1Threshold&quot; /&gt; is less than -1.">
        <paramref name="sleep1Threshold" /> es menor que 1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary vsli:raw="Spins until the specified condition is satisfied.">Itera en ciclos hasta que se satisface la condición especificada.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Delegado que se va a ejecutar una y otra vez hasta que devuelva true.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">El argumento <paramref name="condition" /> es null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Itera en ciclos hasta que se satisface la condición especificada o se agota el tiempo de espera indicado.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Delegado que se va a ejecutar una y otra vez hasta que devuelva true.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> si la condición se satisface dentro del tiempo de espera; de lo contrario, es false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">El argumento <paramref name="condition" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;millisecondsTimeout&quot; /&gt; is a negative number other than -1, which represents an infinite time-out.">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary vsli:raw="Spins until the specified condition is satisfied or until the specified timeout is expired.">Itera en ciclos hasta que se satisface la condición especificada o se agota el tiempo de espera indicado.</summary>
      <param name="condition" vsli:raw="A delegate to be executed over and over until it returns true.">Delegado que se va a ejecutar una y otra vez hasta que devuelva true.</param>
      <param name="timeout" vsli:raw="A &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o TimeSpan que representa -1 milisegundo para esperar indefinidamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the condition is satisfied within the timeout; otherwise, false.">
        <see langword="true" /> si la condición se satisface dentro del tiempo de espera; de lo contrario, es false</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="The &lt;paramref name=&quot;condition&quot; /&gt; argument is null.">El argumento <paramref name="condition" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;timeout&quot; /&gt; is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;.">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary vsli:raw="Provides the basic functionality for propagating a synchronization context in various synchronization models.">Proporciona la funcionalidad básica para difundir un contexto de sincronización en varios modelos de sincronización.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; class.">Crea una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary vsli:raw="When overridden in a derived class, creates a copy of the synchronization context.">Cuando se invalida en una clase derivada, crea una copia del contexto de sincronización.</summary>
      <returns vsli:raw="A new &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object.">Un nuevo objeto <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary vsli:raw="Gets the synchronization context for the current thread.">Obtiene el contexto de sincronización del subproceso actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object representing the current synchronization context.">Objeto <see cref="T:System.Threading.SynchronizationContext" /> que representa el contexto de sincronización actual.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary vsli:raw="Determines if wait notification is required.">Determina si se requiere una notificación de espera.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if wait notification is required; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si se requiere la notificación; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has completed.">Cuando se invalida en una clase derivada, responde a la notificación de que se ha completado una operación.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary vsli:raw="When overridden in a derived class, responds to the notification that an operation has started.">Cuando se invalida en una clase derivada, responde a la notificación de que se ha iniciado una operación.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches an asynchronous message to a synchronization context.">Cuando se invalida en una clase derivada, envía un mensaje asincrónico a un contexto de sincronización.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Delegado de <see cref="T:System.Threading.SendOrPostCallback" /> al que se va a llamar.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Objeto que se ha pasado al delegado.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary vsli:raw="When overridden in a derived class, dispatches a synchronous message to a synchronization context.">Cuando se invalida en una clase derivada, envía un mensaje sincrónico a un contexto de sincronización.</summary>
      <param name="d" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SendOrPostCallback&quot; /&gt; delegate to call.">Delegado de <see cref="T:System.Threading.SendOrPostCallback" /> al que se va a llamar.</param>
      <param name="state" vsli:raw="The object passed to the delegate.">Objeto que se ha pasado al delegado.</param>
      <exception cref="T:System.NotSupportedException" vsli:raw="The method was called in a Windows Store app. The implementation of &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; for Windows Store apps does not support the &lt;see cref=&quot;M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)&quot; /&gt; method.">Se llamó al método en una aplicación de la Tienda Windows. La implementación de <see cref="T:System.Threading.SynchronizationContext" /> para las aplicaciones de la Tienda Windows no admite el método <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary vsli:raw="Sets the current synchronization context.">Establece el contexto de sincronización actual.</summary>
      <param name="syncContext" vsli:raw="The &lt;see cref=&quot;T:System.Threading.SynchronizationContext&quot; /&gt; object to be set.">Objeto <see cref="T:System.Threading.SynchronizationContext" /> que se va a establecer.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary vsli:raw="Sets notification that wait notification is required and prepares the callback method so it can be called more reliably when a wait occurs.">Establece que se requiere la notificación de espera y prepara el método de devolución de llamada para que la llamada pueda efectuarse de manera más confiable cuando se produzca una espera.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Waits for any or all the elements in the specified array to receive a signal.">Espera a que cualquiera o la totalidad de los elementos de la matriz especificada reciban una señal.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Matriz de tipo <see cref="T:System.IntPtr" /> que contiene los identificadores del sistema operativo nativo.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles; &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">Es <see langword="true" /> para que se espere a todos los identificadores; es <see langword="false" /> para que se espere a cualquiera de ellos.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Índice de la matriz del objeto que satisfizo la espera.</returns>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;waitHandles&quot; /&gt; is null.">
        <paramref name="waitHandles" /> es null.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary vsli:raw="Helper function that waits for any or all the elements in the specified array to receive a signal.">Función del asistente que espera a que cualquiera o la totalidad de los elementos de la matriz especificada reciban una señal.</summary>
      <param name="waitHandles" vsli:raw="An array of type &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; that contains the native operating system handles.">Matriz de tipo <see cref="T:System.IntPtr" /> que contiene los identificadores del sistema operativo nativo.</param>
      <param name="waitAll" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to wait for all handles;  &lt;see langword=&quot;false&quot; /&gt; to wait for any handle.">
        <see langword="true" /> para que se espere a todos los identificadores; <see langword="false" /> para que se espere a cualquiera de ellos.</param>
      <param name="millisecondsTimeout" vsli:raw="The number of milliseconds to wait, or &lt;see cref=&quot;F:System.Threading.Timeout.Infinite&quot; /&gt; (-1) to wait indefinitely.">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns vsli:raw="The array index of the object that satisfied the wait.">Índice de la matriz del objeto que satisfizo la espera.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary vsli:raw="The exception that is thrown when a method requires the caller to own the lock on a given Monitor, and the method is invoked by a caller that does not own that lock.">Excepción que se produce cuando un método requiere que el llamador sea propietario del bloqueo en un Monitor dado y un llamador al que no pertenece ese bloqueo llama al método.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with default properties.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con propiedades predeterminadas.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with serialized data.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con datos serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; that holds the serialized object data about the exception being thrown.">
        <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto que hacen referencia a la excepción que se va a producir.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; that contains contextual information about the source or destination.">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con el mensaje de error especificado.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Mensaje de error que explica el motivo de la excepción.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.SynchronizationLockException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Mensaje de error que explica el motivo de la excepción.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary vsli:raw="Provides thread-local storage of data.">Proporciona almacenamiento local de los datos de un subproceso.</summary>
      <typeparam name="T" vsli:raw="Specifies the type of data stored per-thread.">Especifica el tipo de datos almacenados por subproceso.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Inicializa la instancia <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance and specifies whether all values are accessible from any thread.">Inicializa la instancia <see cref="T:System.Threading.ThreadLocal`1" /> y especifica si todos los valores son accesibles desde cualquier subproceso.</summary>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> para hacer un seguimiento de todos los valores establecidos en la instancia y exponerlos a través de la propiedad <see cref="P:System.Threading.ThreadLocal`1.Values" />; en caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function.">Inicializa una instancia de <see cref="T:System.Threading.ThreadLocal`1" /> con la función especificada por el parámetro <paramref name="valueFactory" />.</summary>
      <param name="valueFactory" vsli:raw="The  &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">
        <see cref="T:System.Func`1" /> que se invoca para generar un valor de inicialización diferida cuando se intenta recuperar <see cref="P:System.Threading.ThreadLocal`1.Value" /> sin que se haya inicializado anteriormente.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a null reference (Nothing in Visual Basic).">
        <paramref name="valueFactory" /> es una referencia nula (nada en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary vsli:raw="Initializes the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance with the specified &lt;paramref name=&quot;valueFactory&quot; /&gt; function and a flag that indicates whether all values are accessible from any thread.">Inicializa la instancia <see cref="T:System.Threading.ThreadLocal`1" /> con la función <paramref name="valueFactory" /> especificada y una marca que indica si todos los valores son accesibles desde cualquier subproceso.</summary>
      <param name="valueFactory" vsli:raw="The &lt;see cref=&quot;T:System.Func`1&quot; /&gt; invoked to produce a lazily-initialized value when an attempt is made to retrieve &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; without it having been previously initialized.">
        <see cref="T:System.Func`1" /> que se invoca para generar un valor de inicialización diferida cuando se intenta recuperar <see cref="P:System.Threading.ThreadLocal`1.Value" /> sin que se haya inicializado anteriormente.</param>
      <param name="trackAllValues" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to track all values set on the instance and expose them through the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; property; &lt;see langword=&quot;false&quot; /&gt; otherwise. When set to &lt;see langword=&quot;true&quot; /&gt;, a value stored from a given thread will be available through &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Values&quot; /&gt; even after that thread has exited.">
        <see langword="true" /> para hacer un seguimiento de todos los valores establecidos en la instancia y exponerlos a través de la propiedad <see cref="P:System.Threading.ThreadLocal`1.Values" />; en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;valueFactory&quot; /&gt; is a &lt;see langword=&quot;null&quot; /&gt; reference (&lt;see langword=&quot;Nothing&quot; /&gt; in Visual Basic).">
        <paramref name="valueFactory" /> es una referencia <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary vsli:raw="Releases all resources used by the current instance of the &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; class.">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Libera los recursos que usa la instancia <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing" vsli:raw="A Boolean value that indicates whether this method is being called due to a call to &lt;see cref=&quot;M:System.Threading.ThreadLocal`1.Dispose&quot; /&gt;.">Valor booleano que indica si se llama a este método debido a una llamada a <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary vsli:raw="Releases the resources used by this &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance.">Libera los recursos que usa la instancia <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary vsli:raw="Gets whether &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread.">Obtiene un valor que indica si <see cref="P:System.Threading.ThreadLocal`1.Value" /> se inicializa en el subproceso actual.</summary>
      <returns vsli:raw="true if &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; is initialized on the current thread; otherwise false.">Es true si <see cref="P:System.Threading.ThreadLocal`1.Value" /> se inicializa en el subproceso actual; en caso contrario, es false.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary vsli:raw="Creates and returns a string representation of this instance for the current thread.">Crea y devuelve una representación de cadena de esta instancia del subproceso actual.</summary>
      <returns vsli:raw="The result of calling &lt;see cref=&quot;M:System.Object.ToString&quot; /&gt; on the &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt;.">Resultado de llamar al método <see cref="M:System.Object.ToString" /> en <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
      <exception cref="T:System.NullReferenceException" vsli:raw="The &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; for the current thread is a null reference (Nothing in Visual Basic).">La propiedad <see cref="P:System.Threading.ThreadLocal`1.Value" /> del subproceso actual es una referencia nula (Nothing en Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">La función de inicialización intentó hacer referencia de forma recursiva a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">No se proporciona ningún constructor sin parámetros y no se proporciona ningún generador de valor.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary vsli:raw="Gets or sets the value of this instance for the current thread.">Obtiene o establece el valor de esta instancia del subproceso actual.</summary>
      <returns vsli:raw="Returns an instance of the object that this ThreadLocal is responsible for initializing.">Devuelve una instancia del objeto que ThreadLocal es responsable de inicializar.</returns>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The initialization function attempted to reference &lt;see cref=&quot;P:System.Threading.ThreadLocal`1.Value&quot; /&gt; recursively.">La función de inicialización intentó hacer referencia de forma recursiva a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException" vsli:raw="No parameterless constructor is provided and no value factory is supplied.">No se proporciona ningún constructor sin parámetros y no se proporciona ningún generador de valor.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary vsli:raw="Gets a list containing the values stored by all threads that have accessed this instance.">Obtiene una lista de todos los valores almacenados actualmente por todos los subprocesos que han tenido acceso a esta instancia.</summary>
      <returns vsli:raw="A list for all of the values stored by all of the threads that have accessed this instance.">Lista de todos los valores almacenados actualmente por todos los subprocesos que han tenido acceso a esta instancia.</returns>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Values stored by all threads are not available because this instance was initialized with the &lt;paramref name=&quot;trackAllValues&quot; /&gt; argument set to &lt;see langword=&quot;false&quot; /&gt; in the call to a class constructor.">Los valores almacenados por todos los subprocesos no están disponibles porque esta instancia se inicializó con el argumento <paramref name="trackAllValues" /> establecido en <see langword="false" /> en la llamada a un constructor de clase.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="The &lt;see cref=&quot;T:System.Threading.ThreadLocal`1&quot; /&gt; instance has been disposed.">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary vsli:raw="Contains methods for performing volatile memory operations.">Contiene los métodos para realizar operaciones de memoria volátil.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary vsli:raw="Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <returns vsli:raw="The value that was read.">Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary vsli:raw="Reads the object reference from the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.">Lee la referencia al objeto desde el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location" vsli:raw="The field to read.">Campo que se va a leer.</param>
      <typeparam name="T" vsli:raw="The type of field to read. This must be a reference type, not a value type.">Tipo del campo que se va a leer. Debe ser un tipo de referencia, no un tipo de valor.</typeparam>
      <returns vsli:raw="The reference to &lt;paramref name=&quot;T&quot; /&gt; that was read. This reference is the latest written by any processor in the computer, regardless of the number of processors or the state of processor cache.">Referencia al <paramref name="T" /> que se ha leído. Esta referencia es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary vsli:raw="Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the value is written.">Campo donde se escribe el valor.</param>
      <param name="value" vsli:raw="The value to write.">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary vsli:raw="Writes the specified object reference to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.">Escribe la referencia de objeto especificada en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location" vsli:raw="The field where the object reference is written.">Campo donde se escribe la referencia de objeto.</param>
      <param name="value" vsli:raw="The object reference to write.">Referencia de objeto que se va a escribir. La referencia se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
      <typeparam name="T" vsli:raw="The type of field to write. This must be a reference type, not a value type.">Tipo del campo que se va a escribir. Debe ser un tipo de referencia, no un tipo de valor.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary vsli:raw="The exception that is thrown when an attempt is made to open a system mutex, semaphore, or event wait handle that does not exist.">La excepción que se produce cuando se intenta abrir una exclusión mutua del sistema, un semáforo o un identificador de espera de eventos que no existe.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with default values.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con valores predeterminados.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with serialized data.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con datos serializados.</summary>
      <param name="info" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.SerializationInfo&quot; /&gt; object that holds the serialized object data about the exception being thrown.">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto sobre la excepción iniciada.</param>
      <param name="context" vsli:raw="The &lt;see cref=&quot;T:System.Runtime.Serialization.StreamingContext&quot; /&gt; object that contains contextual information about the source or destination.">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con el mensaje de error especificado.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Mensaje de error que explica el motivo de la excepción.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Threading.WaitHandleCannotBeOpenedException&quot; /&gt; class with a specified error message and a reference to the inner exception that is the cause of this exception.">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for the exception.">Mensaje de error que explica el motivo de la excepción.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception. If the &lt;paramref name=&quot;innerException&quot; /&gt; parameter is not &lt;see langword=&quot;null&quot; /&gt;, the current exception is raised in a &lt;see langword=&quot;catch&quot; /&gt; block that handles the inner exception.">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
  </members>
</doc>