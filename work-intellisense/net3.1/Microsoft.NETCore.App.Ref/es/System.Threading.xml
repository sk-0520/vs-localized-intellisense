<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>Excepción que se produce cuando un subproceso adquiere un objeto <see cref="T:System.Threading.Mutex" /> que otro subproceso ha abandonado al salir sin liberarlo.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con valores predeterminados.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un índice especificado para la exclusión mutua abandonada, si es aplicable, y un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua.</summary>
      <param name="location">Índice de la exclusión mutua abandonada en la matriz de identificadores de espera si la excepción se produce para el método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, o -1 si la excepción se produce para los métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> o <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con datos serializados.</summary>
      <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto sobre la excepción iniciada.</param>
      <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con el mensaje de error especificado.</summary>
      <param name="message">Mensaje de error que explica la razón de la excepción.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un mensaje de error y una excepción interna especificados.</summary>
      <param name="message">Mensaje de error que explica la razón de la excepción.</param>
      <param name="inner">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="inner" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un mensaje de error especificado, la excepción interna, el índice para la exclusión mutua abandonada, si es aplicable, y un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua.</summary>
      <param name="message">Mensaje de error que explica la razón de la excepción.</param>
      <param name="inner">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="inner" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
      <param name="location">Índice de la exclusión mutua abandonada en la matriz de identificadores de espera si la excepción se produce para el método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, o -1 si la excepción se produce para los métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> o <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AbandonedMutexException" /> con un mensaje de error especificado, el índice de la exclusión mutua abandonada, si es aplicable, y la exclusión mutua abandonada.</summary>
      <param name="message">Mensaje de error que explica la razón de la excepción.</param>
      <param name="location">Índice de la exclusión mutua abandonada en la matriz de identificadores de espera si la excepción se produce para el método <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, o -1 si la excepción se produce para los métodos <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> o <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>Obtiene la exclusión mutua abandonada que produjo la excepción, si se conoce.</summary>
      <returns>Objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua abandonada o <see langword="null" /> si no se han podido identificar las exclusiones mutuas abandonadas.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>Obtiene el índice de la exclusión mutua abandonada que produjo la excepción, si se conoce.</summary>
      <returns>Índice de la matriz de identificadores de espera pasados al <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> método <see cref="T:System.Threading.Mutex" /> del objeto que representa la exclusión mutua abandonada, o-1 si no se pudo determinar el índice de la exclusión mutua abandonada.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary>Proporciona la funcionalidad para restaurar la migración, o el flujo, del contexto de ejecución entre los subprocesos.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException">La estructura <see cref="T:System.Threading.AsyncFlowControl" /> no se utiliza en el subproceso donde fue creado.
O bien
La estructura <see cref="T:System.Threading.AsyncFlowControl" /> ya se ha utilizado para llamar a <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary>Determina si el objeto especificado es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</summary>
      <param name="obj">Objeto que se va a comparar con la estructura actual.</param>
      <returns>Es <see langword="true" /> si <paramref name="obj" /> es una estructura <see cref="T:System.Threading.AsyncFlowControl" /> y es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary>Determina si la estructura <see cref="T:System.Threading.AsyncFlowControl" /> especificada es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</summary>
      <param name="obj">Estructura <see cref="T:System.Threading.AsyncFlowControl" /> para comparar con la estructura actual.</param>
      <returns>Es <see langword="true" /> si <paramref name="obj" /> es igual a la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary>Obtiene código hash para la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</summary>
      <returns>Código hash para la estructura <see cref="T:System.Threading.AsyncFlowControl" /> actual.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Compara dos estructuras <see cref="T:System.Threading.AsyncFlowControl" /> para determinar si son iguales.</summary>
      <param name="a">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>Es <see langword="true" /> si las dos estructuras son iguales; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Compara dos estructuras <see cref="T:System.Threading.AsyncFlowControl" /> para determinar si no son iguales.</summary>
      <param name="a">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Estructura <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>Es <see langword="true" /> si las estructuras no son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary>Restaura el flujo del contexto de ejecución entre los subprocesos.</summary>
      <exception cref="T:System.InvalidOperationException">La estructura <see cref="T:System.Threading.AsyncFlowControl" /> no se utiliza en el subproceso donde fue creado.
o bien
La estructura <see cref="T:System.Threading.AsyncFlowControl" /> ya se ha utilizado para llamar a <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> o <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary>Representa datos ambiente locales de un flujo de control asincrónico determinado, por ejemplo, un método asincrónico.</summary>
      <typeparam name="T">Tipo de los datos ambiente.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary>Crea una instancia <see cref="T:System.Threading.AsyncLocal`1" /> que no recibe las notificaciones de cambio.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary>Crea una instancia <see cref="T:System.Threading.AsyncLocal`1" /> local que recibe notificaciones de cambio.</summary>
      <param name="valueChangedHandler">Delegado al que se llama cuando cambia el valor actual en cualquier subproceso.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary>Obtiene o establece el valor de los datos ambiente.</summary>
      <returns>Valor de los datos ambiente. Si no se ha establecido ningún valor, el valor devuelto es <c>default (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary>Clase que proporciona información de cambio de datos a las instancias <see cref="T:System.Threading.AsyncLocal`1" /> que se registran para las notificaciones de cambios.</summary>
      <typeparam name="T">Tipo de los datos.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary>Obtiene el valor actual de los datos.</summary>
      <returns>Valor actual de los datos.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary>Obtiene el valor anterior de los datos.</summary>
      <returns>Valor anterior de los datos.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary>Devuelve un valor que indica si el valor cambia debido a un cambio de contexto de ejecución.</summary>
      <returns>
        <see langword="true" />Si el valor cambió debido a un cambio de contexto de ejecución; en caso <see langword="false" />contrario,.</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>Representa un evento de sincronización de subprocesos que cuando se señala, se restablece automáticamente después de liberar un único subproceso en espera. Esta clase no puede heredarse.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.AutoResetEvent" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado.</summary>
      <param name="initialState">
        <see langword="true" /> para establecer el estado inicial en señalado; <see langword="false" /> para establecer el estado inicial en no señalado.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>Habilita varias tareas para que colaboren en un algoritmo en paralelo en varias fases.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Número de subprocesos que participan.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> es menor que 0 o mayor que 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Número de subprocesos que participan.</param>
      <param name="postPhaseAction">Objeto <see cref="T:System.Action`1" /> que se va a ejecutar después de cada fase. Se puede pasar null (Nothing en Visual Basic) para indicar que no se realiza ninguna acción.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> es menor que 0 o mayor que 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber un participante adicional.</summary>
      <returns>Número de fase de la barrera en la que primero participarán los nuevos participantes.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException">Agregar un participante haría que el recuento de participantes de la barrera superase los 32.767.
o bien
El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber participantes adicionales.</summary>
      <param name="participantCount">Número de participantes adicionales que se van a agregar a la barrera.</param>
      <returns>Número de fase de la barrera en la que primero participarán los nuevos participantes.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> es menor que 0.
o bien
Agregar <paramref name="participantCount" /> haría que el recuento de participantes de la barrera superase los 32.767.</exception>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>Obtiene el número de la fase actual de la barrera.</summary>
      <returns>Devuelve el número de la fase actual de la barrera.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.Barrier" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">true para liberar tanto los recursos administrados como los no administrados; false para liberar únicamente los recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>Obtiene el número total de participantes de la barrera.</summary>
      <returns>Devuelve el número total de participantes de la barrera.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>Obtiene el número de participantes en la barrera que aún no se han señalado en la fase actual.</summary>
      <returns>Devuelve el número de participantes en la barrera que todavía no se han señalado en la fase actual.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber un participante menos.</summary>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException">La barrera ya tiene 0 participantes.
o bien
El método se invocó desde dentro de una acción posterior a la fase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>Notifica a <see cref="T:System.Threading.Barrier" /> que va a haber menos participantes.</summary>
      <param name="participantCount">Número de participantes adicionales que se van a quitar de la barrera.</param>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El total de participantes es menor que el <paramref name="participantCount" /> especificado.</exception>
      <exception cref="T:System.InvalidOperationException">La barrera ya tiene 0 participantes.
O bien
El método se invocó desde dentro de una acción posterior a la fase.
o bien
el recuento del participante actual es menor que el participantCount especificado</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen también la barrera.</summary>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Si una excepción se produce de la acción de fase de envío de una barrera después de todos los subprocesos hayan llamado a SignalAndWait, la excepción se ajustará en una BarrierPostPhaseException y se producirá en todos los subprocesos que participan.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen también la barrera usando un entero de 32 bits con signo para medir el tiempo de espera.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si todos los participantes han alcanzado la barrera dentro del tiempo especificado; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Si una excepción se produce de la acción de fase de envío de una barrera después de todos los subprocesos hayan llamado a SignalAndWait, la excepción se ajustará en una BarrierPostPhaseException y se producirá en todos los subprocesos que participan.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes la alcancen también usando un entero de 32 bits con signo para medir el tiempo de espera mientras se observa un token de cancelación.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>si todos los participantes alcanzaron la barrera dentro del tiempo especificado; de lo contrario, es false.</returns>
      <exception cref="T:System.OperationCanceledException">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen la barrera mientras se observa un token de cancelación.</summary>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes alcancen también la barrera usando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo.</summary>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si todos los demás participantes han alcanzado la barrera; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o es mayor de 32 767.</exception>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Señala que un participante ha alcanzado la barrera y espera a que todos los demás participantes la alcancen también usando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo, mientras se observa un token de cancelación.</summary>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>
        <see langword="true" /> si todos los demás participantes han alcanzado la barrera; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException">El método se invocó desde dentro de una acción posterior a la fase, la barrera tiene actualmente 0 participantes, o la barrera la señalan más subprocesos de los que están registrados como participantes.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>La excepción que se inicia cuando se produce un error en la acción posterior a la fase de <see cref="T:System.Threading.Barrier" />.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con un mensaje proporcionado por el sistema que describe el error.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con la excepción interna especificada.</summary>
      <param name="innerException">Excepción que es la causa de la excepción actual.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con datos serializados.</summary>
      <param name="info">Objeto que contiene los datos del objeto serializados.</param>
      <param name="context">Información contextual acerca del origen o del destino.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con un mensaje especificado que describe el error.</summary>
      <param name="message">Mensaje que describe la excepción. El autor de llamada de este constructor debe asegurarse de que la cadena se haya adaptado para la referencia cultural actual del sistema.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.BarrierPostPhaseException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message">Mensaje que describe la excepción. El autor de llamada de este constructor debe asegurarse de que la cadena se haya adaptado para la referencia cultural actual del sistema.</param>
      <param name="innerException">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary>Representa un método al que se va a llamar dentro de un nuevo contexto.</summary>
      <param name="state">Objeto que contiene la información que va a utilizar el método de devolución de llamadas cada vez que se ejecute.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>Representa una primitiva de sincronización que está señalada cuando su recuento alcanza el valor cero.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.CountdownEvent" /> con el recuento especificado.</summary>
      <param name="initialCount">Número de señales necesarias inicialmente para establecer <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>Incrementa en uno el recuento actual de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException">La instancia actual ya está establecida.
O bien
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> es igual o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>Incrementa en un valor especificado el recuento actual de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <param name="signalCount">Valor en que se va a aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> es menor o igual que 0.</exception>
      <exception cref="T:System.InvalidOperationException">La instancia actual ya está establecida.
O bien
<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> es igual o mayor que <see cref="F:System.Int32.MaxValue" /> después de incrementar la cuenta en <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>Obtiene el número de señales restantes necesario para establecer el evento.</summary>
      <returns>El número de señales restantes necesario para establecer el evento.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.CountdownEvent" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">true para liberar tanto los recursos administrados como los no administrados; false para liberar únicamente los recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>Obtiene los números de señales que se necesitan inicialmente para establecer el evento.</summary>
      <returns>El número de señales que se necesitan inicialmente para establecer el evento.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>Indica si el recuento actual del objeto <see cref="T:System.Threading.CountdownEvent" /> ha llegado a cero.</summary>
      <returns>
        <see langword="true" /> si el recuento actual es cero; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>Restablece <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> en el valor de <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>Restablece la propiedad <see cref="P:System.Threading.CountdownEvent.InitialCount" /> según un valor especificado.</summary>
      <param name="count">Número de señales necesario para establecer <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>Registra una señal con <see cref="T:System.Threading.CountdownEvent" /> y disminuye el valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns>
        <see langword="true" /> si la señal ha provocado que el recuento alcanzara el valor cero y se estableciera el evento; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException">La instancia actual ya está establecida.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>Registra varias señales con <see cref="T:System.Threading.CountdownEvent" /> reduciendo el valor de <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> según la cantidad especificada.</summary>
      <param name="signalCount">Número de señales que se va a registrar.</param>
      <returns>
        <see langword="true" /> si las señales han provocado que el recuento alcanzara el valor cero y se estableciera el evento; de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> es menor que 1.</exception>
      <exception cref="T:System.InvalidOperationException">La instancia actual ya está establecida. -o bien- <paramref name="signalCount" /> es mayor que <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>Intenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> en uno.</summary>
      <returns>
        <see langword="true" /> si el incremento se ha realizado correctamente; en caso contrario, es false. Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> ya está en el valor cero, este método devolverá <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> es igual a <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>Intenta incrementar <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> en un valor especificado.</summary>
      <param name="signalCount">Valor en que se va a aumentar <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns>
        <see langword="true" /> si el incremento se ha realizado correctamente; en caso contrario, es false. Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> ya está en el valor cero, se devolverá <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> es menor o igual que 0.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> es igual o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un entero de 32 bits con signo para medir el tiempo de espera.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un entero de 32 bits con signo para medir el tiempo de espera, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual. o bien, <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> sido eliminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual. o bien, <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> sido eliminado.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un objeto <see cref="T:System.TimeSpan" /> para medir el tiempo de espera.</summary>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.CountdownEvent" />, usando un objeto <see cref="T:System.TimeSpan" /> para medir el tiempo de espera, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.CountdownEvent" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">Se ha cancelado <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual. o bien, <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> sido eliminado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>Obtiene un objeto <see cref="T:System.Threading.WaitHandle" /> que se usa para esperar a que se establezca el evento.</summary>
      <returns>Objeto <see cref="T:System.Threading.WaitHandle" /> que se usa para esperar a que se establezca el evento.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>Indica si un objeto <see cref="T:System.Threading.EventWaitHandle" /> se restablece automática o manualmente después de recibir una señal.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>El objeto <see cref="T:System.Threading.EventWaitHandle" />, cuando está señalado, se restablece automáticamente después de haber liberado un único subproceso. Si hay ningún subproceso en espera, el objeto <see cref="T:System.Threading.EventWaitHandle" /> permanece señalado hasta que un subproceso se bloquea y se restablece después de haber liberado el subproceso.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>El objeto <see cref="T:System.Threading.EventWaitHandle" />, cuando está señalado, libera todos los subprocesos en espera y permanece señalado hasta que se restablece manualmente.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>Representa un evento de sincronización de subprocesos.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente y si se restablece automática o manualmente.</summary>
      <param name="initialState">Es <see langword="true" /> para establecer el estado inicial en señalado; es <see langword="false" /> para establecerlo en no señalado.</param>
      <param name="mode">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente cuando se crea como resultado de esta llamada, si se restablece automática o manualmente y el nombre de un evento de sincronización del sistema.</summary>
      <param name="initialState">
        <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</param>
      <param name="mode">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
      <param name="name">Nombre de un evento de sincronización de todo el sistema.</param>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente si se crea como resultado de esta llamada, si se restablece automática o manualmente, el nombre de un evento de sincronización del sistema y una variable booleana cuyo valor después de la llamada indica si se creó el evento del sistema con nombre.</summary>
      <param name="initialState">
        <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</param>
      <param name="mode">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
      <param name="name">Nombre de un evento de sincronización de todo el sistema.</param>
      <param name="createdNew">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se ha creado un evento local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se ha creado el evento del sistema con nombre especificado; es <see langword="false" /> si el evento del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>Abre el evento de sincronización con nombre especificado, si ya existe.</summary>
      <param name="name">Nombre del evento de sincronización del sistema que se va a abrir.</param>
      <returns>Objeto que representa el evento del sistema con nombre.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">El evento del sistema con nombre no existe.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad exigido para utilizarlo.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>Establece el estado del evento en no señalado, haciendo que los subprocesos se bloqueen.</summary>
      <returns>
        <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">El método <see cref="M:System.Threading.WaitHandle.Close" /> se llamó previamente en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>Establece el estado del evento en señalado, permitiendo que uno o varios subprocesos en espera continúen.</summary>
      <returns>
        <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">El método <see cref="M:System.Threading.WaitHandle.Close" /> se llamó previamente en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>Abre el evento de sincronización con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="name">Nombre del evento de sincronización del sistema que se va a abrir.</param>
      <param name="result">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa el evento de sincronización con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
      <returns>Es <see langword="true" /> si el evento de sincronización con nombre se abrió correctamente; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary>Administra el contexto de ejecución del subproceso actual. Esta clase no puede heredarse.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary>Captura el contexto de ejecución del subproceso actual.</summary>
      <returns>Objeto <see cref="T:System.Threading.ExecutionContext" /> que representa el contexto de ejecución del subproceso actual.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary>Crea una copia del contexto de ejecución actual.</summary>
      <returns>Objeto <see cref="T:System.Threading.ExecutionContext" /> que representa el contexto de ejecución actual.</returns>
      <exception cref="T:System.InvalidOperationException">Este contexto no se puede copiar porque se utiliza. Sólo se pueden copiar contextos recién capturados.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Establece el objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> especificado con la información de contexto lógica necesaria para volver a crear una instancia del contexto de ejecución actual.</summary>
      <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que se debe llenar con información de serialización.</param>
      <param name="context">Estructura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que representa el contexto de destino de la serialización.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="info" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary>Indica si el flujo del contexto de ejecución está suprimido en este momento.</summary>
      <returns>Es <see langword="true" /> si el flujo está suprimido; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary>Restaura el flujo del contexto de ejecución entre subprocesos asincrónicos.</summary>
      <exception cref="T:System.InvalidOperationException">El flujo del contexto no se puede restaurar porque no se está suprimiendo.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary>Ejecuta un método en un contexto de ejecución especificado en el subproceso actual.</summary>
      <param name="executionContext">Objeto <see cref="T:System.Threading.ExecutionContext" /> que se va a establecer.</param>
      <param name="callback">Delegado <see cref="T:System.Threading.ContextCallback" /> que representa el método que se va a ejecutar en el contexto de ejecución proporcionado.</param>
      <param name="state">Objeto que se pasa al método de devolución de llamada.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="executionContext" /> es <see langword="null" />.
O bien
<paramref name="executionContext" /> no se adquirió a través de una operación de captura.
o bien
<paramref name="executionContext" /> ya se ha utilizado como argumento de una llamada a <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary>Suprime el flujo del contexto de ejecución entre subprocesos asincrónicos.</summary>
      <returns>Estructura <see cref="T:System.Threading.AsyncFlowControl" /> para restaurar el flujo.</returns>
      <exception cref="T:System.InvalidOperationException">El flujo del contexto ya se ha suprimido.</exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary>Encapsula y difunde el contexto de ejecución del host en todos los subprocesos.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.HostExecutionContext" /> utilizando el estado especificado.</summary>
      <param name="state">Objeto que representa el estado del contexto de ejecución del host.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary>Crea una copia del contexto de ejecución del host actual.</summary>
      <returns>Objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa el contexto del host del subproceso actual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary>Cuando se reemplaza en una clase derivada, libera los recursos no administrados que usa <see cref="T:System.Threading.WaitHandle" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary>Obtiene o establece el estado del contexto de ejecución del host.</summary>
      <returns>Objeto que representa el estado del contexto de ejecución del host.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary>Proporciona la funcionalidad que permite que un host de Common Language Runtime participe en el flujo, o migración, del contexto de ejecución.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary>Captura el contexto de ejecución del host en el subproceso actual.</summary>
      <returns>Objeto <see cref="T:System.Threading.HostExecutionContext" /> que representa el contexto de ejecución del host del subproceso actual.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary>Restaura el contexto de ejecución del host a su estado anterior.</summary>
      <param name="previousState">Estado del contexto anterior que se va a recuperar.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="previousState" /> es <see langword="null" />.
o bien
<paramref name="previousState" /> no se ha creado en el subproceso actual.
o bien
<paramref name="previousState" /> no es el último estado del <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary>Establece el contexto de ejecución del host actual en el contexto de ejecución del host especificado.</summary>
      <param name="hostExecutionContext">
        <see cref="T:System.Threading.HostExecutionContext" /> que hay que establecer.</param>
      <returns>Objeto para restaurar el <see cref="T:System.Threading.HostExecutionContext" /> a su estado anterior.</returns>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="hostExecutionContext" /> no se adquirió a través de una operación de captura.
O bien
<paramref name="hostExecutionContext" /> ha sido el argumento de una llamada anterior al método <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" />.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>Proporciona operaciones atómicas para las variables compartidas por varios subprocesos.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>Agrega dos enteros de 32 bits y reemplaza el primer entero por la suma, como una operación atómica.</summary>
      <param name="location1">Variable que contiene el primer valor que se va a agregar. La suma de los dos valores se almacena en <paramref name="location1" />.</param>
      <param name="value">Valor que se va a agregar al entero en <paramref name="location1" />.</param>
      <returns>Nuevo valor almacenado en <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>Agrega dos enteros de 64 bits y reemplaza el primer entero por la suma, como operación atómica.</summary>
      <param name="location1">Variable que contiene el primer valor que se va a agregar. La suma de los dos valores se almacena en <paramref name="location1" />.</param>
      <param name="value">Valor que se va a agregar al entero en <paramref name="location1" />.</param>
      <returns>Nuevo valor almacenado en <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>Compara dos números de punto flotante de precisión doble para comprobar si son iguales y, si lo son, reemplaza el primero de los valores.</summary>
      <param name="location1">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>Compara dos enteros de 32 bits con signo para comprobar si son iguales y, si lo son, reemplaza el primer valor.</summary>
      <param name="location1">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>Compara dos enteros de 64 bits con signo para comprobar si son iguales y, si lo son, reemplaza el primer valor.</summary>
      <param name="location1">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>Compara dos identificadores o punteros específicos de la plataforma en términos de igualdad y, si son iguales, reemplaza el primero.</summary>
      <param name="location1">Estructura <see cref="T:System.IntPtr" /> de destino, cuyo valor se compara con el valor de <paramref name="comparand" /> y que posiblemente se reemplace por <paramref name="value" />.</param>
      <param name="value">Estructura <see cref="T:System.IntPtr" /> que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand">Estructura <see cref="T:System.IntPtr" /> que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>Compara dos objetos en términos de igualdad de referencia y, si son iguales, reemplaza el primero.</summary>
      <param name="location1">Objeto de destino que se compara por referencia con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value">Objeto que reemplaza el objeto de destino si la comparación de referencia da como resultado la igualdad de ambos parámetros.</param>
      <param name="comparand">Objeto que se compara por referencia con el objeto que hay en <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>Compara dos números de punto flotante de precisión sencilla para comprobar si son iguales y, si lo son, reemplaza el primero de los valores.</summary>
      <param name="location1">Destino, cuyo valor se compara con <paramref name="comparand" /> y que posiblemente se reemplace.</param>
      <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
      <param name="comparand">Valor que se compara con el valor que hay en <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>Compara dos instancias del tipo de referencia especificado <paramref name="T" /> para comprobar si las referencias son iguales y, si lo son, reemplaza la primera.</summary>
      <param name="location1">Destino cuyo valor se compara por referencia con <paramref name="comparand" /> y que posiblemente se reemplace. Este es un parámetro de referencia (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
      <param name="value">Valor que reemplaza el valor de destino si la comparación por referencia da como resultado una igualdad.</param>
      <param name="comparand">Valor que se compara por referencia con el que hay en <paramref name="location1" />.</param>
      <typeparam name="T">Tipo que se va a utilizar para <paramref name="location1" />, <paramref name="value" /> y <paramref name="comparand" />. Este tipo debe ser un tipo de referencia.</typeparam>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>Disminuye el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location">Variable cuyo valor se va a reducir.</param>
      <returns>Valor reducido.</returns>
      <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>Disminuye el valor de la variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location">Variable cuyo valor se va a reducir.</param>
      <returns>Valor reducido.</returns>
      <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>Establece un número de punto flotante de precisión doble en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1">Variable que se va a establecer en el valor especificado.</param>
      <param name="value">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>Establece un entero de 32 bits con signo en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1">Variable que se va a establecer en el valor especificado.</param>
      <param name="value">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>Establece un entero de 64 bits con signo en un valor especificado y devuelve el valor original, como operación atómica.</summary>
      <param name="location1">Variable que se va a establecer en el valor especificado.</param>
      <param name="value">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>Establece un puntero o identificador específico de plataforma en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1">Variable que se va a establecer en el valor especificado.</param>
      <param name="value">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>Establece un objeto en un valor especificado y devuelve una referencia al objeto original, como una operación atómica.</summary>
      <param name="location1">Variable que se va a establecer en el valor especificado.</param>
      <param name="value">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>Establece un número de punto flotante de precisión sencilla en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1">Variable que se va a establecer en el valor especificado.</param>
      <param name="value">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary>Establece una variable del tipo <paramref name="T" /> especificado en un valor determinado y devuelve el valor original, como una operación atómica.</summary>
      <param name="location1">Variable que se va a establecer en el valor especificado. Este es un parámetro de referencia (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
      <param name="value">Valor en el que está establecido el parámetro <paramref name="location1" />.</param>
      <typeparam name="T">Tipo que se va a usar para <paramref name="location1" /> y <paramref name="value" />. Este tipo debe ser un tipo de referencia.</typeparam>
      <returns>Valor original de <paramref name="location1" />.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary>Aumenta el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location">Variable cuyo valor se va a incrementar.</param>
      <returns>Valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary>Aumenta el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      <param name="location">Variable cuyo valor se va a incrementar.</param>
      <returns>Valor incrementado.</returns>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary>Sincroniza el acceso a la memoria de la siguiente forma: El procesador que ejecuta el subproceso actual no puede reordenar las instrucciones de forma que los accesos a la memoria anteriores a la llamada a <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> se ejecuten después de los accesos a memoria posteriores a la llamada a <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary>Proporciona una barrera de memoria para todo el proceso con el fin de asegurar que las operaciones de lectura y escritura desde cualquier CPU no puedan superar la barrera.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary>Devuelve un valor de 64 bits, cargado como una operación atómica.</summary>
      <param name="location">Valor de 64 bits que se va a cargar.</param>
      <returns>Valor cargado.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>Proporciona rutinas de inicialización diferida.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>Inicializa un tipo de referencia de destino con su constructor sin parámetros si aún no se ha inicializado el destino.</summary>
      <param name="target">Referencia que se va a inicializar si aún no se ha inicializado.</param>
      <typeparam name="T">Tipo de referencia que se va a inicializar.</typeparam>
      <returns>Objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</exception>
      <exception cref="T:System.MissingMemberException">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>Inicializa un tipo de valor o referencia de destino con su constructor sin parámetros si aún no se ha inicializado.</summary>
      <param name="target">Referencia o valor de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</param>
      <param name="initialized">Referencia a un valor booleano que determina si ya se ha inicializado el destino.</param>
      <param name="syncLock">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />. Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</param>
      <typeparam name="T">Tipo de referencia que se va a inicializar.</typeparam>
      <returns>Objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</exception>
      <exception cref="T:System.MissingMemberException">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>Inicializa un tipo de referencia de destino o tipo de valor utilizando la función especificada si aún no se ha inicializado.</summary>
      <param name="target">Referencia o valor de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</param>
      <param name="initialized">Referencia a un valor booleano que determina si ya se ha inicializado el destino.</param>
      <param name="syncLock">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />. Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</param>
      <param name="valueFactory">Función que se llama para inicializar la referencia o el valor.</param>
      <typeparam name="T">Tipo de referencia que se va a inicializar.</typeparam>
      <returns>Objeto inicializado.</returns>
      <exception cref="T:System.MemberAccessException">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</exception>
      <exception cref="T:System.MissingMemberException">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>Inicializa un tipo de referencia de destino utilizando la función especificada si aún no se ha inicializado.</summary>
      <param name="target">Referencia que se va a inicializar si aún no se ha inicializado.</param>
      <param name="valueFactory">Función que se llama para inicializar la referencia.</param>
      <typeparam name="T">Tipo de referencia que se va a inicializar.</typeparam>
      <returns>Objeto inicializado.</returns>
      <exception cref="T:System.MissingMemberException">El tipo <paramref name="T" /> no tiene ningún constructor sin parámetros.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> devuelve un valor NULL (Nothing en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary>Inicializa un tipo de referencia de destino con una función especificada si aún no se ha inicializado.</summary>
      <param name="target">Referencia que se va a inicializar si aún no se ha inicializado.</param>
      <param name="syncLock">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />. Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</param>
      <param name="valueFactory">Método que se va a invocar para inicializar <paramref name="target" />.</param>
      <typeparam name="T">Tipo de referencia que se va a inicializar.</typeparam>
      <returns>Objeto inicializado.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary>Define el bloqueo que implementa la semántica de un sistema de escritura y varios sistemas de lectura. Se trata de un tipo de valor.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary>Indica si un objeto especificado es un <see cref="T:System.Threading.LockCookie" /> y es igual a la instancia actual.</summary>
      <param name="obj">Objeto que se va a comparar con la actual instancia.</param>
      <returns>Es <see langword="true" /> si el valor de <paramref name="obj" /> es igual al de la instancia actual; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary>Indica si la instancia actual es igual al objeto <see cref="T:System.Threading.LockCookie" /> especificado.</summary>
      <param name="obj">
        <see cref="T:System.Threading.LockCookie" /> que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> es igual al valor de la instancia actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary>Devuelve el código hash de esta instancia.</summary>
      <returns>Código hash de un entero de 32 bits con signo.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Indica si dos estructuras de <see cref="T:System.Threading.LockCookie" /> son iguales.</summary>
      <param name="a">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="b" />.</param>
      <param name="b">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="a" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="a" /> es igual a <paramref name="b" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Indica si dos estructuras de <see cref="T:System.Threading.LockCookie" /> no son iguales.</summary>
      <param name="a">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="b" />.</param>
      <param name="b">
        <see cref="T:System.Threading.LockCookie" /> que se compara con <paramref name="a" />.</param>
      <returns>Es <see langword="true" /> si <paramref name="a" /> no es igual a <paramref name="b" />; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary>Excepción que se inicia cuando la entrada recursiva en un bloqueo no es compatible con la directiva de recursividad del bloqueo.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con un mensaje proporcionado por el sistema que describe el error.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con datos serializados.</summary>
      <param name="info">Objeto que contiene los datos del objeto serializados.</param>
      <param name="context">Información contextual acerca del origen o del destino.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con un mensaje especificado que describe el error.</summary>
      <param name="message">Mensaje que describe la excepción. El llamador de este constructor debe asegurarse de que la cadena se ha traducido para la referencia cultural actual del sistema.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.LockRecursionException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message">Mensaje que describe la excepción. El llamador de este constructor debe asegurarse de que la cadena se ha traducido para la referencia cultural actual del sistema.</param>
      <param name="innerException">Excepción que ha producido la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>Especifica si el mismo subproceso puede entrar varias veces en un bloqueo.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>Si un subproceso intenta entrar en un bloqueo de forma recursiva, se inicia una excepción. Algunas clases pueden permitir cierta recursividad cuando se aplica esta configuración.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>Un subproceso puede entrar en un bloqueo de forma recursiva. Algunas clases pueden limitar esta posibilidad.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary>Representa un evento de sincronización de subprocesos que, cuando se señale, se debe restablecer manualmente. Esta clase no puede heredarse.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ManualResetEvent" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado.</summary>
      <param name="initialState">
        <see langword="true" /> para establecer el estado inicial de señalado; <see langword="false" /> para establecer el estado inicial en no señalado.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>Representa un evento de sincronización de subprocesos que, cuando se señale, se debe restablecer manualmente. Esta clase es una alternativa ligera a <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ManualResetEventSlim" /> con el estado inicial establecido en nonsignaled.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ManualResetEventSlim" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado.</summary>
      <param name="initialState">Es true para establecer el estado inicial en señalado; es false para establecer el estado inicial en no señalado.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Threading.ManualResetEventSlim" /> con un valor booleano que indica si hay que establecer el estado inicial en señalado y un recuento circular especificado.</summary>
      <param name="initialState">Es true para establecer el estado inicial en señalado; es false para establecer el estado inicial en no señalado.</param>
      <param name="spinCount">Número de esperas circulares que se van a producir antes de una operación de espera basada en kernel.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> es menor que 0 o mayor que el máximo valor permitido.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">true para liberar tanto los recursos administrados como los no administrados; false para liberar únicamente los recursos no administrados.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>Obtiene un valor que indica si se ha establecido el evento.</summary>
      <returns>Es true si se establece el evento; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>Establece el estado del evento en no señalado, por lo que se bloquean los subprocesos.</summary>
      <exception cref="T:System.ObjectDisposedException">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>Establece el estado del evento en señalado, lo que permite la continuación de uno o varios subprocesos que están esperando en el evento.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>Obtiene el número de esperas circulares que se van a producir antes de una operación de espera basada en kernel.</summary>
      <returns>Devuelve el número de esperas circulares que se van a producir antes de una operación de espera basada en kernel.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual.</summary>
      <exception cref="T:System.InvalidOperationException">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, usando un entero de 32 bits con signo para medir el intervalo de tiempo.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, usando un entero de 32 bits con signo para medir el intervalo de tiempo, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException">El objeto ya se ha eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> se ha eliminado.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual reciba una señal, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.InvalidOperationException">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">El objeto ya se ha eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> se ha eliminado.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, utilizando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo.</summary>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.
o bien
El número de milisegundos en <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException">El objeto ya se ha desechado.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que se establezca el objeto <see cref="T:System.Threading.ManualResetEventSlim" /> actual, usando un objeto <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo, mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>
        <see langword="true" /> si se estableció <see cref="T:System.Threading.ManualResetEventSlim" />; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.
o bien
El número de milisegundos en <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha superado el número máximo de esperas.</exception>
      <exception cref="T:System.ObjectDisposedException">El objeto ya se ha eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> se ha eliminado.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>Obtiene el objeto <see cref="T:System.Threading.WaitHandle" /> subyacente de este objeto <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns>Objeto de evento <see cref="T:System.Threading.WaitHandle" /> subyacente de este objeto <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>Proporciona un mecanismo que sincroniza el acceso a los objetos.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>Adquiere un bloqueo exclusivo en el objeto especificado.</summary>
      <param name="obj">Objeto en el que se va a adquirir el bloqueo de monitor.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>Adquiere un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj">Objeto en el que se va a esperar.</param>
      <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.
Nota   Si no se produce ninguna excepción, el resultado de este método siempre es <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>Libera un bloqueo exclusivo en el objeto especificado.</summary>
      <param name="obj">Objeto en el que se va a liberar el bloqueo.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no posee el bloqueo para el objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>Determina si el subproceso actual mantiene el bloqueo en el objeto especificado.</summary>
      <param name="obj">El objeto que se va a probar.</param>
      <returns>Es <see langword="true" /> si el subproceso actual mantiene el bloqueo en <paramref name="obj" />; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary>Obtiene el número de veces que ha habido contención al intentar tomar el bloqueo del monitor.</summary>
      <returns>Número de veces que se ha producido una contención al intentar realizar el bloqueo del monitor.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>Notifica un cambio de estado del objeto bloqueado al subproceso que se encuentra en la cola de espera.</summary>
      <param name="obj">Objeto que está esperando un subproceso.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>Notifica un cambio de estado del objeto a todos los subprocesos que se encuentran en espera.</summary>
      <param name="obj">Objeto que envía el pulso.</param>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado.</summary>
      <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
      <returns>Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
      <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el número de segundos especificado.</summary>
      <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="millisecondsTimeout">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</param>
      <returns>Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>Intenta, durante el número especificado de milisegundos, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="millisecondsTimeout">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</param>
      <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
      <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el período de tiempo especificado.</summary>
      <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> que representa el período de tiempo que se va a esperar para adquirir el bloqueo. Un valor de -1 milisegundo especifica una espera infinita.</param>
      <returns>Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>Intenta, durante el periodo de tiempo indicado, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
      <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
      <param name="timeout">Tiempo que se va a esperar el bloqueo. Un valor de -1 milisegundo especifica una espera infinita.</param>
      <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
      <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</summary>
      <param name="obj">Objeto en el que se va a esperar.</param>
      <returns>
        <see langword="true" /> si la llamada fue devuelta porque el llamador volvió a adquirir el bloqueo para el objeto especificado. Este método no devuelve ningún resultado si el bloqueo no vuelve a adquirirse.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</summary>
      <param name="obj">Objeto en el que se va a esperar.</param>
      <param name="millisecondsTimeout">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos. Este método también especifica si el dominio de sincronización del contexto (si se trata de un contexto sincronizado) sale antes de la espera y vuelve a adquirir el bloqueo después.</summary>
      <param name="obj">Objeto en el que se va a esperar.</param>
      <param name="millisecondsTimeout">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <param name="exitContext">
        <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</param>
      <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</summary>
      <param name="obj">Objeto en el que se va a esperar.</param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="timeout" /> en milisegundos es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundo) o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos. De modo opcional, sale del dominio de sincronización del contexto sincronizado antes de la espera y vuelve a adquirir el dominio después.</summary>
      <param name="obj">Objeto en el que se va a esperar.</param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</param>
      <param name="exitContext">
        <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</param>
      <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a Wait se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="timeout" /> es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundo), o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>Primitiva de sincronización que puede usarse también para la sincronización entre procesos.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con propiedades predeterminadas.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> para otorgar la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada, en caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua y una cadena que representa el nombre de la exclusión mutua.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</param>
      <param name="name">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
      <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, una cadena que es el nombre de la exclusión mutua y un valor booleano que, cuando se devuelva el método, indicará si se concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada.</summary>
      <param name="initiallyOwned">
        <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</param>
      <param name="name">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
      <param name="createdNew">Cuando se devuelve este método, contiene un valor booleano que es <see langword="true" /> si se creó una exclusión mutua local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía. Este parámetro se pasa sin inicializar.</param>
      <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> tiene más de 260 caracteres.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>Abre la exclusión mutua con nombre especificada, si ya existe.</summary>
      <param name="name">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
      <returns>Objeto que representa la exclusión mutua del sistema con nombre.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">La excepción mutua con nombre no existe.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>Libera una vez la instancia de <see cref="T:System.Threading.Mutex" />.</summary>
      <exception cref="T:System.ApplicationException">El subproceso que realiza la llamada no posee la exclusión mutua.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>Abre la exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="name">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
      <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> es una cadena vacía.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary>Define un bloqueo que admite un escritor y varios lectores.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary>Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</summary>
      <param name="millisecondsTimeout">Tiempo de espera en milisegundos.</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary>Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</summary>
      <param name="timeout">Un <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary>Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</summary>
      <param name="millisecondsTimeout">Tiempo de espera en milisegundos.</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary>Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</summary>
      <param name="timeout">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary>Indica si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia.</summary>
      <param name="seqNum">Número de secuencia.</param>
      <returns>
        <see langword="true" /> si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary>Recupera el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
      <param name="lockCookie">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException">El subproceso no dispone del bloqueo de escritor.</exception>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual tiene un bloqueo de lector.</summary>
      <returns>
        <see langword="true" /> si el subproceso actual tiene un bloqueo de lector; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual tiene el bloqueo de escritor.</summary>
      <returns>
        <see langword="true" /> si el subproceso actual tiene el bloqueo de escritor; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary>Libera el bloqueo, independientemente del número de veces que el subproceso haya adquirido el bloqueo.</summary>
      <returns>Un valor <see cref="T:System.Threading.LockCookie" /> que representa el bloqueo liberado.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary>Reduce el recuento de bloqueos.</summary>
      <exception cref="T:System.ApplicationException">El subproceso no tiene ningún bloqueo de lector o escritor.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary>Reduce el recuento de bloqueos del bloqueo de escritor.</summary>
      <exception cref="T:System.ApplicationException">El subproceso no dispone del bloqueo de escritor.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary>Restaura el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary>Actualiza un bloqueo de lector al bloqueo de escritor, utilizando un valor <see langword="Int32" /> para el tiempo de espera.</summary>
      <param name="millisecondsTimeout">Tiempo de espera en milisegundos.</param>
      <returns>Valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException">
        <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary>Actualiza un bloqueo de lector al bloqueo de escritor utilizando un valor <see langword="TimeSpan" /> para el tiempo de espera.</summary>
      <param name="timeout">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
      <returns>Valor <see cref="T:System.Threading.LockCookie" />.</returns>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary>Obtiene el número de secuencia actual.</summary>
      <returns>Número de secuencia actual.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Representa un bloqueo que se utiliza para administrar el acceso a un recurso y que permite varios subprocesos para la lectura o acceso exclusivo para la escritura.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> con los valores de propiedad predeterminados.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> especificando la directiva de recursividad de bloqueo.</summary>
      <param name="recursionPolicy">Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Obtiene el número total de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</summary>
      <returns>Número de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> es mayor que cero.
O bien
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> es mayor que cero.
O bien
<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> es mayor que cero.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Intenta entrar en el bloqueo en modo de lectura.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ha intentado adquirir el bloqueo de lectura cuando ya lo tenía.
o bien
La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ha intentado adquirir el bloqueo de lectura cuando ya tenía el bloqueo de escritura.
O bien
El número de recursividad superaría la capacidad del contador. Este límite es tan grande que en las aplicaciones no debe aparecer nunca esta excepción.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Intenta entrar en el bloqueo en modo de actualización.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo.
o bien
El subproceso actual ha entrado en modo de lectura, por lo que, al intentar entrar en modo de actualización, existiría la posibilidad de interbloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Intenta entrar en el bloqueo en modo de escritura.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo.
o bien
El subproceso actual ha entrado en modo de lectura y ya no posee un bloqueo de escritura, por lo que, si se intenta entrar en el bloqueo en modo de escritura, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Reduce el recuento de recursividad para el modo de lectura y sale del modo de lectura si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no ha entrado en el bloqueo en modo de lectura.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Reduce el recuento de recursividad para el modo de actualización y sale del modo de actualización si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no ha entrado en el bloqueo en modo de actualización.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Reduce el recuento de recursividad para el modo de escritura y sale del modo de escritura si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no ha entrado en el bloqueo en modo de escritura.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de lectura.</summary>
      <returns>
        <see langword="true" /> si el subproceso actual ha entrado en modo de lectura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de actualización.</summary>
      <returns>
        <see langword="true" /> si el subproceso actual ha entrado en modo de actualización; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de escritura.</summary>
      <returns>
        <see langword="true" /> si el subproceso actual ha entrado en modo de escritura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>Obtiene un valor que indica la directiva de recursividad del objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> actual.</summary>
      <returns>Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de lectura, como una indicación de recursividad.</summary>
      <returns>0 (cero) si el subproceso actual no entró en modo Lectura, 1 si el subproceso entró en modo Lectura pero no lo hizo de forma recursiva o n si el subproceso entró de forma recursiva en el bloqueo n - 1 veces.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de actualización, como una indicación de recursividad.</summary>
      <returns>0 (cero) si el subproceso actual no entró en modo de actualización, 1 si el subproceso entró en modo de actualización pero no lo hizo de forma recursiva o n si el subproceso entró de forma recursiva en el modo de actualización n - 1 veces.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de escritura, como una indicación de recursividad.</summary>
      <returns>0 (cero) si el subproceso actual no entró en modo de escritura, 1 si el subproceso entró en modo de escritura pero no lo hizo de forma recursiva o n si el subproceso entró de forma recursiva en el modo de escritura n - 1 veces.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>Intenta entrar en el bloqueo en modo de lectura, con un tiempo de espera entero opcional.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de lectura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>Intenta entrar en el bloqueo en modo de lectura, con tiempo de espera opcional.</summary>
      <param name="timeout">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de lectura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.
o bien
El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de actualización, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
O bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</summary>
      <param name="timeout">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de actualización, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
o bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.
O bien
El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
o bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo.
o bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</summary>
      <param name="timeout">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, <see langword="false" />.</returns>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.
o bien
El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo.
O bien
El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.
O bien
El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de lectura.</summary>
      <returns>Número total de subprocesos que están a la espera de entrar en modo de lectura.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de actualización.</summary>
      <returns>Número total de subprocesos que están a la espera de entrar en modo de actualización.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de escritura.</summary>
      <returns>Número total de subprocesos que están a la espera de entrar en modo de escritura.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary>Limita el número de subprocesos que pueden tener acceso a un recurso o grupo de recursos simultáneamente.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas.</summary>
      <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="maximumCount">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> es menor que 1.
O bien
<paramref name="initialCount" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas y, de forma opcional, especifica el nombre de un objeto semáforo del sistema.</summary>
      <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="maximumCount">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="name">Nombre de un objeto de semáforo del sistema con nombre.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.
o bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> es menor que 1.
o bien
<paramref name="initialCount" /> es menor que 0.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Threading.Semaphore" />, especificando el número inicial de entradas y el número máximo de entradas simultáneas, especificando de forma opcional el nombre de un objeto semáforo de sistema y especificando una variable que recibe un valor que indica si se creó un semáforo del sistema nuevo.</summary>
      <param name="initialCount">Número inicial de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
      <param name="maximumCount">Número máximo de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
      <param name="name">Nombre de un objeto de semáforo del sistema con nombre.</param>
      <param name="createdNew">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un semáforo local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó el semáforo del sistema con nombre especificado; es <see langword="false" /> si el semáforo del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.
O bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> es menor que 1.
o bien
<paramref name="initialCount" /> es menor que 0.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary>Abre el semáforo con nombre especificado, si ya existe.</summary>
      <param name="name">Nombre del semáforo del sistema que se va a abrir.</param>
      <returns>Objeto que representa el semáforo del sistema con nombre.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> es una cadena vacía.
O bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">El semáforo con nombre no existe.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary>Sale del semáforo y devuelve el recuento anterior.</summary>
      <returns>Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException">El recuento del semáforo ya está en el valor máximo.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32 con un semáforo con nombre.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
O bien
El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary>Sale del semáforo un número especificado de veces y devuelve el recuento anterior.</summary>
      <param name="releaseCount">Número de veces que se abandona el semáforo.</param>
      <returns>Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> es menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">El recuento del semáforo ya está en el valor máximo.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32 con un semáforo con nombre.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.
O bien
El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary>Abre el semáforo con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="name">Nombre del semáforo del sistema que se va a abrir.</param>
      <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Semaphore" /> que representa el semáforo con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
      <returns>
        <see langword="true" /> si el semáforo con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> es una cadena vacía.
O bien
<paramref name="name" /> tiene más de 260 caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Error de Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary>Excepción que se produce cuando se llama al método <see cref="Overload:System.Threading.Semaphore.Release" /> en un semáforo cuyo recuento ya ha alcanzado el valor máximo.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con valores predeterminados.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con datos serializados.</summary>
      <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto sobre la excepción iniciada.</param>
      <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con el mensaje de error especificado.</summary>
      <param name="message">Mensaje de error que explica el motivo de la excepción.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreFullException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message">Mensaje de error que explica el motivo de la excepción.</param>
      <param name="innerException">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>Representa una alternativa ligera a <see cref="T:System.Threading.Semaphore" /> que limita el número de subprocesos que pueden tener acceso a un recurso o grupo de recursos simultáneamente.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreSlim" />, especificando el número inicial de solicitudes que se pueden conceder simultáneamente.</summary>
      <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreSlim" />, especificando el número inicial y máximo de solicitudes que se pueden conceder simultáneamente.</summary>
      <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <param name="maxCount">El número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> es menor que 0, <paramref name="initialCount" /> es mayor que <paramref name="maxCount" />, o <paramref name="maxCount" /> es igual o menor que 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>Devuelve un objeto <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar en el semáforo.</summary>
      <returns>
        <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar en el semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>Obtiene el número de subprocesos restantes que puede introducir el objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Obtiene el número de subprocesos restantes que pueden entrar en el semáforo.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.SemaphoreSlim" /> y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>Libera una vez el objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Recuento anterior de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> ya ha alcanzado su tamaño máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>Libera el objeto <see cref="T:System.Threading.SemaphoreSlim" /> el número de veces especificado.</summary>
      <param name="releaseCount">El número de veces que sale del semáforo.</param>
      <returns>Recuento anterior de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> es menor que 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> ya ha alcanzado su tamaño máximo.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits con signo que especifica el tiempo de espera.</summary>
      <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" />(-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <returns>Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits con signo que especifica el tiempo de espera mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" />(-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="millisecondsTimeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado la instancia <see cref="T:System.Threading.SemaphoreSlim" /> o se ha eliminado el <see cref="T:System.Threading.CancellationTokenSource" /> que ha creado <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />, mientras se observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.
o bien
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando <see cref="T:System.TimeSpan" /> para especificar el tiempo de espera.</summary>
      <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <returns>Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">La instancia de semaphoreSlim se ha eliminado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloquea el subproceso actual hasta que pueda entrar en <see cref="T:System.Threading.SemaphoreSlim" />, usando un <see cref="T:System.TimeSpan" /> que especifica el tiempo de espera mientras se observa un token <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
O bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">La instancia de semaphoreSlim se ha eliminado.
o bien
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary>De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Tarea que se completará cuando se entre en el semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary>De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, utilizando un entero de 32 bits para medir el intervalo de tiempo.</summary>
      <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="millisecondsTimeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, utilizando un entero de 32 bits para medir el intervalo de tiempo, mientras observa <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="millisecondsTimeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary>De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, mientras observa <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>Una tarea que se completará cuando se especifica el semáforo.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary>De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, mediante <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo.</summary>
      <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>De forma asincrónica espera que entre el <see cref="T:System.Threading.SemaphoreSlim" />, mediante <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo, mientras observa <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
      <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
      <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de expiración infinito.
o bien
<paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary>Representa el método al que hay que llamar cuando se va a enviar un mensaje a un contexto de sincronización.</summary>
      <param name="state">Objeto que se ha pasado al delegado.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>Proporciona una primitiva de bloqueo de exclusión mutua donde un subproceso que intenta adquirir el bloqueo espera en un bucle y realiza comprobaciones repetidamente hasta que haya un bloqueo disponible.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Threading.SpinLock" /> con la opción de realizar el seguimiento de los identificadores de subprocesos para mejorar la depuración.</summary>
      <param name="enableThreadOwnerTracking">Indica si se han de capturar y utilizar identificadores de subprocesos con fines de depuración.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>Adquiere el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="lockTaken">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentException">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>Libera el bloqueo.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual no es el propietario de este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>Libera el bloqueo.</summary>
      <param name="useMemoryBarrier">Valor booleano que indica si una barrera de memoria debe emitirse para publicar inmediatamente la operación de salida a otros subprocesos.</param>
      <exception cref="T:System.Threading.SynchronizationLockException">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual no es el propietario de este bloqueo.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>Obtiene un valor que indica si un subproceso mantiene actualmente el bloqueo.</summary>
      <returns>Es true si cualquier subproceso mantiene actualmente el bloqueo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>Obtiene un valor que indica si el subproceso actual mantiene actualmente el bloqueo.</summary>
      <returns>Es true si el subproceso actual mantiene el bloqueo; de lo contrario, es false.</returns>
      <exception cref="T:System.InvalidOperationException">El seguimiento de propiedad de subprocesos está deshabilitado.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>Obtiene un valor que indica si el seguimiento de propiedad de subprocesos está habilitado para esta instancia.</summary>
      <returns>Es true si se ha habilitado el seguimiento de propiedad de subprocesos para esta instancia; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>Intenta adquirir el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="lockTaken">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentException">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>Intenta adquirir el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <param name="lockTaken">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
      <exception cref="T:System.ArgumentException">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>Intenta adquirir el bloqueo de manera confiable de modo que, incluso si se produce una excepción en la llamada al método, se pueda examinar <paramref name="lockTaken" /> de manera confiable para determinar si se adquirió el bloqueo.</summary>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
      <param name="lockTaken">Es true si se adquiere el bloqueo; de lo contrario, es false. <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a este método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      <exception cref="T:System.ArgumentException">El argumento <paramref name="lockTaken" /> se debe inicializar en false antes de llamar a TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">El seguimiento de propiedad de subprocesos está habilitado, y el subproceso actual ya ha adquirido este bloqueo.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>Proporciona compatibilidad para la espera basada en ciclos.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>Obtiene el número de veces que se ha llamado a <see cref="M:System.Threading.SpinWait.SpinOnce" /> en esta instancia.</summary>
      <returns>Devuelve un entero que representa el número de veces que <see cref="M:System.Threading.SpinWait.SpinOnce" /> se ha llamado en esta instancia.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>Obtiene si la llamada siguiente a <see cref="M:System.Threading.SpinWait.SpinOnce" /> da paso al procesador, lo que activa un cambio de contexto forzado.</summary>
      <returns>Si la llamada siguiente a <see cref="M:System.Threading.SpinWait.SpinOnce" /> da paso al procesador, lo que activa un cambio de contexto forzado.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>Restablece el contador de ciclos.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>Realiza un único ciclo.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary>Realiza una sola rotación y llama a <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> después de un recuento de rotación mínimo.</summary>
      <param name="sleep1Threshold">Recuento de rotación mínima después del cual puede utilizarse <see langword="Thread.Sleep(1)" />. El valor -1 deshabilita el uso de <see langword="Thread.Sleep(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sleep1Threshold" /> es menor que 1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>Itera en ciclos hasta que se satisface la condición especificada.</summary>
      <param name="condition">Delegado que se va a ejecutar una y otra vez hasta que devuelva true.</param>
      <exception cref="T:System.ArgumentNullException">El argumento <paramref name="condition" /> es null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>Itera en ciclos hasta que se satisface la condición especificada o se agota el tiempo de espera indicado.</summary>
      <param name="condition">Delegado que se va a ejecutar una y otra vez hasta que devuelva true.</param>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si la condición se satisface dentro del tiempo de espera; de lo contrario, es false</returns>
      <exception cref="T:System.ArgumentNullException">El argumento <paramref name="condition" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>Itera en ciclos hasta que se satisface la condición especificada o se agota el tiempo de espera indicado.</summary>
      <param name="condition">Delegado que se va a ejecutar una y otra vez hasta que devuelva true.</param>
      <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o TimeSpan que representa -1 milisegundo para esperar indefinidamente.</param>
      <returns>
        <see langword="true" /> si la condición se satisface dentro del tiempo de espera; de lo contrario, es false</returns>
      <exception cref="T:System.ArgumentNullException">El argumento <paramref name="condition" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary>Proporciona la funcionalidad básica para difundir un contexto de sincronización en varios modelos de sincronización.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary>Crea una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary>Cuando se invalida en una clase derivada, crea una copia del contexto de sincronización.</summary>
      <returns>Un nuevo objeto <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary>Obtiene el contexto de sincronización del subproceso actual.</summary>
      <returns>Objeto <see cref="T:System.Threading.SynchronizationContext" /> que representa el contexto de sincronización actual.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary>Determina si se requiere una notificación de espera.</summary>
      <returns>Es <see langword="true" /> si se requiere la notificación; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary>Cuando se invalida en una clase derivada, responde a la notificación de que se ha completado una operación.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary>Cuando se invalida en una clase derivada, responde a la notificación de que se ha iniciado una operación.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>Cuando se invalida en una clase derivada, envía un mensaje asincrónico a un contexto de sincronización.</summary>
      <param name="d">Delegado de <see cref="T:System.Threading.SendOrPostCallback" /> al que se va a llamar.</param>
      <param name="state">Objeto que se ha pasado al delegado.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>Cuando se invalida en una clase derivada, envía un mensaje sincrónico a un contexto de sincronización.</summary>
      <param name="d">Delegado de <see cref="T:System.Threading.SendOrPostCallback" /> al que se va a llamar.</param>
      <param name="state">Objeto que se ha pasado al delegado.</param>
      <exception cref="T:System.NotSupportedException">Se llamó al método en una aplicación de la Tienda Windows. La implementación de <see cref="T:System.Threading.SynchronizationContext" /> para las aplicaciones de la Tienda Windows no admite el método <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>Establece el contexto de sincronización actual.</summary>
      <param name="syncContext">Objeto <see cref="T:System.Threading.SynchronizationContext" /> que se va a establecer.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary>Establece que se requiere la notificación de espera y prepara el método de devolución de llamada para que la llamada pueda efectuarse de manera más confiable cuando se produzca una espera.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Espera a que cualquiera o la totalidad de los elementos de la matriz especificada reciban una señal.</summary>
      <param name="waitHandles">Matriz de tipo <see cref="T:System.IntPtr" /> que contiene los identificadores del sistema operativo nativo.</param>
      <param name="waitAll">Es <see langword="true" /> para que se espere a todos los identificadores; es <see langword="false" /> para que se espere a cualquiera de ellos.</param>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns>Índice de la matriz del objeto que satisfizo la espera.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="waitHandles" /> es null.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Función del asistente que espera a que cualquiera o la totalidad de los elementos de la matriz especificada reciban una señal.</summary>
      <param name="waitHandles">Matriz de tipo <see cref="T:System.IntPtr" /> que contiene los identificadores del sistema operativo nativo.</param>
      <param name="waitAll">
        <see langword="true" /> para que se espere a todos los identificadores; <see langword="false" /> para que se espere a cualquiera de ellos.</param>
      <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
      <returns>Índice de la matriz del objeto que satisfizo la espera.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary>Excepción que se produce cuando un método requiere que el llamador sea propietario del bloqueo en un Monitor dado y un llamador al que no pertenece ese bloqueo llama al método.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con propiedades predeterminadas.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con datos serializados.</summary>
      <param name="info">
        <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto que hacen referencia a la excepción que se va a producir.</param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con el mensaje de error especificado.</summary>
      <param name="message">Mensaje de error que explica el motivo de la excepción.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SynchronizationLockException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message">Mensaje de error que explica el motivo de la excepción.</param>
      <param name="innerException">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>Proporciona almacenamiento local de los datos de un subproceso.</summary>
      <typeparam name="T">Especifica el tipo de datos almacenados por subproceso.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>Inicializa la instancia <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary>Inicializa la instancia <see cref="T:System.Threading.ThreadLocal`1" /> y especifica si todos los valores son accesibles desde cualquier subproceso.</summary>
      <param name="trackAllValues">
        <see langword="true" /> para hacer un seguimiento de todos los valores establecidos en la instancia y exponerlos a través de la propiedad <see cref="P:System.Threading.ThreadLocal`1.Values" />; en caso contrario, <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>Inicializa una instancia de <see cref="T:System.Threading.ThreadLocal`1" /> con la función especificada por el parámetro <paramref name="valueFactory" />.</summary>
      <param name="valueFactory">
        <see cref="T:System.Func`1" /> que se invoca para generar un valor de inicialización diferida cuando se intenta recuperar <see cref="P:System.Threading.ThreadLocal`1.Value" /> sin que se haya inicializado anteriormente.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> es una referencia nula (nada en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>Inicializa la instancia <see cref="T:System.Threading.ThreadLocal`1" /> con la función <paramref name="valueFactory" /> especificada y una marca que indica si todos los valores son accesibles desde cualquier subproceso.</summary>
      <param name="valueFactory">
        <see cref="T:System.Func`1" /> que se invoca para generar un valor de inicialización diferida cuando se intenta recuperar <see cref="P:System.Threading.ThreadLocal`1.Value" /> sin que se haya inicializado anteriormente.</param>
      <param name="trackAllValues">
        <see langword="true" /> para hacer un seguimiento de todos los valores establecidos en la instancia y exponerlos a través de la propiedad <see cref="P:System.Threading.ThreadLocal`1.Values" />; en caso contrario, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> es una referencia <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>Libera los recursos que usa la instancia <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing">Valor booleano que indica si se llama a este método debido a una llamada a <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>Libera los recursos que usa la instancia <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>Obtiene un valor que indica si <see cref="P:System.Threading.ThreadLocal`1.Value" /> se inicializa en el subproceso actual.</summary>
      <returns>Es true si <see cref="P:System.Threading.ThreadLocal`1.Value" /> se inicializa en el subproceso actual; en caso contrario, es false.</returns>
      <exception cref="T:System.ObjectDisposedException">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>Crea y devuelve una representación de cadena de esta instancia del subproceso actual.</summary>
      <returns>Resultado de llamar al método <see cref="M:System.Object.ToString" /> en <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
      <exception cref="T:System.NullReferenceException">La propiedad <see cref="P:System.Threading.ThreadLocal`1.Value" /> del subproceso actual es una referencia nula (Nothing en Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">La función de inicialización intentó hacer referencia de forma recursiva a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">No se proporciona ningún constructor sin parámetros y no se proporciona ningún generador de valor.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>Obtiene o establece el valor de esta instancia del subproceso actual.</summary>
      <returns>Devuelve una instancia del objeto que ThreadLocal es responsable de inicializar.</returns>
      <exception cref="T:System.ObjectDisposedException">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
      <exception cref="T:System.InvalidOperationException">La función de inicialización intentó hacer referencia de forma recursiva a <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">No se proporciona ningún constructor sin parámetros y no se proporciona ningún generador de valor.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary>Obtiene una lista de todos los valores almacenados actualmente por todos los subprocesos que han tenido acceso a esta instancia.</summary>
      <returns>Lista de todos los valores almacenados actualmente por todos los subprocesos que han tenido acceso a esta instancia.</returns>
      <exception cref="T:System.InvalidOperationException">Los valores almacenados por todos los subprocesos no están disponibles porque esta instancia se inicializó con el argumento <paramref name="trackAllValues" /> establecido en <see langword="false" /> en la llamada a un constructor de clase.</exception>
      <exception cref="T:System.ObjectDisposedException">Se eliminó la instancia de <see cref="T:System.Threading.ThreadLocal`1" />.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary>Contiene los métodos para realizar operaciones de memoria volátil.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary>Lee el valor del campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <returns>Valor que se leyó. El valor es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary>Lee la referencia al objeto desde el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura después de este método en el código, el procesador no puede moverla antes de este método.</summary>
      <param name="location">Campo que se va a leer.</param>
      <typeparam name="T">Tipo del campo que se va a leer. Debe ser un tipo de referencia, no un tipo de valor.</typeparam>
      <returns>Referencia al <paramref name="T" /> que se ha leído. Esta referencia es el último que haya escrito cualquier procesador del equipo, independientemente del número de procesadores y del estado de la memoria caché del procesador.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary>Escribe el valor especificado en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe el valor.</param>
      <param name="value">Valor que se va a escribir. El valor se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary>Escribe la referencia de objeto especificada en el campo especificado. En los sistemas que lo requieren, inserta una barrera de memoria que impide que el procesador reordene las operaciones de memoria del modo siguiente: Si aparece una lectura o escritura antes de este método en el código, el procesador no puede moverla después de este método.</summary>
      <param name="location">Campo donde se escribe la referencia de objeto.</param>
      <param name="value">Referencia de objeto que se va a escribir. La referencia se escribe inmediatamente de manera que sea visible para todos los procesadores del equipo.</param>
      <typeparam name="T">Tipo del campo que se va a escribir. Debe ser un tipo de referencia, no un tipo de valor.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary>La excepción que se produce cuando se intenta abrir una exclusión mutua del sistema, un semáforo o un identificador de espera de eventos que no existe.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con valores predeterminados.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con datos serializados.</summary>
      <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto sobre la excepción iniciada.</param>
      <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con el mensaje de error especificado.</summary>
      <param name="message">Mensaje de error que explica el motivo de la excepción.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
      <param name="message">Mensaje de error que explica el motivo de la excepción.</param>
      <param name="innerException">Excepción que es la causa de la excepción actual. Si el parámetro <paramref name="innerException" /> no es <see langword="null" />, la excepción actual se produce en un bloque <see langword="catch" /> que controla la excepción interna.</param>
    </member>
  </members>
</doc>