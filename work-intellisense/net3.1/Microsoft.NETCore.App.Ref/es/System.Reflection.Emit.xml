<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary>Define y representa un ensamblado dinámico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary>Obtiene la ubicación del ensamblado tal y como se especificó originalmente (como en un objeto <see cref="T:System.Reflection.AssemblyName" />).</summary>
      <returns>Ubicación del ensamblado tal y como se especificó originalmente.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary>Define un ensamblado dinámico que tiene los derechos de acceso y nombre especificados.</summary>
      <param name="name">Nombre del ensamblado.</param>
      <param name="access">Derechos de acceso del ensamblado.</param>
      <returns>Un objeto que representa el nuevo ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary>Define un nuevo ensamblado que tiene el nombre, los derechos de acceso y los atributos especificados.</summary>
      <param name="name">Nombre del ensamblado.</param>
      <param name="access">Derechos de acceso del ensamblado.</param>
      <param name="assemblyAttributes">Colección que contiene los atributos del ensamblado.</param>
      <returns>Objeto que representa el nuevo ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary>Define un módulo dinámico transitorio con nombre en este ensamblado.</summary>
      <param name="name">Nombre del módulo dinámico.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.ModuleBuilder" /> que representa el módulo dinámico definido.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> comienza con un espacio en blanco.
o bien
La longitud de <paramref name="name" /> es cero.
o bien
La longitud de <paramref name="name" /> es superior a la longitud máxima definida por el sistema.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      <exception cref="T:System.ExecutionEngineException">No se puede cargar el ensamblado para el sistema de escritura de símbolos predeterminado.
o bien
No se encuentra el tipo que implementa la interfaz del escritor de símbolos predeterminado.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary>Devuelve el punto de entrada de este ensamblado.</summary>
      <returns>Punto de entrada de este ensamblado.</returns>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary>Devuelve un valor que indica si esta instancia es igual que el objeto especificado.</summary>
      <param name="obj">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
      <returns>Es <see langword="true" /> si <paramref name="obj" /> es igual al tipo y valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary>Obtiene el nombre para mostrar del ensamblado dinámico actual.</summary>
      <returns>Nombre para mostrar del ensamblado dinámico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual.</summary>
      <param name="inherit">Se omite este argumento para los objetos de este tipo.</param>
      <returns>Matriz que contiene los atributos personalizados; la matriz está vacía si no hay ningún atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual y que derivan de un tipo de atributo especificado.</summary>
      <param name="attributeType">Tipo base del que derivan los atributos.</param>
      <param name="inherit">Se omite este argumento para los objetos de este tipo.</param>
      <returns>Matriz que contiene los atributos personalizados que se derivan en cualquier nivel de <paramref name="attributeType" />; la matriz está vacía si no hay ninguno de esos atributos.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado por el tiempo de ejecución. Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary>Devuelve objetos <see cref="T:System.Reflection.CustomAttributeData" /> que contienen información sobre los atributos que se han aplicado a la clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual.</summary>
      <returns>Lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representan datos sobre los atributos que se aplicaron al módulo actual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary>Devuelve el módulo dinámico con el nombre especificado.</summary>
      <param name="name">Nombre del módulo dinámico solicitado.</param>
      <returns>Objeto ModuleBuilder que representa el módulo dinámico solicitado.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary>Obtiene los tipos exportados definidos en este ensamblado.</summary>
      <returns>Matriz de <see cref="T:System.Type" /> que contiene los tipos exportados definidos en este ensamblado.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary>Obtiene un objeto <see cref="T:System.IO.FileStream" /> para el archivo especificado en la tabla de archivos del manifiesto de este ensamblado.</summary>
      <param name="name">Nombre del archivo especificado.</param>
      <returns>
        <see cref="T:System.IO.FileStream" /> para el archivo especificado o <see langword="null" /> si no se encuentra el archivo.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary>Obtiene los archivos en la tabla de archivos del manifiesto del ensamblado, especificando si deben incluirse módulos de recursos.</summary>
      <param name="getResourceModules">
        <see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</param>
      <returns>Matriz de objetos <see cref="T:System.IO.FileStream" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary>Devuelve el código hash de esta instancia.</summary>
      <returns>Código hash de un entero de 32 bits con signo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary>Devuelve todos los módulos cargados que forman parte de este ensamblado y, opcionalmente, incluye módulos de recursos.</summary>
      <param name="getResourceModules">
        <see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</param>
      <returns>Módulos cargados que forman parte de este ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary>Devuelve información sobre cómo el recurso dado ha persistido.</summary>
      <param name="resourceName">Nombre del recurso.</param>
      <returns>
        <see cref="T:System.Reflection.ManifestResourceInfo" /> se llena con información sobre la topología del recurso o <see langword="null" /> si no se encuentra el recurso en cuestión.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary>Carga el recurso del manifiesto especificado a partir de este ensamblado.</summary>
      <returns>Matriz de tipo <see langword="String" /> que contiene los nombres de todos los recursos.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite en un ensamblado dinámico. Para obtener los nombre de los recursos del manifiesto, utilice el método <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary>Carga el recurso del manifiesto especificado a partir de este ensamblado.</summary>
      <param name="name">Nombre del recurso de manifiesto que se solicita.</param>
      <returns>
        <see cref="T:System.IO.Stream" /> que representa este recurso de manifiesto.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary>Carga el recurso del manifiesto especificado según el espacio de nombres del tipo especificado a partir de este ensamblado.</summary>
      <param name="type">Tipo cuyo espacio de nombres se utiliza para establecer el nombre de recurso del manifiesto.</param>
      <param name="name">Nombre del recurso del manifiesto que se solicita.</param>
      <returns>
        <see cref="T:System.IO.Stream" /> que representa este recurso de manifiesto.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary>Obtiene el módulo especificado en este ensamblado.</summary>
      <param name="name">Nombre del módulo solicitado.</param>
      <returns>Módulo que se solicita o <see langword="null" /> si no se encuentra el módulo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary>Obtiene todos los módulos que forman parte de este ensamblado y, opcionalmente, incluye módulos de recursos.</summary>
      <param name="getResourceModules">
        <see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</param>
      <returns>Módulos que forman parte de este ensamblado.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary>Obtiene el objeto <see cref="T:System.Reflection.AssemblyName" /> que se especificó cuando se creó el ensamblado dinámico actual, y establece el código base tal y como se especifica.</summary>
      <param name="copiedName">Es <see langword="true" /> para establecer el código base en la ubicación del ensamblado después de realizar una copia sombra; es <see langword="false" /> para establecer el código base en la ubicación original.</param>
      <returns>Nombre del ensamblado dinámico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary>Obtiene una lista incompleta de objetos <see cref="T:System.Reflection.AssemblyName" /> para los ensamblados a los que hace referencia esta clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
      <returns>Matriz de nombres de ensamblado para los ensamblados a los que se hace referencia. Esta matriz no es una lista completa.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary>Obtiene el ensamblado satélite para la referencia cultural especificada.</summary>
      <param name="culture">Referencia cultural especificada.</param>
      <returns>Ensamblado satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileNotFoundException">No se encuentra el ensamblado.</exception>
      <exception cref="T:System.IO.FileLoadException">Se encontró un ensamblado satélite con un nombre de archivo coincidente, pero la <see langword="CultureInfo" /> no coincidía con la especificada.</exception>
      <exception cref="T:System.BadImageFormatException">El ensamblado satélite no es un ensamblado válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary>Obtiene la versión especificada del ensamblado satélite para la referencia cultural especificada.</summary>
      <param name="culture">Referencia cultural especificada.</param>
      <param name="version">Versión del ensamblado satélite.</param>
      <returns>Ensamblado satélite especificado.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> es <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileLoadException">Se encontró un ensamblado satélite con un nombre de archivo coincidente, pero la <see langword="CultureInfo" /> o la versión no coincidía con la especificada.</exception>
      <exception cref="T:System.IO.FileNotFoundException">No se encuentra el ensamblado.</exception>
      <exception cref="T:System.BadImageFormatException">El ensamblado satélite no es un ensamblado válido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Obtiene el tipo especificado de los tipos que se han definido y creado en la clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" />actual.</summary>
      <param name="name">Nombre del tipo que se va a buscar.</param>
      <param name="throwOnError">
        <see langword="true" /> para producir una excepción si no se encuentra el tipo; de lo contrario, <see langword="false" />.</param>
      <param name="ignoreCase">
        <see langword="true" /> para no distinguir entre mayúsculas y minúsculas en el nombre del tipo durante la búsqueda; de lo contrario, <see langword="false" />.</param>
      <returns>Tipo especificado, o <see langword="null" /> si el tipo no se encuentra o todavía no se creó.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>Obtiene un valor que indica si el ensamblado se ha cargado desde la caché global de ensamblados.</summary>
      <returns>Siempre es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary>Obtiene el contexto del host donde se está creando el ensamblado dinámico.</summary>
      <returns>Valor que indica el contexto del host donde se está creando el ensamblado dinámico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>Obtiene la versión de Common Language Runtime que se guardará en el archivo que contiene el manifiesto.</summary>
      <returns>Cadena que representa la versión de Common Language Runtime.</returns>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Devuelve un valor que indica si se aplican una o más instancias del tipo de atributo especificado a este miembro.</summary>
      <param name="attributeType">Tipo de atributo que se va a probar.</param>
      <param name="inherit">Se omite este argumento para los objetos de este tipo.</param>
      <returns>Es <see langword="true" /> si se aplican una o más instancias de <paramref name="attributeType" /> a este ensamblado dinámico; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary>Obtiene un valor que indica que el ensamblado actual es un ensamblado dinámico.</summary>
      <returns>Siempre es <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary>Obtiene la ubicación, en formato de código base, del archivo cargado que contiene el manifiesto si no se han creado instantáneas.</summary>
      <returns>Ubicación del archivo cargado que contiene el manifiesto. Si se ha realizado una copia de seguridad del archivo cargado, la <see langword="Location" /> es la ubicación del archivo antes de que se hiciera la copia de seguridad.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary>Obtiene el módulo de la clase <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> actual que contiene el manifiesto del ensamblado.</summary>
      <returns>Módulo de manifiesto.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary>Obtiene un valor que indica si el ensamblado dinámico está en el contexto de solo reflexión.</summary>
      <returns>
        <see langword="true" /> si el ensamblado dinámico está en el contexto de solo reflexión; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establezca un atributo personalizado en este ensamblado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="con" /> no es un objeto <see langword="RuntimeConstructorInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establezca un atributo personalizado en este ensamblado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary>Define los modos de acceso de un ensamblado dinámico.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary>El ensamblado dinámico se puede ejecutar, pero no guardar.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary>Cuando ya no es accesible, el ensamblado dinámico se descarga automáticamente y su memoria se reclama.</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary>Define y representa un constructor de una clase dinámica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary>Obtiene los atributos de este constructor.</summary>
      <returns>Atributos de este constructor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary>Obtiene un valor <see cref="T:System.Reflection.CallingConventions" /> que depende de si el tipo declarativo es genérico.</summary>
      <returns>
        <see cref="F:System.Reflection.CallingConventions.HasThis" /> si el tipo declarativo es genérico; en caso contrario, <see cref="F:System.Reflection.CallingConventions.Standard" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary>Obtiene una referencia al objeto <see cref="T:System.Type" /> para el tipo que declara este miembro.</summary>
      <returns>Tipo que declara este miembro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Define un parámetro de este constructor.</summary>
      <param name="iSequence">Posición del parámetro en la lista de parámetros. Los parámetros se indizan empezando por el número 1 para el primer parámetro.</param>
      <param name="attributes">Atributos del parámetro.</param>
      <param name="strParamName">Nombre del parámetro. El nombre puede ser la cadena nula.</param>
      <returns>Objeto que representa el nuevo parámetro de este constructor.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iSequence" /> es menor que 0 (cero) o es mayor que el número de parámetros del constructor.</exception>
      <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve todos los atributos personalizados definidos para este constructor.</summary>
      <param name="inherit">Controla la herencia de atributos personalizados de las clases base. Este parámetro se ignora.</param>
      <returns>Matriz de objetos que representa todos los atributos personalizados del constructor que representa esta instancia de <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve los atributos personalizados identificados por el tipo dado.</summary>
      <param name="attributeType">Tipo de atributo personalizado.</param>
      <param name="inherit">Controla la herencia de los atributos personalizados de las clases base. Este parámetro se ignora.</param>
      <returns>Matriz de objetos que representa los atributos de este constructor.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para este constructor.</summary>
      <returns>Objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para este constructor.</returns>
      <exception cref="T:System.InvalidOperationException">El constructor no tiene parámetros.
o bien
El constructor tiene marcas <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" /> que señalan que no debe tener un cuerpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.Emit.ILGenerator" />, con el tamaño de la secuencia de MSIL especificado, que se puede utilizar para crear un cuerpo de método para este constructor.</summary>
      <param name="streamSize">Tamaño de la secuencia de MSIL, en bytes.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.ILGenerator" /> para este constructor.</returns>
      <exception cref="T:System.InvalidOperationException">El constructor no tiene parámetros.
o bien
El constructor tiene las marcas <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" /> que indican que no debe tener un cuerpo de método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary>Devuelve las marcas de implementación de método de este constructor.</summary>
      <returns>Marcadores de implementación de método para este constructor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary>Devuelve los parámetros de este constructor.</summary>
      <returns>Matriz que representa los parámetros de este constructor.</returns>
      <exception cref="T:System.InvalidOperationException">No se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo de este constructor, en las versiones 1.0 y 1.1 de .NET Framework.</exception>
      <exception cref="T:System.NotSupportedException">No se ha llamado al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo de este constructor, en .NET Framework versión 2.0.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary>Obtiene o establece si las variables locales de este constructor deben inicializarse en cero.</summary>
      <returns>Lectura y escritura. Obtiene o establece si las variables locales de este constructor deben inicializarse en cero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Se invoca dinámicamente al constructor reflejado por esta instancia con los argumentos especificados considerando las restricciones del <see langword="Binder" /> especificado.</summary>
      <param name="obj">Objeto que necesita reinicializarse.</param>
      <param name="invokeAttr">Uno de los valores <see langword="BindingFlags" /> que especifica el tipo de enlace deseado.</param>
      <param name="binder">
        <see langword="Binder" /> que define un conjunto de propiedades y permite el enlace, la conversión de tipos de argumentos y la invocación de miembros mediante la reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa Binder.DefaultBinding.</param>
      <param name="parameters">Lista de argumentos. Esta matriz de argumentos tiene el mismo número, orden y tipo que los parámetros del constructor al que se va a invocar. Si no hay ningún parámetro, debe ser una referencia nula (<see langword="Nothing" /> en Visual Basic).</param>
      <param name="culture">
        <see cref="T:System.Globalization.CultureInfo" /> que se usa para regir la conversión de tipos. Si es null, se utiliza <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual.</param>
      <returns>Instancia de la clase asociada al constructor.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Puede recuperar el constructor con <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llamar a <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> en el <see cref="T:System.Reflection.ConstructorInfo" /> devuelto.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Invoca dinámicamente al constructor representado por esta instancia en el objeto dado, pasando los parámetros especificados y considerando las restricciones del enlazador facilitado.</summary>
      <param name="invokeAttr">Este debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, por ejemplo, InvokeMethod, NonPublic, etc.</param>
      <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Lista de argumentos. Esta es una matriz de argumentos con el mismo número, orden y tipo que los parámetros del constructor al que se va a invocar. Si no hay ningún parámetro, deberá ser <see langword="null" />.</param>
      <param name="culture">Instancia de <see cref="T:System.Globalization.CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual. Esto es necesario, por ejemplo, para convertir un objeto <see cref="T:System.String" /> que representa 1000 en un valor <see cref="T:System.Double" />, ya que 1000 se representa de manera diferente según las distintas referencias culturales.</param>
      <returns>Valor devuelto por el constructor invocado.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Puede recuperar el constructor con <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llamar a <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> en el <see cref="T:System.Reflection.ConstructorInfo" /> devuelto.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Comprueba si se define el tipo de atributo personalizado especificado.</summary>
      <param name="attributeType">Tipo de atributo personalizado.</param>
      <param name="inherit">Controla la herencia de los atributos personalizados de las clases base. Este parámetro se ignora.</param>
      <returns>
        <see langword="true" /> si se define el tipo de atributo personalizado especificado; si no, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Se puede recuperar el constructor utilizando <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />, y llamar al método <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en la clase <see cref="T:System.Reflection.ConstructorInfo" /> devuelta.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary>Obtiene el identificador interno para el método. Use este identificador para tener acceso al identificador de metadatos subyacente.</summary>
      <returns>Identificador interno para el método. Use este identificador para tener acceso al identificador de metadatos subyacente.</returns>
      <exception cref="T:System.NotSupportedException">Esta propiedad no es compatible con esta clase.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary>Obtiene el módulo dinámico en el que se define este constructor.</summary>
      <returns>Objeto <see cref="T:System.Reflection.Module" /> que representa el módulo dinámico en el que se define este constructor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary>Recupera el nombre de este constructor.</summary>
      <returns>Nombre de este constructor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary>Contiene una referencia al objeto <see cref="T:System.Type" /> del que se obtuvo este objeto.</summary>
      <returns>Objeto <see langword="Type" /> del que se obtuvo este objeto.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Establece las marcas de implementación de método para este constructor.</summary>
      <param name="attributes">Marcas de implementación de método.</param>
      <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary>Devuelve la instancia <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> como <see cref="T:System.String" />.</summary>
      <returns>Cadena que contiene el nombre, los atributos y las excepciones de este constructor, seguidos de la secuencia actual del Lenguaje Intermedio de Microsoft (MSIL).</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary>Describe y representa un tipo de enumeración.</summary>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary>Recupera el ensamblado dinámico que contiene esta definición de enumeración.</summary>
      <returns>Sólo lectura. Ensamblado dinámico que contiene esta definición de enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary>Devuelve la ruta de acceso completa de esta enumeración calificada por el nombre para mostrar del ensamblado principal.</summary>
      <returns>Sólo lectura. Ruta de acceso completa de esta enumeración calificada por el nombre para mostrar del ensamblado principal.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary>Devuelve el elemento <see cref="T:System.Type" /> principal de este tipo, que siempre es <see cref="T:System.Enum" />.</summary>
      <returns>Sólo lectura. Elemento <see cref="T:System.Type" /> principal de este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.TypeInfo" /> que representa esta enumeración.</summary>
      <returns>Objeto que representa esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary>Devuelve el tipo que declaró este <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Sólo lectura. Tipo que declaró este <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary>Define el campo estático con nombre en un tipo de enumeración con el valor constante especificado.</summary>
      <param name="literalName">El nombre del campo estático.</param>
      <param name="literalValue">El valor constante del literal.</param>
      <returns>Campo definido.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary>Devuelve la ruta de acceso completa de esta enumeración.</summary>
      <returns>Sólo lectura. Ruta de acceso completa de esta enumeración.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores públicos y no públicos definidos para esta clase, tal como se especifica.</summary>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores especificados definidos para esta clase. Si no se definen constructores, se devuelve una matriz vacía.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve todos los atributos personalizados definidos para este constructor.</summary>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>Devuelve una matriz de objetos que representa todos los atributos personalizados del constructor que representa esta instancia de <see cref="T:System.Reflection.Emit.ConstructorBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve los atributos personalizados identificados por el tipo proporcionado.</summary>
      <param name="attributeType">Objeto <see langword="Type" /> al que se aplican los atributos personalizados.</param>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>Devuelve una matriz de objetos que representan los atributos de este constructor, que son de <see cref="T:System.Type" /><paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary>Cuando se llama a este método, siempre se produce <see cref="T:System.NotSupportedException" />.</summary>
      <returns>No se admite este método. No se devuelve ningún valor.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary>Devuelve el tipo entero subyacente de la enumeración actual, que se establece cuando se define el generador de enumeraciones.</summary>
      <returns>Tipo subyacente.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Devuelve el evento con el nombre especificado.</summary>
      <param name="name">Nombre del evento que se va a obtener.</param>
      <param name="bindingAttr">Este atributo de invocación. Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve un objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento declarado o heredado por este tipo con el nombre especificado. Si no existen coincidencias, se devuelve <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary>Devuelve los eventos para los eventos públicos declarados o heredados por este tipo.</summary>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representan los eventos públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Devuelve los eventos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representan los eventos públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay eventos, según se especifica.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Devuelve el campo especificado por el nombre facilitado.</summary>
      <param name="name">Nombre del campo que se va a obtener.</param>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo declarado o heredado por este tipo con el nombre especificado y el modificador público o no público. Si no existen coincidencias, se devolverá null.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Devuelve los campos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr">Este debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, por ejemplo, InvokeMethod, NonPublic, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.FieldInfo" /> objetos que representan los campos públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún campo,  como se especifica.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Devuelve la interfaz implementada (directa o indirectamente) por este tipo con el nombre completo especificado.</summary>
      <param name="name">Nombre de la interfaz.</param>
      <param name="ignoreCase">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns>Devuelve un objeto <see cref="T:System.Type" /> que representa las interfaz implementada. Devuelve null si no se encuentra ningún nombre de interfaz coincidente.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary>Devuelve una asignación de interfaz para la interfaz solicitada.</summary>
      <param name="interfaceType">Tipo de interfaz para la que se debe recuperar la asignación de interfaz.</param>
      <returns>Asignación de interfaz solicitada.</returns>
      <exception cref="T:System.ArgumentException">El tipo no implementa la interfaz.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary>Devuelve una matriz de todas las interfaces implementadas en esta clase y sus clases base.</summary>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan las interfaces implementadas. Si no hay ninguna definida, se devuelve una matriz vacía.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Devuelve a todos los miembros con el nombre especificado, tipo y enlace declarados o heredados por este tipo.</summary>
      <param name="name">Nombre del miembro.</param>
      <param name="type">Tipo de miembro que se va a devolver.</param>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representan los miembros públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los miembros públicos.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Devuelve los miembros especificados declarados o heredados por este tipo.</summary>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún miembro coincidente.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Devuelve todos los métodos públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
      <param name="bindingAttr">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.MethodInfo" /> objetos que representan los métodos públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los métodos públicos.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Devuelve el tipo anidado especificado que este tipo declara.</summary>
      <param name="name">
        <see cref="T:System.String" /> que contiene el nombre del tipo anidado que se va a obtener.</param>
      <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.
O bien
Cero, para realizar una búsqueda de los métodos públicos que distinga entre mayúsculas y minúsculas.</param>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo anidado que cumple los requisitos especificados, si se encuentra; en caso contrario, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Devuelve los tipos anidados públicos y no públicos declarados o heredados por este tipo.</summary>
      <param name="bindingAttr">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Matriz de objetos <see cref="T:System.Type" /> que representa a todos los tipos anidados del objeto <see cref="T:System.Type" /> actual que coinciden con las restricciones de enlace especificadas.
Matriz vacía de tipo <see cref="T:System.Type" />, si no hay tipos anidados dentro del actual <see cref="T:System.Type" />, o si ninguno de los tipos anidados coincide con las limitaciones de enlace.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Devuelve todas las propiedades públicas y no públicas declaradas o heredadas por este tipo, como se especifica.</summary>
      <param name="bindingAttr">Este atributo de invocación. Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representan las propiedades públicas y no públicas definidas en este tipo si se usa <paramref name="nonPublic" />; en caso contrario, solo se devuelven las propiedades públicas.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary>Devuelve el GUID de esta enumeración.</summary>
      <returns>Sólo lectura. GUID de esta enumeración.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Invoca el miembro especificado. El método que se va a invocar debe ser accesible y proporcionar la coincidencia más específica con la lista de argumentos dada, bajo las restricciones del enlazador y los atributos de invocación indicados.</summary>
      <param name="name">Nombre del miembro que se va a invocar. Puede ser un constructor, un método, una propiedad o un campo. Debe especificarse un atributo de invocación apropiado. Tenga en cuenta que es posible invocar al miembro predeterminado de una clase pasando una cadena vacía como el nombre del miembro.</param>
      <param name="invokeAttr">Atributo de invocación. Debe ser un indicador de bits de <see langword="BindingFlags" />.</param>
      <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Objeto donde debe invocarse al miembro especificado. Si el miembro es estático, se ignora este parámetro.</param>
      <param name="args">Lista de argumentos. Se trata de una matriz de objetos que contiene el número, orden y tipo de los parámetros del miembro que se va a  invocar. Si no hay ningún parámetro, este valor debe ser null.</param>
      <param name="modifiers">Matriz de la misma longitud que <paramref name="args" /> con elementos que representan los atributos asociados a los argumentos del miembro que se va a invocar. Un parámetro tiene atributos asociados a él en los metadatos. Los usan varios servicios de interoperabilidad. Consulte las especificaciones de metadatos para obtener detalles como este.</param>
      <param name="culture">Instancia de <see langword="CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see langword="CultureInfo" /> para el subproceso actual. (Por ejemplo, esto es necesario para convertir una cadena que representa 1000 en un valor doble, dado que 1000 se representa de manera diferente según la referencia cultural).</param>
      <param name="namedParameters">Cada parámetro de la matriz <paramref name="namedParameters" /> obtiene el valor del elemento correspondiente en la matriz <paramref name="args" />. Si la longitud de <paramref name="args" /> es mayor que la longitud de <paramref name="namedParameters" />, los valores de argumento restantes se pasan por orden.</param>
      <returns>Devuelve el valor devuelto del miembro invocado.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary>Obtiene un valor que indica si este objeto representa un tipo genérico construido.</summary>
      <returns>
        <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Comprueba si se define el tipo de atributo personalizado especificado.</summary>
      <param name="attributeType">Objeto <see langword="Type" /> al que se aplican los atributos personalizados.</param>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>
        <see langword="true" /> si una o más instancias de <paramref name="attributeType" /> se definen en este miembro; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente en tipos que no están completos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</summary>
      <param name="rank">Número de dimensiones de la matriz. Este número debe ser menor o igual que 32.</param>
      <returns>Objeto que representa una matriz del tipo actual, con el número de dimensiones especificado.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> es menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro ref (parámetro ByRef en Visual Basic).</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro ref (parámetro ByRef en Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary>Recupera el módulo dinámico que contiene esta definición de <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Sólo lectura. Recupera el módulo dinámico que contiene esta definición de <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary>Devuelve el nombre de esta enumeración.</summary>
      <returns>Sólo lectura. Nombre de esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary>Devuelve el espacio de nombres de esta enumeración.</summary>
      <returns>Sólo lectura. Espacio de nombres de esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary>Devuelve el tipo que se usó para obtener este elemento <see cref="T:System.Reflection.Emit.EnumBuilder" />.</summary>
      <returns>Sólo lectura. Tipo que se usó para obtener este elemento <see cref="T:System.Reflection.Emit.EnumBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary>Recupera el identificador interno de esta enumeración.</summary>
      <returns>Sólo lectura. Identificador interno de esta enumeración.</returns>
      <exception cref="T:System.NotSupportedException">Actualmente, esta propiedad no es compatible.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary>Devuelve el campo subyacente de esta enumeración.</summary>
      <returns>Sólo lectura. Campo subyacente de esta enumeración.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary>Devuelve el tipo de sistema subyacente para esta enumeración.</summary>
      <returns>Sólo lectura. Devuelve el tipo de sistema subyacente.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary>Define los eventos para una clase.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Agrega alguno de los "otros" métodos asociados a este evento. Cuando se habla de "otros" métodos, se hace referencia a métodos distintos de los métodos "on" y "raise" que están asociados a un evento. Se puede llamar a esta función numerosas veces para agregar todos los "otros" métodos que se desee.</summary>
      <param name="mdBuilder">Objeto <see langword="MethodBuilder" /> que representa el otro método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Establece el método que se utiliza para suscribirse a este evento.</summary>
      <param name="mdBuilder">Objeto <see langword="MethodBuilder" /> que representa al método utilizado para suscribirse a este evento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para describir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Establece el método que se utiliza para generar este evento.</summary>
      <param name="mdBuilder">Objeto <see langword="MethodBuilder" /> que representa al método utilizado para generar este evento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Establece el método que se utiliza para cancelar la suscripción a este evento.</summary>
      <param name="mdBuilder">Objeto <see langword="MethodBuilder" /> que representa al método utilizado para cancelar la suscripción a este evento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary>Define y representa a un campo. Esta clase no puede heredarse.</summary>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary>Indica los atributos de este campo. Esta propiedad es de sólo lectura.</summary>
      <returns>Atributos de este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary>Indica una referencia al objeto <see cref="T:System.Type" /> para el tipo que declara este campo. Esta propiedad es de sólo lectura.</summary>
      <returns>Referencia al objeto <see cref="T:System.Type" /> para el tipo que declara este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary>Indica el identificador interno de metadatos para este campo. Esta propiedad es de sólo lectura.</summary>
      <returns>Identificador interno de metadatos para este campo.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary>Indica el objeto <see cref="T:System.Type" /> que representa al tipo de este campo. Esta propiedad es de sólo lectura.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa al tipo de este campo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve los atributos personalizados definidos para este campo.</summary>
      <param name="inherit">Controla la herencia de los atributos personalizados de las clases base.</param>
      <returns>Matriz de tipo <see cref="T:System.Object" /> que representa a todos los atributos personalizados del constructor representado mediante la instancia <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve todos los atributos personalizados definidos para este campo identificado por el tipo dado.</summary>
      <param name="attributeType">Tipo de atributo personalizado.</param>
      <param name="inherit">Controla la herencia de los atributos personalizados de las clases base.</param>
      <returns>Matriz de tipo <see cref="T:System.Object" /> que representa a todos los atributos personalizados del constructor representado mediante la instancia <see cref="T:System.Reflection.Emit.FieldBuilder" />.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary>Recupera el valor del campo compatible con el objeto dado.</summary>
      <param name="obj">Objeto desde el que obtener acceso al campo.</param>
      <returns>
        <see cref="T:System.Object" /> que contiene el valor del campo reflejado por esta instancia.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Indica si un atributo que tenga el tipo especificado, aparece definido en un campo.</summary>
      <param name="attributeType">Tipo del atributo.</param>
      <param name="inherit">Controla la herencia de los atributos personalizados de las clases base.</param>
      <returns>
        <see langword="true" /> si hay definidas una o más instancias de <paramref name="attributeType" /> en este campo; en cualquier otro caso, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Recupera el campo mediante <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> y llama a <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el <see cref="T:System.Reflection.FieldInfo" /> devuelto.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary>Obtiene el módulo en el que se define el tipo que contiene este campo.</summary>
      <returns>Clase <see cref="T:System.Reflection.Module" /> que representa el módulo dinámico en el que se define este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary>Indica el nombre de este campo. Esta propiedad es de sólo lectura.</summary>
      <returns>
        <see cref="T:System.String" /> que contiene el nombre de este campo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary>Indica la referencia al objeto <see cref="T:System.Type" /> del que se obtuvo este objeto. Esta propiedad es de sólo lectura.</summary>
      <returns>Referencia al objeto <see cref="T:System.Type" /> a partir del que se obtuvo esta instancia.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary>Establece el valor predeterminado de este campo.</summary>
      <param name="defaultValue">Nuevo valor predeterminado para este campo.</param>
      <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">El campo no es ninguno de los tipos admitidos.
o bien
El tipo de <paramref name="defaultValue" /> no coincide con el tipo del campo.
o bien
El campo es de tipo <see cref="T:System.Object" /> o de otro tipo de referencia, el valor de <paramref name="defaultValue" /> no es <see langword="null" /> y el valor no se puede asignar al tipo de referencia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo principal de este campo está completo.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo principal de este campo está completo.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary>Especifica el diseño del campo.</summary>
      <param name="iOffset">Desplazamiento del campo dentro del tipo que contiene a este campo.</param>
      <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="iOffset" /> es menor que cero.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary>Establece el valor del campo admitido por el objeto determinado.</summary>
      <param name="obj">Objeto desde el que obtener acceso al campo.</param>
      <param name="val">Valor que se va a asignar al campo.</param>
      <param name="invokeAttr">Miembro de <see langword="IBinder" /> que especifica el tipo de enlace deseado (por ejemplo, IBinder.CreateInstance, IBinder.ExactBinding).</param>
      <param name="binder">Conjunto de propiedades que habilitan el enlace, la conversión de tipos de argumentos y las invocaciones a miembros mediante Reflection. Si el enlazador es null, se utilizará IBinder.DefaultBinding.</param>
      <param name="culture">Preferencias de software de una referencia cultural determinada.</param>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary>Define y crea parámetros de tipo genérico para los métodos y tipos genéricos definidos dinámicamente. Esta clase no puede heredarse.</summary>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.Assembly" /> que representa al ensamblado dinámico que contiene la definición de tipo genérico a que pertenece el parámetro de tipo actual.</summary>
      <returns>Un objeto <see cref="T:System.Reflection.Assembly" /> que representa el ensamblado dinámico que contiene la definición de tipo genérico a que pertenece el parámetro de tipo actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary>Obtiene <see langword="null" /> en todos los casos.</summary>
      <returns>Una referencia nula (<see langword="Nothing" /> en Visual Basic) en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary>Obtiene la restricción de tipo base del parámetro de tipo genérico actual.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa la restricción de tipo base del parámetro de tipo genérico, o <see langword="null" /> si el parámetro de tipo no tiene ninguna restricción de tipo base.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary>Obtiene <see langword="true" /> en todos los casos.</summary>
      <returns>
        <see langword="true" /> en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método declarativo si el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actual representa un parámetro de tipo de un método genérico.</summary>
      <returns>Un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método declarativo si el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actual representa un parámetro de tipo de un método genérico; en otro caso, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary>Obtiene la definición de tipo genérico o la definición de método genérico a la que pertenece el parámetro de tipo genérico.</summary>
      <returns>Si el parámetro de tipo pertenece a un tipo genérico, un objeto <see cref="T:System.Type" /> que representa ese tipo genérico; si el parámetro de tipo pertenece a un método genérico, un objeto <see cref="T:System.Type" /> que representa ese tipo que declaró ese método genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary>Comprueba si el objeto determinado es una instancia de <see langword="EventToken" /> y es igual a la instancia actual.</summary>
      <param name="o">Objeto que se va a comparar con la instancia actual.</param>
      <returns>
        <see langword="true" /> si <paramref name="o" /> es una instancia de <see langword="EventToken" /> y es igual a la instancia actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary>Obtiene <see langword="null" /> en todos los casos.</summary>
      <returns>Una referencia nula (<see langword="Nothing" /> en Visual Basic) en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary>Obtiene una combinación de marcas <see cref="T:System.Reflection.GenericParameterAttributes" /> que describen la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</summary>
      <returns>Combinación bit a bit de valores que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary>Obtiene la posición del parámetro de tipo en la lista de parámetros de tipo del método o tipo genérico que declaró el parámetro.</summary>
      <returns>La posición del parámetro de tipo en la lista de parámetros de tipo del método o tipo genérico que declaró el parámetro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary>No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>No se admite para parámetros de tipo genérico incompletos.</summary>
      <param name="attributeType">El tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary>Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns>El tipo al que hace referencia el tipo de matriz actual, el tipo de puntero, o el tipo <see langword="ByRef" />; o <see langword="null" /> si el tipo actual no es un tipo de matriz, no es un tipo de puntero y no se pasa por referencia.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="name">No se admite.</param>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="name">No se admite.</param>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary>No válido para los parámetros de tipo genérico.</summary>
      <returns>No válido para los parámetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary>No válido para los parámetros de tipo genérico.</summary>
      <returns>No válido para los parámetros de tipo genérico.</returns>
      <exception cref="T:System.InvalidOperationException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary>Devuelve un código hash entero de 32 bits para la instancia actual.</summary>
      <returns>Código hash de un entero de 32 bits.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="name">Nombre de la interfaz.</param>
      <param name="ignoreCase">
        <see langword="true" /> para buscar sin considerar la grafía; <see langword="false" /> para realizar una búsqueda con distinción entre mayúsculas y minúsculas.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="interfaceType">Objeto <see cref="T:System.Type" /> que representa el tipo de interfaz para el que se va a recuperar la asignación.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="name">No se admite.</param>
      <param name="type">No se admite.</param>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="name">No se admite.</param>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="bindingAttr">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="name">No se admite.</param>
      <param name="invokeAttr">No se admite.</param>
      <param name="binder">No se admite.</param>
      <param name="target">No se admite.</param>
      <param name="args">No se admite.</param>
      <param name="modifiers">No se admite.</param>
      <param name="culture">No se admite.</param>
      <param name="namedParameters">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary>Se produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos.</summary>
      <param name="c">El objeto que se va a probar.</param>
      <returns>Se produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary>Obtiene un valor que indica si este objeto representa un tipo genérico construido.</summary>
      <returns>
        <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="attributeType">No se admite.</param>
      <param name="inherit">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary>Obtiene <see langword="true" /> en todos los casos.</summary>
      <returns>
        <see langword="true" /> en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary>Devuelve <see langword="false" /> en todos los casos</summary>
      <returns>
        <see langword="false" /> en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary>Obtiene <see langword="false" /> en todos los casos.</summary>
      <returns>
        <see langword="false" /> en todos los casos.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <param name="c">No se admite.</param>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary>Devuelve el tipo de una matriz unidimensional cuyo tipo de elemento es el parámetro de tipo genérico.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de una matriz unidimensional cuyo tipo de elemento es el parámetro de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary>Devuelve el tipo de una matriz cuyo tipo de elemento es el parámetro de tipo genérico, con el número de dimensiones especificado.</summary>
      <param name="rank">Número de dimensiones de la matriz.</param>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de una matriz cuyo tipo de elemento es el parámetro de tipo genérico, con el número especificado de dimensiones.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> no es un número válido de dimensiones. Por ejemplo, su valor es menor que 1.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa el parámetro de tipo genérico actual cuando se pasa como parámetro de referencia.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el parámetro de tipo genérico actual cuando se pasa como un parámetro de referencia.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary>No válido para parámetros de tipo genérico incompletos.</summary>
      <param name="typeArguments">Matriz de argumentos de tipo.</param>
      <returns>Este método no es válido para parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.InvalidOperationException">En todos los casos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa un puntero al parámetro de tipo genérico actual.</summary>
      <returns>Un objeto <see cref="T:System.Type" /> que representa un puntero al parámetro de tipo genérico actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary>Obtiene el módulo dinámico que contiene el parámetro de tipo genérico.</summary>
      <returns>Un objeto <see cref="T:System.Reflection.Module" /> que representa el módulo dinámico que contiene el parámetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary>Obtiene el nombre del parámetro de tipo genérico.</summary>
      <returns>Nombre del parámetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary>Obtiene <see langword="null" /> en todos los casos.</summary>
      <returns>Una referencia nula (<see langword="Nothing" /> en Visual Basic) en todos los casos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary>Obtiene el objeto <see cref="T:System.Type" /> utilizado para obtener el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</summary>
      <returns>El objeto <see cref="T:System.Type" /> utilizado para obtener el objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary>Establece el tipo base que debe heredar un tipo con el fin de ser sustituido para el parámetro de tipo.</summary>
      <param name="baseTypeConstraint">
        <see cref="T:System.Type" /> que debe heredar cualquier tipo que es sustituido para el parámetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Objeto binario de bytes que representa el atributo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> es <see langword="null" />.
O bien
<paramref name="binaryAttribute" /> es una referencia nula.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente que define el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary>Establece las características de varianza y las restricciones especiales del parámetro genérico, como la restricción de constructor sin parámetros.</summary>
      <param name="genericParameterAttributes">Una combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que representan las características de varianza y las restricciones especiales del parámetro de tipo genérico.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary>Establece las interfaces que debe implementar un tipo para que se sustituya por el parámetro de tipo.</summary>
      <param name="interfaceConstraints">Una matriz de objetos <see cref="T:System.Type" /> que representan las interfaces que un tipo debe implementar con el fin de ser sustituido para el parámetro de tipo.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary>Devuelve una representación de cadena del parámetro de tipo genérico actual.</summary>
      <returns>Una cadena que contiene el nombre del parámetro de tipo genérico.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary>No compatible para los parámetros de tipo genérico incompletos.</summary>
      <returns>No compatible para los parámetros de tipo genérico incompletos.</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary>Obtiene el parámetro de tipo genérico actual.</summary>
      <returns>Objeto <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> actual.</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary>Define y representa un método (o constructor) de una clase dinámica.</summary>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary>Recupera los atributos para este método.</summary>
      <returns>Sólo lectura. Recupera los <see langword="MethodAttributes" /> para este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary>Devuelve la convención de llamadas del método.</summary>
      <returns>Sólo lectura. Convención de llamada del método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary>No es compatible con este tipo.</summary>
      <returns>No se admite.</returns>
      <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary>Devuelve el tipo que declara este método.</summary>
      <returns>Sólo lectura. Tipo que declara este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary>Establece el número de parámetros de tipo genérico del método actual, especifica sus nombres y devuelve una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que se pueden utilizar para definir sus restricciones.</summary>
      <param name="names">Matriz de cadenas que representan los nombres de los parámetros de tipo genérico.</param>
      <returns>Matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo del método genérico.</returns>
      <exception cref="T:System.InvalidOperationException">Los parámetros de tipo genérico ya se han definido para este método.
o bien
Ya ha finalizado el método.
O bien
El método actual ha llamado al método <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> es <see langword="null" />.
O bien
Un elemento de <paramref name="names" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> es una matriz vacía.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Establece los atributos de parámetro y el nombre de un parámetro de este método, o del valor devuelto de este método. Devuelve un ParameterBuilder, que se puede usar para aplicar atributos personalizados.</summary>
      <param name="position">Posición del parámetro en la lista de parámetros. Los parámetros se indizan empezando por el número 1 para el primer parámetro; el número 0 representa el valor devuelto del método.</param>
      <param name="attributes">Atributos del parámetro.</param>
      <param name="strParamName">Nombre del parámetro. El nombre puede ser una cadena nula.</param>
      <returns>Devuelve un objeto <see langword="ParameterBuilder" /> que representa un parámetro de este método o el valor devuelto de este método.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">El método no tiene parámetros.
O bien
<paramref name="position" /> es menor que cero.
o bien
<paramref name="position" /> es mayor que el número de parámetros del método.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo contenedor se creó anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
O bien
Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary>Determina si el objeto dado es igual a esta instancia.</summary>
      <param name="obj">Objeto que se va a comparar con la instancia <see langword="MethodBuilder" />.</param>
      <returns>
        <see langword="true" /> si <paramref name="obj" /> es una instancia de <see langword="MethodBuilder" /> y es igual a este objeto; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary>Devuelve la implementación base para un método.</summary>
      <returns>Implementación base de este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve los atributos personalizados definidos para este método.</summary>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro con el fin de encontrar los atributos personalizados.</param>
      <returns>Devuelve una matriz de objetos que representa a todos los atributos personalizados de este método.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el valor devuelto <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve los atributos personalizados identificados por el tipo proporcionado.</summary>
      <param name="attributeType">Tipo de atributo personalizado.</param>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos personalizados.</param>
      <returns>Devuelve una matriz de objetos que representan los atributos de este método que son del tipo <paramref name="attributeType" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el valor devuelto <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary>Devuelve una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo del método si es genérico.</summary>
      <returns>Matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo, si el método es genérico, o <see langword="null" /> si el método no es genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary>Devuelve este método.</summary>
      <returns>La instancia actual de <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
      <exception cref="T:System.InvalidOperationException">El método actual no es genérico. Es decir, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> devuelve <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary>Obtiene el código hash para este método.</summary>
      <returns>Código hash para este método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary>Devuelve un <see langword="ILGenerator" /> para este método con un tamaño predeterminado de secuencia de Lenguaje intermedio de Microsoft (MSIL) de 64 bytes.</summary>
      <returns>Devuelve un objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException">El método no debe tener un cuerpo debido a sus marcas <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />, por ejemplo porque tiene la marca <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.
o bien
El método es un método genérico, pero no una definición de método genérico. Es decir, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary>Devuelve un <see langword="ILGenerator" /> para este método con el tamaño de secuencia de Lenguaje intermedio de Microsoft (MSIL) especificado.</summary>
      <param name="size">El tamaño de la secuencia MSIL, en bytes.</param>
      <returns>Devuelve un objeto <see langword="ILGenerator" /> para este método.</returns>
      <exception cref="T:System.InvalidOperationException">El método no debe tener un cuerpo debido a sus marcas <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />, por ejemplo porque tiene la marca <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.
o bien
El método es un método genérico, pero no una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary>Devuelve las marcas de implementación para el método.</summary>
      <returns>Devuelve las marcas de implementación para el método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary>Devuelve los parámetros de este método.</summary>
      <returns>Matriz de objetos <see langword="ParameterInfo" /> que representan los parámetros del método.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see langword="GetParameters" /> en el valor devuelto <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary>Obtiene o establece un valor booleano que especifica si las variables locales de este método se inicializan en cero. El valor predeterminado de esta propiedad es <see langword="true" />.</summary>
      <returns>Es <see langword="true" /> si las variables locales de este método deben inicializarse en cero; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />. (Get o set.)</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Invoca dinámicamente al método que refleja esta instancia sobre el objeto dado, pasando los parámetros especificados y considerando las restricciones del enlazador dado.</summary>
      <param name="obj">Objeto donde debe invocarse al método especificado. Si el miembro es estático, se omite este parámetro.</param>
      <param name="invokeAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos MemberInfo mediante reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Para obtener más información, vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Lista de argumentos. Esta es una matriz de argumentos con el mismo número, orden y tipo que los parámetros del método al que se va a invocar. Si no hay ningún parámetro, este debería ser <see langword="null" />.</param>
      <param name="culture">Instancia de <see cref="T:System.Globalization.CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual. (Hay que tener en cuenta que esto es necesario, por ejemplo, a la hora de convertir <see cref="T:System.String" /> que representa a 1000 en un valor <see cref="T:System.Double" />, ya que 1000 aparece representado de forma diferente en distintas referencias culturales).</param>
      <returns>Devuelve un objeto que contiene el valor devuelto del método invocado.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> en el valor devuelto <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Comprueba si se define el tipo de atributo personalizado especificado.</summary>
      <param name="attributeType">Tipo de atributo personalizado.</param>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos personalizados.</param>
      <returns>
        <see langword="true" /> si se define el tipo de atributo personalizado especificado; si no, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el valor devuelto <see cref="T:System.Reflection.MethodInfo" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary>Obtiene un valor que indica si el método es un método genérico.</summary>
      <returns>Es <see langword="true" /> si el método es genérico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary>Obtiene un valor que indica si el actual objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> representa la definición de un método genérico.</summary>
      <returns>
        <see langword="true" /> si el objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> representa la definición de un método genérico; si no, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary>Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns>Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary>Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns>Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary>Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
      <returns>Devuelve <see cref="T:System.NotSupportedException" /> en todos los casos</returns>
      <exception cref="T:System.NotSupportedException">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary>Devuelve un método genérico construido a partir de la actual definición de método genérico utilizando los argumentos de tipo genérico especificados.</summary>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo del método genérico.</param>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método genérico construido a partir de la definición de método genérico actual mediante los argumentos de tipo genérico especificados.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary>Recupera el identificador interno para el método. Use este identificador para tener acceso al identificador de metadatos subyacente.</summary>
      <returns>Sólo lectura. Identificador interno para el método. Utilice este identificador para tener acceso al identificador de metadatos subyacente.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="P:System.Reflection.MethodBase.MethodHandle" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary>Obtiene el módulo en el que se define el método actual.</summary>
      <returns>
        <see cref="T:System.Reflection.Module" /> en que se define el miembro representado por la <see cref="T:System.Reflection.MemberInfo" /> actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary>Recupera el nombre de este método.</summary>
      <returns>Sólo lectura. Recupera una cadena que contiene el nombre sencillo de este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary>Recupera la clase utilizada en la reflexión para obtener este objeto.</summary>
      <returns>Sólo lectura. Tipo utilizado para obtener este método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto del método como, por ejemplo, cuando el tipo de valor devuelto tiene modificadores personalizados.</summary>
      <returns>Objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto.</returns>
      <exception cref="T:System.InvalidOperationException">No se creó el tipo declarativo.</exception>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary>Obtiene el tipo de valor devuelto del método representado por <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
      <returns>Tipo devuelto del método.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary>Devuelve los atributos personalizados del tipo de valor devuelto por el método.</summary>
      <returns>Sólo lectura. Atributos personalizados del tipo de valor devuelto por el método.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para describir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Establece las marcas de implementación para este método.</summary>
      <param name="attributes">Marcas de implementación que hay que establecer.</param>
      <exception cref="T:System.InvalidOperationException">El tipo contenedor se creó anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
O bien
Para el método actual, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary>Establece el número y los tipos de parámetros de un método.</summary>
      <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que representan los tipos de parámetros.</param>
      <exception cref="T:System.InvalidOperationException">El método actual es genérico, pero no es una definición de método genérico. Es decir, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary>Establece el tipo devuelto del método.</summary>
      <param name="returnType">Objeto <see cref="T:System.Type" /> que representa el tipo de valor devuelto del método.</param>
      <exception cref="T:System.InvalidOperationException">El método actual es genérico, pero no es una definición de método genérico. Es decir, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Establece la firma del método, incluidos el tipo de valor devuelto, los tipos de parámetros y los modificadores personalizados necesarios y opcionales de los tipos de parámetros y el tipo de valor devuelto.</summary>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="returnTypeRequiredCustomModifiers">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <exception cref="T:System.InvalidOperationException">El método actual es genérico, pero no es una definición de método genérico. Es decir, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary>Devuelve la instancia <see langword="MethodBuilder" /> como una cadena.</summary>
      <returns>Devuelve una cadena con el nombre, atributos, firma del método, excepciones y firma local de este método, seguido de una secuencia actual en Lenguaje intermedio de Microsoft (MSIL).</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary>Define y representa un módulo en un ensamblado dinámico.</summary>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary>Obtiene el ensamblado dinámico que definió esta instancia de <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      <returns>Ensamblado dinámico que definió el módulo dinámico actual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary>Finaliza las definiciones de funciones globales y las definiciones de datos globales para este módulo dinámico.</summary>
      <exception cref="T:System.InvalidOperationException">Se ha llamado anteriormente a este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Define un tipo de enumeración que consiste en un tipo de valor con un único campo no estático denominado <paramref name="value__" /> del tipo especificado.</summary>
      <param name="name">Ruta de acceso completa del tipo de enumeración. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="visibility">Atributos de tipo de la enumeración. Los atributos son los bits definidos por <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
      <param name="underlyingType">Tipo subyacente de la enumeración. Debe ser un tipo entero integrado.</param>
      <returns>Enumeración que se ha definido.</returns>
      <exception cref="T:System.ArgumentException">Se proporcionan atributos que no son de visibilidad.
o bien
Ya existe una enumeración con el nombre especificado en el ensamblado principal de este módulo.
o bien
Los atributos de visibilidad no coinciden con el ámbito de la enumeración. Por ejemplo, se especifica <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> para <paramref name="visibility" /> pero la enumeración no es un tipo anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Define un método global con el nombre, los atributos, la convención de llamada, el tipo de valor devuelto y los tipos de parámetro especificados.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del método. <paramref name="attributes" /> debe incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <returns>Método global que se ha definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático. Es decir, <paramref name="attributes" /> no incluye <see cref="F:System.Reflection.MethodAttributes.Static" />.
o bien
Un elemento de la matriz <see cref="T:System.Type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Define un método global con el nombre, los atributos, la convención de llamada, el tipo de valor devuelto, los modificadores personalizados del tipo de valor devuelto, los tipos de parámetro y los modificadores personalizados de los tipos de parámetro que se hayan especificado.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener caracteres null insertados.</param>
      <param name="attributes">Atributos del método. <paramref name="attributes" /> debe incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="requiredReturnTypeCustomModifiers">Matriz de tipos que representa los modificadores personalizados obligatorios para el tipo de valor devuelto, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> o <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="optionalReturnTypeCustomModifiers">Matriz de tipos que representa los modificadores personalizados opcionales para el tipo de valor devuelto, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> o <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="requiredParameterTypeCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente del método global. Si un argumento concreto no tiene modificadores personalizados obligatorios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si el método global no tiene ningún argumento, o si ninguno de los argumentos tiene modificadores personalizados obligatorios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="optionalParameterTypeCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente. Si un argumento concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si el método global no tiene ningún argumento, o si ninguno de los argumentos tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns>Método global que se ha definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático. Es decir, <paramref name="attributes" /> no incluye <see cref="F:System.Reflection.MethodAttributes.Static" />.
O bien
Un elemento de la matriz <see cref="T:System.Type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado previamente al método <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Define un método global con el nombre, los atributos, el tipo de valor devuelto y los tipos de parámetro especificados.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del método. <paramref name="attributes" /> debe incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <returns>Método global que se ha definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático. Es decir, <paramref name="attributes" /> no incluye <see cref="F:System.Reflection.MethodAttributes.Static" />.
o bien
La longitud de <paramref name="name" /> es cero.
o bien
Un elemento de la matriz <see cref="T:System.Type" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Define un campo de datos inicializado en la sección .sdata del archivo portable ejecutable (PE).</summary>
      <param name="name">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="data">Objeto binario grande (BLOB) de datos.</param>
      <param name="attributes">Los atributos para este campo. De manera predeterminada, es <see langword="Static" />.</param>
      <returns>Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
o bien
El tamaño de <paramref name="data" /> es menor o igual que cero o mayor o igual que 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> o <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define un método <see langword="PInvoke" /> con el nombre especificado, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamada del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <see langword="PInvoke" />.</summary>
      <param name="name">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv">Convención de llamada nativa.</param>
      <param name="nativeCharSet">Juego de caracteres nativo del método.</param>
      <returns>Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático o si el tipo contenedor es una interfaz.
O bien
Método abstracto.
o bien
El método se definió anteriormente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define un método <see langword="PInvoke" /> con el nombre especificado, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamada del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <see langword="PInvoke" />.</summary>
      <param name="name">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="entryName">El nombre del punto de entrada del archivo DLL.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv">Convención de llamada nativa.</param>
      <param name="nativeCharSet">Juego de caracteres nativo del método.</param>
      <returns>Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático o si el tipo contenedor es una interfaz o si el método es abstracto o si el método se ha definido previamente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary>Crea un <see langword="TypeBuilder" /> para un tipo privado con el nombre especificado en este módulo.</summary>
      <param name="name">Ruta de acceso completa del tipo, incluido el espacio de nombres. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <returns>Tipo privado con el nombre especificado.</returns>
      <exception cref="T:System.ArgumentException">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.
O bien
Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary>Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo y los atributos de tipo especificados.</summary>
      <param name="name">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo definido.</param>
      <returns>Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.
o bien
Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, sus atributos y el tipo que extiende el tipo definido.</summary>
      <param name="name">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributo que se va a asociar al tipo.</param>
      <param name="parent">Tipo que extiende el tipo definido.</param>
      <returns>Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.
O bien
Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido y el tamaño total del tipo.</summary>
      <param name="name">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo definido.</param>
      <param name="parent">Tipo que extiende el tipo definido.</param>
      <param name="typesize">Tamaño total del tipo.</param>
      <returns>Objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.
o bien
Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido y el tamaño de empaquetado del tipo.</summary>
      <param name="name">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo definido.</param>
      <param name="parent">Tipo que extiende el tipo definido.</param>
      <param name="packsize">Tamaño de empaquetado del tipo.</param>
      <returns>Objeto <see langword="TypeBuilder" />.</returns>
      <exception cref="T:System.ArgumentException">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.
o bien
Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido, el tamaño de empaquetado del tipo definido y el tamaño total del tipo definido.</summary>
      <param name="name">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo definido.</param>
      <param name="parent">Tipo que extiende el tipo definido.</param>
      <param name="packingSize">Tamaño de empaquetado del tipo.</param>
      <param name="typesize">Tamaño total del tipo.</param>
      <returns>Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.
o bien
Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Construye un <see langword="TypeBuilder" /> a partir del nombre de tipo, los atributos, el tipo que extiende el tipo definido y las interfaces que implementa el tipo definido.</summary>
      <param name="name">Ruta de acceso completa del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos que se van a asociar al tipo.</param>
      <param name="parent">Tipo que extiende el tipo definido.</param>
      <param name="interfaces">Lista de interfaces que implementa el tipo.</param>
      <returns>Objeto <see langword="TypeBuilder" /> creado con todos los atributos solicitados.</returns>
      <exception cref="T:System.ArgumentException">Existe un tipo con el nombre especificado en el ensamblado principal de este módulo.
o bien
Los atributos de tipo anidado se han establecido en un tipo que no está anidado.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Define un campo de datos sin inicializar en la sección .sdata del archivo portable ejecutable (PE).</summary>
      <param name="name">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null insertados.</param>
      <param name="size">Tamaño del campo de datos.</param>
      <param name="attributes">Los atributos para este campo.</param>
      <returns>Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
o bien
<paramref name="size" /> es menor o igual que cero, o mayor o igual que 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary>Devuelve un valor que indica si esta instancia es igual que el objeto especificado.</summary>
      <param name="obj">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
      <returns>Es <see langword="true" /> si <paramref name="obj" /> es igual al tipo y valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary>Obtiene un valor de tipo <see langword="String" /> que representa el nombre completo de este módulo y su ruta de acceso.</summary>
      <returns>Nombre completo del módulo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Devuelve el método con nombre en una clase de matriz.</summary>
      <param name="arrayClass">Clase de matriz.</param>
      <param name="methodName">Nombre de un método en la clase de matriz.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <returns>Método con nombre en una clase de matriz.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayClass" /> no es una matriz.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayClass" /> o <paramref name="methodName" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual.</summary>
      <param name="inherit">Se omite este argumento para los objetos de este tipo.</param>
      <returns>Matriz que contiene los atributos personalizados; la matriz está vacía si no hay ningún atributo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve todos los atributos personalizados que se aplicaron al <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual y que derivan de un tipo de atributo especificado.</summary>
      <param name="attributeType">Tipo base del que derivan los atributos.</param>
      <param name="inherit">Se omite este argumento para los objetos de este tipo.</param>
      <returns>Matriz que contiene los atributos personalizados que se derivan, en cualquier nivel, de <paramref name="attributeType" />; la matriz está vacía si no hay ningún atributo.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado por el tiempo de ejecución. Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary>Devuelve información sobre los atributos que se han aplicado al <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual, expresado como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
      <returns>Lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representan datos sobre los atributos que se aplicaron al módulo actual.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Devuelve un campo de nivel de módulo, definido en la región .sdata del archivo portable ejecutable (PE), que tiene el nombre y los atributos de enlace especificados.</summary>
      <param name="name">Nombre de campo.</param>
      <param name="bindingAttr">Combinación de las marcas de bits <see langword="BindingFlags" /> utilizadas para controlar la búsqueda.</param>
      <returns>Campo que tiene el nombre y los atributos de enlace especificados, o <see langword="null" /> si el campo no existe.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Devuelve todos los campos definidos en la región .sdata del archivo portable ejecutable (PE) que coinciden con las marcas de enlace especificadas.</summary>
      <param name="bindingFlags">Combinación de las marcas de bits <see langword="BindingFlags" /> utilizadas para controlar la búsqueda.</param>
      <returns>Matriz de campos que coinciden con las marcas especificadas; la matriz está vacía si no existe ninguno de esos campos.</returns>
      <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary>Devuelve el código hash de esta instancia.</summary>
      <returns>Código hash de un entero de 32 bits con signo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Devuelve todos los métodos definidos en el nivel de módulo para la clase <see cref="T:System.Reflection.Emit.ModuleBuilder" /> actual y que coinciden con las marcas de enlace especificadas.</summary>
      <param name="bindingFlags">Combinación de marcas de bits <see langword="BindingFlags" /> utilizadas para controlar la búsqueda.</param>
      <returns>Matriz que contiene todos los métodos de nivel de módulo que coinciden con <paramref name="bindingFlags" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary>Obtiene un par de valores que indican la naturaleza del código en un módulo y la plataforma de destino del módulo.</summary>
      <param name="peKind">El resultado de este método contiene una combinación de los valores <see cref="T:System.Reflection.PortableExecutableKinds" /> que indican la naturaleza del código en el módulo.</param>
      <param name="machine">El resultado de este método contiene uno de los valores de <see cref="T:System.Reflection.ImageFileMachine" /> que indican la plataforma destino del módulo.</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary>Obtiene el tipo con nombre definido en el módulo.</summary>
      <param name="className">Nombre del objeto <see cref="T:System.Type" /> que se va a obtener.</param>
      <returns>Devuelve el tipo solicitado si está definido en este módulo; de lo contrario, devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="className" /> es cero o es mayor que 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">El <see cref="T:System.Type" /> solicitado no es público y el llamador no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar objetos no públicos fuera del ensamblado actual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
      <exception cref="T:System.TypeLoadException">Se ha producido un error al cargar <see cref="T:System.Type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary>Obtiene el tipo con nombre definido en el módulo, con la opción de pasar por alto el uso de mayúsculas y minúsculas en el nombre de tipo.</summary>
      <param name="className">Nombre del objeto <see cref="T:System.Type" /> que se va a obtener.</param>
      <param name="ignoreCase">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns>Devuelve el tipo solicitado si está definido en este módulo; de lo contrario, devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="className" /> es cero o es mayor que 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">El <see cref="T:System.Type" /> solicitado no es público y el llamador no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar objetos no públicos fuera del ensamblado actual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Obtiene el tipo con nombre definido en el módulo, con la opción de pasar por alto el uso de mayúsculas y minúsculas en el nombre de tipo. De manera opcional, se produce una excepción si no se encuentra el tipo.</summary>
      <param name="className">Nombre del objeto <see cref="T:System.Type" /> que se va a obtener.</param>
      <param name="throwOnError">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />.</param>
      <param name="ignoreCase">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns>Devuelve el tipo especificado si está declarado en este módulo; de lo contrario, devuelve <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="className" /> es cero o es mayor que 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> es <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">El <see cref="T:System.Type" /> solicitado no es público y el llamador no tiene <see cref="T:System.Security.Permissions.ReflectionPermission" /> para reflejar objetos no públicos fuera del ensamblado actual.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
      <exception cref="T:System.TypeLoadException">El valor de <paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo especificado.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary>Devuelve todas las clases definidas en este módulo.</summary>
      <returns>Matriz que contiene los tipos definidos en el módulo reflejado por esta instancia.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">No se pudieron cargar una o más clases en un módulo.</exception>
      <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Devuelve un valor que indica si el tipo de atributo especificado se ha aplicado a este módulo.</summary>
      <param name="attributeType">Tipo de atributo personalizado que se va a probar.</param>
      <param name="inherit">Se omite este argumento para los objetos de este tipo.</param>
      <returns>Es <see langword="true" /> si se han aplicado una o varias instancias de <paramref name="attributeType" /> a este módulo; de lo contrario, es <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> no es un objeto <see cref="T:System.Type" /> proporcionado por el tiempo de ejecución. Por ejemplo, <paramref name="attributeType" /> es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary>Obtiene un valor que indica si el objeto es un recurso.</summary>
      <returns>Es <see langword="true" /> si el objeto es un recurso; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary>Obtiene la versión del flujo de metadatos.</summary>
      <returns>Entero de 32 bits que representa la versión del flujo de metadatos. Los dos bytes de orden superior representan el número de versión principal, mientras que los dos bytes de orden inferior representan el número de versión secundaria.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary>Obtiene un token que identifica el módulo dinámico actual en los metadatos.</summary>
      <returns>Token entero que identifica el módulo actual en los metadatos.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary>Obtiene un identificador único universal (UUID) que puede utilizarse para distinguir entre dos versiones de un módulo.</summary>
      <returns>
        <see cref="T:System.Guid" /> que se puede utilizar para distinguir entre dos versiones de un módulo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary>Cadena que indica que se trata de un módulo en memoria.</summary>
      <returns>Texto que indica que se trata de un módulo en memoria.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary>Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Token de metadatos que identifica un campo del módulo.</param>
      <param name="genericTypeArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns>Objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> no es un token válido para un campo en el ámbito del módulo actual.
o bien
<paramref name="metadataToken" /> identifica un campo cuyo <see langword="TypeSpec" /> primario tiene una firma que contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary>Devuelve el tipo o miembro identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Token de metadatos que identifica un tipo o integrante del módulo.</param>
      <param name="genericTypeArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns>Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el tipo o integrante identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> no es un token para un tipo o integrante en el ámbito del módulo actual.
o bien
<paramref name="metadataToken" /> es un <see langword="MethodSpec" /> o <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.
o bien
<paramref name="metadataToken" /> identifica una propiedad o evento.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary>Devuelve el método o constructor identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Token de metadatos que identifica un método o constructor en el módulo.</param>
      <param name="genericTypeArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns>Objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> no es un token para un método o constructor en el ámbito del módulo actual.
o bien
<paramref name="metadataToken" /> es un <see langword="MethodSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary>Devuelve el objeto binario de firma identificado por un token de metadatos.</summary>
      <param name="metadataToken">Token de metadatos que identifica una firma en el módulo.</param>
      <returns>Una matriz de bytes que representan el objeto binario de firma.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> no es un token <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, de firma o <see langword="FieldDef" /> válido en el ámbito del módulo actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary>Devuelve la cadena identificada por el token de metadatos especificado.</summary>
      <param name="metadataToken">Token de metadatos que identifica una cadena en el montón de cadena del módulo.</param>
      <returns>
        <see cref="T:System.String" /> que contiene un valor de cadena del montón de cadena de metadatos.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> no es un token de una cadena en el ámbito del módulo actual.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary>Devuelve el campo identificado por el token de metadatos especificado, en el contexto definido por los parámetros de tipo genérico especificados.</summary>
      <param name="metadataToken">Token de metadatos que identifica un tipo en el módulo.</param>
      <param name="genericTypeArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del tipo en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho tipo no es genérico.</param>
      <param name="genericMethodArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo genérico del método en cuyo ámbito se encuentra el token; o es <see langword="null" /> si dicho método no es genérico.</param>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo identificado por el token de metadatos especificado.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> no es un token válido para un tipo en el ámbito del módulo actual.
o bien
<paramref name="metadataToken" /> es un <see langword="TypeSpec" /> cuya firma contiene el tipo de elemento <see langword="var" /> (un parámetro de tipo de un tipo genérico) o <see langword="mvar" /> (un parámetro de tipo de un método genérico) y no se proporcionaron los argumentos de tipo genérico necesarios para uno o ambos parámetros <paramref name="genericTypeArguments" /> y <paramref name="genericMethodArguments" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> no es un token válido en el ámbito del módulo actual.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary>Obtiene una cadena que representa el nombre del módulo dinámico.</summary>
      <returns>Nombre del módulo dinámico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Aplica un atributo personalizado a este módulo utilizando el objeto binario grande (BLOB) especificado que representa el atributo.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">BLOB de bytes que representa el atributo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Aplica un atributo personalizado a este módulo utilizando un generador de atributos personalizados.</summary>
      <param name="customBuilder">Instancia de una clase del asistente que especifica el atributo personalizado que se va a aplicar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary>Define las propiedades de un tipo.</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Agrega uno de los otros métodos asociados a esta propiedad.</summary>
      <param name="mdBuilder">Objeto <see langword="MethodBuilder" /> que representa el otro método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary>Obtiene los atributos de esta propiedad.</summary>
      <returns>Atributos de esta propiedad.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary>Obtiene un valor que indica si se puede leer la propiedad.</summary>
      <returns>Es <see langword="true" /> si se puede leer esta propiedad; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary>Obtiene un valor que indica si se puede escribir en la propiedad.</summary>
      <returns>Es <see langword="true" /> si se puede escribir en esta propiedad; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary>Obtiene la clase que declara este miembro.</summary>
      <returns>Objeto <see langword="Type" /> de la clase que declara este miembro.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary>Devuelve una matriz de los descriptores de acceso <see langword="get" /> y <see langword="set" /> públicos y no públicos en esta propiedad.</summary>
      <param name="nonPublic">Indica si se deben devolver métodos que no sean públicos en la matriz <see langword="MethodInfo" />. <see langword="true" /> si los métodos no públicos deben incluirse; de lo contrario, <see langword="false" />.</param>
      <returns>Matriz de tipo <see langword="MethodInfo" /> que contiene los descriptores de acceso públicos y no públicos coincidentes, o una matriz vacía si no existen descriptores de acceso coincidentes en esta propiedad.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve una matriz de todos los atributos personalizados de esta propiedad.</summary>
      <param name="inherit">Si es <see langword="true" />, asciende por la cadena de herencia de esta propiedad para buscar los atributos personalizados.</param>
      <returns>Matriz de todos los atributos personalizados.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve una matriz de atributos personalizados identificados por <see cref="T:System.Type" />.</summary>
      <param name="attributeType">Matriz de atributos personalizados identificados según el tipo.</param>
      <param name="inherit">Si es <see langword="true" />, asciende por la cadena de herencia de esta propiedad para buscar los atributos personalizados.</param>
      <returns>Matriz de atributos personalizados definidos en este miembro reflejado, o <see langword="null" /> si no hay atributos definidos en este miembro.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary>Devuelve el descriptor de acceso get público y no público de esta propiedad.</summary>
      <param name="nonPublic">Indica si se deben devolver descriptores de acceso get que no sean públicos. <see langword="true" /> si los métodos no públicos deben incluirse; de lo contrario, <see langword="false" />.</param>
      <returns>Objeto <see langword="MethodInfo" /> que representa el descriptor de acceso get de esta propiedad si <paramref name="nonPublic" /> es <see langword="true" />. Devuelve <see langword="null" /> si <paramref name="nonPublic" /> es <see langword="false" /> y el descriptor de acceso get no es público, o si <paramref name="nonPublic" /> es <see langword="true" /> pero no existe ningún descriptor de acceso get.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary>Devuelve una matriz de todos los parámetros de índice de la propiedad.</summary>
      <returns>Matriz de tipo <see langword="ParameterInfo" /> que contiene los parámetros de los índices.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary>Devuelve el descriptor de acceso establecido de esta propiedad.</summary>
      <param name="nonPublic">Indica si se debe devolver el descriptor de acceso si es no público. <see langword="true" /> si los métodos no públicos deben incluirse; de lo contrario, <see langword="false" />.</param>
      <returns>Método <see langword="Set" /> de la propiedad, o <see langword="null" />, como se muestra en la tabla siguiente.
  Valor 
  Condición 
  Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método Set de esta propiedad.  
  
  El descriptor de acceso set es público.  
  
 <paramref name="nonPublic" /> es true y se pueden devolver métodos no públicos.  
  
  nulo 
 <paramref name="nonPublic" /> es true, pero la propiedad es de sólo lectura.  
  
 <paramref name="nonPublic" /> es falso y el descriptor de acceso establecido no es público.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary>Obtiene el valor de la propiedad indizada llamando al método Get de la propiedad.</summary>
      <param name="obj">Objeto cuyo valor de propiedad se va a devolver.</param>
      <param name="index">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <returns>Valor de la propiedad indizada especificada.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Obtiene el valor de una propiedad con el enlace, índice y <see langword="CultureInfo" /> especificados.</summary>
      <param name="obj">Objeto cuyo valor de propiedad se va a devolver.</param>
      <param name="invokeAttr">Atributo de invocación. Debe ser un marcador de bits de <see langword="BindingFlags" />: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />. Debe especificarse un atributo de invocación apropiado. Si se va a invocar un miembro estático, se debe establecer la marca <see langword="Static" /> de <see langword="BindingFlags" />.</param>
      <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
      <param name="index">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <param name="culture">Objeto <see langword="CultureInfo" /> que representa la referencia cultural para la que se va a buscar el recurso. Observe que si no se encuentra el recurso correspondiente a esta referencia cultural, se llamará sucesivamente al método <see langword="CultureInfo.Parent" /> para buscar una coincidencia. Si este valor es <see langword="null" />, <see langword="CultureInfo" /> se obtiene a partir de la propiedad <see langword="CultureInfo.CurrentUICulture" />.</param>
      <returns>Valor de propiedad de <paramref name="obj" />.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Indica si se han definido una o varias instancias de <paramref name="attributeType" /> en esta propiedad.</summary>
      <param name="attributeType">Objeto <see langword="Type" /> al que se aplican los atributos personalizados.</param>
      <param name="inherit">Especifica si se va ascender por la cadena de herencia de esta propiedad para buscar los atributos personalizados.</param>
      <returns>
        <see langword="true" /> si se han definido una o varias instancias de <paramref name="attributeType" /> en esta propiedad; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary>Obtiene el módulo en el que se está definiendo el tipo que declara la propiedad actual.</summary>
      <returns>Clase <see cref="T:System.Reflection.Module" /> en la que se define el tipo que declara la propiedad actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary>Obtiene el nombre de este miembro.</summary>
      <returns>
        <see cref="T:System.String" /> que contiene el nombre de este miembro.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary>Obtiene el tipo del campo de esta propiedad.</summary>
      <returns>Tipo de esta propiedad.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary>Obtiene el objeto de la clase utilizado para obtener esta instancia de <see langword="MemberInfo" />.</summary>
      <returns>Objeto <see langword="Type" /> a través del cual se obtuvo este objeto <see langword="MemberInfo" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary>Establece el valor predeterminado de esta propiedad.</summary>
      <param name="defaultValue">Valor predeterminado de esta propiedad.</param>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
      <exception cref="T:System.ArgumentException">La propiedad no es uno de los tipos admitidos.
O bien
El tipo de <paramref name="defaultValue" /> no coincide con el tipo de la propiedad.
O bien
La propiedad es de tipo <see cref="T:System.Object" /> o de otro tipo de referencia, el valor de <paramref name="defaultValue" /> no es <see langword="null" /> y el valor no se puede asignar al tipo de referencia.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">si se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Establece el método que obtiene el valor de propiedad.</summary>
      <param name="mdBuilder">Objeto <see langword="MethodBuilder" /> que representa el método que obtiene el valor de propiedad.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Establece el método que define el valor de propiedad.</summary>
      <param name="mdBuilder">Objeto <see langword="MethodBuilder" /> que representa el método que establece el valor de propiedad.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> en el tipo envolvente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary>Establece el valor de la propiedad con valores de índice opcionales para propiedades indizadas.</summary>
      <param name="obj">Objeto cuyo valor de propiedad se va a establecer.</param>
      <param name="value">Nuevo valor de esta propiedad.</param>
      <param name="index">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Establece el valor de propiedad del objeto especificado en el valor indicado.</summary>
      <param name="obj">Objeto cuyo valor de propiedad se va a devolver.</param>
      <param name="value">Nuevo valor de esta propiedad.</param>
      <param name="invokeAttr">Atributo de invocación. Debe ser un marcador de bits de <see langword="BindingFlags" />: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />. Debe especificarse un atributo de invocación apropiado. Si se va a invocar un miembro estático, se debe establecer la marca <see langword="Static" /> de <see langword="BindingFlags" />.</param>
      <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
      <param name="index">Valores de índice opcionales para propiedades indizadas. Este valor debe ser <see langword="null" /> para propiedades no indizadas.</param>
      <param name="culture">Objeto <see langword="CultureInfo" /> que representa la referencia cultural para la que se va a buscar el recurso. Observe que si no se encuentra el recurso correspondiente a esta referencia cultural, se llamará sucesivamente al método <see langword="CultureInfo.Parent" /> para buscar una coincidencia. Si este valor es <see langword="null" />, <see langword="CultureInfo" /> se obtiene a partir de la propiedad <see langword="CultureInfo.CurrentUICulture" />.</param>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary>Define y crea nuevas instancias de clases en tiempo de ejecución.</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary>Agrega una interfaz que implementa este tipo.</summary>
      <param name="interfaceType">La interfaz que implementa este tipo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="interfaceType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary>Recupera el ensamblado dinámico que contiene esta definición de tipo.</summary>
      <returns>Sólo lectura. Recupera el ensamblado dinámico que contiene esta definición de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary>Devuelve el nombre completo del tipo calificado por el nombre para mostrar del ensamblado.</summary>
      <returns>Sólo lectura. Nombre completo del tipo calificado por el nombre para mostrar del ensamblado.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary>Recupera el tipo base de este tipo.</summary>
      <returns>Sólo lectura. Recupera el tipo base de este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary>Crea un objeto <see cref="T:System.Type" /> para esta clase. Después de definir los campos y métodos en la clase, se llama a <see langword="CreateType" /> para cargar su objeto <see langword="Type" />.</summary>
      <returns>Devuelve el nuevo objeto <see cref="T:System.Type" /> para esta clase.</returns>
      <exception cref="T:System.InvalidOperationException">No se ha creado el tipo envolvente.
O bien
Este tipo no es abstracto y contiene un método abstracto.
o bien
Este tipo no es una clase o interfaz abstracta y tiene un método sin cuerpo de método.</exception>
      <exception cref="T:System.ArgumentException">Contenido de etiqueta incorrecto en <see cref="T:System.Reflection.Emit.ILGenerator" />: Ha definido una etiqueta sin llamar a <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />.</exception>
      <exception cref="T:System.NotSupportedException">El tipo contiene código de Lenguaje Intermedio de Microsoft (MSIL) no válido.
o bien
El destino de bifurcación se especifica con un desplazamiento de 1 byte, pero el destino está a una distancia superior a 127 bytes de la bifurcación.</exception>
      <exception cref="T:System.TypeLoadException">No se puede cargar el tipo. Por ejemplo, contiene un método <see langword="static" /> con la convención de llamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary>Obtiene un objeto <see cref="T:System.Reflection.TypeInfo" /> que representa este tipo.</summary>
      <returns>Un objeto que representa este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary>Obtiene el método que declaró el parámetro de tipo genérico actual.</summary>
      <returns>Un <see cref="T:System.Reflection.MethodBase" /> que representa el método que declaró el tipo actual, si el tipo actual es un parámetro de tipo genérico; de lo contrario, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary>Devuelve el tipo que declaró este tipo.</summary>
      <returns>Sólo lectura. Tipo que declaró este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary>Agrega un nuevo constructor al tipo, con los atributos y firma especificados.</summary>
      <param name="attributes">Atributos del constructor.</param>
      <param name="callingConvention">Convención de llamada del constructor.</param>
      <param name="parameterTypes">Tipos de parámetro del constructor.</param>
      <returns>El constructor definido.</returns>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary>Agrega un nuevo constructor al tipo, con los atributos, la firma y los modificadores personalizados especificados.</summary>
      <param name="attributes">Atributos del constructor.</param>
      <param name="callingConvention">Convención de llamada del constructor.</param>
      <param name="parameterTypes">Tipos de parámetro del constructor.</param>
      <param name="requiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="optionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns>El constructor definido.</returns>
      <exception cref="T:System.ArgumentException">El tamaño de <paramref name="requiredCustomModifiers" /> o <paramref name="optionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
O bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary>Define el constructor sin parámetros. El constructor que se define aquí simplemente llamará al constructor sin parámetros del elemento primario.</summary>
      <param name="attributes">Un objeto <see langword="MethodAttributes" /> que representa los atributos que se aplicarán al constructor.</param>
      <returns>Devuelve el constructor.</returns>
      <exception cref="T:System.NotSupportedException">El tipo de elemento primario (tipo base) no tiene un constructor sin parámetros.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
O bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary>Agrega un nuevo evento al tipo, con el nombre, los atributos y el tipo de evento especificados.</summary>
      <param name="name">Nombre del evento. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del evento.</param>
      <param name="eventtype">Tipo del evento.</param>
      <returns>Evento definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.
O bien
<paramref name="eventtype" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>Agrega un nuevo campo al tipo, con el nombre, los atributos y el tipo de campo especificados.</summary>
      <param name="fieldName">Nombre del campo. <paramref name="fieldName" /> no puede contener valores null incrustados.</param>
      <param name="type">Tipo del campo.</param>
      <param name="attributes">Atributos del campo.</param>
      <returns>Campo definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="fieldName" /> es cero.
o bien
<paramref name="type" /> es System.Void.
O bien
Se especificó un tamaño total de la clase primaria de este campo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary>Agrega un nuevo campo al tipo, con el nombre, los atributos, el tipo de campo y os modificadores personalizados especificados.</summary>
      <param name="fieldName">Nombre del campo. <paramref name="fieldName" /> no puede contener valores null incrustados.</param>
      <param name="type">Tipo del campo.</param>
      <param name="requiredCustomModifiers">Matriz de tipos que representan los modificadores personalizados necesarios para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="optionalCustomModifiers">Matriz de tipos que representan los modificadores personalizados opcionales para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="attributes">Atributos del campo.</param>
      <returns>Campo definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="fieldName" /> es cero.
O bien
<paramref name="type" /> es System.Void.
o bien
Se especificó un tamaño total de la clase primaria de este campo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary>Define los parámetros de tipo genérico para el tipo actual, especificando su número y sus nombres y devuelve una matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que pueden usarse para establecer sus restricciones.</summary>
      <param name="names">Una matriz de nombres para los parámetros de tipo genérico.</param>
      <returns>Una matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que pueden usarse para definir las restricciones de los parámetros de tipo genérico para el tipo actual.</returns>
      <exception cref="T:System.InvalidOperationException">Los parámetros de tipo genérico ya se han definido para este tipo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> es <see langword="null" />.
o bien
Un elemento de <paramref name="names" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> es una matriz vacía.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Define el campo de datos inicializado en la sección .sdata del archivo ejecutable portable (PE).</summary>
      <param name="name">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="data">El blob de datos.</param>
      <param name="attributes">Los atributos para este campo.</param>
      <returns>Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
o bien
El tamaño de los datos es menor o igual que cero, o mayor o igual que 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> o <paramref name="data" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary>Agrega un nuevo método al tipo, con el nombre especificado y los atributos de método.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del método.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
o bien
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
o bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary>Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método y la convención de llamada.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
O bien
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
O bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método, la convención de llamada y la firma del método.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
o bien
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
o bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método, la convención de llamada, la firma del método y los modificadores personalizados.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="returnTypeRequiredCustomModifiers">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns>Un objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién agregado.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
O bien
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).
o bien
El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
o bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método y la firma del método.</summary>
      <param name="name">Nombre del método. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="returnType">Tipo devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <returns>Método definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
o bien
El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
o bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>Especifica un cuerpo de método determinado que implementa una declaración de método concreta, posiblemente con otro nombre.</summary>
      <param name="methodInfoBody">Cuerpo del método que se va a usar. Debería ser un objeto <see langword="MethodBuilder" /> .</param>
      <param name="methodInfoDeclaration">Método cuya declaración se va a usar.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodInfoBody" /> no pertenece a esta clase.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="methodInfoBody" /> o <paramref name="methodInfoDeclaration" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
O bien
El tipo declarativo de <paramref name="methodInfoBody" /> no es del tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary>Define un tipo anidado, dado su nombre.</summary>
      <param name="name">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <returns>El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero o mayor que 1023.
o bien
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary>Define un tipo anidado, dado su nombre y atributos.</summary>
      <param name="name">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo.</param>
      <returns>El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException">No se especificó el atributo anidado.
O bien
Este tipo está sellado.
o bien
Este tipo es una matriz.
o bien
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.
o bien
La longitud de <paramref name="name" /> es cero o mayor que 1023.
o bien
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Define un tipo anidado, dado su nombre, sus atributos y el tipo que extiende.</summary>
      <param name="name">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo.</param>
      <param name="parent">El tipo que extiende el tipo anidado.</param>
      <returns>El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException">No se especificó el atributo anidado.
o bien
Este tipo está sellado.
o bien
Este tipo es una matriz.
O bien
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.
o bien
La longitud de <paramref name="name" /> es cero o mayor que 1023.
o bien
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Define un tipo anidado, dados su nombre, sus atributos, el tamaño total del tipo y el tipo que extiende.</summary>
      <param name="name">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo.</param>
      <param name="parent">El tipo que extiende el tipo anidado.</param>
      <param name="typeSize">Tamaño total del tipo.</param>
      <returns>El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException">No se especificó el atributo anidado.
o bien
Este tipo está sellado.
o bien
Este tipo es una matriz.
o bien
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.
O bien
La longitud de <paramref name="name" /> es cero o mayor que 1023.
O bien
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Define un tipo anidado, dado su nombre, sus atributos, el tipo que extiende y el tamaño de empaquetado.</summary>
      <param name="name">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo.</param>
      <param name="parent">El tipo que extiende el tipo anidado.</param>
      <param name="packSize">Tamaño de empaquetado del tipo.</param>
      <returns>El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException">No se especificó el atributo anidado.
o bien
Este tipo está sellado.
o bien
Este tipo es una matriz.
o bien
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.
o bien
La longitud de <paramref name="name" /> es cero o mayor que 1023.
o bien
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Define un tipo anidado, dado su nombre, atributos, tamaño y el tipo que extiende.</summary>
      <param name="name">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null insertados.</param>
      <param name="attr">Atributos del tipo.</param>
      <param name="parent">El tipo que extiende el tipo anidado.</param>
      <param name="packSize">Tamaño de empaquetado del tipo.</param>
      <param name="typeSize">Tamaño total del tipo.</param>
      <returns>El tipo anidado definido.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Define un tipo anidado, dados su nombre, sus atributos, el tipo que extiende y las interfaces que implementa.</summary>
      <param name="name">Nombre corto del tipo. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attr">Atributos del tipo.</param>
      <param name="parent">El tipo que extiende el tipo anidado.</param>
      <param name="interfaces">Las interfaces que implementa el tipo anidado.</param>
      <returns>El tipo anidado definido.</returns>
      <exception cref="T:System.ArgumentException">No se especificó el atributo anidado.
o bien
Este tipo está sellado.
o bien
Este tipo es una matriz.
o bien
Este tipo es una interfaz, pero el tipo anidado no es una interfaz.
O bien
La longitud de <paramref name="name" /> es cero o mayor que 1023.
o bien
Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.
O bien
Un elemento de la matriz <paramref name="interfaces" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método y las marcas <see langword="PInvoke" />.</summary>
      <param name="name">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv">Convención de llamada nativa.</param>
      <param name="nativeCharSet">Juego de caracteres nativo del método.</param>
      <returns>Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático.
o bien
El tipo principal es una interfaz.
o bien
Método abstracto.
o bien
El método se definió anteriormente.
o bien
La longitud de <paramref name="name" /> o <paramref name="dllName" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método y las marcas <see langword="PInvoke" />.</summary>
      <param name="name">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="entryName">El nombre del punto de entrada del archivo DLL.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo de valor devuelto del método.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="nativeCallConv">Convención de llamada nativa.</param>
      <param name="nativeCharSet">Juego de caracteres nativo del método.</param>
      <returns>Método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático.
o bien
El tipo principal es una interfaz.
O bien
Método abstracto.
o bien
El método se definió anteriormente.
o bien
La longitud de <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][])">
      <summary>Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método, las marcas <see langword="PInvoke" /> y los modificadores personalizados para los parámetros y el tipo de valor devuelto.</summary>
      <param name="name">Nombre del método <see langword="PInvoke" />. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="dllName">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</param>
      <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="nativeCallConv">Convención de llamada nativa.</param>
      <param name="nativeCharSet">Juego de caracteres nativo del método.</param>
      <param name="entryName">El nombre del punto de entrada del archivo DLL.</param>
      <param name="attributes">Atributos del método.</param>
      <param name="callingConvention">Convención de llamada del método.</param>
      <param name="returnType">Tipo de valor devuelto del método.</param>
      <param name="returnTypeRequiredCustomModifiers">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Tipos de los parámetros del método.</param>
      <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método <see langword="PInvoke" /> definido.</returns>
      <exception cref="T:System.ArgumentException">El método no es estático.
O bien
El tipo principal es una interfaz.
o bien
Método abstracto.
O bien
El método se definió anteriormente.
o bien
La longitud de <paramref name="name" />, <paramref name="dllName" />o <paramref name="entryName" /> es cero.
o bien
El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
o bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Agrega una nueva propiedad al tipo, con el nombre, atributos, convención de llamada y firma de la propiedad especificados.</summary>
      <param name="name">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos de la propiedad.</param>
      <param name="callingConvention">Convención de llamada de los descriptores de acceso de la propiedad.</param>
      <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
      <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
      <returns>Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.
o bien
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Agrega una nueva propiedad al tipo, con el nombre proporcionado, la convención de llamada, la firma de la propiedad y los modificadores personalizados.</summary>
      <param name="name">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos de la propiedad.</param>
      <param name="callingConvention">Convención de llamada de los descriptores de acceso de la propiedad.</param>
      <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
      <param name="returnTypeRequiredCustomModifiers">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
      <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns>Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.
O bien
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary>Agrega una nueva propiedad al tipo, con el nombre proporcionado y la firma de la propiedad.</summary>
      <param name="name">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos de la propiedad.</param>
      <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
      <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
      <returns>Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.
o bien
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Agrega una nueva propiedad al tipo, con el nombre proporcionado, la firma de la propiedad y los modificadores especificados.</summary>
      <param name="name">Nombre de la propiedad. <paramref name="name" /> no puede contener valores null incrustados.</param>
      <param name="attributes">Atributos de la propiedad.</param>
      <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
      <param name="returnTypeRequiredCustomModifiers">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
      <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
      <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
      <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
      <returns>Propiedad definida.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />
O bien
Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary>Define el inicializador para este tipo.</summary>
      <returns>Devuelve un inicializador de tipo.</returns>
      <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Define un campo de datos inicializado en la sección <see langword=".sdata" /> del archivo portable ejecutable (PE).</summary>
      <param name="name">El nombre que se usa para hacer referencia a los datos. <paramref name="name" /> no puede contener valores null insertados.</param>
      <param name="size">Tamaño del campo de datos.</param>
      <param name="attributes">Los atributos para este campo.</param>
      <returns>Campo para hacer referencia a los datos.</returns>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.
O bien
<paramref name="size" /> es menor o igual que cero, o mayor o igual que 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary>Recupera la ruta de acceso completa de este tipo.</summary>
      <returns>Sólo lectura. Recupera la ruta de acceso completa de este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary>Obtiene un valor que indica la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</summary>
      <returns>Combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary>Obtiene la posición de un parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro.</summary>
      <returns>Si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico, la posición del parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro; en otro caso, sin definir.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary>Devuelve el constructor del tipo genérico construido especificado que corresponde al constructor especificado de la definición de tipo genérico.</summary>
      <param name="type">Tipo genérico construido cuyo constructor se devuelve.</param>
      <param name="constructor">Constructor de la definición de tipo genérico de <paramref name="type" />, que especifica qué constructor de <paramref name="type" /> devolver.</param>
      <returns>Objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor de <paramref name="type" /> correspondiente a <paramref name="constructor" />, que especifica un constructor perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> no representa un tipo genérico.
o bien
<paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.
o bien
El tipo declarativo de <paramref name="constructor" /> no es una definición de tipo genérico.
o bien
El tipo declarativo de <paramref name="constructor" /> no es una definición de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores públicos y no públicos definidos para esta clase, tal como se especifica.</summary>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representan los constructores especificados definidos para esta clase. Si no se definen constructores, se devuelve una matriz vacía.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Devuelve todos los atributos personalizados definidos para este tipo.</summary>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>Devuelve una matriz de objetos que representan todos los atributos personalizados de este tipo.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente para tipos incompletos. Recupere el tipo mediante <see cref="M:System.Type.GetType" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el <see cref="T:System.Type" /> devuelto.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Devuelve todos los atributos personalizados del tipo actual que se pueden asignar a un tipo especificado.</summary>
      <param name="attributeType">El tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>Una matriz de atributos personalizados definidos en el tipo actual.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente para tipos incompletos. Recupere el tipo mediante <see cref="M:System.Type.GetType" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el <see cref="T:System.Type" />devuelto.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">El tipo debe ser un tipo proporcionado por el sistema en tiempo de ejecución subyacente.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary>Cuando se llama a este método, siempre se produce <see cref="T:System.NotSupportedException" />.</summary>
      <returns>No se admite este método. No se devuelve ningún valor.</returns>
      <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Devuelve el evento con el nombre especificado.</summary>
      <param name="name">Nombre del evento que se va a buscar.</param>
      <param name="bindingAttr">Combinación bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</param>
      <returns>Objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento declarado o heredado por este tipo con el nombre especificado, o <see langword="null" /> si no hay ninguna coincidencia.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary>Devuelve los eventos públicos declarados o heredados por este tipo.</summary>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representan los eventos públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay eventos públicos.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Devuelve los eventos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr">Combinación bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.EventInfo" /> objetos que representan los eventos declarados o heredados por este tipo que coinciden con los marcadores de enlace especificados. Se devuelve una matriz vacía si no hay eventos coincidentes.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Devuelve el campo especificado por el nombre facilitado.</summary>
      <param name="name">Nombre del campo que se va a obtener.</param>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo declarado o heredado por este tipo con el nombre especificado y el modificador público o no público. Si no existen coincidencias, se devuelve <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary>Devuelve el campo del tipo genérico construido especificado que corresponde al campo especificado de la definición de tipo genérico.</summary>
      <param name="type">Tipo genérico construido cuyo campo se devuelve.</param>
      <param name="field">Campo de la definición de tipo genérico de <paramref name="type" />, que especifica qué campo de <paramref name="type" /> se va a devolver.</param>
      <returns>Objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo de <paramref name="type" /> correspondiente a <paramref name="field" />, que especifica un campo perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> no representa un tipo genérico.
o bien
<paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.
o bien
El tipo declarativo de <paramref name="field" /> no es una definición de tipo genérico.
O bien
El tipo declarativo de <paramref name="field" /> no es una definición de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Devuelve los campos públicos y no públicos declarados por este tipo.</summary>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.FieldInfo" /> objetos que representan los campos públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún campo,  como se especifica.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</summary>
      <returns>Matriz de objetos <see cref="T:System.Type" />. Los elementos de la matriz representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</returns>
      <exception cref="T:System.InvalidOperationException">El tipo actual no es genérico. Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> devuelve <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Devuelve la interfaz implementada por esta clase (directa o indirectamente) con el nombre completo que coincide con el nombre de la interfaz dada.</summary>
      <param name="name">Nombre de la interfaz.</param>
      <param name="ignoreCase">Si <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
      <returns>Devuelve un objeto <see cref="T:System.Type" /> que representa las interfaz implementada. Devuelve null si no se encuentra ningún nombre de interfaz coincidente.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary>Devuelve una asignación de interfaz para la interfaz solicitada.</summary>
      <param name="interfaceType">
        <see cref="T:System.Type" /> de interfaz para la que se debe recuperar la asignación.</param>
      <returns>Devuelve la asignación de interfaz solicitada.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary>Devuelve una matriz de todas las interfaces implementadas en este tipo y sus tipos base.</summary>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan las interfaces implementadas. Si no hay ninguna definida, se devuelve una matriz vacía.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Devuelve todos los miembros públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
      <param name="name">Nombre del miembro.</param>
      <param name="type">Tipo del miembro que se va a devolver.</param>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representan los miembros públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los miembros públicos.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Devuelve los miembros para los miembros públicos y no públicos declarados o heredados por este tipo.</summary>
      <param name="bindingAttr">Debe ser una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos y no públicos declarados o heredados por este tipo. Se devuelve una matriz vacía si no hay ningún miembro coincidente.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>Devuelve el método del tipo genérico construido especificado que corresponde al método especificado de la definición de tipo genérico.</summary>
      <param name="type">Tipo genérico construido cuyo método se devuelve.</param>
      <param name="method">Método de la definición de tipo genérico de <paramref name="type" />, que especifica qué método de <paramref name="type" /> devolver.</param>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de <paramref name="type" /> correspondiente a <paramref name="method" />, que especifica un método perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> es un método genérico que no es una definición de método genérico.
o bien
<paramref name="type" /> no representa un tipo genérico.
o bien
<paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.
o bien
El tipo declarativo de <paramref name="method" /> no es una definición de tipo genérico.
o bien
El tipo declarativo de <paramref name="method" /> no es una definición de tipo genérico de <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Devuelve todos los métodos públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de <see cref="T:System.Reflection.MethodInfo" /> objetos que representan los métodos públicos y no públicos definidos en este tipo si <paramref name="nonPublic" /> se usa; en caso contrario, se devuelven solo los métodos públicos.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Devuelve los tipos anidados públicos y no públicos declarados por este tipo.</summary>
      <param name="name">
        <see cref="T:System.String" /> que contiene el nombre del tipo anidado que se va a obtener.</param>
      <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.
o bien
Cero, para realizar una búsqueda de los métodos públicos que distinga entre mayúsculas y minúsculas.</param>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo anidado que cumple los requisitos especificados, si se encuentra; en caso contrario, <see langword="null" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Devuelve los tipos anidados públicos y no públicos declarados o heredados por este tipo.</summary>
      <param name="bindingAttr">Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Matriz de objetos <see cref="T:System.Type" /> que representa a todos los tipos anidados del objeto <see cref="T:System.Type" /> actual que coinciden con las restricciones de enlace especificadas.
Matriz vacía de tipo <see cref="T:System.Type" />, si no hay tipos anidados dentro del actual <see cref="T:System.Type" />, o si ninguno de los tipos anidados coincide con las limitaciones de enlace.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Devuelve todas las propiedades públicas y no públicas declaradas o heredadas por este tipo, como se especifica.</summary>
      <param name="bindingAttr">Este atributo de invocación. Debe ser un indicador de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
      <returns>Devuelve una matriz de objetos <see langword="PropertyInfo" /> que representan las propiedades públicas y no públicas definidas en este tipo si se usa <paramref name="nonPublic" />; en caso contrario, solo se devuelven las propiedades públicas.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se implementa para tipos incompletos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary>Recupera el GUID de este tipo.</summary>
      <returns>Sólo lectura. Recupera el GUID de este tipo.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Invoca el miembro especificado. El método que se va a invocar debe ser accesible y proporcionar la coincidencia más específica con la lista de argumentos dada, bajo las restricciones del enlazador y los atributos de invocación indicados.</summary>
      <param name="name">Nombre del miembro que se va a invocar. Puede ser un constructor, un método, una propiedad o un campo. Debe especificarse un atributo de invocación apropiado. Tenga en cuenta que es posible invocar al miembro predeterminado de una clase pasando una cadena vacía como el nombre del miembro.</param>
      <param name="invokeAttr">Atributo de invocación. Debe ser un indicador de bits de <see langword="BindingFlags" />.</param>
      <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si el enlazador es <see langword="null" />, se usará el enlazador predeterminado. Vea <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Objeto donde debe invocarse al miembro especificado. Si el miembro es estático, se ignora este parámetro.</param>
      <param name="args">Lista de argumentos. Se trata de una matriz de objetos que contiene el número, orden y tipo de los parámetros del miembro que se va a invocar. Si no hay ningún parámetro, este valor debe ser null.</param>
      <param name="modifiers">Matriz de la misma longitud que <paramref name="args" /> con elementos que representan los atributos asociados a los argumentos del miembro que se va a invocar. Un parámetro tiene atributos asociados a él en los metadatos. Los usan varios servicios de interoperabilidad. Consulte las especificaciones de metadatos para obtener más detalles.</param>
      <param name="culture">Instancia de <see langword="CultureInfo" /> usada para regir la conversión de tipos. Si es null, se utiliza <see langword="CultureInfo" /> para el subproceso actual. (Por ejemplo, esto es necesario para convertir un tipo String que representa 1000 en un valor Double, dado que 1000 se representa de manera diferente según la referencia cultural).</param>
      <param name="namedParameters">Cada parámetro de la matriz <paramref name="namedParameters" /> obtiene el valor del elemento correspondiente en la matriz <paramref name="args" />. Si la longitud de <paramref name="args" /> es mayor que la longitud de <paramref name="namedParameters" />, los valores de argumento restantes se pasan por orden.</param>
      <returns>Devuelve el valor devuelto del miembro invocado.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente para tipos incompletos.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary>Obtiene un valor que indica si se puede asignar a este objeto un <see cref="T:System.Type" /> especificado a este objeto.</summary>
      <param name="c">El objeto que se va a probar.</param>
      <returns>
        <see langword="true" /> si el parámetro <paramref name="c" /> y el tipo actual representan el mismo tipo o si el tipo actual está en la jerarquía de herencia de <paramref name="c" />, o bien si el tipo actual es una interfaz que <paramref name="c" /> admite. Es <see langword="false" /> si ninguna de estas condiciones es válida o si <paramref name="c" /> es <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary>Obtiene un valor que indica si este objeto representa un tipo genérico construido.</summary>
      <returns>
        <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary>Devuelve un valor que indica si se ha creado el tipo dinámico actual.</summary>
      <returns>
        <see langword="true" /> si se ha llamado al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Determina si un atributo personalizado se aplica al tipo actual.</summary>
      <param name="attributeType">El tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
      <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</param>
      <returns>
        <see langword="true" /> si una o más instancias de <paramref name="attributeType" /> o un atributo derivado de <paramref name="attributeType" /> se definen en este tipo; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">Este método no se admite actualmente para tipos incompletos. Recupere el tipo mediante <see cref="M:System.Type.GetType" /> y llame a <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el <see cref="T:System.Type" /> devuelto.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> no está definido.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> es <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary>Obtiene un valor que indica si el tipo actual es un parámetro de tipo genérico.</summary>
      <returns>
        <see langword="true" /> si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary>Obtiene un valor que indica si el tipo actual es genérico.</summary>
      <returns>
        <see langword="true" /> si el tipo representado por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual es genérico; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa una definición de tipo genérico a partir de la cual se pueden construir otros tipos genéricos.</summary>
      <returns>
        <see langword="true" /> si este objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> representa una definición de tipo genérico; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary>Obtiene un valor que indica si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente y, por tanto, puede realizar operaciones críticas.</summary>
      <returns>
        <see langword="true" /> si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es transparente.</returns>
      <exception cref="T:System.NotSupportedException">No se creó el tipo dinámico actual mediante una llamada al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary>Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</summary>
      <returns>
        <see langword="true" /> si el tipo actual es crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es crítico para la seguridad o transparente.</returns>
      <exception cref="T:System.NotSupportedException">No se creó el tipo dinámico actual mediante una llamada al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary>Obtiene un valor que indica si el tipo actual es transparente y, por tanto, no puede realizar operaciones críticas.</summary>
      <returns>
        <see langword="true" /> si el tipo es transparente en seguridad; en caso contrario, <see langword="false" />.</returns>
      <exception cref="T:System.NotSupportedException">No se creó el tipo dinámico actual mediante una llamada al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary>Determina si este tipo se deriva de un tipo especificado.</summary>
      <param name="c">
        <see cref="T:System.Type" /> que se protegerá.</param>
      <returns>Sólo lectura. Devuelve <see langword="true" /> si este tipo es el mismo que el tipo <paramref name="c" />, o es un subtipo del tipo <paramref name="c" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</summary>
      <returns>Un objeto <see cref="T:System.Type" /> que representa un tipo de matriz unidimensional cuyo tipo de elemento es el actual, con un límite inferior de cero.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</summary>
      <param name="rank">Número de dimensiones de la matriz.</param>
      <returns>Objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> no es una dimensión de matriz válida.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary>Sustituye los elementos de una matriz de tipos por los parámetros de tipo de la definición de tipo genérico actual y devuelve el tipo construido resultante.</summary>
      <param name="typeArguments">Matriz de tipos que se va a sustituir por los parámetros de la definición del tipo genérico actual.</param>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo construido formado al sustituir los elementos de <paramref name="typeArguments" /> por los parámetros del tipo genérico actual.</returns>
      <exception cref="T:System.InvalidOperationException">El tipo actual no representa la definición de un tipo genérico. Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> devuelve <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArguments" /> es <see langword="null" />.
O bien
Cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Type.Module" /> de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.
O bien
La propiedad <see cref="P:System.Reflection.Module.Assembly" /> del módulo de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo de puntero no administrado para el tipo actual.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de puntero no administrado para el tipo actual.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary>Recupera el módulo dinámico que contiene esta definición de tipo.</summary>
      <returns>Sólo lectura. Recupera el módulo dinámico que contiene esta definición de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary>Recupera el nombre de este tipo.</summary>
      <returns>Sólo lectura. Recupera el nombre <see cref="T:System.String" /> de este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary>Recupera el espacio de nombres donde se define este <see langword="TypeBuilder" />.</summary>
      <returns>Sólo lectura. Recupera el espacio de nombres donde se define este <see langword="TypeBuilder" /> .</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary>Recupera el tamaño del empaquetado de este tipo.</summary>
      <returns>Sólo lectura. Recupera el tamaño del empaquetado de este tipo.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary>Devuelve el tipo que se utilizó para obtener este tipo.</summary>
      <returns>Sólo lectura. Tipo que se usó para obtener este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</summary>
      <param name="con">Constructor para el atributo personalizado.</param>
      <param name="binaryAttribute">Blob de bytes que representa los atributos.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Establece un atributo personalizado mediante un generador de atributos personalizado.</summary>
      <param name="customBuilder">Instancia de una clase del asistente para definir el atributo personalizado.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> es <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary>Establece el tipo base del tipo actualmente en construcción.</summary>
      <param name="parent">Nuevo tipo base.</param>
      <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.
o bien
<paramref name="parent" /> es <see langword="null" /> y la instancia actual representa una interfaz cuyos atributos no incluyen <see cref="F:System.Reflection.TypeAttributes.Abstract" />.
o bien
Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> es una interfaz. Esta condición de excepción es nueva en la versión 2.0 de .NET Framework.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary>Recupera el tamaño total de un tipo.</summary>
      <returns>Sólo lectura. Recupera el tamaño total de este tipo.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary>Devuelve el nombre del tipo, excluido el espacio de nombres.</summary>
      <returns>Sólo lectura. Nombre del tipo, excluido el espacio de nombres.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary>No se admite en módulos dinámicos.</summary>
      <returns>Sólo lectura.</returns>
      <exception cref="T:System.NotSupportedException">No se admite en módulos dinámicos.</exception>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary>Devuelve el tipo de sistema subyacente para esta <see langword="TypeBuilder" />.</summary>
      <returns>Sólo lectura. Devuelve el tipo de sistema subyacente.</returns>
      <exception cref="T:System.InvalidOperationException">Este tipo es una enumeración, pero no hay ningún tipo de sistema subyacente.</exception>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary>Representa que no se especifica el tamaño total del tipo.</summary>
    </member>
  </members>
</doc>