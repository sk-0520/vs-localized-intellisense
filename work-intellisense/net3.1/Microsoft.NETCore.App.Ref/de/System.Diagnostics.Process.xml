<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Diagnostics.Process</name>
  </assembly>
  <members>
    <member name="T:Microsoft.Win32.SafeHandles.SafeProcessHandle">
      <summary>Stellt einen verwalteten Wrapper für ein Prozesshandle bereit.</summary>
    </member>
    <member name="M:Microsoft.Win32.SafeHandles.SafeProcessHandle.#ctor(System.IntPtr,System.Boolean)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:Microsoft.Win32.SafeHandles.SafeProcessHandle" />-Klasse aus dem angegebenen Handle und gibt an, ob das Handle in der Abschlussphase freigegeben werden soll.</summary>
      <param name="existingHandle">Das zu umschließende Handle.</param>
      <param name="ownsHandle">
        <see langword="true" />, wenn <see cref="T:Microsoft.Win32.SafeHandles.SafeProcessHandle" /> das Handle während der Abschlussphase zuverlässig freigeben soll, andernfalls <see langword="false" />.</param>
    </member>
    <member name="P:Microsoft.Win32.SafeHandles.SafeProcessHandle.IsInvalid" />
    <member name="T:System.Diagnostics.DataReceivedEventArgs">
      <summary>Stellt Daten für das <see cref="E:System.Diagnostics.Process.OutputDataReceived" />-Ereignis und das <see cref="E:System.Diagnostics.Process.ErrorDataReceived" />-Ereignis bereit.</summary>
    </member>
    <member name="P:System.Diagnostics.DataReceivedEventArgs.Data">
      <summary>Ruft die Zeile von Zeichen ab, die in einen umgeleiteten <see cref="T:System.Diagnostics.Process" />-Ausgabestream geschrieben wurde.</summary>
      <returns>Die Zeile, die von einem zugeordneten <see cref="T:System.Diagnostics.Process" /> in seinen umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream oder <see cref="P:System.Diagnostics.Process.StandardError" />-Stream geschrieben wurde.</returns>
    </member>
    <member name="T:System.Diagnostics.DataReceivedEventHandler">
      <summary>Stellt die Methode dar, die das <see cref="E:System.Diagnostics.Process.OutputDataReceived" />-Ereignis oder das <see cref="E:System.Diagnostics.Process.ErrorDataReceived" />-Ereignis eines <see cref="T:System.Diagnostics.Process" /> behandelt.</summary>
      <param name="sender">Die Quelle des Ereignisses.</param>
      <param name="e">Ein <see cref="T:System.Diagnostics.DataReceivedEventArgs" />, das die Ereignisdaten enthält.</param>
    </member>
    <member name="T:System.Diagnostics.MonitoringDescriptionAttribute">
      <summary>Gibt die Beschreibung einer Eigenschaft oder eines Ereignisses an.</summary>
    </member>
    <member name="M:System.Diagnostics.MonitoringDescriptionAttribute.#ctor(System.String)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.MonitoringDescriptionAttribute" />-Klasse mit der angegebenen Beschreibung.</summary>
      <param name="description">Der anwendungsdefinierte Beschreibungstext.</param>
    </member>
    <member name="P:System.Diagnostics.MonitoringDescriptionAttribute.Description">
      <summary>Ruft den Beschreibungstext ab, der dem überwachten Element zugeordnet ist.</summary>
      <returns>Ein anwendungsdefinierter Beschreibungstext.</returns>
    </member>
    <member name="T:System.Diagnostics.Process">
      <summary>Ermöglicht den Zugriff auf lokale Prozesse und Remoteprozesse und das Starten und Anhalten lokaler Systemprozesse.</summary>
    </member>
    <member name="M:System.Diagnostics.Process.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Process" />-Klasse.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.BasePriority">
      <summary>Ruft die Basispriorität des zugeordneten Prozesses ab.</summary>
      <returns>Die Basispriorität, die anhand der <see cref="P:System.Diagnostics.Process.PriorityClass" /> des zugeordneten Prozesses berechnet wird.</returns>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.
- oder -
Der Prozess wurde nicht gestartet, daher gibt es keine Prozess-ID.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.BeginErrorReadLine">
      <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream der Anwendung.</summary>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist <see langword="false" />.
- oder -
Für den <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.
- oder -
Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.BeginOutputReadLine">
      <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream der Anwendung.</summary>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />-Eigenschaft ist <see langword="false" />.
- oder -
Für den <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.
- oder -
Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.CancelErrorRead">
      <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream einer Anwendung ab.</summary>
      <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.CancelOutputRead">
      <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream einer Anwendung ab.</summary>
      <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Close">
      <summary>Gibt alle dieser Komponente zugeordneten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Diagnostics.Process.CloseMainWindow">
      <summary>Schließt einen Prozess mit einer Benutzeroberfläche, indem eine Meldung zum Schließen an das Hauptfenster gesendet wird.</summary>
      <returns>
        <see langword="true" />, wenn die Meldung zum Schließen erfolgreich gesendet wurde. <see langword="false" />, wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt oder wenn das Hauptfenster deaktiviert ist (z. B., wenn ein modales Dialogfeld angezeigt wird).</returns>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.

oder -
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Dispose(System.Boolean)">
      <summary>Gibt alle von diesem Prozess verwendeten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="P:System.Diagnostics.Process.EnableRaisingEvents">
      <summary>Ruft ab oder legt fest, ob beim Beenden des Prozesses das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll.</summary>
      <returns>
        <see langword="true" />, wenn das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll, wenn der zugeordnete Prozess beendet wird (entweder durch Beenden oder einen Aufruf von <see cref="M:System.Diagnostics.Process.Kill" />), andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />. Beachten Sie, dass das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis auch dann ausgelöst wird, wenn der Wert von <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /><see langword="false" /> wird, wenn der Prozess während oder vor der Durchführung einer <see cref="P:System.Diagnostics.Process.HasExited" /> Überprüfung durch den Benutzer beendet wird.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.EnterDebugMode">
      <summary>Versetzt durch Aktivieren der systemeigenen <see cref="T:System.Diagnostics.Process" />-Eigenschaft für den aktuellen Thread eine <see langword="SeDebugPrivilege" />-Komponente in einen Zustand, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
    </member>
    <member name="E:System.Diagnostics.Process.ErrorDataReceived">
      <summary>Tritt auf, wenn eine Anwendung in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream schreibt.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.ExitCode">
      <summary>Ruft den Wert ab, der vom zugeordneten Prozess beim Beenden angegeben wurde.</summary>
      <returns>Der Code, der vom zugeordneten Prozess beim Beenden angegeben wurde.</returns>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht beendet.

oder -
Der Prozess <see cref="P:System.Diagnostics.Process.Handle" /> ist ungültig.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitCode" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="E:System.Diagnostics.Process.Exited">
      <summary>Tritt beim Beenden eines Prozesses ein.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.ExitTime">
      <summary>Ruft den Zeitpunkt ab, zu dem der zugeordnete Prozess beendet wurde.</summary>
      <returns>Eine <see cref="T:System.DateTime" />, die angibt, wann der zugeordnete Prozess beendet wurde.</returns>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetCurrentProcess">
      <summary>Ruft eine neue <see cref="T:System.Diagnostics.Process" />-Komponente ab und ordnet diese dem gegenwärtig aktiven Prozess zu.</summary>
      <returns>Eine neue <see cref="T:System.Diagnostics.Process" />-Komponente, die der Prozessressource zugeordnet ist, die die aufrufende Anwendung ausführt.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessById(System.Int32)">
      <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn der Bezeichner eines Prozesses auf dem lokalen Computer angegeben ist.</summary>
      <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
      <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten lokalen Prozessressource zugeordnet ist.</returns>
      <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)">
      <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn die Prozess-ID und der Name des Computers im Netzwerk angegeben sind.</summary>
      <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
      <param name="machineName">Der Name eines Computers im Netzwerk.</param>
      <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten Remoteprozessressource zugeordnet ist.</returns>
      <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.
- oder -
Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Der Name kann die Länge 0 (null) haben.</exception>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcesses">
      <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
      <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem lokalen Computer ausgeführten Prozessressourcen darstellt.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcesses(System.String)">
      <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
      <param name="machineName">Der Computer, von dem die Liste der Prozesse gelesen werden soll.</param>
      <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem angegebenen Computer ausgeführten Prozessressourcen darstellt.</returns>
      <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
      <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessesByName(System.String)">
      <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf dem lokalen Computer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
      <param name="processName">Der angezeigte Name des Prozesses.</param>
      <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
      <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)">
      <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf einem Remotecomputer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
      <param name="processName">Der angezeigte Name des Prozesses.</param>
      <param name="machineName">Der Name eines Computers im Netzwerk.</param>
      <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
      <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="machineName" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
      <exception cref="T:System.InvalidOperationException">Der Versuch, eine Verbindung zu <paramref name="machineName" /> aufzubauen, ist fehlgeschlagen.
- oder -
Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.Handle">
      <summary>Ruft das systemeigene Handle des zugeordneten Prozesses ab.</summary>
      <returns>Das Handle, das das Betriebssystem dem zugeordneten Prozess beim Starten des Prozesses zugewiesen hat. Das System verwendet dieses Handle zum Verfolgen der Prozessattribute.</returns>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht gestartet oder wurde beendet. Die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft kann nicht gelesen werden, weil dieser <see cref="T:System.Diagnostics.Process" />-Instanz kein Prozess zugeordnet ist.
- oder -
Die <see cref="T:System.Diagnostics.Process" />-Instanz wurde einem aktiven Prozess zugeordnet, Sie haben aber nicht die erforderlichen Berechtigungen, um ein Handle mit vollen Zugriffsrechten abzurufen.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.HandleCount">
      <summary>Ruft die Anzahl der vom Prozess geöffneten Handles ab.</summary>
      <returns>Die Anzahl der vom Prozess geöffneten Betriebssystemhandles.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.HasExited">
      <summary>Ruft einen Wert ab, der angibt, ob der zugehörige Prozess beendet wurde.</summary>
      <returns>
        <see langword="true" />, wenn der Betriebssystemprozess, auf den die <see cref="T:System.Diagnostics.Process" />-Komponente verweist, beendet wurde; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Diesem Objekt ist kein Prozess zugeordnet.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Der Exitcode für den Prozess konnte nicht abgerufen werden.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.HasExited" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.Id">
      <summary>Ruft den eindeutigen Bezeichner für den zugeordneten Prozess ab.</summary>
      <returns>Der vom System generierte eindeutige Bezeichner des Prozesses, auf den von dieser <see cref="T:System.Diagnostics.Process" />-Instanz verwiesen wird.</returns>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft des Prozesses wurde nicht festgelegt.
- oder -
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Kill">
      <summary>Hält den zugeordneten Prozess sofort an.</summary>
      <exception cref="T:System.ComponentModel.Win32Exception">Der zugeordnete Prozess konnte nicht beendet werden.

oder -

Der Prozess wird beendet.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, <see cref="M:System.Diagnostics.Process.Kill" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Die Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.
- oder -
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Kill(System.Boolean)">
      <summary>Beendet sofort den zugeordneten Prozess und optional seine untergeordneten Prozesse/Nachfolgerprozesse.</summary>
      <param name="entireProcessTree">
        <see langword="true" />, um den zugeordneten Prozess und seine Nachfolger zu beenden; <see langword="false" />, um nur den zugeordneten Prozess zu beenden.</param>
      <exception cref="T:System.ComponentModel.Win32Exception">Der zugeordnete Prozess konnte nicht beendet werden.

oder -

Der Prozess wird beendet.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, <see cref="M:System.Diagnostics.Process.Kill" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Die Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.
- oder -
Diesem <see cref="T:System.Diagnostics.Process" /> -Objekt ist kein Prozess zugeordnet.
- oder -
Der aufrufende Prozess ist ein Element der Nachfolgerstruktur des zugeordneten Prozesses.</exception>
      <exception cref="T:System.AggregateException">Nicht alle Prozesse in der Nachfolgerstruktur des zugeordneten Prozesses konnten beendet werden.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.LeaveDebugMode">
      <summary>Beendet den Zustand einer <see cref="T:System.Diagnostics.Process" />-Komponente, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.MachineName">
      <summary>Ruft den Namen des Computers ab, auf dem der zugeordnete Prozess ausgeführt wird.</summary>
      <returns>Der Name des Computers, auf dem der zugeordnete Prozess ausgeführt wird.</returns>
      <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MainModule">
      <summary>Ruft das Hauptmodul für den zugeordneten Prozess ab.</summary>
      <returns>Das zum Starten des Prozesses verwendete <see cref="T:System.Diagnostics.ProcessModule" />.</returns>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainModule" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Ein 32-Bit-Prozess versucht, auf die Module eines 64-Bit-Prozesses zuzugreifen.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.
- oder -
Der Prozess wurde beendet.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MainWindowHandle">
      <summary>Ruft das Fensterhandle des Hauptfensters des zugeordneten Prozesses ab.</summary>
      <returns>Das vom System generierte Fensterhandle des Hauptfensters des zugeordneten Prozesses.</returns>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> ist nicht definiert, da der Prozess beendet wurde.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> -Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MainWindowTitle">
      <summary>Ruft die Beschriftung des Hauptfensters des Prozesses ab.</summary>
      <returns>Der Titel des Hauptfensters des Prozesses.</returns>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.MainWindowTitle" />-Eigenschaft ist nicht definiert, da der Prozess beendet wurde.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowTitle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MaxWorkingSet">
      <summary>Ruft, in Bytes, die maximal zulässige Workingsetgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
      <returns>Die im Speicher maximal zulässige Workingsetgröße für den Prozess in Bytes.</returns>
      <exception cref="T:System.ArgumentException">Die maximale Workingsetgröße ist ungültig. Sie muss größer gleich der Workingsetmindestgröße sein.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden
- oder -
Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MaxWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.
- oder -
Der Prozess wurde beendet.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.MinWorkingSet">
      <summary>Ruft, in Bytes, die Workingsetmindestgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
      <returns>Die im Speicher mindestens erforderliche Workingsetgröße für den Prozess in Bytes.</returns>
      <exception cref="T:System.ArgumentException">Die Workingsetmindestgröße ist ungültig. Sie muss kleiner gleich der maximalen Workingsetgröße sein.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden
- oder -
Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MinWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.
- oder -
Der Prozess wurde beendet.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.Modules">
      <summary>Ruft die Module ab, die vom zugeordneten Prozess geladen wurden.</summary>
      <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessModule" />, das die vom zugeordneten Prozess geladenen Module darstellt.</returns>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für den Systemprozess oder den Leerlaufprozess zuzugreifen. Diese Prozesse verfügen über keine Module.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.NonpagedSystemMemorySize">
      <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
      <returns>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.NonpagedSystemMemorySize64">
      <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
      <returns>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess reserviert ist und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.OnExited">
      <summary>Löst das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis aus.</summary>
    </member>
    <member name="E:System.Diagnostics.Process.OutputDataReceived">
      <summary>Tritt jedes Mal auf, wenn eine Anwendung eine Zeile in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream schreibt.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.PagedMemorySize">
      <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
      <returns>Der Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PagedMemorySize64">
      <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
      <returns>Die Größe des Arbeitsspeichers in Bytes, der für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PagedSystemMemorySize">
      <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
      <returns>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PagedSystemMemorySize64">
      <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
      <returns>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess belegt wird und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakPagedMemorySize">
      <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
      <returns>Der maximale Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakPagedMemorySize64">
      <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
      <returns>Die maximale Größe des Arbeitsspeichers in Bytes, der seit dem Starten für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakVirtualMemorySize">
      <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
      <returns>Die maximale virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakVirtualMemorySize64">
      <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
      <returns>Die maximale Größe des virtuellen Arbeitsspeichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakWorkingSet">
      <summary>Ruft die maximale Größe des Workingsets für den zugeordneten Prozess in Bytes ab.</summary>
      <returns>Die maximale Größe des physischen Speichers in Bytes, den der zugeordnete Prozess gleichzeitig angefordert hat.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PeakWorkingSet64">
      <summary>Ruft die maximale Größe des physischen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
      <returns>Die maximale Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PriorityBoostEnabled">
      <summary>Ruft einen Wert ab, der angibt, ob die zugeordnete Prozesspriorität durch das Betriebssystem vorübergehend erhöht werden soll, wenn das Hauptfenster den Fokus besitzt, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn die Prozesspriorität eines Prozesses dynamisch erhöht werden soll, wenn dieser den Wartezustand verlässt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozesserhöhungsinformationen von der zugeordneten Prozessressource abgerufen werden.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.PriorityClass">
      <summary>Ruft die allgemeine Prioritätskategorie für den zugeordneten Prozess ab oder legt diese fest.</summary>
      <returns>Die Prioritätskategorie für den zugeordneten Prozess, aus der die <see cref="P:System.Diagnostics.Process.BasePriority" /> des Prozesses berechnet wird.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozessprioritätsinformationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.

oder -

Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityClass" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
      <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die Prioritätsklasse kann nicht festgelegt werden, weil sie keinen gültigen Wert gemäß der Definition in der <see cref="T:System.Diagnostics.ProcessPriorityClass" />-Enumeration verwendet.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.PrivateMemorySize">
      <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
      <returns>Die Anzahl der vom zugeordneten Prozess reservierten Bytes, die nicht mit anderen Prozessen gemeinsam genutzt werden können.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PrivateMemorySize64">
      <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
      <returns>Die Größe des Speichers in Bytes, der für den zugeordneten Prozess belegt wird und nicht mit anderen Prozessen gemeinsam genutzt werden kann.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.PrivilegedProcessorTime">
      <summary>Ruft die privilegierte Prozessorzeit für diesen Prozess ab.</summary>
      <returns>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Prozess im Betriebssystemkern Code ausgeführt hat.</returns>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.ProcessName">
      <summary>Ruft den Namen des Prozesses ab.</summary>
      <returns>Der Name, mit dem das System den Prozess für den Benutzer kennzeichnet.</returns>
      <exception cref="T:System.InvalidOperationException">Für den Prozess ist kein Bezeichner vorhanden, oder dem <see cref="T:System.Diagnostics.Process" /> ist kein Prozess zugeordnet.
- oder -
Der zugeordnete Prozess wurde beendet.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess ist auf diesem Computer nicht vorhanden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.ProcessorAffinity">
      <summary>Ruft die Prozessoren ab, auf denen die Ausführung der Threads in diesem Prozess geplant werden kann, oder legt diese fest.</summary>
      <returns>Eine Bitmaske, die angibt, auf welchen Prozessoren die Threads im zugeordneten Prozess ausgeführt werden können. Der Standardwert hängt von der Anzahl der Prozessoren des Computers ab. Der Standardwert ist 2 n -1, wobei n die Anzahl der Prozessoren ist.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Informationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.
- oder -
Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> war nicht verfügbar.
- oder -
Der Prozess wurde beendet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Refresh">
      <summary>Verwirft alle Informationen über den zugeordneten Prozess, die in der Prozesskomponente zwischengespeichert waren.</summary>
    </member>
    <member name="P:System.Diagnostics.Process.Responding">
      <summary>Ruft einen Wert ab, der angibt, ob die Benutzeroberfläche des Prozesses reagiert.</summary>
      <returns>
        <see langword="true" />, wenn die Benutzeroberfläche des zugeordneten Prozesses auf das System reagiert; andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Responding" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.SafeHandle">
      <summary>Ruft das systemeigene Handle dieses Prozesses ab.</summary>
      <returns>Das systemeigene Handle dieses Prozesses.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.SessionId">
      <summary>Ruft die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess ab.</summary>
      <returns>Die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess.</returns>
      <exception cref="T:System.NullReferenceException">Diesem Prozess ist keine Sitzung zugeordnet.</exception>
      <exception cref="T:System.InvalidOperationException">Dieser Sitzungs-ID ist kein Prozess zugeordnet.
- oder -
Der zugeordnete Prozess befindet sich nicht auf diesem Computer.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StandardError">
      <summary>Ruft einen Stream ab, mit dem die Fehlerausgabe der Anwendung gelesen wird.</summary>
      <returns>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardfehlerstreams der Anwendung.</returns>
      <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.
- oder -
Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> geöffnet.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StandardInput">
      <summary>Ruft einen Stream ab, in den die Eingaben der Anwendung geschrieben werden.</summary>
      <returns>Ein <see cref="T:System.IO.StreamWriter" /> zum Schreiben des Standardeingabestreams der Anwendung.</returns>
      <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardInput" />-Stream wurde nicht definiert, da <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> auf <see langword="false" /> festgelegt ist.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StandardOutput">
      <summary>Ruft einen Stream ab, der dazu verwendet wird, die Textausgabe der Anwendung zu lesen.</summary>
      <returns>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardausgabestreams der Anwendung.</returns>
      <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.
- oder -
Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> geöffnet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start">
      <summary>Startet die von der <see cref="P:System.Diagnostics.Process.StartInfo" />-Eigenschaft dieser <see cref="T:System.Diagnostics.Process" />-Komponente angegebene Prozessressource (oder verwendet sie erneut) und ordnet diese der Komponente zu.</summary>
      <returns>
        <see langword="true" />, wenn eine Prozessressource gestartet wird. <see langword="false" />, wenn keine neue Prozessressource gestartet wird, sondern z. B. eine vorhandene Prozessressource wiederverwendet wird.</returns>
      <exception cref="T:System.InvalidOperationException">In <see cref="P:System.Diagnostics.Process.StartInfo" /> der Komponente <see cref="T:System.Diagnostics.Process" /> wurde kein Dateiname angegeben.
- oder -
Das <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> -Member der <see cref="P:System.Diagnostics.Process.StartInfo" /> -Eigenschaft ist <see langword="true" /> , während <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /><see langword="true" />ist.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
      <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Methode, die von Betriebssystemen ohne Shellunterstützung wie z.B. Nano Server nicht unterstützt wird (nur .NET Core).</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)">
      <summary>Startet die Prozessressource, die durch den Parameter mit den Startinformationen für den Prozess angegeben wird (z. B. den Dateinamen des zu startenden Prozesses), und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
      <param name="startInfo">Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Informationen zum Starten des Prozesses enthält, einschließlich Dateiname und Befehlszeilenargumente.</param>
      <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
      <exception cref="T:System.InvalidOperationException">In der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft des <paramref name="startInfo" />-Parameters wurde kein Dateiname angegeben.
- oder -
Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />-, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />- oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist ebenfalls <see langword="true" />.
- oder -
Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft ist nicht <see langword="null" /> oder leer, oder die <see cref="P:System.Diagnostics.ProcessStartInfo.Password" />-Eigenschaft ist nicht <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="startInfo" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.
- oder -
Die in der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft des <paramref name="startInfo" />-Parameters angegebene Datei wurde nicht gefunden.
- oder -
Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die Fehlermeldung dieser Ausnahme kann eine der folgenden sein: „Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein.“ oder "Zugriff verweigert".</exception>
      <exception cref="T:System.PlatformNotSupportedException">Methode, die von Betriebssystemen ohne Shellunterstützung wie z.B. Nano Server nicht unterstützt wird (nur .NET Core).</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String)">
      <summary>Startet eine Prozessressource, indem der Name eines Dokuments oder einer Anwendungsdatei angegeben wird, und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
      <param name="fileName">Der Name eines Dokuments oder einer Anwendungsdatei, das bzw. die im Prozess ausgeführt werden soll.</param>
      <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.
- oder -
Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.</exception>
      <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String,System.String)">
      <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
      <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
      <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
      <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
      <exception cref="T:System.InvalidOperationException">Der <paramref name="fileName" />-Parameter oder der <paramref name="arguments" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.
- oder -
Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.
- oder -
Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die Fehlermeldung dieser Ausnahme kann eine der folgenden sein: „Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein.“ oder "Zugriff verweigert".</exception>
      <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)">
      <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung, eines Benutzernamens und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
      <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
      <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
      <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
      <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
      <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
      <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.
- oder -
Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.</exception>
      <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Dieser Member, die unter Linux oder macOS nicht unterstützt wird (nur .NET Core).</exception>
    </member>
    <member name="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)">
      <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten, eines Benutzernamens, eines Kennworts und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
      <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
      <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
      <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
      <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
      <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
      <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
      <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.
- oder -
Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.
- oder -
Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads zur zugehörigen Datei überschreitet 2080. Die Fehlermeldung dieser Ausnahme kann eine der folgenden sein: „Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein.“ oder "Zugriff verweigert".</exception>
      <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Dieser Member, die unter Linux oder macOS nicht unterstützt wird (nur .NET Core).</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StartInfo">
      <summary>Ruft die Eigenschaften ab, die an die <see cref="M:System.Diagnostics.Process.Start" />-Methode von <see cref="T:System.Diagnostics.Process" /> übergeben werden sollen, oder legt diese fest.</summary>
      <returns>Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Daten darstellt, mit denen der Prozess gestartet werden soll. Diese Argumente beinhalten den Namen der ausführbaren Datei oder des Dokuments, das zum Starten des Prozesses verwendet wurde.</returns>
      <exception cref="T:System.ArgumentNullException">Der Wert, der die <see cref="P:System.Diagnostics.Process.StartInfo" /> angibt, ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Diagnostics.Process.Start" />-Methode wurde nicht verwendet, um den Prozess zu starten.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.StartTime">
      <summary>Ruft die Zeit ab, zu der der zugeordnete Prozess gestartet wurde.</summary>
      <returns>Ein Objekt, das angibt, wann der zugeordnete Prozess gestartet wurde. Eine Ausnahme wird ausgelöst, wenn der Prozess nicht ausgeführt wird.</returns>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.StartTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.
- oder -
Der Prozess wurde nicht gestartet.</exception>
      <exception cref="T:System.ComponentModel.Win32Exception">Beim Aufruf der Windows-Funktion ist ein Fehler aufgetreten.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.SynchronizingObject">
      <summary>Ruft das Objekt ab, das zum Marshallen der Ereignishandleraufrufe verwendet wird, die als Ergebnis eines Prozessbeendigungsereignisses ausgegeben werden, oder legt dieses fest.</summary>
      <returns>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die als Ergebnis eines <see cref="E:System.Diagnostics.Process.Exited" />-Ereignisses des Prozesses ausgegeben werden.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.Threads">
      <summary>Ruft die Gruppe von Threads ab, die im zugeordneten Prozess ausgeführt werden.</summary>
      <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessThread" />, das die Threads des Betriebssystems darstellt, die gegenwärtig im zugeordneten Prozess ausgeführt werden.</returns>
      <exception cref="T:System.SystemException">Für den Prozess ist kein <see cref="P:System.Diagnostics.Process.Id" /> vorhanden, oder der <see cref="T:System.Diagnostics.Process" />-Instanz ist kein Prozess zugeordnet.

oder -
Der zugeordnete Prozess wurde beendet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.ToString">
      <summary>Formatiert den Prozessnamen als Zeichenfolge, ggf. kombiniert mit dem Typ der übergeordneten Komponente.</summary>
      <returns>Der <see cref="P:System.Diagnostics.Process.ProcessName" /> kombiniert mit dem <see cref="M:System.Object.ToString" />-Rückgabewert der Basiskomponente.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.TotalProcessorTime">
      <summary>Ruft die gesamte Prozessorzeit für diesen Prozess ab.</summary>
      <returns>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess die CPU verwendet hat. Dieser Wert ist die Summe von <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> und <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</returns>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.TotalProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.UserProcessorTime">
      <summary>Ruft die Benutzerprozessorzeit für diesen Prozess ab.</summary>
      <returns>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess Code innerhalb der Anwendung des Prozesses (nicht im Betriebssystemkern) ausgeführt hat.</returns>
      <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.UserProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.VirtualMemorySize">
      <summary>Ruft die Größe des virtuellen Speichers für diesen Prozess in Bytes ab.</summary>
      <returns>Die virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.VirtualMemorySize64">
      <summary>Ruft die Größe des virtuellen Speichers, der für den zugeordneten Prozess belegt wird, in Bytes ab.</summary>
      <returns>Die Größe des virtuellen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</returns>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForExit">
      <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, unbestimmte Zeit zu warten, bis der zugeordnete Prozess beendet wird.</summary>
      <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
      <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.
- oder -
Diesem <see cref="T:System.Diagnostics.Process" /> -Objekt ist kein Prozess zugeordnet.
- oder -
Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForExit(System.Int32)">
      <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, für die Dauer von angegebenen Millisekunden zu warten, bis der zugeordnete Prozess beendet wird.</summary>
      <param name="milliseconds">Die Zeitspanne in Millisekunden, die auf die Beendigung des zugeordneten Prozesses gewartet werden soll. Der Höchstwert ist der größtmögliche Wert einer 32-Bit-Ganzzahl, der für das Betriebssystem unendlich bedeutet.</param>
      <returns>
        <see langword="true" />, wenn der zugeordnete Prozess beendet wurde, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
      <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.
- oder -
Diesem <see cref="T:System.Diagnostics.Process" /> -Objekt ist kein Prozess zugeordnet.
- oder -
Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="milliseconds" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForInputIdle">
      <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente unbegrenzt wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
      <returns>
        <see langword="true" />, wenn der zugehörige Prozess in den Leerlauf wechselt.</returns>
      <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.
- oder -
Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.
- oder -
Der Prozess wurde bereits beendet.

oder -
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
    </member>
    <member name="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)">
      <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente die Dauer von angegebenen Millisekunden wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
      <param name="milliseconds">Der Wert 1 für <see cref="F:System.Int32.MaxValue" />, der die Zeitspanne in Millisekunden angibt, die gewartet werden soll, bis sich der zugehörige Prozess im Leerlauf befindet. Der Wert 0 gibt eine sofortige Rückgabe an, der Wert -1 gibt eine unendliche Wartezeit an.</param>
      <returns>
        <see langword="true" />, wenn der zugeordnete Prozess in den Leerlauf wechselt, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.
- oder -
Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.
- oder -
Der Prozess wurde bereits beendet.

oder -
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
    </member>
    <member name="P:System.Diagnostics.Process.WorkingSet">
      <summary>Ruft die Belegung des physischen Speichers durch den zugeordneten Prozess in Bytes ab.</summary>
      <returns>Der Gesamtgröße des vom zugeordneten Prozess verwendeten physischen Speichers in Bytes.</returns>
    </member>
    <member name="P:System.Diagnostics.Process.WorkingSet64">
      <summary>Ruft die Größe des physischen Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
      <returns>Die Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessModule">
      <summary>Stellt eine DLL-oder EXE-Datei dar, die in einen bestimmten Prozess geladen wird.</summary>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.BaseAddress">
      <summary>Ruft die Speicheradresse ab, an der das Modul geladen wurde.</summary>
      <returns>Die Ladeadresse des Moduls.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.EntryPointAddress">
      <summary>Ruft die Speicheradresse für die Funktion ab, die ausgeführt wird, wenn das System das Modul lädt und ausführt.</summary>
      <returns>Der Einstiegspunkt dieses Moduls.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.FileName">
      <summary>Ruft den vollständigen Pfad zum Modul ab.</summary>
      <returns>Der voll qualifizierte Pfad, der den Speicherort des Moduls definiert.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.FileVersionInfo">
      <summary>Ruft Versionsinformationen zum Modul ab.</summary>
      <returns>Ein <see cref="T:System.Diagnostics.FileVersionInfo" />-Wert, der die Versionsinformationen des Moduls enthält.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.ModuleMemorySize">
      <summary>Ruft die Größe des Speichers ab, die zum Laden des Moduls erforderlich ist.</summary>
      <returns>Die Größe des vom Modul belegten Speichers in Byte.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModule.ModuleName">
      <summary>Ruft den Namen des Prozessmoduls ab.</summary>
      <returns>Der Name des Moduls.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessModule.ToString">
      <summary>Konvertiert den Namen des Moduls in eine Zeichenfolge.</summary>
      <returns>Der Wert der <see cref="P:System.Diagnostics.ProcessModule.ModuleName" />-Eigenschaft.</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessModuleCollection">
      <summary>Stellt eine stark typisierte Auflistung von <see cref="T:System.Diagnostics.ProcessModule" />-Objekten bereit.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessModuleCollection" />-Klasse ohne zugeordnete <see cref="T:System.Diagnostics.ProcessModule" />-Instanzen.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.#ctor(System.Diagnostics.ProcessModule[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessModuleCollection" />-Klasse unter Verwendung des angegebenen Arrays von <see cref="T:System.Diagnostics.ProcessModule" />-Instanzen.</summary>
      <param name="processModules">Ein Array von <see cref="T:System.Diagnostics.ProcessModule" />-Instanzen, mit denen diese <see cref="T:System.Diagnostics.ProcessModuleCollection" />-Instanz initialisiert werden soll.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.Contains(System.Diagnostics.ProcessModule)">
      <summary>Bestimmt, ob das angegebene Prozessmodul in der Auflistung vorhanden ist.</summary>
      <param name="module">Eine <see cref="T:System.Diagnostics.ProcessModule" />-Instanz, die das in dieser Auflistung zu suchende Modul angibt.</param>
      <returns>
        <see langword="true" />, wenn das Modul in der Auflistung vorhanden ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.CopyTo(System.Diagnostics.ProcessModule[],System.Int32)">
      <summary>Kopiert ein Array von <see cref="T:System.Diagnostics.ProcessModule" />-Instanzen am angegebenen Index in die Auflistung.</summary>
      <param name="array">Ein Array von <see cref="T:System.Diagnostics.ProcessModule" />-Instanzen, die der Auflistung hinzugefügt werden sollen.</param>
      <param name="index">Der Speicherort, an dem die neuen Instanzen hinzugefügt werden sollen.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessModuleCollection.IndexOf(System.Diagnostics.ProcessModule)">
      <summary>Gibt die Position eines angegebenen Moduls in der Auflistung an.</summary>
      <param name="module">Der <see cref="T:System.Diagnostics.ProcessModule" />, dessen Index abgerufen wird.</param>
      <returns>Der nullbasierte Index, der die Position des Moduls in <see cref="T:System.Diagnostics.ProcessModuleCollection" /> definiert.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessModuleCollection.Item(System.Int32)">
      <summary>Ruft einen Index zum Durchlaufen der Gruppe von Prozessmodulen ab.</summary>
      <param name="index">Der nullbasierte Indexwert des Moduls in der Auflistung.</param>
      <returns>Ein <see cref="T:System.Diagnostics.ProcessModule" />, das die Module in der Auflistung indiziert.</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessPriorityClass">
      <summary>Gibt die Priorität an, die das System einem Prozess zuordnet. Dieser Wert bestimmt, gemeinsam mit dem Prioritätswert für jeden Thread des Prozesses, die Basisprioritätsebene jedes Threads.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.AboveNormal">
      <summary>Gibt an, dass die Priorität des Prozesses höher als <see langword="Normal" />, aber niedriger als <see langword="High" /> ist.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.BelowNormal">
      <summary>Gibt an, dass der Prozess eine höhere Priorität als <see langword="Idle" /> aufweist, aber eine niedrigere als <see langword="Normal" />.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.High">
      <summary>Gibt an, dass der Prozess zeitkritische Aufgaben ausführt, die sofort ausgeführt werden müssen, z. B. für das Dialogfeld <see langword="Task List" />, das beim Aufruf durch den Benutzer unabhängig von der Last des Betriebssystems schnell angezeigt werden muss. Die Threads des Prozesses haben Vorrang vor den Threads von Prozessen in den Prioritätsklassen mit normaler oder Leerlaufpriorität. Wenden Sie bei Angabe von <see langword="High" /> als Prioritätsklasse für den Prozess höchste Sorgfalt an, weil eine Anwendung der hohen Prioritätsklasse nahezu die gesamte verfügbare Prozessorzeit aufbrauchen kann.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.Idle">
      <summary>Gibt an, dass die Threads dieses Prozesses nur ausgeführt werden, wenn sich das System im Leerlauf befindet. Trifft z. B. auf einen Bildschirmschoner zu. Vor den Threads dieses Prozesses haben die Threads eines beliebigen Prozesses Vorrang, der mit einer höheren Prioritätsklasse ausgeführt wird. Diese Prioritätsklasse wird von untergeordneten Prozessen geerbt.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.Normal">
      <summary>Gibt an, dass für den Prozess keine besondere Planung erforderlich ist.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessPriorityClass.RealTime">
      <summary>Gibt an, dass der Prozess die höchstmögliche Priorität aufweist. Die Threads eines Prozesses mit der Priorität <see langword="RealTime" /> haben Vorrang vor den Threads aller übrigen Prozesse, einschließlich Betriebssystemprozessen, die wichtige Aufgaben ausführen. Daher kann ein Prozess mit der Priorität <see langword="RealTime" />, der länger als nur für einen kurzen Zeitraum ausgeführt wird, dazu führen, dass Datenträgercaches nicht geleert werden oder die Maus nicht mehr reagiert.</summary>
    </member>
    <member name="T:System.Diagnostics.ProcessStartInfo">
      <summary>Gibt eine Wertemenge an, die beim Starten eines Prozesses verwendet wird.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessStartInfo.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse, ohne einen Dateinamen anzugeben, mit dem der Prozess gestartet werden soll.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse und gibt einen Dateinamen an, mit dem der Prozess gestartet werden soll, z. B. eine Anwendung oder ein Dokument.</summary>
      <param name="fileName">Eine Anwendung oder ein Dokument, mit der bzw. dem ein Prozess gestartet wird.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse und gibt einen Anwendungsdateinamen an, mit dem der Prozess gestartet wird, sowie einen Satz von Befehlszeilenargumenten, die an die Anwendung übergeben werden.</summary>
      <param name="fileName">Eine Anwendung, mit der ein Prozess gestartet wird.</param>
      <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses an die Anwendung übergeben werden sollen.</param>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.ArgumentList">
      <summary>Ruft eine Sammlung von Befehlszeilenargumenten ab, die beim Starten der Anwendung verwendet werden sollen, oder legt diesen fest.</summary>
      <returns>Eine Auflistung von Befehlszeilen Argumenten.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Arguments">
      <summary>Ruft den Satz von Befehlszeilenargumenten ab, die beim Starten der Anwendung verwendet werden sollen, oder legt diesen fest.</summary>
      <returns>Eine einzelne Zeichenfolge, die die Argumente enthält, die an die in der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebene Zielanwendung übergeben werden sollen. Der Standardwert ist eine leere Zeichenfolge ("").</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow">
      <summary>Ruft einen Wert ab, der angibt, ob der Prozess in einem neuen Fenster gestartet werden soll, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn der Prozess ohne Erstellung eines neuen Fensters gestartet werden soll. Andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Domain">
      <summary>Ruft einen Wert ab, der die Domäne kennzeichnet, die beim Starten des Prozesses verwendet werden soll, oder legt diesen fest. Wenn dieser Wert <see langword="null" /> ist, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft im UPN-Format angegeben werden.</summary>
      <returns>Die Active Directory-Domäne, die beim Starten des Prozesses verwendet werden soll. Wenn dieser Wert <see langword="null" /> ist, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft im UPN-Format angegeben werden.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Environment">
      <summary>Ruft die Umgebungsvariablen ab, die für diesen Prozess und seine untergeordneten Prozesse gelten.</summary>
      <returns>Ein generisches Wörterbuch, das die Umgebungsvariablen enthält, die für diesen Prozess und seine untergeordneten Prozesse gelten. Die Standardeinstellung ist <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables">
      <summary>Ruft Suchpfade für Dateien, Verzeichnisse für temporäre Dateien, anwendungsspezifische Optionen und andere ähnliche Informationen ab.</summary>
      <returns>Ein Zeichenfolgenwörterbuch, das Umgebungsvariablen für diesen Prozess und untergeordnete Prozesse bereitstellt. Die Standardeinstellung ist <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.ErrorDialog">
      <summary>Ruft einen Wert ab, der angibt, ob dem Benutzer ein Fehlerdialogfeld angezeigt wird, wenn der Prozess nicht gestartet werden kann, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn auf dem Bildschirm ein Fehler Dialogfeld angezeigt werden soll, wenn der Prozess nicht gestartet werden kann. Andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle">
      <summary>Ruft das Fensterhandle ab, das beim Anzeigen eines Fehlerdialogfelds für einen fehlgeschlagenen Prozessstart verwendet wird, oder legt dieses fest.</summary>
      <returns>Ein Zeiger auf das Handle des Fehlerdialogfelds, das aus einem fehlerhaften Prozessstart resultiert.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.FileName">
      <summary>Ruft die zu startende Anwendung oder das zu startende Dokument ab oder legt die Anwendung bzw. das Dokument fest.</summary>
      <returns>Der Name der zu startenden Anwendung oder der Dokumentname eines einer Anwendung zugeordneten Dateityps, für den eine Standard-Öffnen-Aktion verfügbar ist. Der Standardwert ist eine leere Zeichenfolge ("").</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.LoadUserProfile">
      <summary>Ruft einen Wert ab, der angibt, ob das Windows-Benutzerprofil aus der Registrierung geladen werden soll, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn das Windows-Benutzerprofil geladen werden soll. Andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Password">
      <summary>Ruft eine sichere Zeichenfolge ab, die das Benutzerkennwort enthält, das beim Starten des Prozesses verwendet werden soll, oder legt diese fest.</summary>
      <returns>Das beim Starten des Prozesses zu verwendende Kennwort.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.PasswordInClearText">
      <summary>Dient zum Abrufen oder Festlegen des unverschlüsselten Benutzerkennworts, das beim Starten des Prozesses verwendet werden soll.</summary>
      <returns>Das unverschlüsselte Benutzerkennwort.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError">
      <summary>Ruft einen Wert ab, der angibt, ob die Fehlerausgabe einer Anwendung in den <see cref="P:System.Diagnostics.Process.StandardError" />-Datenstrom geschrieben wird, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn die Fehlerausgabe in <see cref="P:System.Diagnostics.Process.StandardError" />geschrieben werden soll. Andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput">
      <summary>Ruft einen Wert ab, der angibt, ob die Eingabe für eine Anwendung aus dem <see cref="P:System.Diagnostics.Process.StandardInput" />-Datenstrom gelesen wird, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn die Eingabe von <see cref="P:System.Diagnostics.Process.StandardInput" /> gelesen werden soll; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput">
      <summary>Ruft einen Wert ab, der angibt, ob die Textausgabe einer Anwendung in den <see cref="P:System.Diagnostics.Process.StandardOutput" />-Datenstrom geschrieben wird, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn die Ausgabe in <see cref="P:System.Diagnostics.Process.StandardOutput" /> geschrieben werden soll; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding">
      <summary>Ruft die bevorzugte Codierung für die Fehlerausgabe ab oder legt diese fest.</summary>
      <returns>Ein Objekt, das die bevorzugte Codierung für die Fehlerausgabe darstellt. Die Standardeinstellung ist <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.StandardInputEncoding">
      <summary>Ruft die bevorzugte Codierung für die Standardeingabe ab oder legt diese fest.</summary>
      <returns>Ein-Objekt, das die bevorzugte Codierung für Standard Eingaben darstellt. Die Standardeinstellung ist <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding">
      <summary>Ruft die bevorzugte Codierung für die Standardausgabe ab oder legt diese fest.</summary>
      <returns>Ein Objekt, das die bevorzugte Codierung für die Standardausgabe darstellt. Die Standardeinstellung ist <see langword="null" />.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.UserName">
      <summary>Ruft den beim Starten des Prozesses zu verwendenden Benutzernamen ab oder legt diesen fest. Wenn Sie das UPN-Format (<paramref name="user" />@<paramref name="DNS_domain_name" />) verwenden, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" />-Eigenschaft <see langword="null" /> sein.</summary>
      <returns>Der beim Starten des Prozesses zu verwendende Benutzername. Wenn Sie das UPN-Format (<paramref name="user" />@<paramref name="DNS_domain_name" />) verwenden, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" />-Eigenschaft <see langword="null" /> sein.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.UseShellExecute">
      <summary>Ruft einen Wert ab, der angibt, ob zum Starten des Prozesses die Betriebssystemshell verwendet werden soll, oder legt diesen fest.</summary>
      <returns>
        <see langword="true" />, wenn beim Starten des Prozesses die Shell verwendet werden soll. <see langword="false" />, wenn der Prozess direkt aus der ausführbaren Datei erstellt werden soll. Der Standardwert ist <see langword="true" /> für .NET Framework-apps und <see langword="false" /> für .net Core-apps.</returns>
      <exception cref="T:System.PlatformNotSupportedException">Ein Versuch, den Wert für UWP-Apps (Universal Windows Platform) auf <see langword="true" /> festzulegen, wird unternommen.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Verb">
      <summary>Ruft das Verb ab, das beim Öffnen der in der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebenen Anwendung oder des in dieser Eigenschaft angegebenen Dokuments verwendet wird, oder legt dieses fest.</summary>
      <returns>Die Aktion, die mit der vom Prozess geöffneten Datei durchzuführen ist. Der Standardwert ist eine leere Zeichenfolge (""), die keine Aktion angibt.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.Verbs">
      <summary>Ruft den Satz der Verben ab, der dem durch die <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebenen Dateityp zugeordnet ist.</summary>
      <returns>Die Aktionen, die das System auf die durch die <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebene Datei anwenden kann.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.WindowStyle">
      <summary>Ruft den Fensterzustand ab, der beim Starten des Prozesses verwendet werden soll, oder legt diesen fest.</summary>
      <returns>Einer der Enumerationswerte, der angibt, ob der Prozess in einem maximierten, minimierten, normalen (weder maximierten noch minimierten) oder in einem nicht sichtbaren Fenster gestartet wird. Die Standardeinstellung ist <see langword="Normal" />.</returns>
      <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der Fensterstil gehört nicht zu den <see cref="T:System.Diagnostics.ProcessWindowStyle" />-Enumerationsmembern.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessStartInfo.WorkingDirectory">
      <summary>Ruft das Arbeitsverzeichnis für den zu startenden Prozess ab oder legt es fest, wenn die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Eigenschaft <see langword="false" /> ist. Ruft das Verzeichnis ab, das den zu startenden Prozess enthält, oder legt es fest, wenn <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /><see langword="true" /> ist.</summary>
      <returns>Wenn <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /><see langword="true" /> ist, der voll gekennzeichnete Name des Verzeichnisses, das den zu startenden Prozess enthält. Wenn die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Eigenschaft <see langword="false" /> ist, das Arbeitsverzeichnis für den zu startenden Prozess. Der Standardwert ist eine leere Zeichenfolge ("").</returns>
    </member>
    <member name="T:System.Diagnostics.ProcessThread">
      <summary>Stellt einen Prozessthread für ein Betriebssystem dar.</summary>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.BasePriority">
      <summary>Ruft die Basispriorität des Threads ab.</summary>
      <returns>Die Basispriorität des Threads, die vom Betriebssystem durch Kombinieren der Prioritätsklasse des Prozesses mit der Prioritätsebene des zugeordneten Threads errechnet wird.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.CurrentPriority">
      <summary>Ruft die aktuelle Priorität des Threads ab.</summary>
      <returns>Die aktuelle Priorität des Threads. Abhängig davon, wie das Betriebssystem den Thread plant, kann diese Priorität von der Basispriorität abweichen. Die Priorität kann für einen aktiven Thread vorübergehend erhöht werden.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.Id">
      <summary>Ruft den eindeutigen Bezeichner des Threads ab.</summary>
      <returns>Der eindeutige Bezeichner, der dem angegebenen Thread zugeordnet ist.</returns>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.IdealProcessor">
      <summary>Legt den bevorzugten Prozessor fest, auf dem dieser Thread ausgeführt werden soll.</summary>
      <returns>Der bevorzugte Prozessor für den Thread, der bei der Threadplanung des Systems verwendet wird, die bestimmt, auf welchem Prozessor der Thread ausgeführt werden soll.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Das System konnte die Ausführung des Threads nicht auf den angegebenen Prozessor festlegen.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled">
      <summary>Ruft einen Wert ab, der angibt, ob das Betriebssystem die Priorität des zugeordneten Threads vorübergehend erhöhen soll, sobald das Hauptfenster des Threadprozesses den Fokus hat, oder legt diesen Wert fest.</summary>
      <returns>
        <see langword="true" />, wenn die Priorität des Threads bei Interaktion des Benutzers mit der Schnittstelle erhöht werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Die Informationen zur Prioritätserhöhung konnten nicht abgerufen werden.
- oder -
Die Informationen zur Prioritätserhöhung konnten nicht festgelegt werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.PriorityLevel">
      <summary>Ruft die Prioritätsebene des Threads ab oder legt diese fest.</summary>
      <returns>Einer der <see cref="T:System.Diagnostics.ThreadPriorityLevel" />-Werte, der einen Bereich für die Begrenzung der Priorität des Threads angibt.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Die Informationen für die Prioritätsebene des Threads konnten nicht abgerufen werden.

oder -

Die Prioritätsebene für den Thread konnte nicht festgelegt werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime">
      <summary>Ruft die Zeit ab, während der der Thread im Betriebssystemkern Code ausgeführt hat.</summary>
      <returns>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Thread im Betriebssystemkern Code ausgeführt hat.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.ProcessorAffinity">
      <summary>Legt die Prozessoren fest, auf denen der zugeordnete Thread ausgeführt werden kann.</summary>
      <returns>Ein <see cref="T:System.IntPtr" />, das auf eine Gruppe von Bits zeigt, wovon jedes einzelne einen Prozessor darstellt, auf dem der Thread ausgeführt werden kann.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Die Prozessoraffinität konnte nicht festgelgt werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="M:System.Diagnostics.ProcessThread.ResetIdealProcessor">
      <summary>Setzt den für diesen Thread idealen Prozessor zurück, um anzugeben, dass kein einzelner idealer Prozessor vorhanden ist. Das heißt, dass jeder Prozessor ideal sein kann.</summary>
      <exception cref="T:System.ComponentModel.Win32Exception">Der ideale Prozessor konnte nicht zurückgesetzt werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.StartAddress">
      <summary>Ruft die Speicheradresse der Funktion ab, die vom Betriebssystem aufgerufen wurde, das diesen Thread gestartet hat.</summary>
      <returns>Die Anfangsadresse des Threads, die auf die vom Thread ausgeführte anwendungsdefinierte Funktion zeigt.</returns>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.StartTime">
      <summary>Ruft die Zeit ab, zu der das Betriebssystem den Thread gestartet hat.</summary>
      <returns>Eine <see cref="T:System.DateTime" />, die die Zeit auf dem System darstellt, zu der das Betriebssystem den Thread gestartet hat.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.ThreadState">
      <summary>Ruft den aktuellen Zustand dieses Threads ab.</summary>
      <returns>Ein <see cref="T:System.Diagnostics.ThreadState" />, der die Ausführung des Threads angibt, z. B. wird ausgeführt, wartet oder wurde beendet.</returns>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.TotalProcessorTime">
      <summary>Ruft die gesamte Zeit ab, während der der Thread den Prozessor verwendet hat.</summary>
      <returns>Eine <see cref="T:System.TimeSpan" />, die die Zeit angibt, während der Thread den Prozessor gesteuert hat.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.UserProcessorTime">
      <summary>Ruft die Zeit ab, während der der zugeordnete Thread in der Anwendung Code ausgeführt hat.</summary>
      <returns>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Thread Code in der Anwendung (im Gegensatz zum Betriebssystemkern) ausgeführt hat.</returns>
      <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="P:System.Diagnostics.ProcessThread.WaitReason">
      <summary>Ruft die Ursache für den Wartezustand des Threads ab.</summary>
      <returns>Eine <see cref="T:System.Diagnostics.ThreadWaitReason" />, die die Ursache für den Wartezustand des Threads darstellt.</returns>
      <exception cref="T:System.InvalidOperationException">Der Thread befindet sich nicht im Wartezustand.</exception>
      <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
    </member>
    <member name="T:System.Diagnostics.ProcessThreadCollection">
      <summary>Stellt eine stark typisierte Auflistung von <see cref="T:System.Diagnostics.ProcessThread" />-Objekten bereit.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessThreadCollection" />-Klasse ohne zugeordnete <see cref="T:System.Diagnostics.ProcessThread" />-Instanzen.</summary>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.#ctor(System.Diagnostics.ProcessThread[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessThreadCollection" />-Klasse mit dem angegebenen Array von <see cref="T:System.Diagnostics.ProcessThread" />-Instanzen.</summary>
      <param name="processThreads">Ein Array von <see cref="T:System.Diagnostics.ProcessThread" />-Instanzen, mit denen diese <see cref="T:System.Diagnostics.ProcessThreadCollection" />-Instanz initialisiert werden soll.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Add(System.Diagnostics.ProcessThread)">
      <summary>Fügt einen Prozessthread an die Auflistung an.</summary>
      <param name="thread">Der der Auflistung hinzuzufügende Thread.</param>
      <returns>Der nullbasierte Index des Threads in der Auflistung.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Contains(System.Diagnostics.ProcessThread)">
      <summary>Bestimmt, ob der angegebene Prozessthread in der Auflistung enthalten ist.</summary>
      <param name="thread">Eine <see cref="T:System.Diagnostics.ProcessThread" />-Instanz, die den in dieser Auflistung zu suchenden Thread anzeigt.</param>
      <returns>
        <see langword="true" />, wenn der Thread in der Auflistung vorhanden ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.CopyTo(System.Diagnostics.ProcessThread[],System.Int32)">
      <summary>Kopiert ein Array von <see cref="T:System.Diagnostics.ProcessThread" />-Instanzen am angegebenen Index in die Auflistung.</summary>
      <param name="array">Ein Array von <see cref="T:System.Diagnostics.ProcessThread" />-Instanzen, die der Auflistung hinzugefügt werden sollen.</param>
      <param name="index">Der Speicherort, an dem die neuen Instanzen hinzugefügt werden sollen.</param>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.IndexOf(System.Diagnostics.ProcessThread)">
      <summary>Stellt die Position eines angegebenen Threads in der Auflistung zur Verfügung.</summary>
      <param name="thread">Der <see cref="T:System.Diagnostics.ProcessThread" />, dessen Index abgerufen wird.</param>
      <returns>Der nullbasierte Index, der die Position des Threads in der <see cref="T:System.Diagnostics.ProcessThreadCollection" /> definiert.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Insert(System.Int32,System.Diagnostics.ProcessThread)">
      <summary>Fügt an der angegebenen Position einen Prozessthread in die Auflistung ein.</summary>
      <param name="index">Der nullbasierte Index, der die Position angibt, an der der Thread eingefügt werden soll.</param>
      <param name="thread">Der in die Auflistung einzufügende Thread.</param>
    </member>
    <member name="P:System.Diagnostics.ProcessThreadCollection.Item(System.Int32)">
      <summary>Ruft einen Index ab, mit dem die Gruppe von Prozessthreads durchlaufen werden kann.</summary>
      <param name="index">Der nullbasierte Indexwert des Threads in der Auflistung.</param>
      <returns>Ein <see cref="T:System.Diagnostics.ProcessThread" />, der die Threads in der Auflistung indiziert.</returns>
    </member>
    <member name="M:System.Diagnostics.ProcessThreadCollection.Remove(System.Diagnostics.ProcessThread)">
      <summary>Löscht einen Prozessthread aus der Auflistung.</summary>
      <param name="thread">Der Thread, der aus der Auflistung entfernt werden soll.</param>
    </member>
    <member name="T:System.Diagnostics.ProcessWindowStyle">
      <summary>Gibt an, wie ein neues Fenster angezeigt wird, wenn im System ein neuer Prozess gestartet wird.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Hidden">
      <summary>Der Stil für ausgeblendete Fenster. Ein Fenster kann sichtbar oder ausgeblendet sein. Ausgeblendete Fenster werden vom System angezeigt, indem sie nicht gezeichnet werden. Ein ausgeblendetes Fenster ist deaktiviert. Ein ausgeblendetes Fenster kann zwar Meldungen vom System oder anderen Fenstern verarbeiten, kann jedoch keine Benutzereingaben verarbeiten oder Ausgaben anzeigen. Eine Anwendung zeigt ein neues Fenster häufig nicht sofort an, um zunächst die Darstellung des Fensters anzupassen und das Fenster dann im <see cref="F:System.Diagnostics.ProcessWindowStyle.Normal" />-Stil anzuzeigen. Zur Verwendung von <see cref="F:System.Diagnostics.ProcessWindowStyle.Hidden" /> muss die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft <see langword="true" /> sein.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Maximized">
      <summary>Der Stil für maximierte Fenster. In der Standardeinstellung wird ein maximiertes Fenster so vergrößert, dass es den Bildschirm oder, im Fall eines untergeordneten Fensters, den Clientbereich des übergeordneten Fensters ausfüllt. Wenn das Fenster über eine Titelleiste verfügt, verschiebt das System diese automatisch an den oberen Bildschirmrand oder an den oberen Rand des Clientbereichs des übergeordneten Fensters. Außerdem werden der Vergrößerungsrahmen und die Titelleistenfunktionen zum Positionieren des Fensters deaktiviert, sodass der Benutzer das Fenster nicht durch Ziehen der Titelleiste verschieben kann.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Minimized">
      <summary>Der Stil für minimierte Fenster. In der Standardeinstellung wird ein minimiertes Fenster auf die Größe seiner Schaltfläche auf der Taskleiste verkleinert und auf die Taskleiste verschoben.</summary>
    </member>
    <member name="F:System.Diagnostics.ProcessWindowStyle.Normal">
      <summary>Der Stil für normale, sichtbare Fenster. Das System zeigt das Fenster in einer Standardposition im <see cref="F:System.Diagnostics.ProcessWindowStyle.Normal" />-Stil auf dem Bildschirm an. Wenn das Fenster sichtbar ist, kann der Benutzer im Fenster Eingaben vornehmen und sich die Fensterausgabe anzeigen lassen. Eine Anwendung initialisiert ein neues Fenster häufig im <see cref="F:System.Diagnostics.ProcessWindowStyle.Hidden" />-Stil, um zunächst die Darstellung des Fensters anzupassen und den Fensterstil anschließend auf <see cref="F:System.Diagnostics.ProcessWindowStyle.Normal" /> festzulegen.</summary>
    </member>
    <member name="T:System.Diagnostics.ThreadPriorityLevel">
      <summary>Gibt die Prioritätsebene eines Threads an.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.AboveNormal">
      <summary>Gibt eine Stufe über der normalen Priorität für die zugeordnete <see cref="T:System.Diagnostics.ProcessPriorityClass" /> an.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.BelowNormal">
      <summary>Gibt eine Stufe unter der normalen Priorität für die zugeordnete <see cref="T:System.Diagnostics.ProcessPriorityClass" /> an.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Highest">
      <summary>Gibt die höchste Priorität an. Dies ist zwei Stufen über der normalen Priorität für die zugeordnete <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Idle">
      <summary>Gibt die Leerlaufpriorität an. Dies ist der niedrigste mögliche Prioritätswert aller Threads, unabhängig vom Wert der zugeordneten <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Lowest">
      <summary>Gibt die niedrigste Priorität an. Dies ist zwei Stufen unter der normalen Priorität für die zugeordnete <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.Normal">
      <summary>Gibt die normale Priorität für die zugeordnete <see cref="T:System.Diagnostics.ProcessPriorityClass" /> an.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadPriorityLevel.TimeCritical">
      <summary>Gibt die auf die Ausführungsgeschwindigkeit bezogene Priorität an. Dies ist die höchste Priorität aller Threads, unabhängig vom Wert der zugeordneten <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</summary>
    </member>
    <member name="T:System.Diagnostics.ThreadState">
      <summary>Gibt den aktuellen Ausführungszustand des Threads an.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Initialized">
      <summary>Ein Zustand, der angibt, dass der Thread initialisiert wurde, jedoch noch nicht gestartet ist.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Ready">
      <summary>Ein Zustand, der anzeigt, dass der Thread auf die Verwendung eines Prozessors wartet, da gegenwärtig kein Prozessor frei ist. Der Thread kann auf dem nächsten verfügbaren Prozessor ausgeführt werden.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Running">
      <summary>Ein Zustand, der angibt, dass der Thread zurzeit einen Prozessor verwendet.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Standby">
      <summary>Ein Zustand, der angibt, dass der Thread gerade einen Prozessor verwenden will. In diesem Zustand kann sich jeweils nur ein Thread befinden.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Terminated">
      <summary>Ein Zustand, der angibt, dass der Thread die Ausführung abgeschlossen hat und beendet wurde.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Transition">
      <summary>Ein Zustand, der angibt, dass der Thread auf eine andere Ressource als den Prozessor wartet, bevor er ausgeführt werden kann. Er könnte z. B. darauf warten, dass der Ausführungsstapel von der Festplatte gelesen wird.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Unknown">
      <summary>Der Zustand des Threads ist unbekannt.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadState.Wait">
      <summary>Ein Zustand, der angibt, dass der Thread den Prozessor nicht verwenden kann, da er auf die Beendigung einer Operation in der Peripherie oder auf das Freiwerden einer Ressource wartet. Wenn der Thread bereit ist, wird der Start neu geplant.</summary>
    </member>
    <member name="T:System.Diagnostics.ThreadWaitReason">
      <summary>Gibt die Ursache für den Wartezustand eines Threads an.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.EventPairHigh">
      <summary>Der Thread wartet auf das Ereignispaar High.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.EventPairLow">
      <summary>Der Thread wartet auf das Ereignispaar Low.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.ExecutionDelay">
      <summary>Die Ausführung des Threads wird verzögert.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.Executive">
      <summary>Der Thread wartet auf den Planer.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.FreePage">
      <summary>Der Thread wartet auf eine freie Seite im virtuellen Speicher.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.LpcReceive">
      <summary>Der Thread wartet auf die Ankunft eines Aufrufs einer lokalen Prozedur.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.LpcReply">
      <summary>Der Thread wartet darauf, dass die Antwort auf den Aufruf einer lokalen Prozedur ankommt.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.PageIn">
      <summary>Der Thread wartet auf die Ankunft einer Seite des virtuellen Speichers im Arbeitsspeicher.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.PageOut">
      <summary>Der Thread wartet darauf, dass eine Seite des virtuellen Speichers auf den Datenträger geschrieben wird.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.Suspended">
      <summary>Die Ausführung des Threads wurde unterbrochen.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.SystemAllocation">
      <summary>Der Thread wartet auf Reservierung durch das System.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.Unknown">
      <summary>Der Thread befindet sich aus unbekannten Gründen im Wartezustand.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.UserRequest">
      <summary>Der Thread wartet auf eine Benutzeranforderung.</summary>
    </member>
    <member name="F:System.Diagnostics.ThreadWaitReason.VirtualMemory">
      <summary>Der Thread wartet darauf, dass das System virtuellen Speicher belegt.</summary>
    </member>
  </members>
</doc>