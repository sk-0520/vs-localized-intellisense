<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>Maskierte Inhaltstypbits, die Werten von <see cref="T:System.Reflection.AssemblyContentType" /> entsprechen.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>JIT-Compileroptimierung (Just-In-Time) ist für die Assembly deaktiviert.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>JIT-Compilernachverfolgung (Just-In-Time) ist für die Assembly aktiviert.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>Der Assemblyverweis enthält den vollständigen (nicht gehashten) öffentlichen Schlüssel. Für Assemblydefinition nicht zutreffend.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>Von der Implementierung der referenzierten Assembly, die zur Laufzeit verwendet wird, wird nicht erwartet, dass sie der Version entspricht, die zur Kompilierzeit angezeigt wird.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>Die Assembly enthält Windows-Runtime-Code.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>Legt die Hashalgorithmen fest, die für das Hashing von Assemblydateien und das Generieren des starken Namens verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>Ruft den Message Digest-Algorithmus MD5 ab.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>Eine Maske, die angibt, dass kein Hashalgorithmus verfügbar ist.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>Ruft eine Revision des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) ab, die einen nicht veröffentlichten Fehler in SHA korrigiert</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>Ruft eine Version des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) mit einer Hashgröße von 256 Bits ab</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>Ruft eine Version des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) mit einer Hashgröße von 384 Bits ab</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>Ruft eine Version des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) mit einer Hashgröße von 512 Bits ab</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>Gibt die Sicherheitsaktionen an, die mit deklarativer Sicherheit ausgeführt werden können.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>Der aufrufende Code kann auch dann auf die durch das aktuelle Berechtigungsobjekt angegebene Ressource zugreifen, wenn übergeordnete Aufrufer in der Aufrufliste keine Zugriffsberechtigung für die Ressource besitzen.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>Überprüft, ob allen Aufrufern in der Aufrufkette die angegebene Berechtigung erteilt wurde.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>Ohne weitere Überprüfungen wird die Anforderung für die angegebene Berechtigung abgelehnt.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>Der abgeleiteten Klasse, die die Klasse erbt oder eine Methode überschreibt, muss die angegebene Berechtigung erteilt worden sein.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>Stellt sicher, dass dem unmittelbaren Aufrufer die angegebene Berechtigung erteilt wurde.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>Keine deklarative Sicherheitsaktion.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>Verweigert ohne weitere Überprüfungen die Anforderung für alle Berechtigungen mit Ausnahme der angegebenen.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>Fordert die Mindestberechtigungen an, die zum Ausführen des Codes erforderlich sind. Diese Aktion kann nur innerhalb des Gültigkeitsbereichs der Assembly verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>Fordert weitere Berechtigungen an, die optional sind (für Ausführung nicht erforderlich). Diese Anforderung lehnt implizit alle anderen nicht speziell angeforderten Berechtigungen ab. Diese Aktion kann nur innerhalb des Gültigkeitsbereichs der Assembly verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>Fordert an, dass dem aufrufenden Code keine Berechtigungen erteilt werden, die missbraucht werden könnten. Diese Aktion kann nur innerhalb des Gültigkeitsbereichs der Assembly verwendet werden.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>Die Ressource wird nicht aus der Assembly exportiert.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>Die Ressource wird aus der Assembly exportiert.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>Maskiert nur die sichtbarkeitsbezogenen Attribute.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>Stellt die Form eines Arraytyps dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ArrayShape" />-Struktur.</summary>
      <param name="rank">Die Anzahl der Dimensionen im Array.</param>
      <param name="sizes">Die Größe jeder Dimension.</param>
      <param name="lowerBounds">Die untere Begrenzung jeder Dimension.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>Ruft die unteren Begrenzungen aller Dimensionen ab. Der Wert für „Length“ ist möglicherweise kleiner als der für „Rank“. In diesem Fall verfügen die nachstehenden Dimensionen über nicht angegebene untere Grenzen.</summary>
      <returns>Ein Array mit unteren Grenzen.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>Ruft die Anzahl der Dimensionen im Array ab.</summary>
      <returns>Die Anzahl der Dimensionen.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>Ruft die Größen alle Dimensionen ab.</summary>
      <returns>Ein Array von Größen.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>Ruft einen Wert ab, der angibt, ob die Datei Metadaten enthält.</summary>
      <returns>
        <see langword="true" />, wenn die Datei Metadaten enthält, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>Ruft den Hashwert des Dateiinhalts ab, der mit <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" /> berechnet wird.</summary>
      <returns>Eine <see cref="T:System.Reflection.Metadata.BlobHandle" />-Instanz, die den Hashwert des Datei Inhalts darstellt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>Ruft den Dateinamen einschließlich der Erweiterung ab.</summary>
      <returns>Eine <see cref="T:System.Reflection.Metadata.StringHandle" />-Instanz, die den Dateinamen mit der Erweiterung darstellt.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>Stellt eine Sammlung von <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> dar.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>Eine Sammlung von Assemblyverweisen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>Vergleicht den aktuellen Inhalt dieses Writers mit einem anderen Writer.</summary>
      <param name="other">Eine <see cref="T:System.Reflection.Metadata.BlobBuilder" />-Instanz, die mit dieser Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn Gleichheit vorliegt, andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>Gibt eine Sequenz aller Blobs zurück, die den Inhalt des Generators darstellen.</summary>
      <returns>Eine Sequenz von Blobs.</returns>
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>Reserviert einen zusammenhängenden Block von Bytes.</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>Versucht, eine Sequenz von Bytes in den Generator zu schreiben. Ein Rückgabewert gibt die Anzahl der erfolgreich geschriebenen Bytes an.</summary>
      <param name="source" />
      <param name="byteCount" />
      <returns>Die Anzahl der Bytes, die erfolgreich aus <paramref name="source" /> geschrieben wurden.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>Schreibt einen <see cref="T:System.Boolean" />-Wert in den Generator.</summary>
      <param name="value">Der zu schreibende Wert.</param>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>Schreibt einen <see cref="T:System.Byte" />-Wert in den Generator.</summary>
      <param name="value">Der zu schreibende Wert.</param>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>Schreibt eine angegebene Anzahl von Bytes aus einem Puffer in den Generator.</summary>
      <param name="buffer" />
      <param name="byteCount">Die Anzahl der zu schreibenden Bytes.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>Schreibt eine angegebene Anzahl von Vorkommen eines Bytewerts in den Generator.</summary>
      <param name="value" />
      <param name="byteCount">Die Anzahl der Vorkommen von <paramref name="value" />, die geschrieben werden sollen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>Schreibt den Inhalt eines Bytearrays in den Generator.</summary>
      <param name="buffer">Das zu schreibende Bytearray.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Schreibt eine angegebene Anzahl von Bytes ab einem angegebenen Index in einem Bytearray in den Generator.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Die Anzahl der zu schreibenden Bytes.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Schreibt den Inhalt eines unveränderlichen Bytearrays in den Generator.</summary>
      <param name="buffer">Das zu schreibende Array.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>Schreibt eine angegebene Anzahl von Bytes ab einem angegebenen Index eines unveränderlichen Arrays in den Generator.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">Die Anzahl der zu schreibenden Bytes.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>Implementiert einen komprimierten Integerwert ohne Vorzeichen, Codierung gemäß ECMA-335-II, Kapitel 23.2: Blobs und Signaturen.</summary>
      <param name="value">Der zu schreibende Wert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> kann nicht als komprimierter Integerwert ohne Vorzeichen dargestellt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementiert einen komprimierten Integerwert mit Vorzeichen, Codierung gemäß ECMA-335-II, Kapitel 23.2: Blobs und Signaturen.</summary>
      <param name="value">Der zu schreibende Wert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> kann nicht als komprimierter Integerwert mit Vorzeichen dargestellt werden.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>Schreibt einen konstanten Wert (siehe ECMA-335, Partition II, Abschnitt 22.9) an der aktuellen Position.</summary>
      <param name="value">Der zu schreibende konstante Wert.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> ist kein konstanter Typ.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> ist der Standardwert (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>Schreibt einen Verweis auf einen Heap (Heapoffset) oder eine Tabelle (Zeilennummer).</summary>
      <param name="reference">Heapoffset oder Tabellenzeilennummer.</param>
      <param name="isSmall">
        <see langword="true" />, um den Verweis als 16-Bit-Integerwert zu codieren. <see langword="false" />, um ihn als 32-Bit-Integerwert zu codieren.</param>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>Schreibt eine Zeichenfolge im SerString-Format (siehe ECMA-335-II 23.3: Benutzerdefinierte Attribute).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>Schreibt eine Zeichenfolge im Benutzerzeichenfolgen-Heapformat (#US) (siehe ECMA-335-II 24.2.4: #US- und #Blob-Heaps).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>Schreibt ein im UTF16-Format (Little-Endian) codiertes Zeichenarray an der aktuellen Position.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>Schreibt eine im UTF16-Format (Little-Endian) codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>Schreibt eine im UTF8-Format codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value">Ein konstanter Wert.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" />, um nicht gepaarte Ersatzzeichen wie angegeben zu codieren, <see langword="false" />, um sie durch ein U+FFFD-Zeichen zu ersetzen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>Erstellt einen Reader des angegebenen Speicherblocks.</summary>
      <param name="buffer">Ein Zeiger auf den Anfang des Speicherblocks.</param>
      <param name="length">Die Länge des Speicherblocks in Bytes.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform ist nicht Little-Endian.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>Positioniert den Reader um die Anzahl von Bytes nach vorn, die benötigt wird, um die angegebene Ausrichtung zu erfüllen.</summary>
      <param name="alignment" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>Ruft einen Zeiger auf das Byte an der aktuellen Position des Readers ab.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>Sucht nach einem angegebenen Byte im Blob, das auf die aktuelle Position folgt.</summary>
      <param name="value">Der zu suchende Bytewert.</param>
      <returns>Der Index relativ zur aktuellen Position oder -1, wenn das Byte im Blob nach der aktuellen Position nicht gefunden wurde.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>Ruft die Gesamtlänge des zugrunde liegenden Speicherblocks ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>Ruft den Offset vom Beginn des Blobs bis zur aktuellen Position ab oder legt ihn fest.</summary>
      <exception cref="T:System.BadImageFormatException">Der Offset wird außerhalb der Grenzen des zugrunde liegenden Readers festgelegt.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>Liest ein Blobheaphandle, das als komprimierter Integerwert codiert ist.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>Liest Bytes ab der aktuellen Position.</summary>
      <param name="byteCount">Die Anzahl der zu lesenden Bytes.</param>
      <returns>Das Bytearray.</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>Liest Bytes ab der aktuellen Position und schreibt sie in den angegebenen Puffer, beginnend am angegebenen Offset.</summary>
      <param name="byteCount">Die Anzahl der zu lesenden Bytes.</param>
      <param name="buffer">Der Zielpuffer, in den der Bytelesevorgang schreibt.</param>
      <param name="bufferOffset">Der Offset im Zielpuffer, in den der Bytelesevorgang geschrieben wird.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>Liest einen komprimierten Integerwert ohne Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II.23.2: Blobs und Signaturen.</summary>
      <returns>Der Wert des komprimierten Integerwerts, der gelesen wurde.</returns>
      <exception cref="T:System.BadImageFormatException">Die Daten an der aktuellen Position waren kein komprimierter gültiger Integerwert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>Liest einen komprimierten Integerwert mit Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II.23.2: Blobs und Signaturen.</summary>
      <returns>Der Wert des komprimierten Integerwerts, der gelesen wurde.</returns>
      <exception cref="T:System.BadImageFormatException">Die Daten an der aktuellen Position waren kein komprimierter gültiger Integerwert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>Liest einen konstanten Wert (siehe ECMA-335, Partition II, Abschnitt 22.9) ab der aktuellen Position.</summary>
      <param name="typeCode" />
      <returns>Ein geschachtelter konstanter Wert. Um die Zuordnung von Objekten zu vermeiden, verwenden Sie Read*-Methoden direkt.</returns>
      <exception cref="T:System.BadImageFormatException">Fehler beim Lesen aus dem Blob.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> ist kein gültiger <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>Liest eine <see cref="T:System.Decimal" />-Zahl.</summary>
      <exception cref="T:System.BadImageFormatException">Die Daten an der aktuellen Position waren keine gültige <see cref="T:System.Decimal" />-Zahl.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>Liest einen Typcode, der in einem serialisierten benutzerdefinierten Attributwert codiert ist.</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />, wenn die Codierung ungültig ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>Liest eine Zeichenfolge, die als komprimierter Integerwert codiert ist, und enthält ihre Länge, gefolgt von ihrem Inhalt im UTF8-Format. NULL-Zeichenfolgen werden als ein einzelnes 0xFF-Byte codiert.</summary>
      <returns>Ein Zeichenfolgenwert oder <see langword="null" />.</returns>
      <exception cref="T:System.BadImageFormatException">Die Codierung ist ungültig.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>Liest einen Typcode, der in einer Signatur codiert ist.</summary>
      <returns>Der Typcode, der im serialisierten benutzerdefinierten Attributwert codiert ist, wenn die Codierung gültig ist, oder <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />, wenn die Codierung ungültig ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>Liest ein Typhandle, das in einer Signatur als TypeDefOrRefOrSpecEncoded codiert (siehe ECMA-335 II.23.2.8).</summary>
      <returns>Das Handle, wenn die Codierung gültig ist. Andernfalls ein Handle, für das die <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" />-Eigenschaft <see langword="true" /> ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>Liest eine im UTF16-Format (Little-Endian) codierte Zeichenfolge ab der aktuellen Position.</summary>
      <param name="byteCount">Die Anzahl der zu lesenden Bytes.</param>
      <returns>Die Zeichenfolge.</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>Liest eine im UTF8-Format codierte Zeichenfolge ab der aktuellen Position.</summary>
      <param name="byteCount">Die Anzahl der zu lesenden Bytes.</param>
      <returns>Die Zeichenfolge.</returns>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>Ruft die Anzahl der Bytes ab, die ab der aktuellen Position bis zum Ende des zugrunde liegenden Speicherblocks verbleiben.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>Positioniert den Reader erneut am Anfang des zugrunde liegenden Speicherblocks.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>Ruft einen Zeiger auf das Byte am Anfang des zugrunde liegenden Speicherblocks ab.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>Liest einen komprimierten Integerwert ohne Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II.23.2: Blobs und Signaturen.</summary>
      <param name="value">Der Wert des komprimierten Integerwerts, der gelesen wurde.</param>
      <returns>
        <see langword="true" />, wenn der Wert erfolgreich gelesen wurde. <see langword="false" />, wenn die Daten an der aktuellen Position kein komprimierter gültiger Integerwert waren.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>Liest einen komprimierten Integerwert mit Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II.23.2: Blobs und Signaturen.</summary>
      <param name="value">Der Wert des komprimierten Integerwerts, der gelesen wurde.</param>
      <returns>
        <see langword="true" />, wenn der Wert erfolgreich gelesen wurde. <see langword="false" />, wenn die Daten an der aktuellen Position kein komprimierter gültiger Integerwert waren.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>Vergleicht den aktuellen Inhalt dieses Writers mit einem anderen Writer.</summary>
      <param name="other" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>Implementiert einen komprimierten Integerwert ohne Vorzeichen, Codierung gemäß ECMA-335-II, Kapitel 23.2: Blobs und Signaturen.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> kann nicht als komprimierter Integerwert ohne Vorzeichen dargestellt werden.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementiert einen komprimierten Integerwert mit Vorzeichen, Codierung gemäß ECMA-335-II, Kapitel 23.2: Blobs und Signaturen.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> kann nicht als komprimierter Integerwert mit Vorzeichen dargestellt werden.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>Schreibt einen konstanten Wert (siehe ECMA-335, Partition II, Abschnitt 22.9) an der aktuellen Position.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> ist kein konstanter Typ.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>Schreibt einen Verweis auf einen Heap (Heapoffset) oder eine Tabelle (Zeilennummer).</summary>
      <param name="reference">Heapoffset oder Tabellenzeilennummer.</param>
      <param name="isSmall">
        <see langword="true" />, um den Verweis als 16-Bit-Integerwert zu codieren. <see langword="false" />, um ihn als 32-Bit-Integerwert zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>Schreibt eine Zeichenfolge im SerString-Format (siehe ECMA-335-II 23.3: Benutzerdefinierte Attribute).</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>Schreibt eine Zeichenfolge im Benutzerzeichenfolgen-Heapformat (#US) (siehe ECMA-335-II 24.2.4: #US- und #Blob-Heaps).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>Schreibt eine im UTF16-Format (Little-Endian) codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>Schreibt eine im UTF16-Format (Little-Endian) codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>Schreibt eine im UTF8-Format codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> ist <see langword="null" />.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>Ruft das übergeordnete Handle ab (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>Ruft einen Typcode ab, mit dem der Typ des konstanten Werts identifiziert wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>Ruft den konstanten Wert ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>Gibt Werte an, die Typen von Metadatenkonstanten darstellen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Ein boolescher Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>Ein unsignierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>Ein Zeichentyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>Ein 8-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>Ein signierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>Ein signierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>Ein signierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>Ein ungültiger Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>Ein NULL-Verweis.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>Ein signierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>Ein 4-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>Ein <see cref="T:System.String" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>Ein unsignierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>Ein unsignierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>Ein unsignierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>Ruft den Konstruktor (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) des benutzerdefinierten Attributtyps ab.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>Decodiert die Argumente, die im Wertblob codiert sind.</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>Ruft das Handle für die Metadatenentität ab, auf die das Attribut angewendet wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>Ruft den Wert des Attributs ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>Stellt ein benanntes Argument dar, das aus einer benutzerdefinierten Attributsignatur codiert wurde.</summary>
      <typeparam name="TType">Der Typ, der zum Darstellen von Typen von Werten verwendet wird, die von der benutzerdefinierten Attribut Signatur decodiert werden</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" />-Struktur mithilfe des angegebenen Namens, der Art, dem Typen und dem Wert.</summary>
      <param name="name">Der Name des Arguments.</param>
      <param name="kind">Die Art des Arguments.</param>
      <param name="type">Der Typ des Arguments.</param>
      <param name="value">Der Wert des Arguments.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>Ruft die Art des Arguments ab.</summary>
      <returns>Die argumentart.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>Ruft den Namen des Arguments ab.</summary>
      <returns>Der Argumentname.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>Ruft den Typ des Arguments ab.</summary>
      <returns>Der Argumenttyp.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>Ruft den Wert des Arguments ab.</summary>
      <returns>Ein-Objekt, das den Argument Wert enthält.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>Gibt Konstanten an, die die Arten von Argumenten in einer benutzerdefinierten Attributsignatur definieren.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>Ein Feldargument.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>Ein Eigenschaftsargument.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>Stellt ein typisiertes Argument für ein benutzerdefiniertes Metadatenattribut dar.</summary>
      <typeparam name="TType">Der Typ des Arguments.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" />-Struktur mithilfe des angegebenen Argumenttypen und -werts.</summary>
      <param name="type">Der Typ des Arguments.</param>
      <param name="value">Der Argumentwert.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>Ruft den Typ des Arguments ab.</summary>
      <returns>Der Argumenttyp.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>Ruft den Wert des Arguments ab.</summary>
      <returns>Der Argumentwert.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>Stellt ein benutzerdefiniertes Attribut des von <paramref name="TType" /> angegebenen Typs dar.</summary>
      <typeparam name="TType">Der Attributtyp.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />-Struktur mithilfe der angegebenen festen und benannten Argumente.</summary>
      <param name="fixedArguments">Die festen Argumente.</param>
      <param name="namedArguments">Die benannten Argumente.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>Ruft die festen Argumente für das benutzerdefinierte Argument ab.</summary>
      <returns>Ein unveränderliches Array von Argumenten.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>Ruft die benannten Argumente für das benutzerdefinierte Argument ab.</summary>
      <returns>Ein unveränderliches Array von Argumenten.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>Ruft den Offset (in Bytes) vom Anfang des Metadatenblobs bis zum Anfang des <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />-Blobs ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.Document">
      <summary>Das Quelldokument in den Debugmetadaten.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>Ruft den Dokumentinhaltshash ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>Ruft den Hashalgorithmus ab, der zum Berechnen des <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256, usw.) verwendet wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>Ruft die Quellcodesprache (C#, VB, F# usw.) ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>Ruft das Dokumentnamenblob ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>Ein <see cref="T:System.Reflection.Metadata.BlobHandle" />, das ein Blob auf dem #Blob-Heap in Portable PDB darstellt, strukturiert als Dokumentname.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <param name="rank" />
      <param name="sizes" />
      <param name="lowerBounds" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <param name="fixedArguments" />
      <param name="namedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <param name="fixedArguments" />
      <param name="namedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <param name="variableCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <param name="convention" />
      <param name="genericParameterCount" />
      <param name="isInstanceMethod" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <param name="genericArgumentCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <param name="argumentCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <param name="attributeCount" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <param name="isInstanceProperty" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
      <param name="catchType" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
      <param name="filterStart" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="tryStart" />
      <param name="tryEnd" />
      <param name="handlerStart" />
      <param name="handlerEnd" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <param name="type" />
      <param name="isOptional" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <param name="kind" />
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="catchType" />
      <param name="filterOffset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="catchType" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
      <param name="filterOffset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <param name="tryOffset" />
      <param name="tryLength" />
      <param name="handlerOffset" />
      <param name="handlerLength" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <param name="startOffset" />
      <param name="length" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <param name="exceptionRegionCount" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <param name="codeBuilder" />
      <param name="controlFlowBuilder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="code" />
      <param name="label" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="signature" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder" />
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="label" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset" />
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <param name="argumentIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <param name="slotIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>ID mit der Basis 1 zur Identifizierung der Bezeichnung im Kontext eines <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>Stellt Methoden zum Codieren von Literalen bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">Erstellt eine neue Instanz der <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" />-Klasse mit dem angegebenen Blob-Generator.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>Gibt den Encoder zurück, der zum Codieren des Literalwerts verwendet wird.</summary>
      <returns>Der Encoder des Literalwerts.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>Codiert den Typ und den Wert eines Literals mithilfe der angegebenen Delegaten.</summary>
      <param name="type">Ein Delegat, der verwendet wird, um den Typ des Literals zu codieren. Wird von dieser Methode zuerst aufgerufen.</param>
      <param name="scalar">Ein Delegat, der verwendet wird, um den Wert des Literals zu codieren. Wird von dieser Methode als zweites aufgerufen.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>Gibt ein Encoderpaar zurück, das zum Codieren des Typs und des Werts eines Literals in der Reihenfolge verwendet werden muss, in der sie in der Parameterliste stehen.</summary>
      <param name="type">Nach Ausführung dieser Methode ein benutzerdefinierter Attributelementtyp-Encoder, der verwendet wird, um den Typ des Literals zu codieren.</param>
      <param name="scalar">Nach Ausführung dieser Methode ein codierter Skalarwert, der verwendet wird, um den Wert des Literals zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>Codiert den Typ und die Elemente eines Vektors mithilfe der angegebenen Delegaten.</summary>
      <param name="arrayType">Ein Delegat, der verwendet wird, um den Typ des Vektors zu codieren. Wird von dieser Methode zuerst aufgerufen.</param>
      <param name="vector">Ein Delegat, der verwendet wird, um die Elemente des Vektors zu codieren. Wird von dieser Methode als zweites aufgerufen.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>Gibt ein Encoderpaar zurück, das zum Codieren des Typs und der Elemente eines Vektorliterals in der Reihenfolge verwendet werden muss, in der sie in der Parameterliste stehen.</summary>
      <param name="arrayType">Nach Ausführung dieser Methode ein benutzerdefinierter Attributarraytyp-Encoder, der verwendet wird, um den Typ des Vektors zu codieren.</param>
      <param name="vector">Nach Ausführung dieser Methode ein codierter Vektor, der verwendet wird, um die Elemente des Vektors zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>Ruft einen Vektorencoder ab, der zum Codieren der Elemente eines Vektors verwendet wird.</summary>
      <returns>Ein Vektorencoder, der zum Codieren der Elemente eines Vektors verwendet wird.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>Berechnet das Handle der Entität in der Metadatengenerierung, in der sie definiert ist, wenn ein Handle einer Entität in Aggregatmetadaten angegeben ist.</summary>
      <param name="handle">Handle einer Entität in Aggregatmetadaten.</param>
      <param name="generation">Die Generierung, in der die Entität definiert ist.</param>
      <returns>Handle der Entität in der Metadaten-<paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>Die MetadataBuilder-Klasse liest und schreibt Metadaten für eine Assembly auf sehr leistungsfähige Weise. Sie dient der Verwendung durch Compiler und andere Tools zum Generieren von Assemblys.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Erstellt einen Generator für Metadatentabellen und Heaps.</summary>
      <param name="userStringHeapStartOffset">Das Anfangsoffset des Benutzerzeichenfolgenheaps. Die kumulierte Größe von Benutzerzeichenfolgenheaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
      <param name="stringHeapStartOffset">Das Anfangsoffset des Zeichenfolgenheaps. Die kumulierte Größe von Zeichenfolgenheaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
      <param name="blobHeapStartOffset">Das Anfangsoffset des Blobheaps. Die kumulierte Größe von Blobheaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
      <param name="guidHeapStartOffset">Das Anfangsoffset des GUID-Heaps. Die kumulierte Größe von GUID-Heaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>Fügt einen Standardwert für einen Parameter, ein Feld oder eine Eigenschaft hinzu.</summary>
      <param name="parent">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value">Der konstante Wert.</param>
      <returns>Ein Handle für die hinzugefügte Konstante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt ein benutzerdefiniertes Attribut hinzu.</summary>
      <param name="parent">Eine Entität zum Anfügen des benutzerdefinierten Attributs an folgende Handles: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor">Ein benutzerdefinierter Attributkonstruktor: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value">Ein benutzerdefiniertes Attributwertblob.</param>
      <returns>Ein Handle für das hinzugefügte benutzerdefinierte Attribut.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt benutzerdefinierte Debuginformationen hinzu.</summary>
      <param name="parent">Eine Entität zum Anfügen der Debuginformationen an folgende Handles: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> oder <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind">Die Art der Informationen. Bestimmt die Struktur des <paramref name="value" />-Blobs.</param>
      <param name="value">Das Blob für benutzerdefinierte Debuginformationen.</param>
      <returns>Ein Handle für die hinzugefügten benutzerdefinierten Debuginformationen.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt einem Typ, einer Methode oder einer Assembly ein deklaratives Sicherheitsattribut hinzu.</summary>
      <param name="parent">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action">Eine deklarative Sicherheitsaktion.</param>
      <param name="permissionSet">Das Blob für den Berechtigungssatz.</param>
      <returns>Ein Handle für das hinzugefügte deklarative Sicherheitsattribut.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>Fügt Dokumentdebuginformationen hinzu.</summary>
      <param name="name">Das Dokumentnamenblob.</param>
      <param name="hashAlgorithm">Die GUID des Hashalgorithmus, die zum Berechnen des Werts von <paramref name="hash" /> verwendet wird.</param>
      <param name="hash">Der Hash des Dokumenteninhalts.</param>
      <param name="language">Die GUID der Sprache.</param>
      <returns>Ein Handle für das hinzugefügte Dokument.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Fügt eine Ereignisdefinition hinzu.</summary>
      <param name="attributes">Die Ereignisattribute.</param>
      <param name="name">Der Name des Ereignisses.</param>
      <param name="type">Der Typ des Ereignisses: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns>Ein Handle für die hinzugefügte Ereignisdefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Fügt einen exportierten Typ hinzu.</summary>
      <param name="attributes">Die Typattribute.</param>
      <param name="namespace">Der Typnamespace.</param>
      <param name="name">Der Typname.</param>
      <param name="implementation">Das Handle der Implementierungsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> oder <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId">Die Typdefinitions-ID.</param>
      <returns>Ein Handle für den hinzugefügten exportierten Typ.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt eine Felddefinition hinzu.</summary>
      <param name="attributes">Die Feldattribute.</param>
      <param name="name">Der Feldname.</param>
      <param name="signature">Die Feldsignatur. Verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />, um das Blob zu erstellen.</param>
      <returns>Ein Handle für die hinzugefügte Felddefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Definiert ein Feldlayout einer Felddefinition.</summary>
      <param name="field">Das Felddefinitionshandle.</param>
      <param name="offset">Der Byteoffset des Felds in der deklarierenden Typinstanz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Fügt dem im PE-Image gespeicherten Anfangswert eine Zuordnung von einem Feld hinzu.</summary>
      <param name="field">Das Felddefinitionshandle.</param>
      <param name="offset">Der Offset innerhalb des Blocks im PE-Image, das Anfangswerte zugeordneter Felder speichert (normalerweise im .text-Abschnitt).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Fügt eine generische Parameterdefinition hinzu.</summary>
      <param name="parent">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes">Die generischen Parameterattribute.</param>
      <param name="name">Der Name des Parameters.</param>
      <param name="index">Der nullbasierte Parameterindex.</param>
      <returns>Ein Handle für den hinzugefügten generischen Parameter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Fügt einem generischen Parameter eine Typeinschränkung hinzu.</summary>
      <param name="genericParameter">Der einzuschränkende generischen Parameter.</param>
      <param name="constraint">Die Typeinschränkung. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns>Ein Handle für die hinzugefügte Einschränkung des generischen Parameters.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt Debuginformationen für den lokalen Bereich hinzu.</summary>
      <param name="parentScope">Das übergeordnete Bereichshandle.</param>
      <param name="imports">Das Importbereichshandle.</param>
      <returns>Ein Handle für den hinzugefügten Importbereich.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Fügt einem Typ eine Schnittstellenimplementierung hinzu.</summary>
      <param name="type">Der Typ, der die Schnittstelle implementiert.</param>
      <param name="implementedInterface">Die Schnittstelle, die implementiert wird. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <returns>Ein Handle für die hinzugefügte Schnittstellenimplementierung.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt Debuginformationen für die lokale Konstante hinzu.</summary>
      <param name="name">Der Name der Variablen.</param>
      <param name="signature">Das LocalConstantSig-Blob.</param>
      <returns>Ein Handle für die hinzugefügte lokale Konstante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>Fügt Debuginformationen für den lokalen Bereich hinzu.</summary>
      <param name="method">Die Methode mit Inhalt.</param>
      <param name="importScope">Das Handle des zugeordneten Importbereichs.</param>
      <param name="variableList">Wenn mit dem Bereich Variablen deklariert werden, legen Sie hierfür das Handle der ersten Variablen fest. Oder legen Sie hierfür das Handle der ersten Variablen fest, die mit der nächsten Bereichsdefinition deklariert wird. Wenn mit keinem Bereich Variablen definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
      <param name="constantList">Wenn mit dem Bereich Konstanten deklariert werden, legen Sie hierfür das Handle der ersten Variablen fest. Oder legen Sie hierfür das Handle der ersten Konstante fest, die mit der nächsten Bereichsdefinition deklariert wird. Wenn mit keinem Bereich Konstanten definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
      <param name="startOffset">Der vom Bereich abgedeckte Offset der ersten Anweisung.</param>
      <param name="length">Die Länge des Bereichs (in Byte).</param>
      <returns>Ein Handle für den hinzugefügten lokalen Bereich.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>Fügt Debuginformationen für die lokale Variable hinzu.</summary>
      <param name="attributes">Die Attribute der lokalen Variable.</param>
      <param name="index">Der nullbasierte Index der lokalen Variable in der lokalen Signatur.</param>
      <param name="name">Der Name der Variablen.</param>
      <returns>Ein Handle für die hinzugefügte lokale Variable.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>Fügt eine Manifestressource hinzu.</summary>
      <param name="attributes">Die Attribute der Manifestressource.</param>
      <param name="name">Der Name der Manifestressource.</param>
      <param name="implementation">Das Handle der Implementierungsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> oder <see langword="null" />.</param>
      <param name="offset">Gibt den Byteoffset in der referenzierten Datei an, an dem dieser Ressourceneintrag beginnt.</param>
      <returns>Ein Handle für die hinzugefügte Manifestressource.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt einem Feld oder einem Parameter Marshallinginformationen hinzu.</summary>
      <param name="parent">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> oder <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor">Das Deskriptorblob.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt eine MemberRef-Tabellenzeile hinzu.</summary>
      <param name="parent">Die Entität mit Inhalt. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name">Der Membername.</param>
      <param name="signature">Die Membersignatur.</param>
      <returns>Ein Handle für den hinzugefügten Memberverweis.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt Debuginformationen für die Methode hinzu.</summary>
      <param name="document">Das Handle eines einzelnen Dokuments, das alle Sequenzpunkte der Methode enthält, oder <see langword="null" />, wenn die Methode keine Sequenzpunkte enthält oder mehrere Dokumente umfasst.</param>
      <param name="sequencePoints">Das Sequenzpunkteblob, oder <see langword="null" />, wenn die Methode keine Sequenzpunkte enthält.</param>
      <returns>Ein Handle für die hinzugefügten Debuginformationen für die Methode.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>Fügt eine Methodendefinition hinzu.</summary>
      <param name="attributes">Die Methodenattribute.</param>
      <param name="implAttributes">Die Methodenimplementierungsattribute.</param>
      <param name="name">Der Methodenname.</param>
      <param name="signature">Die Methodensignatur.</param>
      <param name="bodyOffset">Offset innerhalb des Blocks im PE-Image, das Methodenkörper (IL-Stream) speichert, oder-1, wenn die Methode keinen Körper enthält.</param>
      <param name="parameterList">Wenn mit der Methode in der Parametertabelle Parameter deklariert werden, legen Sie hierfür das Handle des ersten Parameters fest. Oder legen Sie hierfür das Handle des ersten Parameters fest, der mit der nächsten Methodendefinition deklariert wird. Wenn im Modul keine Parameter deklariert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
      <returns>Ein Handle für die hinzugefügte Methodendefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Definiert eine Implementierung für eine Methodendeklaration innerhalb eines Typs.</summary>
      <param name="type">Die Typdefinition.</param>
      <param name="methodBody">Das Handle der Methodenkörperentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration">Das Handle der Methodendeklarationsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <returns>Ein Handle für die hinzugefügte Methodenimplementierung.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Fügt einer Methodendefinition Importinformationen hinzu.</summary>
      <param name="method">Das Handle der Methodendefinition.</param>
      <param name="attributes">Die Methodenimportattribute.</param>
      <param name="name">Der Name der nicht verwalteten Methode.</param>
      <param name="module">Das Modul, das die nicht verwaltete Methode enthält.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Ordnet eine Methode (Getter, Setter, Adder usw.) einer Eigenschaft oder einem Ereignis zu.</summary>
      <param name="association">Das Handle der Zuordnungsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics">Die Attribute der Methodensemantik.</param>
      <param name="methodDefinition">Die Methodendefinition.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt eine Methodenspezifikation (Instanziierung) hinzu.</summary>
      <param name="method">Das Handle der Entität der generischen Methode. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation">Das Instanziierungsblob, das die generischen Argumente der Methode codiert.</param>
      <returns>Ein Handle für die hinzugefügte Methodenspezifikation.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Definiert eine Schachtelungsbeziehung mit angegebenen Typdefinitionen.</summary>
      <param name="type">Das Handle der Definition des geschachtelten Typs.</param>
      <param name="enclosingType">Das Handle der Definition des einschließenden Typs.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Fügt eine Parameterdefinition hinzu.</summary>
      <param name="attributes">Die Parameterattribute.</param>
      <param name="name">Dies ist optional. Der Name des Parameters.</param>
      <param name="sequenceNumber">Die Sequenznummer des Parameters. Der Wert 0 bezieht sich auf den Rückgabetyp der Besitzermethode. Die zugehörigen Parameter werden ab hier beginnend mit 1 nummeriert.</param>
      <returns>Ein Handle für den hinzugefügten Parameter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Fügt eine Eigenschaftsdefinition hinzu.</summary>
      <param name="attributes">Die Eigenschaftsattribute.</param>
      <param name="name">Der Eigenschaftenname.</param>
      <param name="signature">Die Signatur der Eigenschaft.</param>
      <returns>Ein Handle für die hinzugefügte Eigenschaftsdefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Fügt Debuginformationen für die Zustandsautomatenmethode hinzu.</summary>
      <param name="moveNextMethod">Das Handle der <see langword="MoveNext" />-Methode des Zustandsautomaten (die vom Compiler generierte Methode).</param>
      <param name="kickoffMethod">Das Handle der Kickoffmethode (die benutzerdefinierte Iterator-/Async-Methode).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Fügt eine Typdefinition hinzu.</summary>
      <param name="attributes">Die Typattribute.</param>
      <param name="namespace">Der Typnamespace.</param>
      <param name="name">Der Typname.</param>
      <param name="baseType">Das Handle der Basistypentität. Hierbei kann es sich um eines der folgenden Handels handeln<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> oder <see langword="null" />.</param>
      <param name="fieldList">Wenn mit dem Typ Felder deklariert werden, legen Sie hierfür das Handle des ersten Felds fest. Oder legen Sie hierfür das Handle des ersten Felds fest, das mit der nächsten Typdefinition deklariert wird. Wenn im Modul durch den Typ keine Felder definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
      <param name="methodList">Wenn mit dem Typ Methoden deklariert werden, legen Sie hierfür das Handle der ersten Methode fest. Oder legen Sie hierfür das Handle der ersten Methode fest, die mit der nächsten Typdefinition deklariert wird. Wenn im Modul durch den Typ keine Methoden definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
      <returns>Ein Handle für die hinzugefügte Typdefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>Definiert ein Typlayout einer Typdefinition.</summary>
      <param name="type">Die Typdefinition.</param>
      <param name="packingSize">Gibt an, dass Felder in der Typinstanz mit Byteadressen platziert werden müssen, bei denen es sich um ein Vielfaches von <paramref name="packingSize" /> handelt, oder mit einer natürlichen Ausrichtung für diesen Feldtyp, je nachdem, welcher Wert kleiner ist. Der entsprechende Wert muss einer der folgenden sein: 0, 1, 2, 4, 8, 16, 32, 64 oder 128. Der Wert 0 (null) gibt an, dass die verwendete Paketgröße mit der Standardeinstellung für die aktuelle Plattform übereinstimmen muss.</param>
      <param name="size">Gibt eine Mindestgröße für die Typinstanz an, und soll ein Auffüllen ermöglichen. Der zugeordnete Arbeitsspeicher entspricht dem Maximalwert für die Größe, die für das Layout und <paramref name="size" /> berechnet wird. Wenn diese Direktive auf einen Werttyp angewendet wird, ist die Größe kleiner als 1 MB.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>Fügt einen Typverweis hinzu.</summary>
      <param name="resolutionScope">Die Entität, mit der der Zieltyp deklariert wird. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see langword="null" />.</param>
      <param name="namespace">Der Namespace des Typverweises.</param>
      <param name="name">Der Name des Typverweises.</param>
      <returns>Ein Handle für den hinzugefügten Typverweis.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>Fügt dem Blobheap das angegebene Blob hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value">Das Array, welches das Blob enthält.</param>
      <returns>Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Fügt dem Blobheap das angegebene Blob aus dem Bytearray hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value">Das Array, welches das Blob enthält.</param>
      <returns>Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>Fügt dem Blobheap das angegebene Blob aus einem unveränderlichen Bytearray hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value">Die Blobgeneratorinstanz, die das Blob enthält.</param>
      <returns>Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>Codiert eine Zeichenfolge mithilfe der UTF16-Codierung in ein Blob, und fügt sie dem Blobheap hinzu, wenn sie nicht bereits enthalten ist.</summary>
      <param name="value">Die hinzuzufügende Zeichenfolge.</param>
      <returns>Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>Codiert eine Zeichenfolge mithilfe der UTF8-Codierung in ein Blob, und fügt es dem Blobheap hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value">Der hinzuzufügende Wert.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" />, um die nicht gepaarten Ersatzzeichen wie angegeben zu codieren, <see langword="false" />, um sie durch das U+FFFD-Zeichen zu ersetzen.</param>
      <returns>Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>Codiert einen konstanten Wert in ein Blob, und fügt es dem Blobheap hinzu, sofern es nicht bereits enthalten ist. Verwendet UTF16 zum Codieren von Zeichenfolgenkonstanten.</summary>
      <param name="value">Der hinzuzufügende konstante Wert.</param>
      <returns>Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>Codiert einen Debugdokumentnamen, und fügt ihn dem Blobheap hinzu, sofern er nicht bereits enthalten ist.</summary>
      <param name="value">Der Dokumentname, der hinzugefügt werden soll.</param>
      <returns>Ein Handle für das hinzugefügte oder vorhandene Dokumentnamenblob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>Fügt dem GUID-Heap die angegebene GUID hinzu, sofern sie nicht bereits enthalten ist.</summary>
      <param name="guid">Die GUID, die hinzugefügt werden soll.</param>
      <returns>Ein Handle für die hinzugefügte oder vorhandene GUID.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>Fügt dem Zeichenfolgenheap die angegebene Zeichenfolge hinzu, sofern sie nicht bereits enthalten ist.</summary>
      <param name="value">Die hinzuzufügende Zeichenfolge.</param>
      <returns>Ein Handle für die hinzugefügte oder vorhandene Zeichenfolge.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>Fügt dem Benutzerzeichenfolgenheap die angegebene Zeichenfolge hinzu, sofern sie nicht bereits enthalten ist.</summary>
      <param name="value">Die hinzuzufügende Zeichenfolge.</param>
      <returns>Ein Handle für die hinzugefügte oder vorhandene Zeichenfolge. Dieser Wert kann in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> verwendet werden.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Gibt die aktuelle Anzahl der Elemente in der angegebenen Tabelle zurück.</summary>
      <param name="table">Der Tabellenindex.</param>
      <returns>Die Anzahl der Elemente in der Tabelle.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>Gibt die aktuelle Anzahl der Elemente in den einzelnen Tabellen zurück.</summary>
      <returns>Ein Array der Größe <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, wobei jedes Element die aktuelle Zeilenanzahl der entsprechenden Tabelle enthält.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>Reserviert im GUID-Heap Speicherplatz für eine GUID.</summary>
      <returns>Ein Handle für die reservierte GUID und ein <see cref="T:System.Reflection.Metadata.Blob" />, welches das GUID-Blob wie im Heap gespeichert darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>Reserviert im Benutzerzeichenfolgenheap Speicherplatz für eine Zeichenfolge der angegebenen Länge.</summary>
      <param name="length">Die Anzahl der zu reservierenden Zeichen.</param>
      <returns>Ein Handle für die reservierte Benutzerzeichenfolge und ein <see cref="T:System.Reflection.Metadata.Blob" />, welches das gesamte Benutzerzeichenfolgenblob (einschließlich Länge und Terminalzeichen) darstellt. Das Handle kann in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> verwendet werden.
Verwenden Sie <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" />, um den Blobinhalt aufzufüllen.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>Legt die Kapazität des angegebenen Heaps fest.</summary>
      <param name="heap">Der Heapindex.</param>
      <param name="byteCount">Die Anzahl der Bytes.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Legt die Kapazität der angegebenen Tabelle fest.</summary>
      <param name="table">Der Tabellenindex.</param>
      <param name="rowCount">Die Anzahl der Zeilen in der Tabelle.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>Stellt Erweiterungsmethoden für die Verwendung von bestimmten Rohelementen der ECMA-335-Metadatentabellen und -Heaps bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Listet Einträge des EnC-Protokolls auf.</summary>
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Listet Einträge der EnC-Zuordnung auf.</summary>
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Gibt den Offset vom Beginn der Metadaten zum angegebenen Heap zurück.</summary>
      <param name="reader" />
      <param name="heapIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Gibt die Größe des angegebenen Heaps zurück.</summary>
      <param name="reader" />
      <param name="heapIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>Gibt das Handle für den <see cref="T:System.Reflection.Metadata.Blob" /> zurück, der auf den im <see cref="T:System.Reflection.Metadata.Blob" /> Heap angegebenen folgt, oder ein Nil-Handle, wenn es sich um das letzte Handle handelt.</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>Gibt das Handle für die Zeichenfolge zurück, die auf die im Zeichenfolgenheap angegebene folgt, oder ein Nil-Handle, wenn es sich um das letzte Handle handelt.</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>Gibt das Handle für den UserString zurück, der auf den im UserString-Heap angegebenen folgt, oder ein Nil-Handle, wenn es sich um das letzte Handle handelt.</summary>
      <param name="reader" />
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Gibt den Offset vom Beginn der Metadaten zur angegebenen Tabelle zurück.</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Gibt die Anzahl von Zeilen in der angegebenen Tabelle zurück.</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Gibt die Größe einer Zeile in der angegebenen Tabelle zurück.</summary>
      <param name="reader" />
      <param name="tableIndex" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumeriert Typen, die mindestens ein Ereignis definieren.</summary>
      <param name="reader" />
      <returns>Die resultierende Sequenz entspricht genau den Einträgen in der EventMap-Tabelle, d. h., das n-te zurückgegebene <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> wird in der n-ten Zeile von EventMap gespeichert.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumeriert Typen, die mindestens eine Eigenschaft definieren.</summary>
      <param name="reader" />
      <returns>Die resultierende Sequenz entspricht genau den Einträgen in der Eigenschaftszuordnungstabelle, d. h., das n-te zurückgegebene <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> wird in der n-ten Zeile der Eigenschaftenzuordnung gespeichert.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>Bestimmt bei Vorliegen eines Typhandles und einer in einem Signaturblob gefundenen Rohtypart, ob der Zieltyp ein Werttyp oder ein Verweistyp ist.</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>Der Generator eines Metadatenstamms, der in ein portierbares ausführbares Image eingebettet werden soll.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>Erstellt einen Generator eines Metadatenstamms.</summary>
      <param name="tablesAndHeaps">Generator, der mit in Tabellen gespeicherten Metadatenentitäten und in Heaps gespeicherten Werten aufgefüllt wird. Die Entitäten und Werte werden aufgezählt, wenn der Metadatenstamm serialisiert wird.</param>
      <param name="metadataVersion">Die in den Metadatenheader geschriebene Versionszeichenfolge. Der Standardwert lautet „v4.0.30319“.</param>
      <param name="suppressValidation">
        <see langword="true" />, um eine grundlegende Validierung von Metadatentabellen während der Serialisierung zu unterdrücken, andernfalls <paramref name="false" />.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>Die Metadatenversion.</summary>
      <returns>Eine Zeichenfolge, die die Metadatenversion darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>Serialisiert den Metadatenstamminhalt in den angegebenen <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder">Der Generator, in den geschrieben werden soll.</param>
      <param name="methodBodyStreamRva">Die relative virtuelle Adresse des Starts des Methodenkörper-Datenstroms. Wird verwendet, um den endgültigen Wert der RVA-Felder der MethodDef-Tabelle zu berechnen.</param>
      <param name="mappedFieldDataStreamRva">Die relative virtuelle Adresse des Starts des Feldinitialisierungs-Datenstroms. Wird verwendet, um den endgültigen Wert der RVA-Felder der FieldRVA-Tabelle zu berechnen.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>Gibt die Größen verschiedener Metadatenstrukturen zurück.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>Bestimmt, ob die grundlegende Validierung von Metadatentabellen unterdrückt werden soll. Mit der Validierung wird überprüft, ob Einträge in den Tabellen in der von der ECMA-Spezifikation benötigten Reihenfolge hinzugefügt wurden. Damit werden nicht alle Spezifikationsanforderungen für Metadatentabellen erzwungen.</summary>
      <returns>
        <see langword="true" />, die grundlegende Validierung von Metadatentabellen zu unterdrücken. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>Stellt Informationen zu den Größen verschiedener Metadatenstrukturen bereit.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>Anzahl der Zeilen externer Tabellen.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Gibt die ausgerichtete Größe des angegebenen Heaps zurück.</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>Exakte (nicht ausgerichtete) Heapgrößen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>Anzahl der Tabellenzeilen.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>Erstellt aus einem Tokenwert ein Entitätshandle.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Erstellt aus einem Tokenwert ein <see cref="T:System.Reflection.Metadata.EntityHandle" />.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" />
      <returns>Nullbasierter Offset, oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> oder <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" />
      <returns>1-basierter Index im #Guid-Heap. Im Gegensatz zu anderen Heaps, bei denen es sich im Wesentlichen um Bytearrays handelt, ist der #Guid-Heap ein Array aus 16-Byte-GUIDs.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" />
      <returns>Offset im entsprechenden Heap oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> oder <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Ruft den Offset von Metadatenheap-Daten ab, der dem angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> entspricht.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Nullbasierter Offset oder-1, wenn <paramref name="handle" /> kein Metadatenheap Handle ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" />
      <returns>Nullbasierter Offset oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> oder <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" />
      <returns>Nullbasierter Offset.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>Ruft die Zeilennummer eines Metadaten-Tabelleneintrags ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" />
      <returns>Nullbasierte Zeilennummer oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> interpretiert werden kann.
Siehe <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Ruft die Zeilennummer eines Metadaten-Tabelleneintrags ab, der dem angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> entspricht.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Zeilennummer mit der Basis 1.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>Ruft das Metadatentoken des angegebenen <paramref name="handle" /> ab.</summary>
      <param name="handle" />
      <returns>Metadatentoken oder 0, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>Ruft das Metadatentoken des angegebenen <paramref name="handle" /> ab.</summary>
      <param name="handle" />
      <returns>Metadatentoken oder 0, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Ruft das Metadatentoken des angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> ab.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Metadatentoken.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Ruft das Metadatentoken des angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> ab.</summary>
      <param name="reader" />
      <param name="handle" />
      <returns>Metadatentoken.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>Erstellt ein Handle aus einem Tokenwert.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Erstellt aus einem Tokenwert ein <see cref="T:System.Reflection.Metadata.EntityHandle" />.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Maximale Anzahl von Tabellen, die in Ecma335-Metadaten vorhanden sein können.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Maximale Anzahl von Tabellen, die in Ecma335-Metadaten vorhanden sein können.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>Ruft den <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> des Heaps ab, der der angegebenen <see cref="T:System.Reflection.Metadata.HandleKind" /> entspricht.</summary>
      <param name="type">Handletyp.</param>
      <param name="index">Heapindex.</param>
      <returns>
        <see langword="true" />, wenn der Handletyp einem Ecma335-Heap entspricht. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>Ruft den <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> der Tabelle ab, die der angegebenen <see cref="T:System.Reflection.Metadata.HandleKind" /> entspricht.</summary>
      <param name="type">Handletyp.</param>
      <param name="index">Tabellenindex.</param>
      <returns>
        <see langword="true" />, wenn der Handletyp einer Ecma335- oder portablen PDB-Tabelle entspricht. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>Definiert Methodentextattribute.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>Initialisiert alle von der Methode definierten lokalen Variablen mit null und weist lokalen Arbeitsspeicher dynamisch zu.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>Führt keine lokale Arbeitsspeicherinitialisierung aus.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>Stellt einen Encoder für einen Methodentext-Datenstrom bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom mithilfe der bereitgestellten Codegröße, der maximalen Stapelgröße, der Anzahl der Ausnahmebereiche, des Signaturhandles der lokalen Variablen und der Methodentextattribute hinzu. Ermöglicht außerdem die Angabe, ob die Ausnahmebereiche im kleinen Format codiert werden sollen.</summary>
      <param name="codeSize">Die Anzahl von Bytes, die für Anweisungen reserviert werden soll.</param>
      <param name="maxStack">Die maximale Stapelgröße.</param>
      <param name="exceptionRegionCount">Die Anzahl der Ausnahmebereiche.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" />, wenn die Ausnahmebereiche im kleinem Format codiert werden sollen, andernfalls <see langword="false" />.</param>
      <param name="localVariablesSignature">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes">Die Methodentextattribute.</param>
      <returns>Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom mithilfe der bereitgestellten Codegröße, der maximalen Stapelgröße, der Anzahl der Ausnahmebereiche, des Signaturhandles der lokalen Variablen und der Methodentextattribute hinzu. Ermöglicht außerdem die Angabe, ob die Ausnahmebereiche im kleinen Format codiert werden sollen. Ermöglicht auch die Angabe, ob die Methode aus dem dynamischen lokalen Speicherpool zugeordnet werden soll.</summary>
      <param name="codeSize">Die Anzahl von Bytes, die für Anweisungen reserviert werden soll.</param>
      <param name="maxStack">Die maximale Stapelgröße.</param>
      <param name="exceptionRegionCount">Die Anzahl der Ausnahmebereiche.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" />, wenn die Ausnahmebereiche im kleinem Format codiert werden sollen, andernfalls <see langword="false" />.</param>
      <param name="localVariablesSignature">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes">Die Methodentextattribute.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" />, wenn die Methode aus dem dynamischen lokalen Speicherpool zugeordnet wird (die <see langword="localloc" />-Anweisung), andernfalls <see langword="false" />.</param>
      <returns>Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom hinzu.</summary>
      <param name="instructionEncoder">Der Anweisungsencoder.</param>
      <param name="maxStack">Die maximale Stapelgröße.</param>
      <param name="localVariablesSignature">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes">Die Methodentextattribute.</param>
      <returns>Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom mithilfe des bereitgestellten Anweisungsencoders, der maximalen Stapelgröße, des Signaturhandles der lokalen Variablen und der Methodentextattribute hinzu. Ermöglicht außerdem die Angabe, ob die Methode Zuordnungen aus dem dynamischen lokalen Speicherpool vornehmen soll.</summary>
      <param name="instructionEncoder">Der Anweisungsencoder.</param>
      <param name="maxStack">Die maximale Stapelgröße.</param>
      <param name="localVariablesSignature">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes">Die Methodentextattribute.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" />, wenn die Methode aus dem dynamischen lokalen Speicherpool zugeordnet wird (die IL enthält die <see langword="localloc" />-Anweisung), andernfalls <see langword="false" />.</param>
      <returns>Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>Beschreibt einen Methodentext. Diese Klasse ist für die Verwendung mit der <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />-Klasse gedacht.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>Ruft ein Encoderobjekt ab, das verwendet werden kann, um Ausnahmebereiche für den Methodentext zu codieren.</summary>
      <returns>Eine Ausnahme Regions-Encoder-Instanz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>Ruft ein Blob ab, das für Anweisungen reserviert ist.</summary>
      <returns>Ein BLOB, das für Anweisungen reserviert ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>Ruft den Offset des codierten Methodentexts im Methodentext-Datenstrom ab.</summary>
      <returns>Der Offset des codierten Methoden Texts im Text Datenstrom der Methode.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>Stellt einen Encoder für Methodensignaturen bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>Codiert den bereitgestellten Rückgabetyp und die Parameter.</summary>
      <param name="parameterCount">Die Anzahl der Parameter.</param>
      <param name="returnType">Die Methode, die zuerst aufgerufen wird, um den Rückgabetyp zu codieren.</param>
      <param name="parameters">Die Methode, die als Zweites aufgerufen wird, um die Parameter zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>Codiert den bereitgestellten Rückgabetyp und die Parameter, die in der Reihenfolge verwendet werden müssen, in der sie in der Parameterliste angezeigt werden.</summary>
      <param name="parameterCount">Die Anzahl der Parameter.</param>
      <param name="returnType">Die Methode, die zuerst aufgerufen wird, um die Rückgabetypen zu codieren.</param>
      <param name="parameters">Die Methode, die als Zweites aufgerufen wird, um die Parameter zu codieren.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />-Struktur.</summary>
      <param name="builder">Ein Generator zum Codieren des benannten Arguments.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>Codiert ein benanntes Argument (ein Feld oder eine Eigenschaft).</summary>
      <param name="isField">
        <see langword="true" />, um ein Feld zu codieren, <see langword="false" />, um eine Eigenschaft zu codieren.</param>
      <param name="type">Die Methode, die zuerst aufgerufen werden soll, um den Typ des Arguments zu codieren.</param>
      <param name="name">Die Methode, die als Zweites aufgerufen werden soll, um den Namen des Felds oder der Eigenschaft zu codieren.</param>
      <param name="literal">Die Methode, die als Drittes aufgerufen werden soll, um den Literalwert des Arguments zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>Codiert ein benanntes Argument (ein Feld oder eine Eigenschaft) und gibt drei Encoder zurück, die in der Reihenfolge verwendet werden müssen, in der sie in der Parameterliste angezeigt werden.</summary>
      <param name="isField">
        <see langword="true" />, um ein Feld zu codieren, <see langword="false" />, um eine Eigenschaft zu codieren.</param>
      <param name="type">Die Methode, die zuerst aufgerufen werden soll, um den Typ des Arguments zu codieren.</param>
      <param name="name">Die Methode, die als Zweites aufgerufen werden soll, um den Namen des Felds oder der Eigenschaft zu codieren.</param>
      <param name="literal">Die Methode, die als Drittes aufgerufen werden soll, um den Literalwert des Arguments zu codieren.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>Stellt den Generator eines Portable PDB-Images dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>Erstellt einen Generator eines Portable PDB-Image.</summary>
      <param name="tablesAndHeaps">Ein Generator, der mit in Tabellen gespeicherten Metadatenentitäten und in Heaps gespeicherten Werten aufgefüllt wird. Die Entitäten und Werte werden aufgezählt, wenn das Portable PDB-Image serialisiert wird.</param>
      <param name="typeSystemRowCounts">Die Zeilenanzahl aller Tabellen, die die zugeordneten Typsystemmetadaten enthalten. Jeder Slot im Array entspricht einer Tabelle (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). Die Länge des Arrays muss gleich <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> sein.</param>
      <param name="entryPoint">Ein Einstiegspunktmethoden-Definitionshandle.</param>
      <param name="idProvider">Eine Funktion, die die ID von Inhalts berechnet, der als Sequenz von Blobs dargestellt wird. Wenn nicht angegeben, wird eine Standardfunktion verwendet, die den Inhalt ignoriert und eine Inhalts-ID basierend auf der aktuellen Uhrzeit zurückgibt (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Sie müssen eine deterministische Funktion angeben, um ein deterministisches Portable PDB-Image zu generieren.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>Serialisiert den portablen PDB-Inhalt in den angegebenen <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder">Der Generator, in den geschrieben werden soll.</param>
      <returns>Die ID des serialisierten Inhalts.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>Codiert ein konstantes Literal.</summary>
      <param name="value">Eine Konstante vom Typ <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (als Zwei-Byte-Unicode-Zeichen codiert), <see cref="T:System.String" /> (als SerString codiert) oder <see cref="T:System.Enum" /> (als zugrunde liegender Integerwert codiert).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>Codiert ein <see langword="null" />-Literal vom Typ <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>Codiert ein Literal vom Typ <see cref="T:System.Type" /> (das möglicherweise <see langword="null" /> sein kann).</summary>
      <param name="serializedTypeName">Der Name des Typs oder <see langword="null" />.</param>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>Decodiert Signaturblobs.</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>Erstellt einen neuen <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider">Der Anbieter, der zum Abrufen von Typsymbolen beim Decodieren der Signatur verwendet wird.</param>
      <param name="metadataReader">Der Metadatenreader, von dem die Signatur abgerufen wurde. Dies kann <see langword="null" /> sein, wenn der angegebene Anbieter dies zulässt.</param>
      <param name="genericContext">Zusätzlicher Kontext, der zum Auflösen generischer Parameter benötigt wird.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodiert ein Feldsignaturblob und positioniert den Reader hinter der Signatur.</summary>
      <param name="blobReader">Der bei einer Feldsignatur positionierte Blobreader.</param>
      <returns>Der decodierte Feldtyp.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodiert ein Signaturblob einer lokalen Variablen und positioniert den Reader hinter der Signatur.</summary>
      <param name="blobReader">Der bei einer Signatur einer lokalen Variable positionierte Blobreader.</param>
      <returns>Die Typen der lokalen Variable.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodiert ein Methoden- (Definition, Verweis, oder eigenständig) oder ein Eigenschaftensignaturblob.</summary>
      <param name="blobReader">Ein bei einer Methodensignatur positionierter Blobreader.</param>
      <returns>Die decodierte Methodensignatur.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodiert ein Methodenspezifikationssignatur-Blob und positioniert den Reader hinter der Signatur.</summary>
      <param name="blobReader">Ein Blobreader, der an einer gültigen Methodenspezifikationssignatur positioniert ist.</param>
      <returns>Die Typen, die zum Instanziieren einer generischen Methode über die Methodenspezifikation verwendet werden.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>Decodiert einen Typ, der in eine Signatur eingebettet ist, und positioniert den Reader hinter dem Typ.</summary>
      <param name="blobReader">Der bei einem führenden <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> positionierte Blobreader.</param>
      <param name="allowTypeSpecifications">
        <see langword="true" />, um zuzulassen, dass einem <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> (CLASS | VALUETYPE) in der Signatur gefolgt wird, andernfalls <see langword="false" />.</param>
      <returns>Der decodierte Typ.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>Codiert einen Arraytyp.</summary>
      <param name="elementType">Wird zuerst aufgerufen, um den Typ des Elements zu codieren.</param>
      <param name="arrayShape">Wird als Zweites aufgerufen, um die Form des Arrays zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>Codiert einen Arraytyp. Gibt ein Encoderpaar zurück, das in der Reihenfolge verwendet werden muss, in der die Encoder in der Parameterliste angezeigt werden.</summary>
      <param name="elementType">Wird zuerst verwendet, um den Typ des Elements zu codieren.</param>
      <param name="arrayShape">Wird als Zweites verwendet, um die Form des Arrays zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>Startet eine Signatur eines Typs mit benutzerdefinierten Modifizierern.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>Startet eine Funktionszeigersignatur.</summary>
      <param name="convention">Aufrufkonvention.</param>
      <param name="attributes">Funktionszeigerattribute.</param>
      <param name="genericParameterCount">Anzahl generischer Parameter.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>Startet eine generische Instanziierungssignatur.</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount">Anzahl generischer Argumente.</param>
      <param name="isValueType">
        <see langword="true" />, um den Typ als Werttyp zu markieren, <see langword="false" />, um ihn als Verweistyp in der Signatur zu markieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>Codiert einen Verweis auf den Typparameter einer enthaltenden generischen Methode.</summary>
      <param name="parameterIndex">Parameterindex.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>Codiert einen Verweis auf den Typparameter eines enthaltenden generischen Typs.</summary>
      <param name="parameterIndex">Parameterindex.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>Startet die Zeigersignatur.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Schreibt primitiven Typcode.</summary>
      <param name="type">Beliebiger primitiver Typcode mit Ausnahme von <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> und <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>Startet die Signatur des SZ-Arrays (Vektor).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Codiert einen Verweis auf einen Typ.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType">
        <see langword="true" />, um den Typ als Werttyp zu markieren, <see langword="false" />, um ihn als Verweistyp in der Signatur zu markieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>Codiert einen void-Zeiger (void*) auf den zugehörigen gespeicherten Wert zugreifen.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>Stellt eine Metadatenentität dar (z. B. einen Typverweis, eine Typdefinition, eine Typspezifikation, eine Methodendefinition oder ein benutzerdefiniertes Attribut).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und das angegebene Objekt gleich sind.</summary>
      <param name="obj">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="obj" /> eine <see cref="T:System.Reflection.Metadata.EntityHandle" />-Struktur ist und der aktuellen Instanz entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und die angegebene <see cref="T:System.Reflection.Metadata.EntityHandle" />-Struktur gleich sind.</summary>
      <param name="other">Der Wert, der mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn die angegebene Instanz und <paramref name="other" /> gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns>Der Hashcode für diese Instanz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>Ruft ein TypeRef-, TypeDef- oder TypeSpec-Handle ab, wenn die Region ein Treffer ist, andernfalls ein NULL-Token (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>Ruft den IL-Offset am Anfang des Filterblocks oder -1 ab, wenn die Region kein Filter ist.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>Ruft die Länge des Ausnahmehandlers in Bytes ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>Ruft den IL-Anfangsoffset des Ausnahmehandlers ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>Ruft die Länge des try-Blocks in Bytes ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>Ruft den IL-Anfangsoffset des try-Blocks ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>Ruft ein Handle zum Auflösen der Implementierung des Zieltyps ab.</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />ein anderes Modul in der Assembly.
<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />eine andere Assembly, <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> Wenn <see langword="true" />ist.
<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />ein, der den deklarierenden exportierten Typ darstellt, in dem dieses gescheitet ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>Ruft den Namen des Zieltyps oder <see langword="default" /> ab, wenn der Typ geschachtelt ist oder in einem Stammnamespace definiert wird.</summary>
      <returns>Eine <see cref="T:System.Reflection.Metadata.StringHandle" /> Struktur Instanz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>Ruft den vollständigen Namen des Namespaces ab, der den Zieltyp enthält, oder <see langword="default" />, wenn der Typ geschachtelt ist oder in einem Stammnamespace definiert wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>Ruft das Definitionshandle des Namespaces ab, in dem der Zieltyp definiert wird, oder <see langword="default" />, wenn der Typ geschachtelt ist oder in einem Stammnamespace definiert wird.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>Stellt eine Auflistung von <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />-Instanzen dar.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>Gibt den Feldlayoutoffset zurück, oder -1, wenn er nicht verfügbar ist.</summary>
      <returns>Der Felddefinitionsoffset, oder -1, wenn er nicht verfügbar ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>Ruft die Attribute ab, die Varianz und Einschränkungen angeben.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>Ruft den nullbasierten (0) Index des Parameters innerhalb des deklarierenden generischen Typs oder einer Methodendeklaration ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>Ruft den Namen des generischen Parameters ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>Ruft ein <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ab, das das übergeordnete Element dieses generischen Parameters darstellt.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>Ruft das eingeschränkte <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>Ruft ein Handle ab (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />), das angibt, von welchem Typ dieser generische Parameter ausschließlich abgeleitet werden kann, oder die Schnittstelle, die dieser generische Parameter ausschließlich implementieren kann.</summary>
      <returns>Eine <see cref="T:System.Reflection.Metadata.EntityHandle" />-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>Stellt eine Sammlung von Einschränkungen eines generischen Typparameters dar.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <param name="index" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>Stellt eine Sammlung von generischen Typparametern einer Methode oder eines Typs dar.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <param name="index" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>Stellt eine beliebige Metadatenentität (z.B. einen Typverweis, eine Typdefinition, eine Typspezifikation, eine Methodendefinition oder ein benutzerdefiniertes Attribut) oder einen Wert (eine Zeichenfolge, ein Blob, eine GUID oder eine Benutzerzeichenfolge) dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Vergleicht zwei Entitätshandles.</summary>
      <param name="x">Das erste zu vergleichende Entitätshandle.</param>
      <param name="y">Das zweite zu vergleichende Entitätshandle.</param>
      <returns>Null (0), wenn die zwei Entitätshandles gleich sind, und ein Wert ungleich null (0), wenn nicht.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Vergleicht zwei Handles.</summary>
      <param name="x">Das erste zu vergleichende Handle.</param>
      <param name="y">Das zweite zu vergleichende Handle.</param>
      <returns>Null (0), wenn die beiden Handles gleich sind, und ein Wert ungleich null (0), wenn nicht.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="x" />
      <param name="y" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="x" />
      <param name="y" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <param name="obj" />
    </member>
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>Ruft das Typsymbol für ein generalisiertes Array des angegebenen Elementtyps und der angegebenen Form ab.</summary>
      <param name="elementType">Der Typ der Elemente im Array.</param>
      <param name="shape">Die Form (Rang, Größen und untere Grenzen) des Arrays.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>Ruft das Typsymbol für einen verwalteten Zeiger auf den angegebenen Elementtyp ab.</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Ruft das Typsymbol für eine generische Instanziierung des angegebenen generischen Typs mit den angegebenen Typargumenten ab.</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>Ruft das Typsymbol für einen nicht verwalteten Zeiger auf den angegebenen Elementtyp ab.</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>Ruft die <typeparamref name="TType" />-Darstellung für <see cref="T:System.Type" /> ab.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>Ruft das Typsymbol für den angegebenen serialisierten Typnamen ab.</summary>
      <param name="name">Der serialisierte Typname im sogenannten „Reflektionsnotations“-Format (gemäß der <see cref="M:System.Type.GetType(System.String)" />-Methode.)</param>
      <returns>Eine <typeparamref name="TType" />-Instanz.</returns>
      <exception cref="T:System.BadImageFormatException">Der Name ist falsch formatiert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>Ruft den zugrunde liegenden Typ des angegebenen Enumerationstypsymbols ab.</summary>
      <param name="type">Ein Enumerationstyp.</param>
      <returns>Ein Typcode, der den zugrunde liegenden Typ der Enumeration angibt.</returns>
      <exception cref="T:System.BadImageFormatException">Der angegebene Symboltyp stellt keine Enumeration dar.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>Überprüft, ob der angegebene Typ <see cref="T:System.Type" /> darstellt.</summary>
      <param name="type">Der zu überprüfende Typ.</param>
      <returns>
        <see langword="true" />, wenn der angegebene Typ ein <see cref="T:System.Type" /> ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>Berechnet die Größe des angegebenen Verzweigungsanweisungsoperanden.</summary>
      <param name="opCode">Der Branch-Op-Code.</param>
      <returns>1, wenn <paramref name="opCode" /> eine kurze Verzweigung ist, oder 4, wenn es sich um eine lange Verzweigung handelt.</returns>
      <exception cref="T:System.ArgumentException">Der angegebene <paramref name="opCode" /> ist kein Branch-Op-Code.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Ruft eine lange Form des angegebenen Branch-Op-Codes ab.</summary>
      <param name="opCode">Der Branch-Op-Code.</param>
      <returns>Die Langform des Branch-Op-Codes.</returns>
      <exception cref="T:System.ArgumentException">Der angegebene <paramref name="opCode" /> ist kein Branch-Op-Code.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Ruft eine Kurzform des angegebenen Branch-Op-Codes ab.</summary>
      <param name="opCode">Der Branch-Op-Code.</param>
      <returns>Die Kurzform des Branch-Op-Codes.</returns>
      <exception cref="T:System.ArgumentException">Der angegebene <paramref name="opCode" /> ist kein Branch-Op-Code.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Überprüft, ob der angegebene Op-Code eine Verzweigung zu einer Bezeichnung ist.</summary>
      <param name="opCode" />
      <returns>
        <see langword="true" />, wenn der angegebene Op-Code eine Verzweigung zu einer Bezeichnung ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>Die Ausnahme, die ausgelöst wird, wenn ein Versuch, Metadaten zu schreiben, eine von der Formatspezifikation angegebene Grenze überschreitet. Dies ist beispielsweise der Fall, wenn die Heapgrößenbeschränkung überschritten wird.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info">Das Objekt, das die Daten des serialisierten Objekts enthält.</param>
      <param name="context">Die Kontextinformationen zur Quelle bzw. zum Ziel.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
      <param name="message">Die Fehlermeldung, in der die Ursache dieser Ausnahme erklärt wird.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse mit einer angegebenen Fehlermeldung und der Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
      <param name="message">Die Fehlermeldung, in der die Ursache dieser Ausnahme erklärt wird.</param>
      <param name="innerException">Die Ausnahme, die die aktuelle Ausnahme verursacht hat, oder <see langword="null" />, wenn keine innere Ausnahme angegeben ist.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <exception cref="T:System.BadImageFormatException">Ungültiges Blobformat.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>Stellt Informationen zum lexikalischen Bereich bereit, in dem eine Gruppe von Importen verfügbar ist. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>Ruft die implementierte Schnittstelle auf (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>Ruft das Typsymbol für den für den Funktionszeigertyp der angegebene Methode <paramref name="signature" /> ab.</summary>
      <param name="signature" />
      <returns>Das Typsymbol für den Funktionszeigertyp.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>Ruft das Typsymbol für den für den generischen Methodenparameter am angegebenen nullbasierten <paramref name="index" /> ab.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Das Typsymbol für den generischen Methodenparameter an <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>Ruft das Typsymbol für den für den generischen Typparameter am angegebenen nullbasierten <paramref name="index" /> ab.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>Das Typsymbol für den für den generischen Typparameter am angegebenen nullbasierten <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>Ruft das Typsymbol für einen Typ mit einem angewendeten benutzerdefinierten Modifizierer ab.</summary>
      <param name="modifier">Der angewendete Modifizierertyp.</param>
      <param name="unmodifiedType">Das Typsymbol des zugrunde liegenden Typs ohne angewendete Modifizierer.</param>
      <param name="isRequired">
        <see langword="true" />, wenn der Modifizierer erforderlich ist, bzw. <see langword="false" />, wenn er optional ist.</param>
      <returns>Das Typsymbol.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>Ruft das Typsymbol für einen lokalen Variablentyp ab, der als „fixiert“ gekennzeichnet ist.</summary>
      <param name="elementType" />
      <returns>Das Typsymbol für den lokalen Variablentyp.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>Ruft das Typsymbol für eine Typspezifikation ab.</summary>
      <param name="reader">Der Metadatenleser, der an den Signaturdecoder übergeben wurde. Kann <see langword="null" /> sein.</param>
      <param name="genericContext">Der Kontext, der an den Signaturdecoder übergeben wurde.</param>
      <param name="handle">Das Typspezifikationshandle.</param>
      <param name="rawTypeKind">Die Art des Typs, wie in der Signatur angegeben. Um diesen Wert zu interpretieren, verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Das Typsymbol für die Typspezifikation.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Ruft das Typsymbol für einen primitiven Typ ab.</summary>
      <param name="typeCode" />
      <returns>Das Typsymbol für <param name="typeCode" />sein.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>Ruft das Typsymbol für eine Typdefinition ab.</summary>
      <param name="reader">Der Metadatenleser, der an den Signaturdecoder übergeben wurde. Kann <see langword="null" /> sein.</param>
      <param name="handle">Das Typdefinitionshandle.</param>
      <param name="rawTypeKind">Die Art des Typs, wie in der Signatur angegeben. Um diesen Wert zu interpretieren, verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Das Typsymbol.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>Ruft das Typsymbol für einen Typverweis ab.</summary>
      <param name="reader">Der Metadatenleser, der an den Signaturdecoder übergeben wurde. Kann <see langword="null" /> sein.</param>
      <param name="handle">Das Typdefinitionshandle.</param>
      <param name="rawTypeKind">Die Art des Typs, wie in der Signatur angegeben. Um diesen Wert zu interpretieren, verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>Das Typsymbol.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>Ruft das Typsymbol für ein eindimensionales Array des angegebenen Elementtyps mit einer Untergrenze von 0 (null) ab.</summary>
      <param name="elementType" />
      <returns>Eine <typeparamref name="TType" />-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>Stellt Informationen zu lokalen Konstanten bereit. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>Ruft die Konstantensignatur ab</summary>
      <returns>Die Konstante Signatur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>Stellt Informationen zum Bereich lokaler Variablen und Konstanten bereit. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>Stellt Informationen zu lokalen Variablen bereit. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>Ruft die Attribute der Manifestressource ab.</summary>
      <returns>Eine bitweise Kombination der Enumerationswerte, die die manifestressourcenattribute angeben.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>Ruft das Handle der Implementierungsentität ab.</summary>
      <returns>Eine entityhandle-Instanz. Wenn die <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" />-Eigenschaft <see langword="true" />ist, verfügt das zurückgegebene Handle über Standardwerte.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>Ruft den Namen der Ressource ab.</summary>
      <returns>Der Ressourcen Name.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>Ruft das Byteoffset in der referenzierten Datei ab, an dem dieser Ressourceneintrag beginnt.</summary>
      <returns>Der Byte Offset in der Datei, auf die verwiesen wird, wenn dieser Ressourcen Daten Satz beginnt.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>Stellt eine Auflistung von <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />-Instanzen dar.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>Bestimmt, ob sich der Memberverweis auf eine Methode oder ein Feld bezieht.</summary>
      <returns>Einer der Enumerationswerte, der die Art des Memberverweises angibt.</returns>
      <exception cref="T:System.BadImageFormatException">Die Signatur des Memberverweises ist ungültig.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>Ruft das Handle der übergeordneten Entität ab.</summary>
      <returns>Eine entitätenhandle-Instanz. Wenn die <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" />-Eigenschaft <see langword="true" /> ist, verfügt das zurückgegebene Handle über Standardwerte.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>Ruft ein Handle zum Signaturblob ab.</summary>
      <returns>Ein Handle für das Signatur-BLOB.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>Stellt eine Auflistung von <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />-Instanzen dar.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>Gibt Konstanten an, die angeben, ob <see cref="T:System.Reflection.Metadata.MemberReference" /> auf eine Methode oder ein Feld verweist.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> verweist auf ein Feld.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> verweist auf eine Methode.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>CLI-Metadaten.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>Windows-Metadaten, die von verwalteten Compilern generiert werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Windows-Metadaten.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>Liest Metadaten gemäß der ECMA 335 CLI-Spezifikation.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse aus den Metadaten, die am angegebenen Speicherort gespeichert sind.</summary>
      <param name="metadata">Ein Zeiger auf das erste Byte in einem Metadatenblock.</param>
      <param name="length">Die Anzahl von Bytes im Block.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse aus den Metadaten, die am angegebenen Speicherort gespeichert sind.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse aus den Metadaten, die am angegebenen Speicherort gespeichert sind.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> ist nicht positiv.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Die Codierung von <paramref name="utf8Decoder" /> ist keine <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.BadImageFormatException">Fehlerhafter Metadatenheader.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>Ruft die aus dem #Pdb-Datenstrom decodierten Informationen oder <see langword="null" /> ab, wenn der Datenstrom nicht vorhanden ist.</summary>
      <returns>Die Informationen, die aus #PDB Stream decodiert werden, oder <see langword="null" />, wenn der Stream nicht vorhanden ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>Ruft einen Wert ab, der angibt, ob diese Metadaten eine Assembly darstellen.</summary>
      <returns>
        <see langword="true" />, wenn die Metadaten eine Assembly darstellen. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>Ruft die Art der Metadaten ab.</summary>
      <returns>Einer der Enumerationswerte, der die metadatenart angibt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>Ruft die Länge der zugrunde liegenden Daten ab.</summary>
      <returns>Die Länge der zugrunde liegenden Daten.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>Ruft den Zeiger auf die zugrunde liegenden Daten ab.</summary>
      <returns>Der Zeiger auf die zugrunde liegenden Daten.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>Ruft die Versionszeichenfolge aus dem Metadatenheader ab.</summary>
      <returns>Die Versions Zeichenfolge aus dem Metadatenheader.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>Ruft die an den Konstruktor übergebenen <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> ab.</summary>
      <returns>Eine bitweise Kombination der Enumerationswerte, die den <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />-Enumerationswert beschreibt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>Ruft den Comparer ab, der zum Vergleichen von Zeichenfolgen verwendet wird, die in den Metadaten gespeichert sind.</summary>
      <returns>Der Vergleich, der zum Vergleichen von in Metadaten gespeicherten Zeichen folgen verwendet wird.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>Ruft den Decoder ab, der vom Reader verwendet wird, um Zeichenfolgeninstanzen aus Bytefolgen zu generieren, die als UTF8 codiertsind.</summary>
      <returns>Der vom Reader verwendete Decoder, der Zeichen folgen Instanzen aus UTF8-codierten Byte Sequenzen erzeugt.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>Projektionen der Windows-Runtime sind aktiviert (standardmäßig aktiviert).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>Die Optionen werden verwendet, wenn eine <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse über eine Überladung abgerufen wird, die kein <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />-Argument annimmt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>Alle Optionen sind deaktiviert.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>Stellt einen <see cref="T:System.Reflection.Metadata.MetadataReader" /> für Metadaten bereit, die in einem Bytearray, einem Speicherblock oder einem Stream gespeichert sind.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>Verwirft den gesamten vom Leser zugewiesenen Speicher.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>Erstellt einen Metadatenanbieter über ein im Arbeitsspeicher gespeichertes Image.</summary>
      <param name="start">Zeiger auf den Anfang des Metadatenblobs.</param>
      <param name="size">Die Größe des Metadatenblobs.</param>
      <returns>Der neue Metadatenanbieter.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Erstellt einen Anbieter über einen Bytearray.</summary>
      <param name="image">Metadatenimage.</param>
      <returns>Der neue Anbieter.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Erstellt einen Anbieter für einen Stream der angegebenen Größe, beginnend an der aktuellen Position.</summary>
      <param name="stream">Eine <see cref="T:System.IO.Stream" />-Instanz.</param>
      <param name="options">Optionen, die angeben, wie Abschnitte des Images aus dem Stream gelesen werden.</param>
      <param name="size">Größe des Metadatenblobs im Stream. Ist dieser Wert nicht angegeben, wird angenommen, dass sich der Metadatenblob bis zum Ende des Streams erstreckt.</param>
      <returns>Der neue Anbieter.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> unterstützt keine Lese- und Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Größe ist negativ oder erstreckt sich über das Ende des Streams hinaus.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem Stream (nur wenn <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> angegeben ist).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>Erstellt einen portablen PDB-Metadatenanbieter über einen im Arbeitsspeicher gespeicherten Blob.</summary>
      <param name="start">Zeiger auf den Anfang des portablen PDB-Blobs.</param>
      <param name="size">Die Größe des portablen PDB-Blobs.</param>
      <returns>Der neue portable PDB-Metadatenanbieter.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Erstellt einen portablen PDB-Metadatenanbieter über einen Bytearray.</summary>
      <param name="image">Ein portables PDB-Image.</param>
      <returns>Der neue portable PDB-Metadatenanbieter.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Erstellt einen Anbieter für einen Stream der angegebenen Größe, beginnend an der aktuellen Position.</summary>
      <param name="stream">Der Stream (Datenstrom).</param>
      <param name="options">Optionen, die angeben, wie Abschnitte des Images aus dem Stream gelesen werden.</param>
      <param name="size">Größe des Metadatenblobs im Stream. Ist dieser Wert nicht angegeben, wird angenommen, dass sich der Metadatenblob bis zum Ende des Streams erstreckt.</param>
      <returns>Eine <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />-Instanz.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> unterstützt keine Lese- und Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Größe ist negativ oder erstreckt sich über das Ende des Streams hinaus.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Ruft ein <see cref="T:System.Reflection.Metadata.MetadataReader" /> aus einem <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> ab.</summary>
      <param name="options">Eine bitweise Kombination von Enumerationswerten, die die Konfiguration beim Lesen der Metadaten darstellen.</param>
      <param name="utf8Decoder">Die zu verwendende Codierung.</param>
      <returns>Eine <see cref="T:System.Reflection.Metadata.MetadataReader" />-Instanz.</returns>
      <exception cref="T:System.ArgumentException">Die Codierung von <paramref name="utf8Decoder" /> ist keine <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus den zugrunde liegenden Stream.</exception>
      <exception cref="T:System.ObjectDisposedException">Anbieter wurde verworfen.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>Standardmäßig wird der Datenstrom entfernt, wenn <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> entfernt wird und Abschnitte des PE-Images verzögert gelesen werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>Hält den Datenstrom geöffnet, wenn <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> entfernt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>Liest PDB-Metadaten direkt in den Speicher.
Die zugrunde liegende Datei kann geschlossen und sogar gelöscht werden, nachdem <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> erstellt wurde. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> schließt den Stream automatisch, wenn der Konstruktor zurückkehrt, es sei denn, <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> wird angegeben.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>Stellt Zeichenfolgenvergleichshilfen zum Abfragen von Zeichenfolgen in Metadaten bereit, wobei die Zuordnung nach Möglichkeit vermieden wird.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>Stellt <see cref="T:System.Reflection.Metadata.MetadataReader" /> mit einem benutzerdefinierten Mechanismus zum Decodieren von Bytesequenzen in Metadaten bereit, die Text darstellen.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" />-Klasse mit der angegebenen Codierung.</summary>
      <param name="encoding">Die zu verwendende Codierung.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>Ruft den Standarddecoder ab, der von <see cref="T:System.Reflection.Metadata.MetadataReader" /> verwendet wird, um UTF-8 zu decodieren, wenn kein Decoder für den Konstruktor bereitgestellt wird.</summary>
      <returns>Der Standard Decoder, der von <see cref="T:System.Reflection.Metadata.MetadataReader" /> zum Decodieren von UTF-8 verwendet wird.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>Ruft die von dieser Instanz verwendete Codierung ab.</summary>
      <returns>Die von dieser Instanz verwendete Codierung.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>Ruft die Zeichenfolgen für Bytefolgen in den Metadaten ab. Überschreiben Sie diese Einstellung, um Zeichenfolgen bei Bedarf zwischenzuspeichern. Andernfalls wird dies durch direkte Weiterleitung an <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> implementiert, und jeder Aufruf weist eine neue Zeichenfolge zu.</summary>
      <param name="bytes">Zeiger auf die zu decodierenden Bytes.</param>
      <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
      <returns>Die decodierte Zeichenfolge.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>Ruft die Größe des Methodentexts einschließlich Header, IL und Ausnahmeregionen ab.</summary>
      <returns>Die Größe des Methoden Texts.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>Stellt Debuginformationen bereit, die einer Methodendefinition zugeordnet sind. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>Ruft das Handle des einzelnen Dokuments ab, das alle Sequenzpunkte der Methode enthält.</summary>
      <returns>Das Handle des einzelnen Dokuments, das alle Sequenz Punkte der Methode enthält, oder ein Handle, dessen <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" />-Eigenschaft <see langword="true" /> ist, wenn die Methode keine Sequenz Punkte hat oder mehrere Dokumente umfasst.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>Gibt eine Sammlung der aus <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" /> decodierten Sequenzpunkte zurück.</summary>
      <returns>Eine Sammlung von Sequenzpunkten.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>Gibt die Kickoffmethode des Zustandsautomaten zurück.</summary>
      <returns>Die Kickoffmethode des Zustandsautomaten, wenn die Methode eine <c>MoveNext</c>-Methode eines Zustandsautomaten ist. Andernfalls wird ein Handle zurückgegeben, dessen <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />-Eigenschaft <see langword="true" /> ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>Gibt ein Handle für die lokale Signatur zurück.</summary>
      <returns>Ein lokales Signatur handle oder ein Handle, dessen <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />-Eigenschaft <see langword="true" /> ist, wenn die Methode keine lokalen Variablen definiert.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>Gibt ein Blob zurück, das Sequenzpunkte codiert.</summary>
      <returns>Ein BLOB-Codierungs Sequenz Punkt oder ein Handle, dessen <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" />-Eigenschaft <see langword="true" /> ist, wenn die Methode keine Sequenz Punkte hat.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>Gibt ein Handle zu einer <see cref="T:System.Reflection.Metadata.MethodDefinition" />-Struktur zurück, die diesem Handle entspricht.</summary>
      <returns>Ein Methodendefinitions-Handle, das diesem Handle entspricht.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>Gibt ein Handle zu einem <see cref="T:System.Reflection.Metadata.MethodDebugInformation" />-Element zurück, das diesem Handle entspricht.</summary>
      <returns>Ein Methodendebug-Informationshandle, das diesem Handle entspricht.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>Stellt eine Methode (Definition, Verweis, oder eigenständig) oder eine Signatur der Eigenschaften dar. In Bezug auf Eigenschaften stimmt die Signatur bis auf einen Unterschied im <see cref="T:System.Reflection.Metadata.SignatureHeader" /> mit der Signatur eines Getters überein.</summary>
      <typeparam name="TType">Der Methodentyp.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MethodSignature`1" />-Struktur unter Verwendung der angegebenen Kopfzeile, des Rückgabetyps und der Parameterinformationen.</summary>
      <param name="header">Die Informationen im führenden Byte der Signatur (Art, Aufrufkonvention, Kennzeichen).</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="requiredParameterCount">Die Anzahl der erforderlichen Parameter.</param>
      <param name="genericParameterCount">Die Anzahl der generischen Typparameter.</param>
      <param name="parameterTypes">Die Parametertypen.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>Ruft die Anzahl der generischen Typparameter für diese Methode ab.</summary>
      <returns>Die Anzahl der generischen Typparameter oder 0 für nicht generische Methoden.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>Ruft die Informationen im führenden Byte der Signatur (Art, Aufrufkonvention, Kennzeichen) ab.</summary>
      <returns>Die Header Signatur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>Ruft die Parametertypen der Methode ab.</summary>
      <returns>Eine unveränderliche Auflistung von Parametertypen.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>Ruft die Anzahl der für diese Methode erforderlichen Parameter ab.</summary>
      <returns>Die Anzahl der erforderlichen Parameter.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>Ruft den Rückgabetypen der Methode ab.</summary>
      <returns>Der Rückgabetyp.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>Ruft ein <see langword="MethodDef" />- oder <see langword="MemberRef" />-Handle ab, das die generische Methode angibt, auf die diese Instanz verweist (d.h. von welcher generischen Methode sie eine Instanziierung ist).</summary>
      <returns>Ein <see langword="MethodDef" /> oder <see langword="MemberRef" /> handle, das angibt, auf welche generische Methode diese Instanz verweist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>Ruft ein Handle zum Signaturblob ab.</summary>
      <returns>Ein Handle für das Signatur-BLOB.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>Ruft alle exportierten Typen ab, die sich direkt in einem Namespace befinden.</summary>
      <returns>Ein unveränderliches Array von exportierten typhandles.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>Ruft den nicht qualifizierten Name der Namespacedefinition ab.</summary>
      <returns>Der nicht qualifizierte Name der Namespace Definition.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>Ruft die Namespacedefinitionen ab, die der aktuellen Namespacedefinition direkt untergeordnet sind.</summary>
      <returns>Ein unveränderliches Array von Namespace Definitionen, die direkte untergeordnete Elemente der aktuellen Namespace Definition sind.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>Ruft den übergeordneten Namespace ab.</summary>
      <returns>Der übergeordnete Namespace.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>Ruft alle Typdefinitionen ab, die sich direkt in einem Namespace befinden.</summary>
      <returns>Ein unveränderliches Array von typdefinitions Handles.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>Stellt ein Handle für eine Namespacedefinition bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>Enthält eine Sammlung von Parametern einer angegebenen Methode.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>Ruft ein <see cref="T:System.Reflection.Metadata.MetadataReader" /> aus einem <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ab.</summary>
      <param name="peReader">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <returns>Ein Metadatenleser.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus den zugrunde liegenden Stream.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Ruft einen Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten aus einem <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ab.</summary>
      <param name="peReader">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <param name="options">Ein Enumerationswert, der die Konfiguration zum Lesen von Metadaten angibt.</param>
      <returns>Ruft einen Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten ab.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus den zugrunde liegenden Stream.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Ruft einen Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten und der Codierungskonfiguration aus einem <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ab.</summary>
      <param name="peReader">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <param name="options">Ein Enumerationswert, der die Konfiguration zum Lesen von Metadaten angibt.</param>
      <param name="utf8Decoder">Ein Metadatenzeichenfolgen-Decoder mit der Codierungskonfiguration.</param>
      <returns>&gt;Ein Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten und der Codierungskonfiguration.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Die Codierung von <paramref name="utf8Decoder" /> ist keine <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus den zugrunde liegenden Stream.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>Gibt einen Textblock einer Methode mit der angegebenen relativen virtuellen Adresse (RVA) zurück.</summary>
      <param name="peReader">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <param name="relativeVirtualAddress">Die RVA (Relative Virtual Address, relative virtuelle Adresse).</param>
      <returns>Eine Methodentextblock-Instanz.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException">Der Text wurde in den Metadaten nicht gefunden oder ist ungültig.</exception>
      <exception cref="T:System.InvalidOperationException">Der Abschnitt, in dem die Methode gespeichert ist, ist nicht verfügbar.</exception>
      <exception cref="T:System.IO.IOException">Beim Lesen aus dem zugrunde liegenden Stream ist ein E/A-Fehler aufgetreten.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>Gibt Konstanten an, die Typcodes definieren, die zum Codieren von Typen primitiver Werte in einem Blob mit dem <see cref="T:System.Reflection.Metadata.CustomAttribute" />-Wert verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>Ein <see cref="T:System.Boolean" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>Ein unsignierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>Ein <see cref="T:System.Char" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>Ein 8-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>Ein signierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>Ein signierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>Ein signierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>Ein signierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>Ein 4-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>Ein <see cref="T:System.String" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>Ein unsignierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>Ein unsignierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>Ein unsignierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>Gibt Konstanten an, die primitive Typen definieren, die in Signaturen von Metadaten gefunden wurden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>Ein <see cref="T:System.Boolean" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>Ein <see cref="T:System.Byte" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>Ein <see cref="T:System.Char" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>Ein <see cref="T:System.Double" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>Ein <see cref="T:System.Int16" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>Ein <see cref="T:System.Int32" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>Ein <see cref="T:System.Int64" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>Ein <see cref="T:System.IntPtr" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>Ein <see cref="T:System.Object" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>Ein <see cref="T:System.SByte" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>Ein <see cref="T:System.Single" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>Ein <see cref="T:System.String" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>Ein typisierter Verweis.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>Ein <see cref="T:System.UInt16" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>Ein <see cref="T:System.UInt32" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>Ein <see cref="T:System.UInt64" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>Ein <see cref="T:System.UIntPtr" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>Ein <see cref="T:System.Void" />-Typ.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>Stellt ein Handle und ein entsprechendes Blob für einen Metadatenheap dar, die für die zukünftige Aktualisierung von Inhalten reserviert wurden.</summary>
      <typeparam name="THandle" />
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>Gibt einen <see cref="T:System.Reflection.Metadata.BlobWriter" /> zurück, der zum Aktualisieren des Inhalts verwendet wird.</summary>
      <returns>Ein Blobschreiber, der zum Aktualisieren des Inhalts verwendet wird.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>Ruft das reservierte Blobhandle ab.</summary>
      <returns>Der reservierte Block handle.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset" />
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>Gibt Typcodes an, die zum Codieren der Werttypen in einem <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />-Blob verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>Das Attributargument ist eine Enum-Instanz.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>Das Attributargument wird „geschachtelt“ (d.h., es wird an einen Parameter, ein Feld oder eine Eigenschaft eines Typobjekts weitergegeben) und enthält Typinformationen im Attributblob.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>Das Attributargument ist eine <see cref="T:System.Type" />-Instanz.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" /> entspricht.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>Gibt zusätzliche Kennzeichen an, die auf die Methodensignatur angewendet werden können. Die zugrunde liegenden Werte der Felder in diesem Typen entsprechen der Darstellung im führenden Signaturbyte, die von einer <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur dargestellt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>Gibt den ersten explizit angegebenen Parameter an, der den Instanzenzeiger darstellt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>Eine generische Methode.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>Eine Instanzmethode.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>Keine Flags.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>Gibt an, wie Argumente in einer vorhandenen Signatur vom Aufrufer an den Aufgerufenen weitergegeben werden. Die zugrunde liegenden Werte der Felder in diesem Typen entsprechen der Darstellung im führenden Signaturbyte, die von einer <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur dargestellt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>Eine nicht verwaltete Aufrufkonvention im C/C++-Stil, bei der die Aufrufliste vom Aufrufer bereinigt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>Eine verwaltete Aufrufkonvention mit einer Liste von Argumenten, die eine feste Länge hat.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>Eine nicht verwaltete Aufrufkonvention, bei der die Argumente, wenn möglich, in Registern weitergegeben werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>Eine nicht verwaltete Aufrufkonvention, bei der die Aufrufliste vom Aufgerufenen bereinigt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>Eine nicht verwaltete Aufrufkonvention im C++-Stil für eine Aufrufinstanz von Memberfunktionen mit einer festen Liste von Argumenten.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>Eine verwaltete Aufrufkonvention zum Weitergeben von zusätzlichen Argumenten.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>Stellt die Signatureigenschaften dar, die vom führenden Byte der Signaturblobs dargestellt werden.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur unter Verwendung des angegebenen Byte.</summary>
      <param name="rawValue">Das Byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur mithilfe der angegebenen Art der Signatur, der Abrufkonvention und der Attribute der Signatur.</summary>
      <param name="kind">Die Art der Signatur.</param>
      <param name="convention">Die Aufrufkonvention.</param>
      <param name="attributes">Die Attribute der Signatur.</param>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>Ruft die Attribute der Signatur ab.</summary>
      <returns>Die Attribute.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>Ruft die Aufrufkonvention ab.</summary>
      <returns>Die Aufrufkonvention.</returns>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>Ruft den Maskenwert für die Aufrufkonvention oder die Art der Signatur ab. Der Standardwert <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> lautet 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>Prüft das angegebene Objekt mit diesem <see cref="T:System.Reflection.Metadata.SignatureHeader" /> auf Gleichheit.</summary>
      <param name="obj">Das zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn die Objekte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>Überprüft zwei <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Werte auf Gleichheit.</summary>
      <param name="other">Der zu vergleichende Wert.</param>
      <returns>
        <see langword="true" />, wenn die Werte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>Ruft einen Hashcode für das aktuelle Objekt ab.</summary>
      <returns>Ein Hashcode für das aktuelle Objekt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur über das <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />-Attribut der Signatur verfügt.</summary>
      <returns>
        <see langword="true" />, wenn <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> das Attribut vorhanden ist, <see langword="false" />andernfalls.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur über das <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />-Attribut der Signatur verfügt.</summary>
      <returns>
        <see langword="true" />, wenn <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> das Attribut vorhanden ist, <see langword="false" />andernfalls.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur über das <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />-Attribut der Signatur verfügt.</summary>
      <returns>
        <see langword="true" />, wenn <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> das Attribut vorhanden ist, <see langword="false" />andernfalls.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>Ruft die Art der Signatur ab.</summary>
      <returns>Die Art der Signatur.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Überprüft zwei <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Werte auf Gleichheit.</summary>
      <param name="left">Der erste zu vergleichende Wert.</param>
      <param name="right">Der zweite zu vergleichende Wert.</param>
      <returns>
        <see langword="true" />, wenn die Werte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Bestimmt, ob zwei <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Werte ungleich sind.</summary>
      <param name="left">Der erste zu vergleichende Wert.</param>
      <param name="right">Der zweite zu vergleichende Wert.</param>
      <returns>
        <see langword="true" />, wenn die Werte ungleich sind; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>Ruft den Rohwert des Headerbytes ab.</summary>
      <returns>Der Rohwert des Header bytes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</summary>
      <returns>Eine Zeichenfolge, die das aktuelle Objekt darstellt.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>Gibt die Art der Signatur an. Die zugrunde liegenden Werte der Felder in diesem Typen entsprechen der Darstellung im führenden Signaturbyte, die von einer <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur dargestellt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>Eine Feldsignatur.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>Eine Signatur der lokalen Variablen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>Ein Methodenverweis, eine Methodendefinition oder eine eigenständige Methodensignatur.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>Eine Methodensignatur zur Spezifizierung.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>Eine Signatureigenschaft.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>Gibt Konstanten an, die in der Signaturcodierung zum Definieren des Typcodes verwendet wurden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>Stellt einen generalisierten <see cref="T:System.Array" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>Stellt einen <see cref="T:System.Boolean" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>Stellt verwaltete Zeiger (ByRef-Rückgabewerte und -Parameter) in Signaturen dar. Im Blob folgt eine Signaturcodierung des zugrunde liegenden Typs.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>Stellt einen <see cref="T:System.Byte" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>Stellt einen <see cref="T:System.Char" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>Stellt einen <see cref="T:System.Double" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>Stellt Typen von Funktionszeigern in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>Stellt einen generischen Methodenparameter dar, der in einer Signatur verwendet wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>Stellt die Instanziierung eines generischen Typs in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>Stellt einen generischen Typparameter dar, der in einer Signatur verwendet wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>Stellt einen generalisierten <see cref="T:System.Int16" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>Stellt einen generalisierten <see cref="T:System.Int32" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>Stellt einen generalisierten <see cref="T:System.Int64" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>Stellt einen generalisierten <see cref="T:System.IntPtr" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>Stellt einen ungültigen oder nicht initialisierten Typcode dar. Er erscheint nicht in gültigen Signaturen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>Stellt einen generalisierten <see cref="T:System.Object" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>Stellt einen benutzerdefinierten Modifizierer dar, der auf einen Typen einer Signatur angewendet wird, die der Aufrufer ignorieren kann.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>Stellt eine lokale Variable dar, die über den Garbage Collector angeheftet wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>Stellt einen nicht verwalteten Zeiger in Signaturen dar. Im Blob folgt eine Signaturcodierung des zugrunde liegenden Typs.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>Stellt einen benutzerdefinierten Modifizierer dar, der auf einen Typen einer Signatur angewendet wird, die der Aufrufer verstehen muss.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>Stellt einen generalisierten <see cref="T:System.SByte" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>Stellt einen Marker dar, der das Ende der festen Argumente und den Anfang der Variablenargumente anzeigen soll.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>Stellt einen <see cref="T:System.Single" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>Stellt einen <see cref="T:System.String" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>Stellt einen eindimensionalen <see cref="T:System.Array" /> mit einer Untergrenze von NULL dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>Stellt einen typisierten Verweis in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>Steht vor einem <see cref="T:System.Reflection.Metadata.EntityHandle" />-Typen in Signaturen. In den Rohmetadaten wird dies als ELEMENT_TYPE_CLASS (0x12) für Verweistypen oder als ELEMENT_TYPE_VALUETYPE (0x11) für Werttypen codiert. Dies wird auf einen einzigen Code reduziert, da Windows-Runtime-Projektionen von Klasse zu Werttyp oder umgekehrt projizieren können, und der Rohcode ist in diesen Fällen irreführend.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>Stellt einen <see cref="T:System.UInt16" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>Stellt einen <see cref="T:System.UInt32" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>Stellt einen <see cref="T:System.UInt64" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>Stellt einen <see cref="T:System.UIntPtr" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>Stellt einen <see cref="T:System.Void" /> in Signaturen dar.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>Gibt die Typdefinition der Signatur an.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>Die Typdefinition oder der Verweis deuten auf eine Klasse hin.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>Im aktuellen Kontext ist nicht bekannt, ob der Typverweis oder die Definition eine Klasse oder einen Werttypen darstellt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>Die Typdefinition oder der Verweis deuten auf einen Werttypen hin.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>Bestimmt die Art der Signatur, die möglicherweise <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> oder <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" /> sein kann.</summary>
      <returns>Ein Enumerationswert, der die Art der Signatur angibt.</returns>
      <exception cref="T:System.BadImageFormatException">Die Signatur ist ungültig.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>Ruft ein Handle zum Signaturblob ab.</summary>
      <returns>Ein Handle für das Signatur-BLOB.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>Gibt an, ob <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> eine eigenständige Methode oder eine Signatur einer lokalen Variablen darstellt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> verweist auf eine Signatur der lokalen Variablen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> stellt eine eigenständige Methodensignatur dar.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>Ruft den Basistyp der Typdefinition ab: entweder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns>Der Basistyp der Typdefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>Gibt den einschließenden Typ für einen angegebenen geschachtelten Typ zurück.</summary>
      <returns>Der einschließende Typ des angegebenen geschachtelten Typs, oder ein Handle, dessen <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />-Eigenschaft <see langword="true" /> ist, wenn der Typ nicht geschachtelt ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>Gibt ein Array von Typen zurück, die in dem angegebenen Typ geschachtelt sind.</summary>
      <returns>Ein unveränderliches Array von Typdefinitionshandles, die in dem angegebenen Typ geschachtelte Typen darstellen.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>Ruft einen Wert ab, der angibt, ob dies ein geschachtelter Typ ist.</summary>
      <returns>
        <see langword="true" />, wenn es sich um einen Typ handelt <see langword="false" /> , andernfalls.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>Ruft den Namen des Typs ab.</summary>
      <returns>Der Name des Typs.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>Ruft den vollständigen Namen des Namespace ab, in dem der Typ definiert ist.</summary>
      <returns>Der vollständige Name des Namespace, in dem der Typ definiert ist, oder ein <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> handle, <see langword="true" /> dessen-Eigenschaft ist, wenn der Typ in einem Stamm Namespace oder in einem Namespace definiert ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>Ruft das Definitionshandle des Namespace ab, in dem der Typ definiert ist.</summary>
      <returns>Das Definitions Handle des Namespace, in dem der Typ definiert ist, oder ein Handle <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> , dessen <see langword="true" /> -Eigenschaft ist, wenn der Typ in einem Stamm Namespace eingebettet oder definiert ist.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>Enthält eine Auflistung von <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />-Instanzen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>Ruft den Namen des Zieltyps ab.</summary>
      <returns>Der Name des Zieltyps.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>Ruft den vollständigen Namen des Namespace ab, in dem der Zieltyp definiert ist.</summary>
      <returns>Der vollständige Name des Namespace, in dem der Zieltyp definiert ist, oder ein Handle, dessen <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" />-Eigenschaft <see langword="true" /> ist, wenn der Typ in einem Stamm Namespace eingebettet oder definiert ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>Ruft den Auflösungsbereich ab, in dem der Zieltyp definiert ist und eindeutig mit dem angegebenen <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> und <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> identifiziert wird.</summary>
      <returns>Der Auflösungs Bereich, in dem der Zieltyp eindeutig definiert ist.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>Enthält eine Auflistung von <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />-Instanzen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext" />
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator" />
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>Stellt ein Handle für den Benutzerzeichenfolgenheap dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>Wird verwendet, um einen Handler für ein Ereignis hinzuzufügen. Entspricht dem <see langword="AddOn" />-Flag in der ECMA 335 CLI-Spezifikation.
CLS-kompatible Adder werden mit dem Präfix <see langword="add_" /> benannt.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>Liest den Wert der-Eigenschaft.
CLS-kompatible Getter werden mit dem Präfix `get_` benannt.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>Andere Methode für eine Eigenschaft (kein Getter oder Setter) oder ein Ereignis (kein Adder, Remover oder Raiser).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>Wird verwendet, um anzugeben, dass ein Ereignis aufgetreten ist. Entspricht dem <see langword="Fire" />-Flag in der ECMA 335 CLI-Spezifikation.
 CLS-kompatible Raiser werden mit dem Präfix <see langword="raise_" /> benannt.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>Wird verwendet, um einen Handler für ein Ereignis zu entfernen. Entspricht dem <see langword="RemoveOn" />-Flag in der ECMA 335 CLI-Spezifikation.
CLS-kompatible Remover werden mit dem Präfix <see langword="remove_" /> benannt.</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>Wird verwendet, um den Wert der-Eigenschaft zu ändern.
CLS-kompatible Setter werden mit dem Präfix <see langword="set_" /> benannt.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>Stellt Informationen zu einer PDB-Datei (Program Debug Database) bereit.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>Die Iteration der PDB-Datei. Die erste Iteration ist 1. Die Iteration wird bei jeder Vergrößerung des PDB-Inhalts erhöht.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>Die GUID (Globally Unique Identifier) der zugeordneten PDB-Datei.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>Der Pfad zur PDB-Datei, die Debuginformationen für die PE/COFF-Datei enthält.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>Stellt den Header einer COFF-Datei dar.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>Ruft die Flags ab, die die Attribute der Datei angeben.</summary>
      <returns>Die Flags, die die Attribute der Datei angeben.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>Ruft den Typ des Zielcomputers ab.</summary>
      <returns>Der Typ des Ziel Computers.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>Ruft die Anzahl der Abschnitte ab. Dies gibt die Größe der Abschnittstabelle an, die unmittelbar auf die Header folgt.</summary>
      <returns>Die Anzahl der Abschnitte.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>Ruft die Anzahl der Einträge in der Symboltabelle ab. Diese Daten können verwendet werden, um die Zeichenfolgentabelle zu suchen, die unmittelbar auf die Symboltabelle folgt. Dieser Wert sollte für ein PE-Image NULL sein.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>Ruft den Dateizeiger auf die COFF-Symboltabelle ab.</summary>
      <returns>Der Dateizeiger auf die COFF-Symboltabelle oder 0 (null), wenn keine COFF-Symboltabelle vorhanden ist. Dieser Wert sollte für ein PE-Image NULL sein.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>Ruft die Größe des optionalen-Headers ab, der für ausführbare Dateien, jedoch nicht für Objektdateien erforderlich ist. Dieser Wert sollte für eine Objektdatei NULL sein.</summary>
      <returns>Die Größe des optionalen Headers.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>Ruft einen Wert ab, der angibt, wann die Datei erstellt wurde.</summary>
      <returns>Die unteren 32 Bits der Anzahl der Sekunden 00:00 seit dem 1. Januar 1970, der angibt, wann die Datei erstellt wurde.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />-Klasse.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>Fügt einen CodeView-Eintrag hinzu.</summary>
      <param name="pdbPath">Der Pfad zur PDB-Datei. Er darf nicht leer sein.</param>
      <param name="pdbContentId">Die eindeutige ID des PDB-Inhalts.</param>
      <param name="portablePdbVersion">Die Version des portablen PDB-Formats (z. B. 0x0100 für 1,0) oder 0 (null), wenn die PDB-Datei nicht portabel ist.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> enthält ein NULL-Zeichen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> ist kleiner als 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>Fügt einen eingebetteten portablen PDB-Eintrag hinzu.</summary>
      <param name="debugMetadata">Ein portabler PDB-Metadatengenerator.</param>
      <param name="portablePdbVersion">Die Version des portablen PDB-Formats (z. B. 0x0100 für 1,0).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> ist kleiner als 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>Fügt einen Eintrag vom angegebenen Typ hinzu.</summary>
      <param name="type">Der Eintragstyp.</param>
      <param name="version">Die Version des Eintrags.</param>
      <param name="stamp">Der Stempel des Eintrags.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>Fügt einen Eintrag vom angegebenen Typ hinzu und serialisiert dessen Daten.</summary>
      <param name="type">Der Eintragstyp.</param>
      <param name="version">Die Version des Eintrags.</param>
      <param name="stamp">Der Stempel des Eintrags.</param>
      <param name="data">Die Daten, die an <paramref name="dataSerializer" /> übergeben werden sollen.</param>
      <param name="dataSerializer">Ein Serialisierungsprogramm zum Serialisieren von Daten in eine <see cref="T:System.Reflection.Metadata.BlobBuilder" />-Klasse.</param>
      <typeparam name="TData">Der Typ der Daten, die an <paramref name="dataSerializer" /> übermittelt werden.</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Fügt einen PDB-Prüfsummeneintrag hinzu.</summary>
      <param name="algorithmName">Der Name des Hashalgorithmus (z. B. „SHA256“).</param>
      <param name="checksum">Die Prüfsumme.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> oder <paramref name="checksum" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> oder <paramref name="checksum" /> ist leer.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>Fügt einen reproduzierbaren Eintrag hinzu.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>Identifiziert den Speicherort, die Größe und das Format eines Debuginformationenblocks.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />-Struktur.</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>Ruft den Dateizeiger auf die Debugdaten ab.</summary>
      <returns>Der Dateizeiger auf die Debugdaten.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>Ruft die Adresse der Debugdaten relativ zur Imagebasis ab, wenn sie geladen werden.</summary>
      <returns>Die Adresse der Debugdaten relativ zur Bildbasis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>Ruft die Größe der Debugdaten ab (ohne das Debugverzeichnis selbst).</summary>
      <returns>die Größe der Debugdaten (mit Ausnahme des debugverzeichnisses).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>Ruft einen Wert ab, der darauf hinweist, ob es sich um einen Eintrag vom Typ <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> handelt, der auf eine portable PDB-Dabei zeigt.</summary>
      <returns>
        <see langword="true" />, wenn es sich bei dem Eintrag um einen <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" />-Eintrag handelt, der auf eine Portable PDB verweist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>Ruft die Hauptversionsnummer des Debugdatenformats ab.</summary>
      <returns>Die Hauptversionsnummer des debugdatenformats.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>Ruft die Nebenversionsnummer des Debugdatenformats ab.</summary>
      <returns>Die neben Versionsnummer des debugdatenformats.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>Ruft das Datum und die Uhrzeit der Erstellung der Debugdaten ab, wenn die PE/COFF-Datei nicht deterministisch ist. Andernfalls wird ein Wert abgerufen, der auf dem Hash des Inhalts basiert.</summary>
      <returns>für eine nicht deterministische PE/COFF-Datei das Datum und die Uhrzeit der Erstellung der Debugdaten. andernfalls ein Wert, der auf dem Hashwert des Inhalts basiert.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>Ruft das Format der Debuginformationen ab.</summary>
      <returns>Das Format der Debuginformationen.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType" />
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>Zugehörige PDB-Dateibeschreibung.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>Die COFF-Debuginformationen (Zeilennummern, Symboltabelle und Zeichenfolgentabelle). Auf diese Art von Debuginformationen wird auch von Feldern in Dateiheadern verwiesen.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>Der Eintrag verweist auf ein Blob, das eingebettete portierbare PDB-Dateien enthält. Das eingebettete portierbare PDB-Blob weist das folgende Format auf:- blob ::= uncompressed-size data (Daten mit nicht komprimierter Größe)- Die Daten umfassen den Rest des Blobs und enthalten eine mit einem Deflate-Algorithmus komprimierte portierbare PDB-Datei.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>Der Eintrag enthält einen Kryptografiehash des Inhalts der Symboldatei, mit dem die PE/COFF-Datei erstellt wurde. Der Hash kann verwendet werden, um zu überprüfen, ob eine bestimmte PDB-Datei mit der PE/COFF-Datei erstellt wurde und in keiner Weise geändert wurde. Wenn mehrere PDB-Dateien während der Erstellung der PE/COFF-Datei erstellt wurden (z. B. private und öffentliche Symbole), können mehrere Einträge vorhanden sein.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>Das Vorhandensein dieses Eintrags deutet auf eine deterministische PE/COFF-Datei hin. Weitere Informationen finden Sie im Abschnitt Hinweise.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>Ein unbekannter Wert, der von allen Tools ignoriert werden sollte.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>Beschreibt die Eigenschaften einer Dynamic Link Library.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>Das Image muss in einem AppContainer ausgeführt werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>Die DLL kann verschoben werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>Das Image kann einen virtuellen 64-Bit-Adressraum mit hoher Entropie verarbeiten.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>Binden Sie dieses Image nicht.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>Das Image erkennt die Isolation und lehnt sie ab.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>Das Image verwendet SEH nicht. In diesem Image darf kein SE-Handler vorhanden sein.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>Das Image ist mit NX kompatibel.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>Das Image ist Terminalserverfähig.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>Der Treiber verwendet das WDM-Modell.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>Gibt die CPU-Architektur des Zielcomputers an.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI-Bytecode.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>MIPS mit FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>MIPS16 mit FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>Die Ziel-CPU ist unbekannt oder wurde nicht angegeben.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS Little-Endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId},System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags)">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="deterministicIdProvider" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>Stellt einen PDB-Prüfsummen-Debugverzeichniseintrag dar.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>Der Name des Kryptografiehashalgorithmus, der verwendet wird, um die Prüfsumme zu berechnen.</summary>
      <returns>Eine Zeichenfolge, die den Namen des kryptografiehash Algorithmus darstellt, mit dem die Prüfsumme berechnet wird.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>Die Prüfsumme des PDB-Inhalts.</summary>
      <returns>Ein unveränderliches Bytearray, das die Prüfsumme des PDB-Inhalts darstellt.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>Erstellt PE-Verzeichnisse.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>Initialisiert eine Instanz der <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />-Klasse.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>Die Adresse des Einstiegspunkts relativ zur Imagebasis, wenn die PE-Datei in den Arbeitsspeicher geladen wird.</summary>
      <returns>Bei Programm Images ist dies die Startadresse. Für Gerätetreiber ist dies die Adresse der Initialisierungsfunktion. Ein Einstiegspunkt ist für DLLs optional. Wenn kein Einstiegspunkt vorhanden ist, muss dieses Feld NULL sein.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>Der Imageverzeichniseintrag einer Basisumsetzungstabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>Der Imageverzeichniseintrag eines gebundenen Imports.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>Der Imageverzeichniseintrag von Copyright/Architektur.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>Der Imageverzeichniseintrag einer COM-Deskriptortabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>Der Imageverzeichniseintrag einer Debugtabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>Der Imageverzeichniseintrag einer Verzögerungsimporttabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>Der Imageverzeichniseintrag einer Ausnahmetabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>Der Imageverzeichniseintrag einer Exporttabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>Der Imageverzeichniseintrag einer globalen Zeigertabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>Der Imageverzeichniseintrag einer Importadresstabelle (IAT).</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>Der Imageverzeichniseintrag einer Importtabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>Der Imageverzeichniseintrag einer Ladekonfigurationstabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>Der Imageverzeichniseintrag einer Ressourcentabelle.</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>Der Imageverzeichniseintrag einer TLS-Tabelle (lokaler Threadspeicher).</summary>
      <returns>Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>Ruft beim Laden der PE-Datei in den Arbeitsspeicher die Adresse des Einstiegspunkts relativ zur Imagebasis ab.</summary>
      <returns>Die Adresse des Einstiegs Punkts, der relativ zur Bildbasis ist.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>Ruft beim Laden des Images in den Arbeitsspeicher die Adresse des Codeanfangsabschnitts relativ zur Imagebasis ab.</summary>
      <returns>Die Adresse des Code anfangs Abschnitts in Bezug auf die Bildbasis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>Ruft beim Laden des Images in den Arbeitsspeicher die Adresse des Datenanfangsabschnitts relativ zur Imagebasis ab.</summary>
      <returns>Die Adresse des Anfangsdaten Abschnitts in Relation zur Bildbasis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>Ruft den Eintrag der Zertifikatstabelle ab, der auf eine Tabelle mit Attributzertifikaten zeigt.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>Ruft die Prüfsumme des Imagedatei ab.</summary>
      <returns>Die Prüfsumme der Bilddatei.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>Ruft den Ausrichtungsfaktor (in Byte) ab, der verwendet wird, um die Rohdaten von Abschnitten in der Imagedatei auszurichten.</summary>
      <returns>Eine Potenz von 2 zwischen 512 und 64K (einschließlich). Der Standardwert liegt bei 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>Ruft beim Laden in den Arbeitsspeicher die bevorzugte Adresse des ersten Imagebytes ab.</summary>
      <returns>Die bevorzugte Adresse, bei der es sich um ein Vielfaches von 64K handelt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>Ruft einen Wert ab, der das Format der Imagedatei angibt.</summary>
      <returns>Das Format der Bilddatei.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>Ruft die Hauptversionsnummer des Images ab.</summary>
      <returns>Die Hauptversionsnummer des Images.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>Ruft die Hauptversionsnummer des Linker ab.</summary>
      <returns>Die Hauptversionsnummer des Linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>Ruft die Hauptversionsnummer des erforderlichen Betriebssystems ab.</summary>
      <returns>Die Hauptversionsnummer des erforderlichen Betriebssystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>Ruft die Hauptversionsnummer des Subsystems ab.</summary>
      <returns>Die Hauptversionsnummer des Subsystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>Ruft die Nebenversionsnummer des Images ab.</summary>
      <returns>Die Nebenversionsnummer des Images.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>Ruft die Nebenversionsnummer des Linker ab.</summary>
      <returns>Die Nebenversionsnummer des Linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>Ruft die Nebenversionsnummer des erforderlichen Betriebssystems ab.</summary>
      <returns>Die Nebenversionsnummer des erforderlichen Betriebssystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>Ruft die Nebenversionsnummer des Subsystems ab.</summary>
      <returns>Die Nebenversionsnummer des Subsystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>Ruft die Anzahl der Datenverzeichniseinträge im Rest von <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> ab. Jeder beschreibt einen Speicherort und eine Größe.</summary>
      <returns>Die Anzahl der Datenverzeichnis Einträge im Rest der <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>Ruft beim Laden in den Arbeitsspeicher die Ausrichtung (in Byte) von Abschnitten ab.</summary>
      <returns>Eine Zahl, die größer oder gleich <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> ist. Der Standard für die Architektur ist die Seitengröße.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>Ruft die Größe des Codeabschnitts (Textes) oder die Summe aller Codeabschnitte ab, wenn mehrere Abschnitte vorhanden sind.</summary>
      <returns>die Größe des Code Abschnitts (Text) oder die Summe aller Code Abschnitte, wenn mehrere Abschnitte vorhanden sind.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>Ruft die kombinierte Größe von MS DOS-Stub, PE-Header und Abschnittsheadern aufgerundet auf ein Vielfaches von FileAlignment ab.</summary>
      <returns>Die kombinierte Größe von MS DOS Stub-, PE-Header-und Abschnitts Headern, die auf ein Vielfaches von FileAlignment aufgerundet werden.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>Ruft die Größe des Speicherplatzes für den lokalen Heap ab, für den ein Commit ausgeführt werden soll.</summary>
      <returns>Die Größe des zu commitenden lokalen Heap-Speicherplatzes.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>Ruft die Größe des Speicherplatzes für den lokalen Heap ab, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns>Die Größe des Speicherplatzes für den lokalen Heap, der reserviert werden soll.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>Ruft beim Laden des Images in den Arbeitsspeicher die Größe (in Byte) des Images mit allen Headern ab.</summary>
      <returns>Die Größe (in Bytes) des Bilds, bei der es sich um ein Vielfaches von <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> handelt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>Ruft die Größe des Abschnitts mit den initialisierten Daten oder die Summe aller derartiger Abschnitte ab, wenn mehrere Datenabschnitte vorhanden sind.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>Ruft die Größe des Stapels ab, für den ein Commit ausgeführt werden soll.</summary>
      <returns>Dier Größe des Stapels, für den ein Commit ausgeführt wird.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>Ruft die Größe des Stapels ab, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns>Die Größe des Stapels, der reserviert werden soll.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>Ruft die Größe des Abschnitts mit den nicht initialisierten Daten (BSS) oder die Summe aller derartiger Abschnitte ab, wenn mehrere BSS-Abschnitte vorhanden sind.</summary>
      <returns>Die Größe des nicht initialisierten Daten Abschnitts (BSS) oder die Summe aller dieser Abschnitte.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>Ruft den Namen des Subsystems ab, das zum Ausführen dieses Images erforderlich ist.</summary>
      <returns>der Name des Subsystems, das zum Ausführen dieses Bilds erforderlich ist.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>Beschreibt den Header für eine portierbare ausführbare (PE)-Datei.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeader" />-Klasse.</summary>
      <param name="machine">Die CPU-Architektur des Zielcomputers.</param>
      <param name="sectionAlignment">Die Ausrichtung (in Bytes) von Abschnitten beim Laden in den Arbeitsspeicher. Dieses muss größer oder gleich <paramref name="fileAlignment" /> sein. Der Standard für die Architektur ist die Seitengröße.</param>
      <param name="majorSubsystemVersion">Die Hauptversionsnummer des Subsystems.</param>
      <param name="minorSubsystemVersion">Die Nebenversionsnummer des Subsystems.</param>
      <param name="subsystem">Das Subsystem, das für die Ausführung des Images erforderlich ist.</param>
      <param name="dllCharacteristics">Ein Objekt, das die Merkmale der Dynamic Link Library beschreibt.</param>
      <param name="imageCharacteristics">Ein Objekt, das die Merkmale des Images beschreibt.</param>
      <param name="sizeOfStackReserve">Die Größe des Stapels, der reserviert werden soll. Nur für <paramref name="sizeOfStackCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</param>
      <param name="sizeOfStackCommit">Dier Größe des Stapels, für den ein Commit ausgeführt wird.</param>
      <param name="sizeOfHeapReserve">Die Größe des Speicherplatzes für den lokalen Heap, der reserviert werden soll. Nur für <paramref name="sizeOfHeapCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</param>
      <param name="sizeOfHeapCommit">Die Größe des Speicherplatzes für den lokalen Heap, für den ein Commit ausgeführt werden soll.</param>
      <param name="fileAlignment">Der Ausrichtungsfaktor (in Byte), der verwendet wird, um die Rohdaten von Abschnitten in der Imagedatei auszurichten. Der Wert muss eine Potenz von 2 sein und zwischen 512 und einschließlich 64.000 liegen. Der Standardwert liegt bei 512. Wenn <paramref name="sectionAlignment" /> kleiner ist als die Seitengröße der Architektur, dann muss <paramref name="fileAlignment" /> mit <paramref name="sectionAlignment" /> übereinstimmen.</param>
      <param name="imageBase">Beim Laden in den Arbeitsspeicher muss die bevorzugte Adresse des ersten Imagebytes ein Vielfaches von 64.000 sein.</param>
      <param name="majorLinkerVersion">Die Hauptversionsnummer des Linker.</param>
      <param name="minorLinkerVersion">Die Nebenversionsnummer des Linker.</param>
      <param name="majorOperatingSystemVersion">Die Hauptversionsnummer des erforderlichen Betriebssystems.</param>
      <param name="minorOperatingSystemVersion">Die Nebenversionsnummer des erforderlichen Betriebssystems.</param>
      <param name="majorImageVersion">Die Hauptversionsnummer des Images.</param>
      <param name="minorImageVersion">Die Nebenversionsnummer des Images.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> ist keine Potenz von 2, die zwischen 512 und 64.000 liegt.
- oder -
<paramref name="sectionAlignment" /> ist keine Potenz von 2.
- oder -
<paramref name="sectionAlignment" /> ist kleiner als <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>Erstellt einen ausführbaren Header.</summary>
      <returns>Eine <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />-Instanz, die den ausführbaren Header darstellt.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>Erstellt einen Header der Library.</summary>
      <returns>Eine <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />-Instanz, die den Header der Library darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>Gibt die Eigenschaften der Dynamic Link Library zurück.</summary>
      <returns>Ein-Objekt, das die Eigenschaften der dynamischen Linker-Bibliothek beschreibt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>Der Ausrichtungsfaktor (in Byte), der verwendet wird, um die Rohdaten von Abschnitten in der Imagedatei auszurichten. Der Wert muss eine Potenz von 2 sein und zwischen 512 und einschließlich 64.000 liegen. Der Standardwert liegt bei 512. Wenn die Abschnittsausrichtung kleiner als die Seitengröße der Architektur ist, dann muss die Dateiausrichtung mit der Abschnittsausrichtung übereinstimmen.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>Beim Laden in den Arbeitsspeicher muss die bevorzugte Adresse des ersten Imagebytes ein Vielfaches von 64.000 sein.</summary>
      <returns>Eine Zahl, die die bevorzugte Adresse des ersten Bytes des Bilds darstellt, wenn Sie in den Arbeitsspeicher geladen wird.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>Gibt die Eigenschaften des Images zurück.</summary>
      <returns>Ein-Objekt, das die Bildmerkmale darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>Die CPU-Architektur des Zielcomputers.</summary>
      <returns>Einer der Enumerationswerte, die die verschiedenen CPU-Architekturen darstellen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>Die Hauptversionsnummer des Images.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.UInt16" /> darstellt, das die Hauptversionsnummer des Bilds darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>Die Hauptversionsnummer des Linker.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.Byte" /> darstellt, das die Linker Hauptversionsnummer darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>Die Hauptversionsnummer des erforderlichen Betriebssystems.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.UInt16" /> darstellt, das die Hauptversionsnummer des erforderlichen Betriebssystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>Die Hauptversionsnummer des Subsystems.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.UInt16" /> darstellt, das die Hauptversionsnummer des Subsystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>Die Nebenversionsnummer des Images.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.UInt16" /> darstellt, das die neben Versionsnummer des Bilds darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>Die Nebenversionsnummer des Linker.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.Byte" /> darstellt, das die neben Versionsnummer des Linker darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>Die Nebenversionsnummer des erforderlichen Betriebssystems.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.UInt16" /> darstellt, das die neben Versionsnummer des erforderlichen Betriebssystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>Die Nebenversionsnummer des Subsystems.</summary>
      <returns>Eine Zahl, die die Größe eines <see cref="T:System.UInt16" /> darstellt, das die neben Versionsnummer des Subsystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>Die Ausrichtung (in Bytes) von Abschnitten beim Laden in den Arbeitsspeicher.</summary>
      <returns>Eine Zahl, die die Ausrichtung (in Bytes) der Abschnitte darstellt, wenn Sie in den Arbeitsspeicher geladen werden. Der Wert muss größer oder gleich der Datei Ausrichtung sein. Der Standard für die Architektur ist die Seitengröße.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>Die Größe des Speicherplatzes für den lokalen Heap, für den ein Commit ausgeführt werden soll.</summary>
      <returns>Eine Zahl, die die Größe des zu commitenden lokalen Heap-Speicherplatzes darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>Die Größe des Speicherplatzes für den lokalen Heap, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns>Eine Zahl, die die Größe des zu reservierenden lokalen Heap-Speicherplatzes darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>Dier Größe des Stapels, für den ein Commit ausgeführt wird.</summary>
      <returns>Eine Zahl, die die Größe des zu commitenden Stapels darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>Die Größe des Stapels, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns>Eine Zahl, die die Größe des zu reservierenden Stapels darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>Das Subsystem, das zum Ausführen dieses Images erforderlich ist.</summary>
      <returns>Eine <see cref="T:System.Reflection.PortableExecutable.Subsystem" />-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>Definiert einen Typ, der PE-Header (Portable Executable) und COFF-Header (Common Object File Format) aus einem Stream liest.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>Instanziiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />-Klasse, die den PE-Header aus der aktuellen Position im angegebenen Stream liest.</summary>
      <param name="peStream">Ein Stream, der das PE-Image enthält, das bei der aktuellen Position des Streams beginnt und am Ende des Streams endet.</param>
      <exception cref="T:System.BadImageFormatException">Die Daten, die aus dem Stream gelesen wurden, haben ein ungültiges Format.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem Datenstrom.</exception>
      <exception cref="T:System.ArgumentException">Der Stream unterstützt keine Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>Instanziiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />-Klasse, die die PE-Header aus dem Stream liest, der ein PE-Image einer angegebenen Größe darstellt.</summary>
      <param name="peStream">Ein Stream, der ein PE-Image der angegebenen Größe enthält, und bei seiner aktuellen Position beginnt.</param>
      <param name="size">Die Größe des PE-Images.</param>
      <exception cref="T:System.BadImageFormatException">Die Daten, die aus dem Stream gelesen wurden, haben ein ungültiges Format.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem Datenstrom.</exception>
      <exception cref="T:System.ArgumentException">Der Stream unterstützt keine Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> ist negativ oder erstreckt sich über das Ende des Datenstroms hinaus.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>Instanziiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />-Klasse, die die PE-Header aus dem Stream liest, der ein PE-Image einer angegebenen Größe darstellt, und anzeigt, ob das PE-Image in den Arbeitsspeicher geladen wurde.</summary>
      <param name="peStream">Der Stream, der ein PE-Image der angegebenen Größe enthält, und bei seiner aktuellen Position beginnt.</param>
      <param name="size">Die Größe des PE-Images.</param>
      <param name="isLoadedImage">
        <see langword="true" />, wenn das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde. Andernfalls <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">Die Daten, die aus dem Stream gelesen wurden, haben ein ungültiges Format.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem Datenstrom.</exception>
      <exception cref="T:System.ArgumentException">Der Stream unterstützt keine Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> ist negativ oder erstreckt sich über das Ende des Datenstroms hinaus.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>Ruft den COFF-Header des Images ab.</summary>
      <returns>Der COFF-Header des Bilds.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>Ruft den Byteoffset vom Anfang des PE-Images bis zum Anfang des COFF-Headers ab.</summary>
      <returns>Der Byte Offset vom Beginn des PE-Bilds bis zum Anfang des COFF-Headers.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>Ruft den COR-Header ab.</summary>
      <returns>Der COR-Header oder <see langword="null" />, wenn das Bild nicht über ein solches verfügt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>Ruft den Byteoffset vom Anfang des Images bis zum COR-Header ab.</summary>
      <returns>Der Byte Offset vom Beginn des Bilds bis zum COR-Header oder-1, wenn das Bild keinen COR-Header besitzt.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>Sucht nach Bereichen des PE-Images für den Bereich, der die angegebene RVA enthält.</summary>
      <param name="relativeVirtualAddress">Die zu suchende relative virtuelle Adresse (RVA).</param>
      <returns>Der Index des Abschnitts, der <paramref name="relativeVirtualAddress" />, oder –1 enthält, wenn die Suche erfolglos war.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>Ruft einen Wert ab, der angibt, ob das Image ausschließlich im COFF-Format vorliegt.</summary>
      <returns>
        <see langword="true" />, wenn das Bild nur COFF ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>Ruft einen Wert ab, der angibt, ob das Image eine Windows-Konsolenanwendung darstellt.</summary>
      <returns>
        <see langword="true" />, wenn das Image eine Windows-Konsolenanwendung ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>Ruft einen Wert ab, der angibt, ob das Image eine Dynamic link Library darstellt.</summary>
      <returns>
        <see langword="true" />, wenn es sich bei dem Bild um eine DLL handelt. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>Ruft einen Wert ab, der angibt, ob das Image eine ausführbare Datei darstellt.</summary>
      <returns>
        <see langword="true" />, wenn das Bild eine ausführbare Datei ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>Ruft die Größe der CLI-Metadaten ab.</summary>
      <returns>die Größe der CLI-Metadaten oder 0, wenn das Image keine Metadaten enthält.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>Ruft den Offset (in Bytes) vom Anfang des PE-Images bis zum Anfang der CLI-Metadaten ab.</summary>
      <returns>Der Offset (in Bytes) vom Anfang des PE-Bilds bis zum Anfang der CLI-Metadaten oder-1, wenn das Image keine Metadaten enthält.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>Ruft den PE-Header des Images ab.</summary>
      <returns>Der PE-Header des Bilds oder <see langword="null" />, wenn das Bild nur COFF ist.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>Ruft den Byteoffset des Headers vom Anfang des Images ab.</summary>
      <returns>Der Byte Offset des Headers vom Beginn des Bilds.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>Ruft die PE-Header des Abschnitts ab.</summary>
      <returns>Ein Array, das die PE-Abschnitts Kopfzeilen enthält.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>Ruft den Offset (in Bytes) vom Anfang des Images bis zu den angegebenen Daten des Verzeichnisses ab.</summary>
      <param name="directory">Der PE-Eintrag eines Verzeichnisses.</param>
      <param name="offset">Wenn die Methode zurückgegeben wird, enthält diese den Offset vom Anfang des Images bis zu den angegebenen Daten des Verzeichnisses.</param>
      <returns>
        <see langword="true" />, wenn die Daten des Verzeichnisses gefunden werden; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>Liest den Inhalt des gesamten Blocks in ein Array ein.</summary>
      <returns>Ein unveränderliches Bytearray.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>Liest den Inhalt eines Teils des Blocks in ein Array ein.</summary>
      <param name="start">Die Anfangsposition im Block.</param>
      <param name="length">Die Anzahl der zu lesenden Bytes.</param>
      <returns>Ein unveränderliches Bytearray.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Bereich ist nicht im Block enthalten.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>Erstellt ein <see cref="T:System.Reflection.Metadata.BlobReader" />-Element für ein Blob, das sich über den gesamten Block erstreckt.</summary>
      <returns>Ein Reader für ein Blob, das sich über den gesamten Block erstreckt.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>Erstellt ein <see cref="T:System.Reflection.Metadata.BlobReader" />-Element für ein Blob, das sich über einen Teil des Blocks erstreckt.</summary>
      <param name="start">Die Anfangsposition im Block.</param>
      <param name="length">Die Anzahl von Bytes in dem Teil des Blocks.</param>
      <returns>Ein Reader für ein Blob, das sich über einen Teil des Blocks erstreckt.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Bereich ist nicht im Block enthalten.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>Ruft die Länge des Blocks ab.</summary>
      <returns>Die Länge des Blocks.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>Ruft einen Zeiger auf das erste Byte des Blocks ab.</summary>
      <returns>Ein Zeiger auf das erste Byte des Blocks.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>Stellt einen Reader für portierbare ausführbare Dateien (PE) bereit.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>Erstellt einen PE-Reader über ein PE-Image, das im Arbeitsspeicher gespeichert ist.</summary>
      <param name="peImage">Ein Zeiger auf den Anfang des PE-Image.</param>
      <param name="size">Die Größe des PE-Images.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>Erstellt einen PE-Reader über ein PE-Image, das im Arbeitsspeicher gespeichert ist. Ein Kennzeichen gibt an, ob das Image bereits in den Arbeitsspeicher geladen wurde.</summary>
      <param name="peImage">Ein Zeiger auf den Anfang des PE-Image.</param>
      <param name="size">Die Größe des PE-Images.</param>
      <param name="isLoadedImage">
        <see langword="true" />, wenn das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde. Andernfalls <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Erstellt einen PE-Reader über ein PE-Image, das in einem Bytearray gespeichert ist.</summary>
      <param name="peImage">Ein unveränderliches Bytearray, das das PE-Image darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>Erstellt einen PE-Reader über ein PE-Image, das in einem Datenstrom gespeichert ist.</summary>
      <param name="peStream">PE-Imagedatenstrom.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>Erstellt einen PE-Reader über ein PE-Image, das in einem Datenstrom gespeichert ist. Der Anfang liegt dabei bei der aktuellen Position, das Ende am Ende des Datenstroms.</summary>
      <param name="peStream">Ein PE-Imagedatenstrom.</param>
      <param name="options">Optionen, die angeben, wie Abschnitte des PE-Image aus dem Datenstrom gelesen werden.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" /> besitzt einen ungültigen Wert.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem Datenstrom (nur beim Vorabrufen von Daten).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> wird angegeben, und die PE-Header des Image sind ungültig.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>Erstellt einen PE-Reader über ein PE-Image der angegebenen Größe. Der Anfang liegt dabei bei der aktuellen Position des Datenstroms.</summary>
      <param name="peStream">Ein PE-Imagedatenstrom.</param>
      <param name="options">Optionen, die angeben, wie Abschnitte des PE-Image aus dem Datenstrom gelesen werden.</param>
      <param name="size">Die Größe des PE-Image.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> ist negativ oder erstreckt sich über das Ende des Datenstroms hinaus.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem Datenstrom (nur beim Vorabrufen von Daten).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> wird angegeben, und die PE-Header des Image sind ungültig.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>Verwirft den gesamten vom Leser zugewiesenen Speicher.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>Ruft ein <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" />-Objekt ab, das das gesamte PE-Image enthält.</summary>
      <returns>Ein Arbeitsspeicherblock, der das gesamte PE-Image enthält.</returns>
      <exception cref="T:System.InvalidOperationException">Das gesamte PE-Image ist nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>Lädt einen PE-Abschnitt, der CLI-Metadaten enthält.</summary>
      <returns>Ein Arbeitsspeicherblock, der die CLI-Metadaten enthält.</returns>
      <exception cref="T:System.InvalidOperationException">Das PE-Image enthält keine Metadaten (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> gibt <see langword="false" /> zurück).</exception>
      <exception cref="T:System.BadImageFormatException">Die PE-Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>Lädt den PE-Abschnitt, der die angegebene relative virtuelle Adresse enthält, in den Arbeitsspeicher und gibt einen Arbeitsspeicherblock zurück, der an dieser Adresse beginnt und am Ende des enthaltenden Abschnitts endet.</summary>
      <param name="relativeVirtualAddress">Die relative virtuelle Adresse der zu lesenden Daten.</param>
      <returns>Ein Arbeitsspeicherblock, der an <paramref name="relativeVirtualAddress" /> beginnt und am Ende des enthaltenden Abschnitts endet, oder ein leerer Block, wenn <paramref name="relativeVirtualAddress" /> keinen Speicherort in einem der PE-Abschnitte dieses PE-Image darstellt.</returns>
      <exception cref="T:System.BadImageFormatException">Die PE-Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException">Beim Lesen aus dem zugrunde liegenden Datenstrom ist ein E/A-Fehler aufgetreten.</exception>
      <exception cref="T:System.InvalidOperationException">Das PE-Image ist nicht verfügbar.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>Lädt den PE-Abschnitt mit dem angegebenen Namen in den Arbeitsspeicher und gibt einen Arbeitsspeicherblock zurück, der den Abschnitt umfasst.</summary>
      <param name="sectionName">Der Name des Abschnitts.</param>
      <returns>Ein Arbeitsspeicherblock, der den Abschnitt umfasst, oder ein leerer Block, wenn kein Abschnitt des angegebenen <paramref name="sectionName" /> in diesem PE-Image vorhanden ist.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Das PE-Image ist nicht verfügbar.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>Ruft einen Wert ab, der angibt, ob das PE-Image CLI-Metadaten enthält.</summary>
      <returns>
        <see langword="true" />, wenn das PE-Image CLI-Metadaten enthält. Andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.BadImageFormatException">Die PE-Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem zugrunde liegenden Datenstrom.</exception>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>Ruft einen Wert ab, der angibt, ob der Reader Zugriff auf das gesamte PE-Image hat.</summary>
      <returns>
        <see langword="true" />, wenn der Reader auf das gesamte PE-Image zugreifen kann. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>Ruft einen Wert ab, der angibt, ob das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde.</summary>
      <returns>
        <see langword="true" />, wenn das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>Ruft die PE-Header ab.</summary>
      <returns>Die PE-Header für dieses PE-Image.</returns>
      <exception cref="T:System.BadImageFormatException">Die Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException">Fehler beim Lesen aus dem Datenstrom.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Liest die Daten, auf die der angegebene Debugverzeichniseintrag zeigt, und interpretiert diese als CodeView.</summary>
      <param name="entry">Eine Debugverzeichniseintragsinstanz.</param>
      <returns>Eine CodeView-Debugverzeichnisdateninstanz.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> ist kein CodeView-Eintrag.</exception>
      <exception cref="T:System.BadImageFormatException">Das Format der Daten ist ungültig.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <exception cref="T:System.InvalidOperationException">Das PE-Image ist nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>Liest alle Debugverzeichnistabelleneinträge.</summary>
      <returns>Ein Array aus Debugverzeichnistabelleneinträgen.</returns>
      <exception cref="T:System.BadImageFormatException">Das Format des Eintrags ist ungültig.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <exception cref="T:System.InvalidOperationException">Das PE-Image ist nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Liest die Daten, auf die der angegebene Debugverzeichniseintrag zeigt, und interpretiert diese als eingebetteten portierbaren PDB-Blob.</summary>
      <param name="entry">Der Debugverzeichniseintrag, dessen Daten gelesen werden sollen.</param>
      <returns>Der Anbieter eines Metadatenreaders zum Lesen eines portierbaren PDB-Image.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> ist kein <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />-Eintrag.</exception>
      <exception cref="T:System.BadImageFormatException">Das Format der Daten ist ungültig.</exception>
      <exception cref="T:System.InvalidOperationException">PE-Image nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Liest die Daten, auf die der angegebene Debugverzeichniseintrag zeigt, und interpretiert diese als PDB-Prüfsummeneintrag.</summary>
      <param name="entry">Der Debugverzeichniseintrag, dessen Daten gelesen werden sollen.</param>
      <returns>Der PDB-Prüfsummeneintrag.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> ist kein PDB-Prüfsummeneintrag.</exception>
      <exception cref="T:System.BadImageFormatException">Das Format der Daten ist ungültig.</exception>
      <exception cref="T:System.IO.IOException">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <exception cref="T:System.InvalidOperationException">Das PE-Image ist nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>Öffnet eine portierbare PDB-Datei, die diesem PE-Image zugeordnet ist.</summary>
      <param name="peImagePath">Der Pfad zum PE-Image. Der Pfad wird verwendet, um die PDB-Datei in dem Verzeichnis zu suchen, das die PE-Datei enthält.</param>
      <param name="pdbFileStreamProvider">Wird falls angegeben aufgerufen, um eine <see cref="T:System.IO.Stream" />-Klasse für einen bestimmten Dateipfad zu öffnen. Es wird erwartet, dass der Anbieter entweder eine lesbare und durchsuchbare <see cref="T:System.IO.Stream" />-Klasse oder <see langword="null" /> zurückgibt, wenn die Zieldatei nicht vorhanden ist oder aus irgendeinem Grund ignoriert werden soll. Der Anbieter sollte <see cref="T:System.IO.IOException" /> auslösen, wenn die Datei aufgrund eines unerwarteten E/A-Fehlers nicht geöffnet werden kann.</param>
      <param name="pdbReaderProvider">Im Erfolgsfall eine neue Instanz von <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />, die zum Lesen der portierbaren PDB-Datei verwendet werden soll.</param>
      <param name="pdbPath">Bei Erfolg und falls die PDB-Datei in einer Datei gefunden wird, der Pfad zur Datei, oder <see langword="null" />, falls die PDB-Datei in das PE-Image selbst eingebettet ist.</param>
      <returns>
        <see langword="true" />, wenn dem PE-Image eine PDB-Datei zugeordnet ist und die PDB-Datei erfolgreich geöffnet wurde. Andernfalls <see langword="false" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> oder <paramref name="pdbFileStreamProvider" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der von <paramref name="pdbFileStreamProvider" /> zurückgegebene Datenstrom unterstützt keine Lese- und Suchvorgänge.</exception>
      <exception cref="T:System.BadImageFormatException">Aufgrund eines Fehlers wurde keine übereinstimmende PDB-Datei gefunden: Das PE-Image oder die PDB-Datei ist ungültig.</exception>
      <exception cref="T:System.IO.IOException">Aufgrund eines Fehlers wurde keine übereinstimmende PDB-Datei gefunden: E/A-Fehler beim Lesen des PE-Image oder der PDB-Datei.</exception>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>Stellt Optionen bereit, die angeben, wie Abschnitte eines PE-Images aus einem Datenstrom gelesen werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>Standardmäßig wird der Datenstrom verworfen, wenn die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse verworfen wird und Abschnitte des PE-Images verzögert gelesen werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>Gibt an, dass das zugrunde liegende PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>Hält den Datenstrom geöffnet, wenn <see cref="T:System.Reflection.PortableExecutable.PEReader" /> entfernt wird.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>Liest das gesamte Image direkt in den Arbeitsspeicher. Die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse schließt den Datenstrom bei Rückgabe durch den Konstruktor automatisch, sofern nicht <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> angegeben wird.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>Liest den Metadatenabschnitt direkt in den Arbeitsspeicher.Aus anderen Abschnitten der Datei darf nicht gelesen werden (andernfalls löst die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse <see cref="T:System.InvalidOperationException" /> aus).Die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse schließt den Datenstrom bei Rückgabe durch den Konstruktor automatisch, sofern nicht <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> angegeben wird. Nachdem die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse erstellt wurde, kann die zugrunde liegende Datei geschlossen und sogar gelöscht werden.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>Definiert die Basisklasse für einen PE-Ressourcenabschnitt-Generator. Ableiten von <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />, um Serialisierungslogik für native Ressourcen bereitzustellen.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />-Klasse.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>Serialisiert die angegebene Ressource.</summary>
      <param name="builder">Ein Blob, das die zu serialisierenden Daten enthält.</param>
      <param name="location">Der Speicherort, an den <paramref name="builder" /> serialisiert werden soll.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>Stellt Informationen zum Abschnittsheader einer PE/COFF-Datei bereit.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>Ruft den Namen des Abschnitts ab.</summary>
      <returns>Der Name des Abschnitts.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>Ruft die Anzahl der Zeilennummereinträge für den Abschnitt ab.</summary>
      <returns>Die Anzahl der Zeilennummern Einträge für den Abschnitt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>Ruft die Anzahl der Verschiebungseinträge für den Abschnitt ab.</summary>
      <returns>Die Anzahl der Verschiebungs Einträge für den Abschnitt. Der Wert für PE-Images ist 0 (null).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>Ruft den Dateizeiger auf den Anfang der Zeilennummereinträge für den Abschnitt ab.</summary>
      <returns>Der Dateizeiger auf den Anfang der Zeilennummern Einträge für den Abschnitt, oder 0 (null), wenn keine COFF-Zeilennummern vorhanden sind.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>Ruft den Dateizeiger auf die erste Seite des Abschnitts in der COFF-Datei ab.</summary>
      <returns>Der Dateizeiger auf die erste Seite des Abschnitts in der COFF-Datei.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>Ruft den Dateizeiger auf den Anfang der Verschiebungseinträge für den Abschnitt ab.</summary>
      <returns>Der Dateizeiger auf den Anfang der Verschiebungs Einträge für den Abschnitt. Es ist für PE-Images auf 0 (null) festgelegt, oder wenn keine Umsetzungen vorhanden sind.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>Ruft die Flags ab, die die Merkmale des Abschnitts beschreiben.</summary>
      <returns>Die Flags, die die Merkmale des Abschnitts beschreiben.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>Ruft die Größe des Abschnitts (für Objektdateien) oder die Größe der initialisierten Daten auf dem Datenträger (für Bilddateien) ab.</summary>
      <returns>Die Größe des Abschnitts (für Objektdateien) oder die Größe der initialisierten Daten auf dem Datenträger (für Bilddateien).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>Ruft die virtuelle Adresse des Abschnitts ab.</summary>
      <returns>Die virtuelle Adresse des Abschnitts.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>Ruft die Gesamtgröße des Abschnitts ab, wenn dieser in den Arbeitsspeicher geladen wird.</summary>
      <returns>Die Gesamtgröße des Abschnitts beim Laden in den Arbeitsspeicher.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>Beschreibt die Subsystemanforderung für das Image.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>EFI-Anwendung (Extensible Firmware Interface).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>EFI-Treiber mit Startdiensten.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>EFI-ROM-Image.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>EFI-Treiber mit Laufzeitdiensten.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>Das Image erfordert kein Subsystem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>Bei dem Image handelt es sich um einen nativen Win9x-Treiber.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>Das Image wird im OS/2-Zeichensubsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>Das Image wird im POSIX-Zeichensubsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>Unbekanntes Subsystem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>Startanwendung.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>Das Image wird im Windows CE-Subsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>Das Image wird im Windows-Zeichensubsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>Das Image wird im Windows GUI-Subsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Xbox-System.</summary>
    </member>
  </members>
</doc>