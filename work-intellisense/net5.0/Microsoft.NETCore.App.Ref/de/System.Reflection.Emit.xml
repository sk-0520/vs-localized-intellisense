<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary>Definiert eine dynamische Assembly und stellt diese dar.</summary>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen und den angegebenen Zugriffsrechten.</summary>
      <param name="name">Der Name der Assembly.</param>
      <param name="access">Die Zugriffsrechte der Assembly.</param>
      <returns>Ein Objekt, das die neue Assembly darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary>Definiert eine neue Assembly mit dem angegebenen Namen sowie den angegebenen Zugriffsrechten und Attributen.</summary>
      <param name="name">Der Name der Assembly.</param>
      <param name="access">Die Zugriffsrechte der Assembly.</param>
      <param name="assemblyAttributes">Eine Auflistung, die die Attribute der Assembly enthält.</param>
      <returns>Ein Objekt, das die neue Assembly darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary>Definiert ein benanntes flüchtiges dynamisches Modul in dieser Assembly.</summary>
      <param name="name">Der Name des dynamischen Moduls.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> beginnt mit einem Leerzeichen.  
  
- oder - 
Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Die Länge von <paramref name="name" /> übersteigt die vom System definierte Höchstlänge.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <exception cref="T:System.ExecutionEngineException">Die Assembly für den Standardsymbolwriter kann nicht geladen werden.  
  
 - oder -  
  
 Der Typ, der die Schnittstelle des Symbolwriters implementiert, wurde nicht gefunden.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.ModuleBuilder" />, das das definierte dynamische Modul darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich dem angegebenen Objekt ist.</summary>
      <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="obj" /> dem Typ und dem Wert dieser Instanz entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt die benutzerdefinierten Attribute zurück, die auf den aktuellen <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> angewendet wurden.</summary>
      <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
      <returns>Ein Array, das die benutzerdefinierten Attribute enthält. Das Array ist leer, wenn keine Attribute vorhanden sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt alle benutzerdefinierten Attribute zurück, die auf den aktuellen <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> angewendet wurden und die von einem angegebenen Attributtyp abgeleitet sind.</summary>
      <param name="attributeType">Der Basistyp, von dem Attribute abgeleitet werden.</param>
      <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> ist kein <see cref="T:System.Type" />-Objekt, das von der Laufzeit bereitgestellt wird. Beispielsweise ist <paramref name="attributeType" /> ein <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt.</exception>
      <returns>Ein Array, das die benutzerdefinierten Attribute enthält, die mit einem beliebigen Grad von <paramref name="attributeType" /> abgeleitet sind. Das Array ist leer, wenn keine solchen Attribute vorhanden sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary>Gibt <see cref="T:System.Reflection.CustomAttributeData" />-Objekte zurück, die Informationen zu den Attributen enthalten, die auf den aktuellen <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> angewendet wurden.</summary>
      <returns>Eine generische Liste von <see cref="T:System.Reflection.CustomAttributeData" />-Objekten, die Daten zu den Attributen darstellen, die auf das aktuelle Modul angewendet wurden.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary>Gibt das dynamische Modul mit dem angegebenen Namen zurück.</summary>
      <param name="name">Der Name des angeforderten dynamischen Moduls.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Ein ModuleBuilder-Objekt, das das angeforderte dynamische Modul darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary>Ruft die in dieser Assembly definierten exportierten Typen ab.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode ist nicht implementiert.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Ein Array von <see cref="T:System.Type" />, das die in dieser Assembly definierten exportierten Typen enthält.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary>Ruft einen <see cref="T:System.IO.FileStream" /> für die angegebene Datei in der Dateitabelle des Manifests dieser Assembly ab.</summary>
      <param name="name">Der Name der angegebenen Datei.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>
        <see cref="T:System.IO.FileStream" /> für die angegebene Datei oder <see langword="null" />, wenn die Datei nicht gefunden wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary>Ruft die Dateien in der Dateitabelle eines Assemblymanifests ab und gibt an, ob Ressourcenmodule eingebunden werden sollen.</summary>
      <param name="getResourceModules">
        <see langword="true" />, wenn Ressourcenmodule eingebunden werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Ein Array von <see cref="T:System.IO.FileStream" />-Objekten.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary>Gibt alle geladenen Module zurück, die Bestandteil dieser Assembly sind, und bindet optional Ressourcenmodule ein.</summary>
      <param name="getResourceModules">
        <see langword="true" />, wenn Ressourcenmodule eingebunden werden sollen, andernfalls <see langword="false" />.</param>
      <returns>Die geladenen Module, die Bestandteil dieser Assembly sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary>Gibt Informationen darüber zurück, wie die angegebene Ressource beibehalten wurde.</summary>
      <param name="resourceName">Der Name der Ressource.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>
        <see cref="T:System.Reflection.ManifestResourceInfo" /> mit Informationen zur Topologie der Ressource, oder <see langword="null" />, falls die Ressource nicht gefunden wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary>Lädt die angegebene Manifestressource aus dieser Assembly.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird für eine dynamische Assembly nicht unterstützt. Um die Manifestressourcennamen abzurufen, verwenden Sie <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Ein Array des Typs <see langword="String" />, das die Namen sämtlicher Ressourcen enthält.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary>Lädt die angegebene Manifestressource aus dieser Assembly.</summary>
      <param name="name">Der Name der angeforderten Manifestressource.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Ein <see cref="T:System.IO.Stream" />, der diese Manifestressource darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary>Lädt die angegebene Manifestressource, deren Gültigkeitsbereich durch den Namespace des angegebenen Typs festgelegt ist, aus dieser Assembly.</summary>
      <param name="type">Der Typ, dessen Namespace verwendet wird, um den Gültigkeitsbereich des Manifestressourcennamens festzulegen.</param>
      <param name="name">Der Name der angeforderten Manifestressource.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Ein <see cref="T:System.IO.Stream" />, der diese Manifestressource darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary>Ruft das angegebene Modul in dieser Assembly ab.</summary>
      <param name="name">Der Name des angeforderten Moduls.</param>
      <returns>Das angeforderte Modul oder <see langword="null" />, wenn das Modul nicht gefunden wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary>Ruft alle Module ab, die Bestandteil dieser Assembly sind, und bindet optional Ressourcenmodule ein.</summary>
      <param name="getResourceModules">
        <see langword="true" />, wenn Ressourcenmodule eingebunden werden sollen, andernfalls <see langword="false" />.</param>
      <returns>Die Module, die Bestandteil dieser Assembly sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary>Ruft den <see cref="T:System.Reflection.AssemblyName" /> ab, der beim Erstellen der aktuellen dynamischen Assembly angegeben wurde, und legt die Codebasis wie angegeben fest.</summary>
      <param name="copiedName">
        <see langword="true" />, um die Codebasis auf den Speicherort der Assembly festzulegen, nachdem sie verborgen kopiert wurde. <see langword="false" />, um die Codebasis auf den ursprünglichen Speicherort festzulegen.</param>
      <returns>Der Name der dynamischen Assembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary>Ruft eine unvollständige Liste von <see cref="T:System.Reflection.AssemblyName" />-Objekten für die Assemblys ab, auf die dieser <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> verweist.</summary>
      <returns>Ein Array der Assemblynamen für die Assemblys, auf die verwiesen wird. Dieses Array stellt keine vollständige Liste dar.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary>Ruft die Satellitenassembly für die angegebene Kultur ab.</summary>
      <param name="culture">Die angegebene Kultur.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Die Assembly wurde nicht gefunden.</exception>
      <exception cref="T:System.IO.FileLoadException">Die Satellitenassembly mit einem übereinstimmenden Dateinamen wurde gefunden, aber die <see langword="CultureInfo" /> stimmte nicht mit der Angabe überein.</exception>
      <exception cref="T:System.BadImageFormatException">Die Satellitenassembly ist keine gültige Assembly.</exception>
      <returns>Die angegebene Satellitenassembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary>Ruft die angegebene Version der Satellitenassembly für die angegebene Kultur ab.</summary>
      <param name="culture">Die angegebene Kultur.</param>
      <param name="version">Die Version der Satellitenassembly.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.IO.FileLoadException">Die Satellitenassembly mit einem übereinstimmenden Dateinamen wurde gefunden, aber die <see langword="CultureInfo" /> oder die Version stimmte nicht mit der den Angaben überein.</exception>
      <exception cref="T:System.IO.FileNotFoundException">Die Assembly wurde nicht gefunden.</exception>
      <exception cref="T:System.BadImageFormatException">Die Satellitenassembly ist keine gültige Assembly.</exception>
      <returns>Die angegebene Satellitenassembly.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Ruft den angegebenen Typ aus den Typen ab, die im aktuellen <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> definiert und erstellt wurden.</summary>
      <param name="name">Der Name des zu suchenden Typs.</param>
      <param name="throwOnError">
        <see langword="true" />, um eine Ausnahme auszulösen, wenn der Typ nicht gefunden wurde, andernfalls <see langword="false" />.</param>
      <param name="ignoreCase">
        <see langword="true" />, um die Groß- und Kleinschreibung des Typnamens beim Suchen zu ignorieren, andernfalls <see langword="false" />.</param>
      <returns>Der angegebene Typ oder <see langword="null" />, wenn der Typ nicht gefunden oder noch nicht erstellt wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Gibt einen Wert zurück, der angibt, ob eine oder mehrere Instanzen des angegebenen Attributtyps auf diesen Member angewendet werden.</summary>
      <param name="attributeType">Der Typ des zu prüfenden Attributs.</param>
      <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
      <returns>
        <see langword="true" /> wenn eine oder mehrere Instanzen von <paramref name="attributeType" /> auf diese dynamische Assembly angewendet werden, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs ein benutzerdefiniertes Attribut für diese Assembly fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="con" /> ist kein <see langword="RuntimeConstructorInfo" />-Objekt.</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt mithilfe eines benutzerdefinierten Attribut-Generators ein benutzerdefiniertes Attribut für diese Assembly fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary>Ruft den ursprünglich angegebenen Speicherort der Assembly ab (z. B. in einem <see cref="T:System.Reflection.AssemblyName" />-Objekt).</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Der Speicherort der Assembly, der ursprünglich angegeben wurde.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary>Gibt den Einstiegspunkt dieser Assembly zurück.</summary>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Der Einstiegspunkt dieser Assembly.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary>Ruft den Anzeigenamen der aktuellen dynamischen Assembly ab.</summary>
      <returns>Der Anzeigename der dynamischen Assembly.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>Ruft einen Wert ab, der angibt, ob die Assembly aus dem globalen Assemblycache geladen wurde.</summary>
      <returns>Immer <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary>Ruft den Hostkontext ab, in dem die dynamische Assembly erstellt wird.</summary>
      <returns>Ein Wert, der den Hostkontext angibt, in dem die dynamische Assembly erstellt wird.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>Ruft die Version der Common Language Runtime ab, die in der Datei gespeichert wird, die das Manifest enthält.</summary>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Eine Zeichenfolge, die die Version der Common Language Runtime anzeigt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary>Ruft einen Wert ab, der angibt, dass die aktuelle Assembly eine dynamische Assembly ist.</summary>
      <returns>Immer <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary>Ruft den Speicherort der geladenen Datei, die das Manifest enthält, im CodeBase-Format ab, sofern es sich nicht um eine Schattenkopie handelt.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Der Speicherort der geladenen Datei, die das Manifest enthält. Wenn eine Schattenkopie der geladenen Datei erstellt wurde, entspricht der <see langword="Location" /> dem der Datei vor dem Erstellen der Schattenkopie.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary>Ruft das Modul im aktuellen <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> ab, das das Assemblymanifest enthält.</summary>
      <returns>Das Manifestmodul.</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary>Ruft einen Wert ab, der angibt, ob sich die dynamische Assembly im reflektionsbezogenen Kontext befindet.</summary>
      <returns>
        <see langword="true" />, wenn sich die dynamische Assembly im reflektionsbezogenen Kontext befindet, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary>Definiert die Zugriffsmodi für eine dynamische Assembly.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary>Die dynamische Assembly kann ausgeführt, jedoch nicht gespeichert werden.</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary>Die dynamische Assembly wird automatisch entladen und der von ihr belegte Arbeitsspeicher wieder freigegeben, wenn kein Zugriff mehr darauf möglich ist.</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary>Definiert einen Konstruktor einer dynamischen Klasse und stellt diesen dar.</summary>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Definiert einen Parameter dieses Konstruktors.</summary>
      <param name="iSequence">Die Position des Parameters in der Parameterliste. Parameter werden beginnend mit der Zahl 1 (für den ersten Parameter) indiziert.</param>
      <param name="attributes">Die Attribute des Parameters.</param>
      <param name="strParamName">Der Name des Parameters. Der Name kann aus einer NULL-Zeichenfolge bestehen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iSequence" /> ist kleiner als 0 (null) oder größer als die Anzahl der Parameter des Konstruktors.</exception>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde mithilfe von <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <returns>Ein Objekt, das den neuen Parameter dieses Konstruktors darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt alle benutzerdefinierten Attribute zurück, die für diesen Konstruktor definiert sind.</summary>
      <param name="inherit">Steuert die Vererbung benutzerdefinierter Attribute aus Basisklassen. Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <returns>Ein Array von Objekten, das alle benutzerdefinierten Attribute des Konstruktors darstellt, der von dieser <see cref="T:System.Reflection.Emit.ConstructorBuilder" />-Instanz dargestellt wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt die benutzerdefinierten Attribute zurück, die durch den angegebenen Typ identifiziert werden.</summary>
      <param name="attributeType">Der benutzerdefinierte Attributtyp.</param>
      <param name="inherit">Steuert die Vererbung benutzerdefinierter Attribute aus Basisklassen. Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <returns>Ein Array von Objekten, das die Attribute dieses Konstruktors darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary>Ruft einen <see cref="T:System.Reflection.Emit.ILGenerator" /> für diesen Konstruktor ab.</summary>
      <exception cref="T:System.InvalidOperationException">Der Konstruktor ist ein parameterloser Konstruktor.  
  
- oder - 
Der Konstruktor verfügt über <see cref="T:System.Reflection.MethodAttributes" />- oder <see cref="T:System.Reflection.MethodImplAttributes" />-Flags, die angeben, dass er keinen Methodentext enthalten sollte.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.ILGenerator" />-Objekt für diesen Konstruktor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary>Ruft ein <see cref="T:System.Reflection.Emit.ILGenerator" />-Objekt mit der angegebenen MSIL-Streamgröße ab, mit dem ein Methodentext für diesen Konstruktor erstellt werden kann.</summary>
      <param name="streamSize">Die Größe des MSIL-Streams in Bytes.</param>
      <exception cref="T:System.InvalidOperationException">Der Konstruktor ist ein parameterloser Konstruktor.  
  
- oder - 
Der Konstruktor verfügt über <see cref="T:System.Reflection.MethodAttributes" />- oder <see cref="T:System.Reflection.MethodImplAttributes" />-Flags, die angeben, dass er keinen Methodentext enthalten sollte.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.ILGenerator" /> für diesen Konstruktor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary>Gibt die Methodenimplementierungsflags für diesen Konstruktor zurück.</summary>
      <returns>Die Methodenimplementierungsflags für diesen Konstruktor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary>Gibt den Parameter dieses Konstruktors zurück.</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für diesen Konstruktortyp in .NET Framework, Version 1.0 und 1.1, nicht aufgerufen.</exception>
      <exception cref="T:System.NotSupportedException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für diesen Konstruktortyp in .NET Framework, Version 2.0, nicht aufgerufen.</exception>
      <returns>Ein Array von Objekten, das die Parameter dieses Konstruktors darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Ruft den Konstruktor, der von dieser Instanz reflektiert wird, mit den angegebenen Argumenten gemäß den Einschränkung des angegebenen <see langword="Binder" />-Elements dynamisch ab.</summary>
      <param name="obj">Das Objekt, das neu initialisiert werden muss.</param>
      <param name="invokeAttr">Einer der <see langword="BindingFlags" />-Werte, der den gewünschten Bindungstyp angibt.</param>
      <param name="binder">Ein <see langword="Binder" />, das einen Satz von Eigenschaften definiert sowie die Bindung, die Koersion von Argumenttypen und das Aufrufen von Membern mittels Reflektion ermöglicht. Wenn <paramref name="binder" /><see langword="null" /> ist, wird "Binder.DefaultBinding" verwendet.</param>
      <param name="parameters">Eine Argumentliste. Diese ist ein Array von Argumenten, die hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors identisch sind. Wenn keine Parameter vorhanden sind, muss dies ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) sein.</param>
      <param name="culture">Eine <see cref="T:System.Globalization.CultureInfo" /> für die Steuerung der Koersion von Typen. Ist diese gleich NULL, wird das <see cref="T:System.Globalization.CultureInfo" /> -Objekt des aktuellen Threads verwendet.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Sie können den Konstruktor mit <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> abrufen und <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> für die zurückgegebene <see cref="T:System.Reflection.ConstructorInfo" /> abrufen.</exception>
      <returns>Eine Instanz der Klasse, die dem Konstruktor zugeordnet ist.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Ruft den durch diese Instanz dargestellten Konstruktor für das angegebene Objekt dynamisch auf und übergibt dabei die angegebenen Parameter unter den Einschränkungen des angegebenen Binders.</summary>
      <param name="invokeAttr">Dies muss ein Bitflag von <see cref="T:System.Reflection.BindingFlags" /> sein, z. B. "InvokeMethod", "NonPublic" usw.</param>
      <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn „binder“ gleich <see langword="null" />ist, wird der Standardbinder verwendet. Siehe <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Eine Argumentliste. Diese ist ein Array von Argumenten, die hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors identisch sind. Wenn keine Parameter vorhanden sind, muss dies gleich <see langword="null" /> sein.</param>
      <param name="culture">Eine Instanz von <see cref="T:System.Globalization.CultureInfo" /> für die Steuerung der Umwandlung von Typen. Ist diese gleich NULL, wird das <see cref="T:System.Globalization.CultureInfo" /> -Objekt des aktuellen Threads verwendet. (Dies ist z. B. erforderlich, um einen <see cref="T:System.String" />, der 1000 darstellt, in einen <see cref="T:System.Double" />-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.)</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Sie können den Konstruktor mit <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> abrufen und <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> für die zurückgegebene <see cref="T:System.Reflection.ConstructorInfo" /> abrufen.</exception>
      <returns>Der Wert, der von dem aufgerufenen Konstruktor zurückgegeben wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Überprüft, ob der Typ des angegebenen benutzerdefinierten Attributs definiert ist.</summary>
      <param name="attributeType">Ein benutzerdefinierter Attributtyp.</param>
      <param name="inherit">Steuert die Vererbung benutzerdefinierter Attribute aus Basisklassen. Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Sie können den Konstruktor mit <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> abrufen und <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> für die zurückgegebene <see cref="T:System.Reflection.ConstructorInfo" /> abrufen.</exception>
      <returns>
        <see langword="true" />, wenn der Typ des angegebenen benutzerdefinierten Attributs definiert ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Legt die Methodenimplementierungsflags für diesen Konstruktor fest.</summary>
      <param name="attributes">Die Methodenimplementierungsflags.</param>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde mithilfe von <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary>Gibt diese <see cref="T:System.Reflection.Emit.ConstructorBuilder" />-Instanz als <see cref="T:System.String" /> zurück.</summary>
      <returns>Eine Zeichenfolge, die den Namen, Attribute und Ausnahmen dieses Konstruktors enthält, gefolgt vom aktuellen MSIL-Stream (Microsoft Intermediate Language).</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary>Ruft die Attribute für diesen Konstruktor ab.</summary>
      <returns>Die Attribute für diesen Konstruktor.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary>Ruft einen <see cref="T:System.Reflection.CallingConventions" />-Wert ab, der davon abhängt, ob der deklarierende Typ generisch ist.</summary>
      <returns>
        <see cref="F:System.Reflection.CallingConventions.HasThis" />, wenn der deklarierende Typ generisch ist, andernfalls <see cref="F:System.Reflection.CallingConventions.Standard" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary>Ruft einen Verweis auf das <see cref="T:System.Type" />-Objekt für den Typ ab, der diesen Member deklariert.</summary>
      <returns>Der Typ, der diesen Member deklariert.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary>Ruft die Information ab, ob die lokalen Variablen in diesem Konstruktor mit 0 (null) initialisiert werden sollen, oder legt diese Information fest.</summary>
      <returns>Lese-/Schreibzugriff. Ruft die Information ab, ob die lokalen Variablen in diesem Konstruktor mit 0 (null) initialisiert werden sollen, oder legt diese Information fest.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary>Ruft das interne Handle für die Methode ab. Verwenden Sie dieses Handle, um auf das zugrunde liegende Metadatenhandle zuzugreifen.</summary>
      <exception cref="T:System.NotSupportedException">Diese Eigenschaft wird für diese Klasse nicht unterstützt.</exception>
      <returns>Das interne Handle für die Methode. Verwenden Sie dieses Handle, um auf das zugrunde liegende Metadatenhandle zuzugreifen.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary>Ruft das dynamische Modul ab, in dem dieser Konstruktor definiert ist.</summary>
      <returns>Ein <see cref="T:System.Reflection.Module" />-Objekt, das das dynamische Modul darstellt, in dem dieser Konstruktor definiert ist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary>Ruft den Namen des Konstruktors ab.</summary>
      <returns>Der Name dieses Konstruktors.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary>Enthält einen Verweis auf das <see cref="T:System.Type" />-Objekt, aus dem dieses Objekt abgerufen wurde.</summary>
      <returns>Das- <see langword="Type" /> Objekt, aus dem dieses Objekt abgerufen wurde.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary>Beschreibt einen Enumerationstyp und stellt ihn dar.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary>Ruft ein <see cref="T:System.Reflection.TypeInfo" />-Objekt ab, das diese Enumeration darstellt.</summary>
      <returns>Ein Objekt, das diese Enumeration darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary>Definiert das benannte statische Feld in einem Enumerationstyp mit dem angegebenen konstanten Wert.</summary>
      <param name="literalName">Der Name des statischen Felds.</param>
      <param name="literalValue">Der konstante Wert des Literals.</param>
      <returns>Das definierte Feld.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten zurück, die die für diese Klasse angegebenen definierten öffentlichen und nicht öffentlichen Konstruktoren darstellen.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten zurück, die die angegebenen Konstruktoren darstellen, die für diese Klasse definiert sind. Wenn keine Konstruktoren definiert sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt alle benutzerdefinierten Attribute zurück, die für diesen Konstruktor definiert sind.</summary>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Objektarray zurück, das alle benutzerdefinierten Attribute des Konstruktors darstellt, der von dieser <see cref="T:System.Reflection.Emit.ConstructorBuilder" />-Instanz dargestellt wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt die benutzerdefinierten Attribute zurück, die durch den angegebenen Typ identifiziert werden.</summary>
      <param name="attributeType">Das <see langword="Type" />-Objekt, auf das die benutzerdefinierten Attribute angewendet werden.</param>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Objektarray zurück, das die Attribute dieses Konstruktors mit dem <see cref="T:System.Type" /><paramref name="attributeType" /> darstellen.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary>Beim Aufrufen dieser Methode wird immer eine <see cref="T:System.NotSupportedException" /> ausgelöst.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt.</exception>
      <returns>Diese Methode wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary>Gibt den zugrunde liegenden Ganzzahltyp der aktuellen Enumeration zurück, die beim Definieren des Enumerations-Generators festgelegt wird.</summary>
      <returns>Der zugrunde liegende Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Gibt das Ereignis mit dem angegebenen Namen zurück.</summary>
      <param name="name">Der Name des abzurufenden Ereignisses.</param>
      <param name="bindingAttr">Dieses Aufrufattribut. Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das Ereignis darstellt, das von diesem Typ mit dem angegebenen Namen deklariert oder geerbt wurde. Wenn keine Übereinstimmungen vorhanden sind, wird <see langword="null" /> zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary>Gibt die Ereignisse für die öffentlichen Ereignisse zurück, die von diesem Typ deklariert oder geerbt wurden.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" /> -Objekten zurück, die die öffentlichen Ereignisse darstellen, die von diesem Typ deklariert oder geerbt wurden. Wenn keine öffentlichen Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Gibt die öffentlichen und nicht öffentlichen Ereignisse zurück, die von diesem Typ deklariert werden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein, z. B. <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Ereignisse darstellen, die von diesem Typ deklariert oder geerbt werden. Wenn es keine Ereignisse wie angegeben gibt, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Gibt das vom angegebenen Namen angegebene Feld zurück.</summary>
      <param name="name">Der Name des abzurufenden Felds.</param>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt das <see cref="T:System.Reflection.FieldInfo" />-Objekt zurück, das das Feld darstellt, das von diesem Typ mit dem angegebenen Namen und dem öffentlichen oder nicht öffentlichen Modifizierer deklariert oder geerbt wurde. Wenn keine Übereinstimmungen vorhanden sind, wird NULL zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Gibt die öffentlichen und nicht öffentlichen Felder zurück, die von diesem Typ deklariert werden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag von <see cref="T:System.Reflection.BindingFlags" /> sein, z. B. "InvokeMethod", "NonPublic" usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Felder darstellen, die von diesem Typ deklariert oder geerbt werden. Wenn keine Felder vorhanden sind, wird ein leeres Array zurückgegeben, wie angegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Gibt die von diesem Typ (direkt oder indirekt) implementierte Schnittstelle mit dem angegebenen vollqualifizierten Namen zurück.</summary>
      <param name="name">Der Name der Schnittstelle.</param>
      <param name="ignoreCase">Falls <see langword="true" />, wird Groß- und Kleinschreibung bei der Suche nicht berücksichtigt. Falls <see langword="false" />, wird Groß- und Kleinschreibung bei der Suche berücksichtigt.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das die implementierte Schnittstelle darstellt. Gibt NULL zurück, wenn kein mit der Schnittstelle übereinstimmender Name gefunden wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary>Gibt eine Schnittstellenzuordnung für die angeforderte Schnittstelle zurück.</summary>
      <param name="interfaceType">Der Typ der Schnittstelle, für die die Schnittstellenzuordnung abgerufen werden soll.</param>
      <exception cref="T:System.ArgumentException">Die Schnittstelle wird vom Typ nicht implementiert.</exception>
      <returns>Die angeforderte Schnittstellenzuordnung.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary>Gibt ein Array aller für diese Klasse und die zugehörigen Basisklassen implementierten Schnittstellen zurück.</summary>
      <returns>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die implementierten Schnittstellen darstellen. Wenn keine definiert sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Gibt alle Member mit dem angegebenen Namen, dem Typ und der Bindung zurück, die von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="name">Der Name des Members.</param>
      <param name="type">Der Typ des zurückzugebenden Members.</param>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Member darstellen, die für diesen Typ definiert wurden, wenn <paramref name="nonPublic" /> verwendet wird. Andernfalls werden nur die öffentlichen Member zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Gibt die angegebenen Member zurück, die von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Member darstellen, die von diesem Typ deklariert oder geerbt werden. Wenn keine übereinstimmenden Member vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Gibt alle öffentlichen und nicht öffentlichen Methoden zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein, z. B. <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Methoden darstellen, die für diesen Typ definiert wurden, wenn <paramref name="nonPublic" /> verwendet wird. Andernfalls werden nur die öffentlichen Methoden zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Gibt den angegebenen geschachtelten Typ zurück, der von diesem Typ deklariert wird.</summary>
      <param name="name">Das <see cref="T:System.String" />, das den Namen des abzurufenden geschachtelten Typs enthält.</param>
      <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder - 
Null, um eine Suche nach öffentlichen Methoden mit Beachtung der Groß-/Kleinschreibung durchzuführen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Gibt die öffentlichen und nicht öffentlichen geschachtelten Typen zurück, die von diesem Typ deklariert oder geerbt werden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein, z. B. <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die sämtliche im aktuellen <see cref="T:System.Type" /> geschachtelten Typen darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
Ein leeres Array vom Typ <see cref="T:System.Type" />, wenn im aktuellen <see cref="T:System.Type" /> keine Typen geschachtelt sind oder keiner der geschachtelten Typen den Bindungseinschränkungen entspricht.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Gibt alle öffentlichen und nicht öffentlichen Eigenschaften zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="bindingAttr">Dieses Aufrufattribut. Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Eigenschaften darstellen, die für diesen Typ definiert wurden, wenn <paramref name="nonPublic" /> verwendet wird. Andernfalls werden nur die öffentlichen Eigenschaften zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Ruft den angegebenen Member auf. Die Methode, die aufgerufen werden soll, muss zugänglich sein und mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und der Aufrufattribute die spezifischste Übereinstimmung bereitstellen.</summary>
      <param name="name">Der Name des aufzurufenden Members. Dies kann ein Konstruktor, eine Methode, eine Eigenschaft oder ein Feld sein. Es muss ein geeignetes Aufrufattribut angegeben werden. Beachten Sie, dass es möglich ist, den Standardmember einer Klasse aufzurufen, indem Sie eine leere Zeichenfolge als Name des Members übergeben.</param>
      <param name="invokeAttr">Das Attribut für den Aufruf. Dies muss ein Bitflag aus <see langword="BindingFlags" /> sein.</param>
      <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn „binder“ gleich <see langword="null" />ist, wird der Standardbinder verwendet. Siehe <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll. Wenn der Member statisch ist, wird dieser Parameter ignoriert.</param>
      <param name="args">Eine Argumentliste. Dies ist ein Array von Objekten, das die Anzahl, Reihenfolge und den Typ der Parameter des aufzurufenden Members enthält. Wenn keine Parameter vorhanden sind, muss dies gleich NULL sein.</param>
      <param name="modifiers">Ein Array derselben Länge wie <paramref name="args" /> mit Elementen, die die Argumente darstellen, die den Argumenten des aufzurufenden Members zugeordnet sind. Ein Parameter verfügt über Attribute, die ihm in den Metadaten zugeordnet werden. Sie werden von verschiedenen Interoperabilitätsdiensten verwendet. Informationen wie diese finden Sie in den Metadatenspezifikationen.</param>
      <param name="culture">Eine Instanz von <see langword="CultureInfo" /> für die Steuerung der Umwandlung von Typen. Ist diese gleich NULL, wird das <see langword="CultureInfo" /> -Objekt des aktuellen Threads verwendet. (Dies ist z. B. erforderlich, um eine Zeichenfolge, die 1000 darstellt, in einen Double-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.)</param>
      <param name="namedParameters">Jeder Parameter im <paramref name="namedParameters" />-Array ruft den Wert im entsprechenden Element im <paramref name="args" />-Array ab. Wenn die Länge von <paramref name="args" /> größer als die Länge von <paramref name="namedParameters" /> ist, werden die restlichen Argumentwerte in der Reihenfolge übergeben.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Gibt den Rückgabewert des aufgerufenen Members zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Überprüft, ob der Typ des angegebenen benutzerdefinierten Attributs definiert ist.</summary>
      <param name="attributeType">Das <see langword="Type" />-Objekt, auf das die benutzerdefinierten Attribute angewendet werden.</param>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>
        <see langword="true" />, wenn mindestens eine Instanz von <paramref name="attributeType" /> für diesen Member definiert ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</summary>
      <param name="rank">Die Anzahl von Dimensionen für das Array. Diese Zahl muss kleiner oder gleich 32 sein.</param>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> ist kleiner als 1.</exception>
      <returns>Ein Objekt, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als ref-Parameter (ByRef-Parameter in Visual Basic) den aktuellen Typ darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als ref-Parameter (ByRef-Parameter in Visual Basic) den aktuellen Typ darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das einen Zeiger auf den aktuellen Typ darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das einen Zeiger auf den aktuellen Typ darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary>Ruft die dynamische Assembly ab, die diese Enumerationsdefinition enthält.</summary>
      <returns>Schreibgeschützt. Die dynamische Assembly, die diese Enumerationsdefinition enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary>Gibt den vollständigen Pfad dieser Enumeration zurück, der durch den Anzeigenamen der übergeordneten Assembly qualifiziert ist.</summary>
      <returns>Schreibgeschützt. Der vollständige Pfad dieser Enumeration, der durch den Anzeigenamen der übergeordneten Assembly qualifiziert ist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary>Gibt den übergeordneten <see cref="T:System.Type" /> dieses Typs, der immer <see cref="T:System.Enum" /> ist.</summary>
      <returns>Schreibgeschützt. Das übergeordnete <see cref="T:System.Type" /> dieses Typs.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary>Gibt den Typ zurück, der diesen <see cref="T:System.Reflection.Emit.EnumBuilder" /> deklariert hat.</summary>
      <returns>Schreibgeschützt. Der Typ, der diesen <see cref="T:System.Reflection.Emit.EnumBuilder" /> deklariert hat.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary>Gibt den vollständigen Pfad dieser Enumeration zurück.</summary>
      <returns>Schreibgeschützt. Der vollständige Pfad dieser Enumeration.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary>Gibt die GUID dieser Enumeration zurück.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird derzeit nicht in Typen unterstützt, die nicht abgeschlossen sind.</exception>
      <returns>Schreibgeschützt. Die GUID dieser Enumeration.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</summary>
      <returns>
        <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary>Ruft das dynamische Modul ab, das diese <see cref="T:System.Reflection.Emit.EnumBuilder" />-Definition enthält.</summary>
      <returns>Schreibgeschützt. Das dynamische Modul, das diese <see cref="T:System.Reflection.Emit.EnumBuilder" />-Definition enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary>Gibt den Namen dieser Enumeration zurück.</summary>
      <returns>Schreibgeschützt. Der Name dieser Enumeration.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary>Gibt den Namespace dieser Enumeration zurück.</summary>
      <returns>Schreibgeschützt. Der Namespace dieser Enumeration.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary>Gibt den Typ zurück, mit dem dieser <see cref="T:System.Reflection.Emit.EnumBuilder" /> abgerufen wurde.</summary>
      <returns>Schreibgeschützt. Der Typ, mit dem dieser <see cref="T:System.Reflection.Emit.EnumBuilder" /> abgerufen wurde.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary>Ruft das interne Handle für diese Enumeration ab.</summary>
      <exception cref="T:System.NotSupportedException">Diese Eigenschaft wird derzeit nicht unterstützt.</exception>
      <returns>Schreibgeschützt. Das interne Handle für diese Enumeration.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary>Gibt das zugrunde liegende Feld für diese Enumeration zurück.</summary>
      <returns>Schreibgeschützt. Das zugrunde liegende Feld für diese Enumeration.</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary>Gibt den zugrunde liegenden Systemtyp für diese Enumeration zurück.</summary>
      <returns>Schreibgeschützt. Gibt den zugrunde liegenden Systemtyp zurück.</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary>Definiert Ereignisse für eine Klasse.</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Fügt eine der Other-Methoden hinzu, die diesem Ereignis zugeordnet sind. Dies sind andere Methoden als die "on"-Methode und die "raise"-Methode, die einem Ereignis zugeordnet sind. Diese Funktion kann mehrmals aufgerufen werden, um dementsprechend viele Other-Methoden hinzuzufügen.</summary>
      <param name="mdBuilder">Ein <see langword="MethodBuilder" />-Objekt, das die andere Methode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Legt die Methode fest, mit der dieses Ereignis abonniert wird.</summary>
      <param name="mdBuilder">Ein <see langword="MethodBuilder" />-Objekt, das die Methode darstellt, mit der dieses Ereignis abonniert wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Beschreiben des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Legt die Methode fest, mit der dieses Ereignis ausgelöst wird.</summary>
      <param name="mdBuilder">Ein <see langword="MethodBuilder" />-Objekt, das die Methode darstellt, mit der dieses Ereignis ausgelöst wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Legt die Methode fest, mit der das Ereignisabonnement aufgehoben wird.</summary>
      <param name="mdBuilder">Ein <see langword="MethodBuilder" />-Objekt, das die Methode darstellt, mit der dieses Ereignisabonnement aufgehoben wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary>Definiert ein Feld und stellt dieses dar. Diese Klasse kann nicht vererbt werden.</summary>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt alle für dieses Feld definierten benutzerdefinierten Attribute zurück.</summary>
      <param name="inherit">Steuert die Vererbung benutzerdefinierter Attribute aus Basisklassen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Ein Array vom Typ <see cref="T:System.Object" />, das alle benutzerdefinierten Attribute des Konstruktors darstellt, die von dieser <see cref="T:System.Reflection.Emit.FieldBuilder" />-Instanz dargestellt werden.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt alle für dieses Feld definierten benutzerdefinierten Attribute zurück, die vom angegebenen Typ bezeichnet werden.</summary>
      <param name="attributeType">Der benutzerdefinierte Attributtyp.</param>
      <param name="inherit">Steuert die Vererbung benutzerdefinierter Attribute aus Basisklassen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Ein Array vom Typ <see cref="T:System.Object" />, das alle benutzerdefinierten Attribute des Konstruktors darstellt, die von dieser <see cref="T:System.Reflection.Emit.FieldBuilder" />-Instanz dargestellt werden.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary>Ruft den Wert des Felds ab, das vom angegebenen Objekt unterstützt wird.</summary>
      <param name="obj">Das Objekt, für das auf das Feld zugegriffen werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Ein <see cref="T:System.Object" /> mit dem Wert des Felds, das von dieser Instanz reflektiert wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Gibt an, ob ein Attribut mit dem angegebenen Typ für ein Feld definiert ist.</summary>
      <param name="attributeType">Der Typ des Attributs.</param>
      <param name="inherit">Steuert die Vererbung benutzerdefinierter Attribute aus Basisklassen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Rufen Sie das Feld mithilfe von <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> ab, und rufen Sie <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> für die zurückgegebene <see cref="T:System.Reflection.FieldInfo" /> auf.</exception>
      <returns>
        <see langword="true" />, wenn eine oder mehrere Instanzen von <paramref name="attributeType" /> für dieses Feld definiert sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary>Legt den Standardwert dieses Felds fest.</summary>
      <param name="defaultValue">Der neue Standardwert für dieses Feld.</param>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde mithilfe von <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <exception cref="T:System.ArgumentException">Das Feld weist keinen unterstützten Typ auf.  
  
- oder - 
Der Typ von <paramref name="defaultValue" /> entspricht nicht dem Typ des Felds.  
  
- oder - 
Das Feld weist den Typ <see cref="T:System.Object" /> oder einen anderen Verweistyp auf, <paramref name="defaultValue" /> ist nicht <see langword="null" />, und der Wert kann nicht dem Verweistyp zugewiesen werden.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der übergeordnete Typ dieses Felds ist vollständig.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der übergeordnete Typ dieses Felds ist vollständig.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary>Gibt das Feldlayout an.</summary>
      <param name="iOffset">Der Offset des Felds innerhalb des Typs, der dieses Feld enthält.</param>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde mithilfe von <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="iOffset" /> ist kleiner als Null.</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary>Legt den Wert des Felds fest, das durch das angegebene Objekt unterstützt wird.</summary>
      <param name="obj">Das Objekt, für das auf das Feld zugegriffen werden soll.</param>
      <param name="val">Der Wert, der dem Feld zugewiesen werden soll.</param>
      <param name="invokeAttr">Ein Member von <see langword="IBinder" />, der den gewünschten Typ der Bindung angibt, z. B. IBinder.CreateInstance, IBinder.ExactBinding.</param>
      <param name="binder">Eine Gruppe von Eigenschaften, die die Bindung, die Umwandlung von Argumenttypen und das Aufrufen von Membern mithilfe von Reflektion ermöglicht. Wenn der Binder NULL ist, wird IBinder.DefaultBinding verwendet.</param>
      <param name="culture">Die Softwareeinstellungen für eine bestimmte Kultur.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary>Gibt die Attribute dieses Felds an. Diese Eigenschaft ist schreibgeschützt.</summary>
      <returns>Die Attribute dieses Felds.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary>Gibt einen Verweis auf das <see cref="T:System.Type" />-Objekt für den Typ an, der dieses Feld deklariert. Diese Eigenschaft ist schreibgeschützt.</summary>
      <returns>Ein Verweis auf das <see cref="T:System.Type" />-Objekt für den Typ, der dieses Feld deklariert.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary>Gibt das interne Metadatenhandle für dieses Feld an. Diese Eigenschaft ist schreibgeschützt.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Das interne Metadatenhandle für dieses Feld.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary>Gibt das <see cref="T:System.Type" />-Objekt an, das den Typ dieses Felds darstellt. Diese Eigenschaft ist schreibgeschützt.</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ dieses Felds darstellt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary>Ruft das Modul ab, in dem der Typ, der dieses Feld enthält, definiert wird.</summary>
      <returns>Eine <see cref="T:System.Reflection.Module" />-Klasse, die das dynamische Modul darstellt, in dem dieses Feld definiert wird.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary>Gibt den Namen dieses Felds an. Diese Eigenschaft ist schreibgeschützt.</summary>
      <returns>Ein <see cref="T:System.String" /> mit dem Namen dieses Felds.</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary>Gibt den Verweis auf das <see cref="T:System.Type" />-Objekt an, von dem dieses Objekt erhalten wurde. Diese Eigenschaft ist schreibgeschützt.</summary>
      <returns>Ein Verweis auf das <see cref="T:System.Type" />-Objekt, von dem diese Instanz erhalten wurde.</returns>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary>Definiert und erstellt generische Typparameter für dynamisch definierte generische Typen und Methoden. Diese Klasse kann nicht vererbt werden.</summary>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary>Testet, ob das angegebene Objekt eine Instanz von <see langword="EventToken" /> und gleich der aktuellen Instanz ist.</summary>
      <param name="o">Das mit der aktuellen Instanz zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="o" /> eine Instanz von <see langword="EventToken" /> und gleich der aktuellen Instanz ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="attributeType">Der Typ des zu suchenden Attributs. Nur Attribute, die diesem Typ zugeordnet werden können, werden zurückgegeben.</param>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" /> aus.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Der Typ, auf den der aktuelle Arraytyp, Zeigertyp oder <see langword="ByRef" />-Typ verweist, oder <see langword="null" />, wenn der aktuelle Typ kein Arraytyp oder kein Zeigertyp ist und nicht als Verweis übergeben wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="name">Wird nicht unterstützt.</param>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="name">Wird nicht unterstützt.</param>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary>Für generische Typparameter ungültig.</summary>
      <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
      <returns>Für generische Typparameter ungültig.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary>Für generische Typparameter ungültig.</summary>
      <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
      <returns>Für generische Typparameter ungültig.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary>Gibt einen 32-Bit-Ganzzahl-Hashcode für die aktuelle Instanz zurück.</summary>
      <returns>Ein 32-Bit-Ganzzahl-Hashcode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="name">Der Name der Schnittstelle.</param>
      <param name="ignoreCase">
        <see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung zu suchen. <see langword="false" />, um bei der Suche die Groß-/Kleinschreibung zu beachten.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="interfaceType">Ein <see cref="T:System.Type" />-Objekt, das den Schnittstellentyp darstellt, für den die Zuordnung abgerufen werden soll.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="name">Wird nicht unterstützt.</param>
      <param name="type">Wird nicht unterstützt.</param>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="name">Wird nicht unterstützt.</param>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="bindingAttr">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="name">Wird nicht unterstützt.</param>
      <param name="invokeAttr">Wird nicht unterstützt.</param>
      <param name="binder">Wird nicht unterstützt.</param>
      <param name="target">Wird nicht unterstützt.</param>
      <param name="args">Wird nicht unterstützt.</param>
      <param name="modifiers">Wird nicht unterstützt.</param>
      <param name="culture">Wird nicht unterstützt.</param>
      <param name="namedParameters">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" />-Ausnahme aus.</summary>
      <param name="c">Das zu überprüfende Objekt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" />-Ausnahme aus.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="attributeType">Wird nicht unterstützt.</param>
      <param name="inherit">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <param name="c">Wird nicht unterstützt.</param>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary>Gibt den Typ eines eindimensionalen Arrays zurück, dessen Elementtyp der generische Typparameter ist.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das den Typ eines eindimensionalen Arrays darstellt, dessen Elementtyp der generische Typparameter ist.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary>Gibt den Typ eines Arrays, dessen Elementtyp der generische Typparameter ist, mit der angegebenen Anzahl von Dimensionen zurück.</summary>
      <param name="rank">Die Anzahl von Dimensionen für das Array.</param>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> ist keine gültige Anzahl von Dimensionen. Beispielsweise ist der Wert kleiner als 1.</exception>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das den Typ eines Arrays, dessen Elementtyp der generische Typparameter ist, mit der angegebenen Anzahl von Dimensionen darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als Verweisparameter den aktuellen generischen Typparameter darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als Verweisparameter den aktuellen generischen Typparameter darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary>Für unvollständige generische Typparameter ungültig.</summary>
      <param name="typeArguments">Ein Array von Typargumenten.</param>
      <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
      <returns>Diese Methode ist für unvollständige generische Typparameter ungültig.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das einen Zeiger auf den aktuellen generischen Typparameter darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das einen Zeiger auf den aktuellen generischen Typparameter darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary>Legt den Basistyp fest, den ein Typ erben muss, um für den Typparameter ersetzt zu werden.</summary>
      <param name="baseTypeConstraint">Das <see cref="T:System.Type" />, das von jedem Typ geerbt werden muss, der für den Typparameter ersetzt werden muss.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das das Attribut darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="binaryAttribute" /> ist ein NULL-Verweis.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary>Legt die Varianzmerkmale und besonderen Einschränkungen des generischen Parameters fest, z. B. die parameterlose Konstruktoreinschränkung.</summary>
      <param name="genericParameterAttributes">Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die Varianzmerkmale und besondere Einschränkungen des generischen Typparameters darstellen.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary>Legt die Schnittstellen fest, die ein Typ implementieren muss, um durch den Typparameter ersetzt werden zu können.</summary>
      <param name="interfaceConstraints">Ein Array von <see cref="T:System.Type" />-Objekten, die die Schnittstellen darstellen, die ein Typ implementieren muss, um durch den Typparameter ersetzt werden zu können.</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary>Gibt eine Zeichenfolgendarstellung des aktuellen generischen Typparameters zurück.</summary>
      <returns>Eine Zeichenfolge, die den Namen des generischen Typparameters enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary>Ruft ein <see cref="T:System.Reflection.Assembly" />-Objekt ab, das die dynamische Assembly darstellt, die die generische Typdefinition enthält, zu der der aktuelle Typparameter gehört.</summary>
      <returns>Ein <see cref="T:System.Reflection.Assembly" />-Objekt, das die dynamische Assembly darstellt, die die generische Typdefinition enthält, zu der der aktuelle Typparameter gehört.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary>Ruft in allen Fällen <see langword="null" /> ab.</summary>
      <returns>In allen Fällen ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary>Ruft die Basistypeinschränkung des aktuellen generischen Typparameters ab.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das die Basistypeinschränkung des generischen Typparameters oder <see langword="null" /> darstellt, wenn der Typparameter keine Basistypeinschränkung aufweist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary>Ruft in allen Fällen <see langword="true" /> ab.</summary>
      <returns>
        <see langword="true" /> in allen Fällen.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary>Ruft eine <see cref="T:System.Reflection.MethodInfo" /> ab, die die deklarierende Methode darstellt, wenn der aktuelle <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> einen Typparameter einer generischen Methode darstellt.</summary>
      <returns>Eine <see cref="T:System.Reflection.MethodInfo" />, die die deklarierende Methode darstellt, wenn der aktuelle <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> einen Typparameter einer generischen Methode darstellt, andernfalls <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary>Ruft die generische Typdefinition oder generische Methodendefinition ab, zu der der generische Typparameter gehört.</summary>
      <returns>Wenn der Typparameter zu einem generischen Typ gehört, ein <see cref="T:System.Type" />-Objekt, das den generischen Typ darstellt. Wenn der Typparameter zu einer generischen Methode gehört, ein <see cref="T:System.Type" />-Objekt, das den Typ darstellt, der die generische Methode deklariert hat.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary>Ruft in allen Fällen <see langword="null" /> ab.</summary>
      <returns>In allen Fällen ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary>Ruft eine Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Flags ab, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</summary>
      <returns>Eine bitweise Kombination von Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary>Ruft die Position des Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode ab, von dem bzw. der der Parameter deklariert wurde.</summary>
      <returns>Die Position des Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode, von dem bzw. der der Parameter deklariert wurde.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</summary>
      <returns>
        <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary>Ruft in allen Fällen <see langword="true" /> ab.</summary>
      <returns>
        <see langword="true" /> in allen Fällen.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary>Gibt immer <see langword="false" /> zurück.</summary>
      <returns>
        <see langword="false" /> in allen Fällen.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary>Ruft in allen Fällen <see langword="false" /> ab.</summary>
      <returns>
        <see langword="false" /> in allen Fällen.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary>Ruft das dynamische Modul ab, das den generischen Typparameter enthält.</summary>
      <returns>Ein <see cref="T:System.Reflection.Module" />-Objekt, das das dynamische Modul darstellt, das den generischen Typparameter enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary>Ruft den Namen des generischen Typparameters ab.</summary>
      <returns>Der Name des generischen Typparameters.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary>Ruft in allen Fällen <see langword="null" /> ab.</summary>
      <returns>In allen Fällen ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary>Ruft das <see cref="T:System.Type" />-Objekt ab, mit dem der <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> abgerufen wurde.</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, mit dem der <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> abgerufen wurde.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary>Wird für unvollständige generische Typparameter nicht unterstützt.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen.</exception>
      <returns>Wird für unvollständige generische Typparameter nicht unterstützt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary>Ruft den aktuellen generischen Typparameter ab.</summary>
      <returns>Das aktuelle <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekt.</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary>Definiert eine Methode (oder einen Konstruktor) für eine dynamischen Klasse und stellt diese(n) dar.</summary>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary>Legt die Anzahl von generischen Typparametern für die aktuelle Methode fest, gibt deren Namen an und gibt ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten zurück, das dazu verwendet werden kann, deren Einschränkungen zu definieren.</summary>
      <param name="names">Ein Array von Zeichenfolgen, die die Namen der generischen Typparameter darstellen.</param>
      <exception cref="T:System.InvalidOperationException">Es wurden bereits generische Typparameter für diese Methode definiert.  
  
- oder - 
Die Methode wurde bereits abgeschlossen.  
  
- oder - 
Die <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />-Methode wurde für die aktuelle Methode aufgerufen.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> ist <see langword="null" />.  
  
- oder - 
Ein Element von <paramref name="names" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> ist ein leeres Array.</exception>
      <returns>Ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten, die die Typparameter der generischen Methode darstellen.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Legt die Parameterattribute und den Namen eines Parameters dieser Methode oder des Rückgabewerts dieser Methode fest. Gibt einen ParameterBuilder zurück, mit dem benutzerdefinierte Attribute angewendet werden können.</summary>
      <param name="position">Die Position des Parameters in der Parameterliste. Parameter werden beginnend mit der Zahl 1 (für den ersten Parameter) indiziert. Die Zahl 0 stellt den Rückgabewert der Methode dar.</param>
      <param name="attributes">Die Parameterattribute des Parameters.</param>
      <param name="strParamName">Der Name des Parameters. Der Name kann aus einer NULL-Zeichenfolge bestehen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Die Methode hat keine Parameter.  
  
- oder - 
 <paramref name="position" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="position" /> ist größer als die Anzahl der Parameter der Methode.</exception>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
- oder - 
Für die aktuelle Methode ist die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Gibt ein <see langword="ParameterBuilder" />-Objekt zurück, das einen Parameter dieser Methode oder den Rückgabewert dieser Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary>Bestimmt, ob das angegebene Objekt gleich dieser Instanz ist.</summary>
      <param name="obj">Das Objekt, das mit dieser <see langword="MethodBuilder" />-Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see langword="MethodBuilder" /> und gleich diesem Objekt ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary>Gibt die Basisimplementierung für eine Methode zurück.</summary>
      <returns>Die Basisimplementierung für diese Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt alle für diese Methode definierten benutzerdefinierten Attribute zurück.</summary>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den benutzerdefinierten Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Rufen Sie die Methode mithilfe von <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> ab, und rufen Sie <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> für das zurückgegebene <see cref="T:System.Reflection.MethodInfo" />-Objekt auf.</exception>
      <returns>Gibt ein Objektarray zurück, das alle benutzerdefinierten Attribute dieser Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt die benutzerdefinierten Attribute zurück, die durch den angegebenen Typ identifiziert werden.</summary>
      <param name="attributeType">Der benutzerdefinierte Attributtyp.</param>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den benutzerdefinierten Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Rufen Sie die Methode mithilfe von <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> ab, und rufen Sie <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> für das zurückgegebene <see cref="T:System.Reflection.MethodInfo" />-Objekt auf.</exception>
      <returns>Gibt ein Array von Objekten zurück, die die Attribute dieser Methode mit dem Typ <paramref name="attributeType" /> darstellen.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary>Gibt ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten zurück, die die Typparameter der Methode darstellen, wenn diese generisch ist.</summary>
      <returns>Ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten, die für eine generische Methode die Typparameter oder <see langword="null" /> darstellen, wenn die Methode nicht generisch ist.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary>Gibt diese Methode zurück.</summary>
      <exception cref="T:System.InvalidOperationException">Die aktuelle Methode ist keine generische Methode. Das bedeutet, dass die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft <see langword="false" /> zurückgibt.</exception>
      <returns>Die aktuelle Instanz von <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary>Ruft den Hashcode für diese Methode ab.</summary>
      <returns>Der Hashcode für diese Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary>Gibt einen <see langword="ILGenerator" /> mit der standardmäßigen MSIL-Streamgröße (Microsoft Intermediate Language) von 64 Bytes für diese Methode zurück.</summary>
      <exception cref="T:System.InvalidOperationException">Die Methode sollte beispielsweise aufgrund ihrer <see cref="T:System.Reflection.MethodAttributes" />- oder <see cref="T:System.Reflection.MethodImplAttributes" />-Flags keinen Text enthalten, weil sie das <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />-Flag aufweist.  
  
- oder - 
Es handelt sich um eine generische Methode, aber nicht um eine generische Methodendefinition. Das bedeutet, die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft ist <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Gibt ein <see langword="ILGenerator" />-Objekt für diese Methode zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary>Gibt einen <see langword="ILGenerator" /> mit der angegebenen MSIL-Streamgröße (Microsoft Intermediate Language) für diese Methode zurück.</summary>
      <param name="size">Die Größe des MSIL-Streams in Bytes.</param>
      <exception cref="T:System.InvalidOperationException">Die Methode sollte beispielsweise aufgrund ihrer <see cref="T:System.Reflection.MethodAttributes" />- oder <see cref="T:System.Reflection.MethodImplAttributes" />-Flags keinen Text enthalten, weil sie das <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />-Flag aufweist.  
  
- oder - 
Es handelt sich um eine generische Methode, aber nicht um eine generische Methodendefinition. Das bedeutet, die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft ist <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Gibt ein <see langword="ILGenerator" />-Objekt für diese Methode zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary>Gibt die Implementierungsflags für die Methode zurück.</summary>
      <returns>Gibt die Implementierungsflags für die Methode zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary>Gibt die Parameter dieser Methode zurück.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Rufen Sie die Methode mithilfe von <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> ab, und rufen Sie <see langword="GetParameters" /> für das zurückgegebene <see cref="T:System.Reflection.MethodInfo" />-Objekt auf.</exception>
      <returns>Ein Array von <see langword="ParameterInfo" />-Objekten, das die Parameter der Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Ruft dynamisch und entsprechend den Einschränkungen des angegebenen Binders die Methode auf, die durch diese Instanz für das angegebene Objekt reflektiert wird. Übergibt dabei die angegebenen Parameter.</summary>
      <param name="obj">Das Objekt, für das die angegebene Methode aufgerufen werden soll. Wenn die Methode statisch ist, wird dieser Parameter ignoriert.</param>
      <param name="invokeAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von MemberInfo-Objekten über Reflektion ermöglicht. Wenn „binder“ gleich <see langword="null" />ist, wird der Standardbinder verwendet. Weitere Details finden Sie unter <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Eine Argumentliste. Diese ist ein Array von Argumenten, die hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern der aufzurufenden Methode identisch sind. Wenn keine Parameter vorhanden sind, muss dies gleich <see langword="null" /> sein.</param>
      <param name="culture">Eine Instanz von <see cref="T:System.Globalization.CultureInfo" /> für die Steuerung der Umwandlung von Typen. Ist diese gleich NULL, wird das <see cref="T:System.Globalization.CultureInfo" /> -Objekt des aktuellen Threads verwendet. (Dies ist z. B. erforderlich, um ein <see cref="T:System.String" />-Objekt, das 1000 darstellt, in einen <see cref="T:System.Double" />-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.)</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Rufen Sie die Methode mithilfe von <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> ab, und rufen Sie <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> für das zurückgegebene <see cref="T:System.Reflection.MethodInfo" />-Objekt auf.</exception>
      <returns>Gibt ein Objekt zurück, das den Rückgabewert der aufgerufenen Methode enthält.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Überprüft, ob der Typ des angegebenen benutzerdefinierten Attributs definiert ist.</summary>
      <param name="attributeType">Der benutzerdefinierte Attributtyp.</param>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den benutzerdefinierten Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Rufen Sie die Methode mithilfe von <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> ab, und rufen Sie <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> für das zurückgegebene <see cref="T:System.Reflection.MethodInfo" />-Objekt auf.</exception>
      <returns>
        <see langword="true" />, wenn der Typ des angegebenen benutzerdefinierten Attributs definiert ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary>Gibt eine aus der aktuellen generischen Methodendefinition mit den angegebenen generischen Typargumenten konstruierte generische Methode zurück.</summary>
      <param name="typeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typargumente für die generische Methode darstellen.</param>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />, das die aus der aktuellen generischen Methodendefinition mit den angegebenen generischen Typargumenten konstruierte generische Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Für die aktuelle Methode ist die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Beschreiben des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Für die aktuelle Methode ist die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>Legt die Implementierungsflags für diese Methode fest.</summary>
      <param name="attributes">Die festzulegenden Implementierungsflags.</param>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.  
  
- oder - 
Für die aktuelle Methode ist die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary>Legt die Anzahl und Typen der Parameter für eine Methode fest.</summary>
      <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Parametertypen darstellen.</param>
      <exception cref="T:System.InvalidOperationException">Die aktuelle Methode ist generisch, die Methodendefinition ist aber nicht generisch. Das bedeutet, die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft ist <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary>Legt den Rückgabetyp der Methode fest.</summary>
      <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der Methode darstellt.</param>
      <exception cref="T:System.InvalidOperationException">Die aktuelle Methode ist generisch, die Methodendefinition ist aber nicht generisch. Das bedeutet, die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft ist <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Legt die Methodensignatur fest, einschließlich des Rückgabetyps, der Parametertypen und der erforderlichen und optionalen benutzerdefinierten Modifizierer für den Rückgabetyp und die Parametertypen.</summary>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" />an.</param>
      <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <exception cref="T:System.InvalidOperationException">Die aktuelle Methode ist generisch, die Methodendefinition ist aber nicht generisch. Das bedeutet, die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft ist <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary>Gibt diese <see langword="MethodBuilder" />-Instanz als Zeichenfolge zurück.</summary>
      <returns>Gibt eine Zeichenfolge zurück, die den Namen, die Attribute, die Methodensignatur, die Ausnahmen und die lokale Signatur dieser Methode enthält, gefolgt vom aktuellen MSIL-Stream (Microsoft Intermediate Language).</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary>Ruft die Attribute für diese Methode ab.</summary>
      <returns>Schreibgeschützt. Ruft die <see langword="MethodAttributes" /> für diese Methode ab.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary>Gibt die Aufrufkonvention der Methode zurück.</summary>
      <returns>Schreibgeschützt. Die Aufrufkonvention der Methode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary>Für diesen Typ nicht unterstützt.</summary>
      <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
      <returns>Wird nicht unterstützt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary>Gibt den Typ zurück, der diese Methode deklariert.</summary>
      <returns>Schreibgeschützt. Der Typ, der diese Methode deklariert.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary>Ruft einen booleschen Wert ab, der angibt, ob die lokalen Variablen in dieser Methode mit 0 (null) initialisiert werden, oder legt diesen Wert fest. Der Standardwert dieser Eigenschaft ist <see langword="true" />.</summary>
      <exception cref="T:System.InvalidOperationException">Für die aktuelle Methode ist die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />-Eigenschaft ist <see langword="false" />. (Abrufen oder festlegen.)</exception>
      <returns>
        <see langword="true" />, wenn die lokalen Variablen in der Methode mit 0 (null) initialisiert werden sollen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary>Ruft einen Wert ab, der angibt, ob die Methode eine generische Methode ist.</summary>
      <returns>
        <see langword="true" />, wenn die Methode generisch ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary>Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Reflection.Emit.MethodBuilder" />-Objekt die Definition einer generischen Methode darstellt.</summary>
      <returns>
        <see langword="true" />, wenn das aktuelle <see cref="T:System.Reflection.Emit.MethodBuilder" />-Objekt die Definition einer generischen Methode darstellt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" /> aus.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen. Diese Eigenschaft wird in dynamischen Assemblys nicht unterstützt.</exception>
      <returns>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" /> aus.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" /> aus.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen. Diese Eigenschaft wird in dynamischen Assemblys nicht unterstützt.</exception>
      <returns>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" /> aus.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" /> aus.</summary>
      <exception cref="T:System.NotSupportedException">In allen Fällen. Diese Eigenschaft wird in dynamischen Assemblys nicht unterstützt.</exception>
      <returns>Löst in allen Fällen eine <see cref="T:System.NotSupportedException" /> aus.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary>Ruft das interne Handle für die Methode ab. Verwenden Sie dieses Handle, um auf das zugrunde liegende Metadatenhandle zuzugreifen.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird zurzeit nicht unterstützt. Rufen Sie die Methode mithilfe von <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> ab, und rufen Sie <see cref="P:System.Reflection.MethodBase.MethodHandle" /> für das zurückgegebene <see cref="T:System.Reflection.MethodInfo" />-Objekt auf.</exception>
      <returns>Schreibgeschützt. Das interne Handle für die Methode. Verwenden Sie dieses Handle, um auf das zugrunde liegende Metadatenhandle zuzugreifen.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary>Ruft das Modul ab, in dem die aktuelle Methode definiert wird.</summary>
      <returns>Das <see cref="T:System.Reflection.Module" />, in dem der durch den aktuellen <see cref="T:System.Reflection.MemberInfo" /> dargestellte Member definiert wird.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary>Ruft den Namen dieser Methode ab.</summary>
      <returns>Schreibgeschützt. Ruft eine Zeichenfolge ab, die den einfachen Namen dieser Methode enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary>Ruft die Klasse ab, die bei der Reflektion verwendet wurde, um dieses Objekt abzurufen.</summary>
      <returns>Schreibgeschützt. Der Typ, der zum Abrufen dieser Methode verwendet wird.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary>Ruft ein <see cref="T:System.Reflection.ParameterInfo" />-Objekt ab, das Informationen zum Rückgabetyp der Methode enthält, z: B. ob der Rückgabetyp benutzerdefinierte Modifizierer hat.</summary>
      <exception cref="T:System.InvalidOperationException">Der deklarierende Typ wurde nicht erstellt.</exception>
      <returns>Ein <see cref="T:System.Reflection.ParameterInfo" />-Objekt, das Informationen zum Rückgabetyp enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary>Ruft den Rückgabetyp der Methode ab, die von diesem <see cref="T:System.Reflection.Emit.MethodBuilder" /> dargestellt wird.</summary>
      <returns>Der Rückgabetyp der Methode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary>Gibt die benutzerdefinierten Attribute des Rückgabetyps der Methode zurück.</summary>
      <returns>Schreibgeschützt. Die benutzerdefinierten Attribute des Rückgabetyps der Methode.</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary>Definiert eine stellt ein Modul in einer dynamischen Assembly dar.</summary>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary>Vervollständigt die globalen Funktions- und Datendefinitionen für dieses dynamische Modul.</summary>
      <exception cref="T:System.InvalidOperationException">Diese Methode wurde bereits aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Definiert einen Enumerationstyp, der ein Werttyp mit dem einzelnen, nicht statischen Feld <paramref name="value__" /> des angegebenen Typs ist.</summary>
      <param name="name">Der vollständige Pfad des Enumerationstyps. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="visibility">Die Typattribute für die Enumeration. Die Attribute sind beliebige, durch <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> definierte Bits.</param>
      <param name="underlyingType">Der zugrunde liegende Typ für die Enumeration. Dabei muss es sich um einen integrierten ganzzahligen Typ handeln.</param>
      <exception cref="T:System.ArgumentException">Außer Sichtbarkeitsattributen werden andere Attribute bereitgestellt.  
  
- oder - 
Eine Enumeration mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
- oder - 
Die Sichtbarkeitsattribute entsprechen nicht dem Bereich der Enumeration. Beispielsweise ist <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> für <paramref name="visibility" /> angegeben, die Enumeration ist jedoch kein geschachtelter Typ.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Die definierte Enumeration.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Definiert eine globale Methode mit den Angaben für Name, Attribute, Aufrufkonvention, Rückgabetyp und Parametertypen.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Methode. <paramref name="attributes" /> muss <see cref="F:System.Reflection.MethodAttributes.Static" /> enthalten.</param>
      <param name="callingConvention">Die Aufrufkonvention für die Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch. Das heißt, <paramref name="attributes" /> enthält nicht <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- oder - 
Ein Element im <see cref="T:System.Type" />-Array ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      <returns>Die definierte globale Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Definiert eine globale Methode mit den Angaben für Name, Attribute, Aufrufkonvention, Rückgabetyp, benutzerdefinierte Modifizierer für den Rückgabetyp, Parametertypen und benutzerdefinierte Modifizierer für die Parametertypen.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten Nullzeichen enthalten.</param>
      <param name="attributes">Die Attribute der Methode. <paramref name="attributes" /> muss <see cref="F:System.Reflection.MethodAttributes.Static" /> enthalten.</param>
      <param name="callingConvention">Die Aufrufkonvention für die Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="requiredReturnTypeCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer für den Rückgabetyp darstellen, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" /> oder <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" />an.</param>
      <param name="optionalReturnTypeCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer für den Rückgabetyp darstellen, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" /> oder <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="requiredParameterTypeCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter der globalen Methode dar. Wenn ein bestimmtes Argument über keine erforderlichen benutzerdefinierten Modifizierer verfügt, geben Sie anstelle eines Arrays von Typen <see langword="null" /> an. Wenn die globale Methode über keine Argumente oder keines der Argumente über erforderliche benutzerdefinierte Modifizierer verfügt, geben Sie anstelle eines Arrays von Arrays <see langword="null" /> an.</param>
      <param name="optionalParameterTypeCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar. Wenn ein bestimmtes Argument über keine optionalen benutzerdefinierten Modifizierer verfügt, geben Sie anstelle eines Arrays von Typen <see langword="null" /> an. Wenn die globale Methode über keine Argumente oder keines der Argumente über optionale benutzerdefinierte Modifizierer verfügt, geben Sie anstelle eines Arrays von Arrays <see langword="null" /> an.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch. Das heißt, <paramref name="attributes" /> enthält nicht <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- oder - 
Ein Element im <see cref="T:System.Type" />-Array ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />-Methode wurde zuvor aufgerufen.</exception>
      <returns>Die definierte globale Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Definiert eine globale Methode mit den Angaben für Name, Attribute, Rückgabetyp und Parametertypen.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Methode. <paramref name="attributes" /> muss <see cref="F:System.Reflection.MethodAttributes.Static" /> enthalten.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch. Das heißt, <paramref name="attributes" /> enthält nicht <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- oder - 
Die Länge von <paramref name="name" /> ist 0. 
- oder - 
Ein Element im <see cref="T:System.Type" />-Array ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      <returns>Die definierte globale Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Definiert ein initialisiertes Datenfeld im .sdata-Abschnitt der übertragbaren ausführbaren Datei (Portable Executable, PE).</summary>
      <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="data">Das BLOB (Binary Large Object) der Daten.</param>
      <param name="attributes">Die Attribute für das Feld. Der Standardwert ist <see langword="Static" />.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Die Größe von <paramref name="data" /> ist kleiner oder gleich 0 bzw. größer oder gleich 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> oder <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      <returns>Ein Feld zum Verweisen auf die Daten.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Definiert eine <see langword="PInvoke" />-Methode mit den Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <see langword="PInvoke" />-Flags.</summary>
      <param name="name">Der Name der <see langword="PInvoke" />-Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
      <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch, wenn der enthaltende Typ eine Schnittstelle ist.  
  
 - oder -  
  
 Die Methode ist abstrakt.  
  
 - oder -  
  
 Die Methode wurde bereits definiert.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> oder <paramref name="dllName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde bereits mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Definiert eine <see langword="PInvoke" />-Methode mit den Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <see langword="PInvoke" />-Flags.</summary>
      <param name="name">Der Name der <see langword="PInvoke" />-Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
      <param name="entryName">Der Name des Einstiegspunkts in die DLL.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
      <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch, der enthaltende Typ ist eine Schnittstelle, die Methode ist abstrakt, oder die Methode wurde bereits definiert.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> oder <paramref name="dllName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde bereits mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary>Erstellt einen <see langword="TypeBuilder" /> für einen privaten Typ mit dem angegebenen Namen in diesem Modul.</summary>
      <param name="name">Der vollständige Pfad des Typs, einschließlich des Namespaces. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <exception cref="T:System.ArgumentException">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
 - oder -  
  
 Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Ein privater Typ mit dem angegebenen Namen.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary>Erstellt einen <see langword="TypeBuilder" /> anhand der Angaben für den Typnamen und die Typattribute.</summary>
      <param name="name">Der vollständige Pfad des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des definierten Typs.</param>
      <exception cref="T:System.ArgumentException">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
 - oder -  
  
 Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Ein <see langword="TypeBuilder" />, der mit allen angeforderten Attributen erstellt wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Erstellt einen <see langword="TypeBuilder" /> anhand der Angaben für den Typnamen, die Attribute und den vom definierten Typ erweiterten Typ.</summary>
      <param name="name">Der vollständige Pfad des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Das Attribut, das diesem Typ zugeordnet werden soll.</param>
      <param name="parent">Der vom definierten Typ erweiterte Typ.</param>
      <exception cref="T:System.ArgumentException">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
 - oder -  
  
 Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Ein <see langword="TypeBuilder" />, der mit allen angeforderten Attributen erstellt wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Erstellt einen <see langword="TypeBuilder" /> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ und die Gesamtgröße des Typs.</summary>
      <param name="name">Der vollständige Pfad des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des definierten Typs.</param>
      <param name="parent">Der vom definierten Typ erweiterte Typ.</param>
      <param name="typesize">Die Gesamtgröße des Typs.</param>
      <exception cref="T:System.ArgumentException">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
 - oder -  
  
 Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Ein <see langword="TypeBuilder" />-Objekt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Erstellt einen <see langword="TypeBuilder" /> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ und die Komprimierungsgröße des Typs.</summary>
      <param name="name">Der vollständige Pfad des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des definierten Typs.</param>
      <param name="parent">Der vom definierten Typ erweiterte Typ.</param>
      <param name="packsize">Die Komprimierungsgröße des Typs.</param>
      <exception cref="T:System.ArgumentException">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
 - oder -  
  
 Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Ein <see langword="TypeBuilder" />-Objekt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Erstellt einen <see langword="TypeBuilder" /> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ, die Komprimierungsgröße des definierten Typs und die Gesamtgröße des definierten Typs.</summary>
      <param name="name">Der vollständige Pfad des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des definierten Typs.</param>
      <param name="parent">Der vom definierten Typ erweiterte Typ.</param>
      <param name="packingSize">Die Komprimierungsgröße des Typs.</param>
      <param name="typesize">Die Gesamtgröße des Typs.</param>
      <exception cref="T:System.ArgumentException">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
 - oder -  
  
 Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Ein <see langword="TypeBuilder" />, der mit allen angeforderten Attributen erstellt wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Erstellt einen <see langword="TypeBuilder" /> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ und den vom definierten Typ implementierten Schnittstellen.</summary>
      <param name="name">Der vollständige Pfad des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute, die diesem Typ zugeordnet werden sollen.</param>
      <param name="parent">Der vom definierten Typ erweiterte Typ.</param>
      <param name="interfaces">Die Liste der vom Typ implementierten Schnittstellen.</param>
      <exception cref="T:System.ArgumentException">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.  
  
 - oder -  
  
 Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Ein <see langword="TypeBuilder" />, der mit allen angeforderten Attributen erstellt wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Definiert ein nicht initialisiertes Datenfeld im .sdata-Abschnitt der übertragbaren ausführbaren Datei (Portable Executable, PE).</summary>
      <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="size">Die Größe des Datenfelds.</param>
      <param name="attributes">Die Attribute für das Feld.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
 <paramref name="size" /> ist kleiner gleich 0 oder größer gleich 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> wurde bereits zuvor aufgerufen.</exception>
      <returns>Ein Feld zum Verweisen auf die Daten.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich dem angegebenen Objekt ist.</summary>
      <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="obj" /> dem Typ und dem Wert dieser Instanz entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Gibt die benannte Methode für eine Arrayklasse zurück.</summary>
      <param name="arrayClass">Eine Arrayklasse.</param>
      <param name="methodName">Der Name einer Methode für eine Arrayklasse.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayClass" /> ist kein Array.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayClass" /> oder <paramref name="methodName" /> ist <see langword="null" />.</exception>
      <returns>Die benannte Methode für eine Arrayklasse.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt die benutzerdefinierten Attribute zurück, die auf den aktuellen <see cref="T:System.Reflection.Emit.ModuleBuilder" /> angewendet wurden.</summary>
      <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
      <returns>Ein Array, das die benutzerdefinierten Attribute enthält. Das Array ist leer, wenn keine Attribute vorhanden sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt alle benutzerdefinierten Attribute zurück, die auf den aktuellen <see cref="T:System.Reflection.Emit.ModuleBuilder" /> angewendet wurden und die von einem angegebenen Attributtyp abgeleitet sind.</summary>
      <param name="attributeType">Der Basistyp, von dem Attribute abgeleitet werden.</param>
      <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> ist kein <see cref="T:System.Type" />-Objekt, das von der Laufzeit bereitgestellt wird. Beispielsweise ist <paramref name="attributeType" /> ein <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt.</exception>
      <returns>Ein Array, das die benutzerdefinierten Attribute enthält, die auf beliebiger Ebene von <paramref name="attributeType" /> abgeleitet sind. Das Array ist leer, wenn keine solchen Attribute vorhanden sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary>Gibt Informationen zu den Attributen zurück, die auf den aktuellen <see cref="T:System.Reflection.Emit.ModuleBuilder" />angewendet wurden. Diese sind als <see cref="T:System.Reflection.CustomAttributeData" /> -Objekte ausgedrückt.</summary>
      <returns>Eine generische Liste von <see cref="T:System.Reflection.CustomAttributeData" />-Objekten, die Daten zu den Attributen darstellen, die auf das aktuelle Modul angewendet wurden.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Gibt ein Feld auf Modulebene zurück, das im .sdata-Bereich der PE-Datei (Portable Executable) definiert ist und über den angegebenen Namen und die angegebenen Bindungsattribute verfügt.</summary>
      <param name="name">Der Feldname.</param>
      <param name="bindingAttr">Eine Kombination der <see langword="BindingFlags" />-Bitflags zum Steuern der Suche.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      <returns>Ein Feld mit dem angegebenen Namen und den angegebenen Bindungsattributen, oder <see langword="null" />, wenn das Feld nicht vorhanden ist.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Gibt alle im .sdata-Bereich der PE-Datei (Portable Executable) definierten Felder zurück, die den angegebenen Bindungsflags entsprechen.</summary>
      <param name="bindingFlags">Eine Kombination der <see langword="BindingFlags" />-Bitflags zum Steuern der Suche.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      <returns>Ein Array von Feldern, die den angegebenen Flags entsprechen. Das Array ist leer, wenn keine solchen Felder vorhanden sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Gibt alle Methoden zurück, die auf Modulebene für den aktuellen <see cref="T:System.Reflection.Emit.ModuleBuilder" /> definiert wurden und den angegebenen Bindungsflags entsprechen.</summary>
      <param name="bindingFlags">Eine Kombination von <see langword="BindingFlags" />-Bitflags zum Steuern der Suche.</param>
      <returns>Ein Array, das alle Methoden auf Modulebene enthält, die <paramref name="bindingFlags" /> entsprechen.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary>Ruft ein Paar von Werten ab, die die Merkmale des Codes in einem Modul und die Plattform angeben, die das Ziel dieses Moduls darstellt.</summary>
      <param name="peKind">Diese Methode gibt eine Kombination der <see cref="T:System.Reflection.PortableExecutableKinds" />-Werte zurück, die die Merkmale des Codes im Modul angeben.</param>
      <param name="machine">Diese Methode gibt einen der <see cref="T:System.Reflection.ImageFileMachine" />-Werte zurück, die die Plattform angeben, die das Ziel des Moduls darstellt.</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary>Ruft den im Modul definierten benannten Typ ab.</summary>
      <param name="className">Der Name des abzurufenden <see cref="T:System.Type" />.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="className" /> ist 0 (null) oder größer als 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Der angeforderte <see cref="T:System.Type" /> ist nicht öffentlich, und der Aufrufer besitzt keine <see cref="T:System.Security.Permissions.ReflectionPermission" /> zum Reflektieren nicht öffentlicher Objekte außerhalb der aktuellen Assembly.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      <exception cref="T:System.TypeLoadException">Beim Laden von <see cref="T:System.Type" /> ist ein Fehler aufgetreten.</exception>
      <returns>Der angeforderte Typ, wenn der Typ in diesem Modul definiert wurde, andernfalls <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary>Ruft den im Modul definierten benannten Typ ab, wobei optional die Groß- und Kleinschreibung des Typnamens nicht berücksichtigt wird.</summary>
      <param name="className">Der Name des abzurufenden <see cref="T:System.Type" />.</param>
      <param name="ignoreCase">Falls <see langword="true" />, wird Groß- und Kleinschreibung bei der Suche nicht berücksichtigt. Falls <see langword="false" />, wird Groß- und Kleinschreibung bei der Suche berücksichtigt.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="className" /> ist 0 (null) oder größer als 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Der angeforderte <see cref="T:System.Type" /> ist nicht öffentlich, und der Aufrufer besitzt keine <see cref="T:System.Security.Permissions.ReflectionPermission" /> zum Reflektieren nicht öffentlicher Objekte außerhalb der aktuellen Assembly.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      <returns>Der angeforderte Typ, wenn der Typ in diesem Modul definiert wurde, andernfalls <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Ruft den im Modul definierten benannten Typ ab, wobei optional die Groß- und Kleinschreibung des Typnamens nicht berücksichtigt wird. Löst optional eine Ausnahme aus, wenn der Typ nicht gefunden wird.</summary>
      <param name="className">Der Name des abzurufenden <see cref="T:System.Type" />.</param>
      <param name="throwOnError">
        <see langword="true" /> , damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" /> , damit <see langword="null" />zurückgegeben wird.</param>
      <param name="ignoreCase">Falls <see langword="true" />, wird Groß- und Kleinschreibung bei der Suche nicht berücksichtigt. Falls <see langword="false" />, wird Groß- und Kleinschreibung bei der Suche berücksichtigt.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="className" /> ist 0 (null) oder größer als 1023.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.SecurityException">Der angeforderte <see cref="T:System.Type" /> ist nicht öffentlich, und der Aufrufer besitzt keine <see cref="T:System.Security.Permissions.ReflectionPermission" /> zum Reflektieren nicht öffentlicher Objekte außerhalb der aktuellen Assembly.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
      <exception cref="T:System.TypeLoadException">
        <paramref name="throwOnError" /> ist <see langword="true" />, und der angegebene Typ wurde nicht gefunden.</exception>
      <returns>Der angegebene Typ, wenn der Typ in diesem Modul deklariert wurde, andernfalls <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary>Gibt alle in diesem Modul definierten Klassen zurück.</summary>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">Mindestens eine Klasse in einem Modul konnte nicht geladen werden.</exception>
      <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      <returns>Ein Array, das die Typen enthält, die in dem durch diese Instanz reflektierten Modul definiert sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Attributtyp auf dieses Modul angewendet wurde.</summary>
      <param name="attributeType">Der Typ des benutzerdefinierten Attributs, auf das getestet werden soll.</param>
      <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> ist kein <see cref="T:System.Type" />-Objekt, das von der Laufzeit bereitgestellt wird. Beispielsweise ist <paramref name="attributeType" /> ein <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt.</exception>
      <returns>
        <see langword="true" />, wenn eine oder mehrere Instanzen von <paramref name="attributeType" /> auf dieses Modul angewendet werden, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary>Ruft einen Wert ab, der angibt, ob das Objekt eine Ressource ist.</summary>
      <returns>
        <see langword="true" />, wenn das Objekt eine Ressource ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary>Gibt das vom angegebenen Metadatentoken angegebene Feld im von den angegebenen generischen Typparametern definierten Kontext zurück.</summary>
      <param name="metadataToken">Ein Metadatentoken, das ein Feld im Modul angibt.</param>
      <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn dieser Typ nicht generisch ist.</param>
      <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn diese Methode nicht generisch ist.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein Token für ein Feld.  
  
- oder - 
 <paramref name="metadataToken" /> gibt ein Feld an, dessen übergeordnete <see langword="TypeSpec" /> eine Signatur mit Elementtyp <see langword="var" /> (Typparameter eines generischen Typs) oder <see langword="mvar" /> (Typparameter einer generischen Methode) aufweist, und die erforderlichen Argumente des generischen Typs wurden nicht für <paramref name="genericTypeArguments" /> und/oder <paramref name="genericMethodArguments" /> angegeben.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein gültiges Token.</exception>
      <returns>Ein <see cref="T:System.Reflection.FieldInfo" />-Objekt, das das durch das angegebene Metadatentoken angegebene Feld darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary>Gibt den vom angegebenen Metadatentoken angegebenen Typ oder Member im von den angegebenen generischen Typparametern definierten Kontext zurück.</summary>
      <param name="metadataToken">Ein Metadatentoken, das einen Typ oder Member im Modul angibt.</param>
      <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn dieser Typ nicht generisch ist.</param>
      <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn diese Methode nicht generisch ist.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> ist im Gültigkeitsbereich des aktuellen Moduls kein Token für einen Typ oder Member.  
  
- oder - 
 <paramref name="metadataToken" /> ist eine <see langword="MethodSpec" /> oder eine <see langword="TypeSpec" />, deren Signatur Elementtyp <see langword="var" /> (Typparameter eines generischen Typs) oder <see langword="mvar" /> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden nicht für <paramref name="genericTypeArguments" /> und/oder <paramref name="genericMethodArguments" /> angegeben.  
  
- oder - 
 <paramref name="metadataToken" /> gibt eine Eigenschaft oder ein Ereignis an.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein gültiges Token.</exception>
      <returns>Ein <see cref="T:System.Reflection.MemberInfo" />-Objekt, das den Typ oder Member darstellt, der vom angegebenen Metadatentoken angegeben wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary>Gibt die vom angegebenen Metadatentoken angegebene Methode oder den vom angegebenen Metadatentoken angegebenen Konstruktor im von den angegebenen generischen Typparametern definierten Kontext zurück.</summary>
      <param name="metadataToken">Ein Metadatentoken, das eine Methode oder einen Konstruktor im Modul identifiziert.</param>
      <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn dieser Typ nicht generisch ist.</param>
      <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn diese Methode nicht generisch ist.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein Token für eine Methode oder einen Konstruktor.  
  
- oder - 
 <paramref name="metadataToken" /> ist eine <see langword="MethodSpec" />, deren Signatur Elementtyp <see langword="var" /> (Typparameter eines generischen Typs) oder <see langword="mvar" /> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden für <paramref name="genericTypeArguments" /> und/oder <paramref name="genericMethodArguments" /> nicht angegeben.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein gültiges Token.</exception>
      <returns>Ein <see cref="T:System.Reflection.MethodBase" />-Objekt, das die Methode darstellt, die durch das angegebene Metadatentoken angegeben wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary>Gibt das von einem Metadatentoken angegebene Signatur-BLOB zurück.</summary>
      <param name="metadataToken">Ein Metadatentoken, das eine Signatur im Modul angibt.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> ist keine gültige <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" /> oder Signatur bzw. kein gültiges <see langword="FieldDef" />-Token im Bereich des aktuellen Moduls.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein gültiges Token.</exception>
      <returns>Ein Bytearray, das den Signatur-BLOB darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary>Gibt die vom angegebenen Metadatentoken angegebene Zeichenfolge zurück.</summary>
      <param name="metadataToken">Ein Metadatentoken, das eine Zeichenfolge im Zeichenfolgenheap des Moduls angibt.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> ist im Gültigkeitsbereich des aktuellen Moduls kein Token für eine Zeichenfolge.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein gültiges Token.</exception>
      <returns>Ein <see cref="T:System.String" />, der einen Zeichenfolgenwert aus dem Metadaten-Zeichenfolgenheap enthält.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary>Gibt den vom angegebenen Metadatentoken angegebenen Typ im von den angegebenen generischen Typparametern definierten Kontext zurück.</summary>
      <param name="metadataToken">Ein Metadatentoken, das einen Typ im Modul identifiziert.</param>
      <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn dieser Typ nicht generisch ist.</param>
      <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <see langword="null" />, wenn diese Methode nicht generisch ist.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein Token für einen Typ.  
  
- oder - 
 <paramref name="metadataToken" /> ist eine <see langword="TypeSpec" />, deren Signatur Elementtyp <see langword="var" /> (Typparameter eines generischen Typs) oder <see langword="mvar" /> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden für <paramref name="genericTypeArguments" /> und/oder <paramref name="genericMethodArguments" /> nicht angegeben.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> ist im Bereich des aktuellen Moduls kein gültiges Token.</exception>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das den Typ darstellt, der durch das angegebene Metadatentoken angegeben wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Wendet ein benutzerdefiniertes Attribut auf dieses Modul an, indem ein angegebenes BLOB (Binary Large Object) verwendet wird, das das Attribut darstellt.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das das Attribut darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Wendet ein benutzerdefiniertes Attribut auf dieses Modul an, indem ein Generator für benutzerdefinierte Attribute verwendet wird.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse, die das anzuwendende benutzerdefinierte Attribut angibt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary>Ruft die dynamische Assembly ab, die diese Instanz von <see cref="T:System.Reflection.Emit.ModuleBuilder" /> definiert hat.</summary>
      <returns>Die dynamische Assembly, die das aktuelle dynamische Modul definiert hat.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary>Ruft einen <see langword="String" /> ab, der den vollqualifizierten Namen und den Pfad zu diesem Modul darstellt.</summary>
      <returns>Der vollqualifizierte Modulname.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary>Ruft die Metadatenstreamversion ab.</summary>
      <returns>Eine 32-Bit-Ganzzahl, die die Metadatenstreamversion darstellt. Die beiden höherwertigen Bytes stellen die Hauptversionsnummer dar und die beiden niederwertigen Bytes die Nebenversionsnummer.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary>Ruft ein Token ab, das das aktuelle dynamische Modul in den Metadaten angibt.</summary>
      <returns>Ein Ganzzahltoken, das das aktuelle Modul in den Metadaten angibt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary>Ruft einen universellen eindeutigen Bezeichner (Universally Unique Identifier, UUID) ab, der zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</summary>
      <returns>Eine <see cref="T:System.Guid" />, die zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary>Eine Zeichenfolge, die angibt, dass es sich um ein speicherinternes Modul handelt.</summary>
      <returns>Text, der angibt, dass es sich um ein speicherinternes Modul handelt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary>Ruft eine Zeichenfolge ab, die den Namen des dynamischen Moduls darstellt.</summary>
      <returns>Der Name des dynamischen Moduls.</returns>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary>Definiert die Eigenschaften für einen Typ.</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Fügt eine der anderen Methoden hinzu, die dieser Eigenschaft zugeordnet sind.</summary>
      <param name="mdBuilder">Ein <see langword="MethodBuilder" />-Objekt, das die andere Methode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary>Gibt ein Array der öffentlichen und nicht öffentlichen <see langword="get" />-Accessoren und <see langword="set" />-Accessoren für diese Eigenschaft zurück.</summary>
      <param name="nonPublic">Gibt an, ob im <see langword="MethodInfo" />-Array nicht öffentliche Methoden zurückgegeben werden sollen. <see langword="true" />, wenn nicht öffentliche Methoden eingeschlossen werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Ein Array vom Typ <see langword="MethodInfo" /> mit den passenden öffentlichen und nicht öffentlichen Accessoren bzw. ein leeres Array, wenn für diese Eigenschaft keine übereinstimmenden Accessoren vorhanden sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt ein Array aller benutzerdefinierten Attribute für diese Eigenschaft zurück.</summary>
      <param name="inherit">Wenn <see langword="true" />, wird die Vererbungskette dieser Eigenschaft in Aufwärtsrichtung durchlaufen und nach benutzerdefinierten Attributen durchsucht.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Ein Array aller benutzerdefinierten Attribute.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt ein Array benutzerdefinierter Attribute zurück, die durch <see cref="T:System.Type" /> bezeichnet werden.</summary>
      <param name="attributeType">Ein Array benutzerdefinierter Attribute, die durch den Typ bezeichnet werden.</param>
      <param name="inherit">Wenn <see langword="true" />, wird die Vererbungskette dieser Eigenschaft in Aufwärtsrichtung durchlaufen und nach benutzerdefinierten Attributen durchsucht.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Ein Array benutzerdefinierter Attribute, die für diesen reflektierten Member definiert sind, oder <see langword="null" />, wenn keine Attribute für diesen Member definiert sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary>Gibt den öffentlichen und nicht öffentlichen Get-Accessor für diese Eigenschaft zurück.</summary>
      <param name="nonPublic">Gibt an, ob nicht öffentliche get-Accessoren zurückgegeben werden sollen. <see langword="true" />, wenn nicht öffentliche Methoden eingeschlossen werden sollen, andernfalls <see langword="false" />.</param>
      <returns>Ein <see langword="MethodInfo" />-Objekt, das den Get-Accessor für diese Eigenschaft darstellt, wenn <paramref name="nonPublic" /><see langword="true" /> ist. Gibt <see langword="null" /> zurück, wenn <paramref name="nonPublic" /><see langword="false" /> ist und der Get-Accessor nicht öffentlich ist, oder wenn <paramref name="nonPublic" /><see langword="true" /> ist, aber kein Get-Accessor vorhanden ist.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary>Gibt ein Array aller Indexparameter für diese Eigenschaft zurück.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Ein Array vom Typ <see langword="ParameterInfo" />, das die Parameter für die Indizes enthält.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary>Gibt den festgelegten Accessor für diese Eigenschaft zurück.</summary>
      <param name="nonPublic">Gibt an, ob die Zugriffsmethode zurückgegeben werden soll, wenn sie nicht öffentlich ist. <see langword="true" />, wenn nicht öffentliche Methoden eingeschlossen werden sollen, andernfalls <see langword="false" />.</param>
      <returns>Die <see langword="Set" />-Methode der Eigenschaft, oder <see langword="null" />, wie in der folgenden Tabelle gezeigt.  
  
 <list type="table"><listheader><term> Wert</term><description> Bedingung</description></listheader><item><term> Ein <see cref="T:System.Reflection.MethodInfo" />-Objekt, das die Set-Methode für diese Eigenschaft darstellt.</term><description> Der Set-Accessor ist öffentlich.  
  
 <paramref name="nonPublic" /> ist „true“, und nicht öffentliche Methoden können zurückgegeben werden.</description></item><item><term> NULL</term><description><paramref name="nonPublic" /> ist „true“, die Eigenschaft ist jedoch schreibgeschützt.  
  
 <paramref name="nonPublic" /> ist „false“, und der Set-Accessor ist nicht öffentlich.</description></item></list></returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary>Ruft durch Aufrufen der Get-Methode der Eigenschaft den Wert der indizierten Eigenschaft ab.</summary>
      <param name="obj">Das Objekt, dessen Eigenschaftswert zurückgegeben wird.</param>
      <param name="index">Optionale Indexwerte für indizierte Eigenschaften. Dieser Wert sollte bei nicht indizierten Eigenschaften <see langword="null" /> sein.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Der Wert der angegebenen indizierten Eigenschaft.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Ruft den Wert einer Eigenschaft mit den Angaben für Bindung, Index und <see langword="CultureInfo" /> ab.</summary>
      <param name="obj">Das Objekt, dessen Eigenschaftswert zurückgegeben wird.</param>
      <param name="invokeAttr">Das Attribut für den Aufruf. Hierbei muss es sich um ein Bitflag aus <see langword="BindingFlags" /> handeln: <see langword="InvokeMethod" />, <see langword="CreateInstance" /><see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />. Es muss ein geeignetes Aufrufattribut angegeben werden. Wenn ein statischer Member aufgerufen werden soll, muss das <see langword="Static" />-Flag von <see langword="BindingFlags" /> festgelegt werden.</param>
      <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
      <param name="index">Optionale Indexwerte für indizierte Eigenschaften. Dieser Wert sollte bei nicht indizierten Eigenschaften <see langword="null" /> sein.</param>
      <param name="culture">Das <see langword="CultureInfo" />-Objekt, das die Kultur darstellt, für die die Ressource lokalisiert werden soll. Beachten Sie, dass die <see langword="CultureInfo.Parent" />-Methode in der Folge für die Suche nach einer Übereinstimmung aufgerufen wird, wenn die Ressource nicht für diese Kultur lokalisiert wurde. Wenn dieser Wert <see langword="null" /> ist, wird <see langword="CultureInfo" /> aus der <see langword="CultureInfo.CurrentUICulture" />-Eigenschaft abgerufen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Der Eigenschaftswert für <paramref name="obj" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Gibt an, ob für diese Eigenschaft eine oder mehrere Instanzen von <paramref name="attributeType" /> definiert sind.</summary>
      <param name="attributeType">Das <see langword="Type" />-Objekt, auf das die benutzerdefinierten Attribute angewendet werden.</param>
      <param name="inherit">Gibt an, ob für die Suche nach benutzerdefinierten Attributen die Vererbungskette dieser Eigenschaft in Aufwärtsrichtung durchlaufen werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>
        <see langword="true" />, wenn eine oder mehrere Instanzen von <paramref name="attributeType" /> für diese Eigenschaft definiert sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary>Legt den Standardwert dieser Eigenschaft fest.</summary>
      <param name="defaultValue">Der Standardwert dieser Eigenschaft.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
      <exception cref="T:System.ArgumentException">Die Eigenschaft weist keinen unterstützten Typ auf.  
  
- oder - 
Der Typ von <paramref name="defaultValue" /> entspricht nicht dem Typ der Eigenschaft.  
  
- oder - 
Die Eigenschaft weist den Typ <see cref="T:System.Object" /> oder einen anderen Verweistyp auf, <paramref name="defaultValue" /> ist nicht <see langword="null" />, und der Wert kann nicht dem Verweistyp zugewiesen werden.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">wenn <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> für den einschließenden Typ aufgerufen wurde.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Legt die Methode fest, die den Eigenschaftswert abruft.</summary>
      <param name="mdBuilder">Ein <see langword="MethodBuilder" />-Objekt, das die Methode zum Abrufen des Eigenschaftswerts darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>Legt die Methode zum Festlegen des Eigenschaftswerts fest.</summary>
      <param name="mdBuilder">Ein <see langword="MethodBuilder" />-Objekt, das die Methode zum Festlegen des Eigenschaftswerts darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde für den einschließenden Typ aufgerufen.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary>Legt den Wert der Eigenschaft mit optionalen Indexwerten für Indexeigenschaften fest.</summary>
      <param name="obj">Das Objekt, dessen Eigenschaftswert festgelegt wird.</param>
      <param name="value">Der neue Wert für diese Eigenschaft.</param>
      <param name="index">Optionale Indexwerte für indizierte Eigenschaften. Dieser Wert sollte bei nicht indizierten Eigenschaften <see langword="null" /> sein.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Legt den Eigenschaftswert für das angegebene Objekt auf den angegebenen Wert fest.</summary>
      <param name="obj">Das Objekt, dessen Eigenschaftswert zurückgegeben wird.</param>
      <param name="value">Der neue Wert für diese Eigenschaft.</param>
      <param name="invokeAttr">Das Attribut für den Aufruf. Hierbei muss es sich um ein Bitflag aus <see langword="BindingFlags" /> handeln: <see langword="InvokeMethod" />, <see langword="CreateInstance" /><see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />. Es muss ein geeignetes Aufrufattribut angegeben werden. Wenn ein statischer Member aufgerufen werden soll, muss das <see langword="Static" />-Flag von <see langword="BindingFlags" /> festgelegt werden.</param>
      <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
      <param name="index">Optionale Indexwerte für indizierte Eigenschaften. Dieser Wert sollte bei nicht indizierten Eigenschaften <see langword="null" /> sein.</param>
      <param name="culture">Das <see langword="CultureInfo" />-Objekt, das die Kultur darstellt, für die die Ressource lokalisiert werden soll. Beachten Sie, dass die <see langword="CultureInfo.Parent" />-Methode in der Folge für die Suche nach einer Übereinstimmung aufgerufen wird, wenn die Ressource nicht für diese Kultur lokalisiert wurde. Wenn dieser Wert <see langword="null" /> ist, wird <see langword="CultureInfo" /> aus der <see langword="CultureInfo.CurrentUICulture" />-Eigenschaft abgerufen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary>Ruft die Attribute für diese Eigenschaft ab.</summary>
      <returns>Attribute für diese Eigenschaft.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary>Ruft einen Wert ab, der angibt, ob die Eigenschaft gelesen werden kann.</summary>
      <returns>
        <see langword="true" />, wenn dieses Objekt gelesen werden kann, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary>Ruft einen Wert ab, der angibt, ob in die Eigenschaft geschrieben werden kann.</summary>
      <returns>
        <see langword="true" />, wenn in diese Eigenschaft geschrieben werden kann, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary>Ruft die Klasse ab, die diesen Member deklariert.</summary>
      <returns>Das <see langword="Type" />-Objekt für die Klasse, in der dieser Member deklariert ist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary>Ruft das Modul ab, in dem der Typ definiert wird, der die aktuelle Eigenschaft deklariert.</summary>
      <returns>Das <see cref="T:System.Reflection.Module" />, in dem der Typ definiert wird, der die aktuelle Eigenschaft deklariert.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary>Ruft den Namen dieses Members ab.</summary>
      <returns>Ein <see cref="T:System.String" /> mit dem Namen dieses Members.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary>Ruft den Typ des Felds für diese Eigenschaft ab.</summary>
      <returns>Der Typ dieser Eigenschaft.</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary>Ruft das Klassenobjekt ab, mit dem diese Instanz von <see langword="MemberInfo" /> abgerufen wurde.</summary>
      <returns>Das <see langword="Type" />-Objekt, über das dieses <see langword="MemberInfo" />-Objekt abgerufen wurde.</returns>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary>Definiert und erstellt zur Laufzeit neue Instanzen von Klassen.</summary>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary>Stellt dar, dass die Gesamtgröße für den Typ nicht angegeben ist.</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary>Fügt eine Schnittstelle hinzu, die dieser Typ implementiert.</summary>
      <param name="interfaceType">Die Schnittstelle, die dieser Typ implementiert.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="interfaceType" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary>Erstellt ein <see cref="T:System.Type" />-Objekt für die Klasse. Nachdem die Felder und Methoden für die Klasse definiert sind, wird <see langword="CreateType" /> aufgerufen, um das <see langword="Type" />-Objekt der Klasse zu laden.</summary>
      <exception cref="T:System.InvalidOperationException">Der einschließende Typ wurde nicht erstellt.  
  
 - oder -  
  
 Dieser Typ ist nicht abstrakt und enthält eine abstrakte Methode.  
  
 - oder -  
  
 Dieser Typ ist weder eine abstrakte Klasse noch eine Schnittstelle und hat eine Methode ohne Methodenkörper.</exception>
      <exception cref="T:System.ArgumentException">Ungültiger Bezeichnungsinhalt in <see cref="T:System.Reflection.Emit.ILGenerator" />: Sie haben eine Bezeichnung ohne Aufruf von <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" /> definiert.</exception>
      <exception cref="T:System.NotSupportedException">Der Typ enthält ungültigen MSIL-Code (Microsoft Intermediate Language).  
  
 - oder -  
  
 Das Verzweigungsziel ist mit einem Offset von 1 Byte angegeben, die Entfernung des Ziels von der Verzweigung ist jedoch größer als 127 Bytes.</exception>
      <exception cref="T:System.TypeLoadException">Der Typ kann nicht geladen werden. Er enthält beispielsweise eine <see langword="static" />-Methode, die die Aufrufkonvention <see cref="F:System.Reflection.CallingConventions.HasThis" /> hat.</exception>
      <returns>Gibt das neue <see cref="T:System.Type" />-Objekt für diese Klasse zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary>Ruft ein <see cref="T:System.Reflection.TypeInfo" />-Objekt ab, das diesen Typ darstellt.</summary>
      <returns>Ein Objekt, das diesen Typ darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary>Fügt dem Typ einen neuen Konstruktor mit den angegebenen Attributen und der Signatur hinzu.</summary>
      <param name="attributes">Die Attribute des Konstruktors.</param>
      <param name="callingConvention">Die Aufrufkonvention des Konstruktors.</param>
      <param name="parameterTypes">Die Parametertypen des Konstruktors.</param>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Der definierte Konstruktor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary>Fügt dem Typ einen neuen Konstruktor mit den angegebenen Attributen, der angegebenen Signatur und den angegebenen benutzerdefinierten Modifizierern hinzu.</summary>
      <param name="attributes">Die Attribute des Konstruktors.</param>
      <param name="callingConvention">Die Aufrufkonvention des Konstruktors.</param>
      <param name="parameterTypes">Die Parametertypen des Konstruktors.</param>
      <param name="requiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <param name="optionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <exception cref="T:System.ArgumentException">Die Größe von <paramref name="requiredCustomModifiers" /> oder <paramref name="optionalCustomModifiers" /> entspricht nicht die Größe von <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Der definierte Konstruktor.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary>Definiert den parameterlosen Konstruktor. Der hier definierte Konstruktor ruft einfach den parameterlosen Konstruktor des übergeordneten Elements auf.</summary>
      <param name="attributes">Ein <see langword="MethodAttributes" />-Objekt, das die auf den Konstruktor anzuwendenden Attribute darstellt.</param>
      <exception cref="T:System.NotSupportedException">Der übergeordnete Typ (Basistyp) weist keinen parameterlosen Konstruktor auf.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Gibt den Konstruktor zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary>Fügt dem Typ ein neues Ereignis hinzu, das den angegebenen Namen, die angegebenen Attribute und den angegebenen Ereignistyp hat.</summary>
      <param name="name">Der Name des Ereignisses. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute des Ereignisses.</param>
      <param name="eventtype">Der Typ des Ereignisses.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="eventtype" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Das definierte Ereignis.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>Fügt ein neues Feld mit dem angegebenen Namen, den angegebenen Attribute und dem angegebenen Feldtyp zum Typ hinzu.</summary>
      <param name="fieldName">Der Name des Felds. <paramref name="fieldName" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="type">Der Typ des Felds.</param>
      <param name="attributes">Die Attribute des Felds.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="fieldName" /> ist 0 (null).  
  
- oder - 
 <paramref name="type" /> ist „System.Void“.  
  
- oder - 
Für die übergeordnete Klasse dieses Felds wurde eine Gesamtgröße angegeben.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Das definierte Feld.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary>Fügt ein neues Feld mit dem angegebenen Namen, den Attributen, dem Feldtyp und den benutzerdefinierten Modifizierern zum Typ hinzu.</summary>
      <param name="fieldName">Der Name des Felds. <paramref name="fieldName" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="type">Der Typ des Felds.</param>
      <param name="requiredCustomModifiers">Gibt ein Array von Typen zurück, das die erforderlichen benutzerdefinierten Modifizierer für das Feld darstellt, z. B. <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="optionalCustomModifiers">Gibt ein Array von Typen zurück, das die optionalen benutzerdefinierten Modifizierer für das Feld darstellt, z. B. <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
      <param name="attributes">Die Attribute des Felds.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="fieldName" /> ist 0 (null).  
  
- oder - 
 <paramref name="type" /> ist „System.Void“.  
  
- oder - 
Für die übergeordnete Klasse dieses Felds wurde eine Gesamtgröße angegeben.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Das definierte Feld.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary>Definiert die generischen Typparameter für den aktuellen Typ, gibt dabei deren Zahl und deren Namen an und gibt ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten zurück, das dazu verwendet werden kann, deren Einschränkungen festzulegen.</summary>
      <param name="names">Ein Array von Namen für die generischen Typparameter.</param>
      <exception cref="T:System.InvalidOperationException">Es wurden bereits generische Typparameter für diesen Typ definiert.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> ist <see langword="null" />.  
  
- oder - 
Ein Element von <paramref name="names" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> ist ein leeres Array.</exception>
      <returns>Ein Array von <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />-Objekten, das dazu verwendet werden kann, die Einschränkungen der generischen Typparameter für den aktuellen Typ zu definieren.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>Definiert das initialisierte Datenfeld im ".sdata"-Abschnitt der portierbaren ausführbaren Datei (Portable Executable, PE).</summary>
      <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="data">Das Daten-BLOB.</param>
      <param name="attributes">Die Attribute für das Feld.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Die Größe der Daten ist kleiner oder gleich 0 (null) bzw. größer oder gleich 0x3f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> oder <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> wurde bereits zuvor aufgerufen.</exception>
      <returns>Ein Feld zum Verweisen auf die Daten.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen und den Methodenattributen hinzu.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die neu definierte Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen und der Aufrufkonvention hinzu.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die neu definierte Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen, der Aufrufkonvention und der Methodensignatur hinzu.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die neu definierte Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen, der Aufrufkonvention, der Methodensignatur und den benutzerdefinierten Modifizierern hinzu.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" />an.</param>
      <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).  
  
- oder - 
Die Größe von <paramref name="parameterTypeRequiredCustomModifiers" /> oder <paramref name="parameterTypeOptionalCustomModifiers" /> entspricht nicht die Größe von <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />-Objekt, das die neu hinzugefügte Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen und der Methodensignatur hinzu.</summary>
      <param name="name">Der Name der Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<see langword="Overridable" /> in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Die definierte Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>Gibt einen bestimmten Methodentext an, der eine bestimmte Methodendeklaration, möglicherweise mit einem anderen Namen, implementiert.</summary>
      <param name="methodInfoBody">Der zu verwendende Methodentext. Dies sollte ein <see langword="MethodBuilder" /> -Objekt sein.</param>
      <param name="methodInfoDeclaration">Die Methode, deren Deklaration verwendet werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodInfoBody" /> gehört nicht zu dieser Klasse.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="methodInfoBody" /> oder <paramref name="methodInfoDeclaration" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Der deklarierende Typ des <paramref name="methodInfoBody" /> ist nicht der von diesem <see cref="T:System.Reflection.Emit.TypeBuilder" /> dargestellte Typ.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary>Definiert einen geschachtelten Typ anhand des Namens.</summary>
      <param name="name">Der Kurzname des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
- oder - 
Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Der definierte geschachtelte Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary>Definiert einen geschachtelten Typ, wozu dessen Name und Attribute angegeben sind.</summary>
      <param name="name">Der Kurzname des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des Typs.</param>
      <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
- oder - 
Dieser Typ ist versiegelt.  
  
- oder - 
Dieser Typ ist ein Array.  
  
- oder - 
Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
- oder - 
Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
- oder - 
Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Der definierte geschachtelte Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen und erweitertem Typ.</summary>
      <param name="name">Der Kurzname des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des Typs.</param>
      <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
      <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
- oder - 
Dieser Typ ist versiegelt.  
  
- oder - 
Dieser Typ ist ein Array.  
  
- oder - 
Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
- oder - 
Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
- oder - 
Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Der definierte geschachtelte Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, Gesamtgröße des Typs und erweitertem Typ.</summary>
      <param name="name">Der Kurzname des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des Typs.</param>
      <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
      <param name="typeSize">Die Gesamtgröße des Typs.</param>
      <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
- oder - 
Dieser Typ ist versiegelt.  
  
- oder - 
Dieser Typ ist ein Array.  
  
- oder - 
Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
- oder - 
Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
- oder - 
Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Der definierte geschachtelte Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, erweitertem Typ und Komprimierungsgröße.</summary>
      <param name="name">Der Kurzname des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des Typs.</param>
      <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
      <param name="packSize">Die Komprimierungsgröße des Typs.</param>
      <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
- oder - 
Dieser Typ ist versiegelt.  
  
- oder - 
Dieser Typ ist ein Array.  
  
- oder - 
Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
- oder - 
Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
- oder - 
Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <returns>Der definierte geschachtelte Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, Größe und erweitertem Typ.</summary>
      <param name="name">Der Kurzname des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des Typs.</param>
      <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
      <param name="packSize">Die Komprimierungsgröße des Typs.</param>
      <param name="typeSize">Die Gesamtgröße des Typs.</param>
      <returns>Der definierte geschachtelte Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>Definiert einen geschachtelten Typ mit seinem Namen, den Attributen, dem erweiterten Typ und den implementierten Schnittstellen.</summary>
      <param name="name">Der Kurzname des Typs. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attr">Die Attribute des Typs.</param>
      <param name="parent">Der Typ, den der geschachtelte Typ erweitert.</param>
      <param name="interfaces">Die vom geschachtelte Typ implementierten Schnittstellen.</param>
      <exception cref="T:System.ArgumentException">Das geschachtelte Attribut ist nicht angegeben.  
  
- oder - 
Dieser Typ ist versiegelt.  
  
- oder - 
Dieser Typ ist ein Array.  
  
- oder - 
Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.  
  
- oder - 
Die Länge von <paramref name="name" /> ist 0 (null) oder größer als 1023.  
  
- oder - 
Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in der aktuellen Assembly erstellen.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
Ein Element des <paramref name="interfaces" />-Arrays ist <see langword="null" />.</exception>
      <returns>Der definierte geschachtelte Typ.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Definiert eine <see langword="PInvoke" />-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <see langword="PInvoke" />-Flags.</summary>
      <param name="name">Der Name der <see langword="PInvoke" />-Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
      <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch.  
  
- oder - 
Der übergeordnete Typ ist eine Schnittstelle.  
  
- oder - 
Die Methode ist abstrakt.  
  
- oder - 
Die Methode wurde bereits definiert.  
  
- oder - 
Die Länge von <paramref name="name" /> oder <paramref name="dllName" /> ist 0 (null).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> oder <paramref name="dllName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Definiert eine <see langword="PInvoke" />-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für den Namen des Einstiegspunkts, die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <see langword="PInvoke" />-Flags.</summary>
      <param name="name">Der Name der <see langword="PInvoke" />-Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
      <param name="entryName">Der Name des Einstiegspunkts in die DLL.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
      <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch.  
  
- oder - 
Der übergeordnete Typ ist eine Schnittstelle.  
  
- oder - 
Die Methode ist abstrakt.  
  
- oder - 
Die Methode wurde bereits definiert.  
  
- oder - 
Die Länge von <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist 0 (null).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <returns>Die definierte <see langword="PInvoke" />-Methode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>Definiert eine <see langword="PInvoke" />-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, den Namen des Einstiegspunkts, die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode, die <see langword="PInvoke" />-Flags, die benutzerdefinierten Modifizierer für die Parameter und den Rückgabetyp.</summary>
      <param name="name">Der Name der <see langword="PInvoke" />-Methode. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="dllName">Der Name der DLL, in der die <see langword="PInvoke" />-Methode definiert ist.</param>
      <param name="entryName">Der Name des Einstiegspunkts in die DLL.</param>
      <param name="attributes">Die Attribute der Methode.</param>
      <param name="callingConvention">Die Aufrufkonvention der Methode.</param>
      <param name="returnType">Der Rückgabetyp der Methode.</param>
      <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" />an.</param>
      <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Methode darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
      <param name="parameterTypes">Die Typen der Parameter der Methode.</param>
      <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <param name="nativeCallConv">Die systemeigene Aufrufkonvention.</param>
      <param name="nativeCharSet">Der systemeigene Zeichensatz der Methode.</param>
      <exception cref="T:System.ArgumentException">Die Methode ist nicht statisch.  
  
- oder - 
Der übergeordnete Typ ist eine Schnittstelle.  
  
- oder - 
Die Methode ist abstrakt.  
  
- oder - 
Die Methode wurde bereits definiert.  
  
- oder - 
Die Länge von <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist 0 (null).  
  
- oder - 
Die Größe von <paramref name="parameterTypeRequiredCustomModifiers" /> oder <paramref name="parameterTypeOptionalCustomModifiers" /> entspricht nicht die Größe von <paramref name="parameterTypes" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />, <paramref name="dllName" /> oder <paramref name="entryName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.Emit.MethodBuilder" />, der die definierte <see langword="PInvoke" />-Methode darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>Fügt dem Typ eine neue Eigenschaft mit den Angaben für den Namen, die Aufrufkonvention und die Signatur der Eigenschaften hinzu.</summary>
      <param name="name">Den Namen der Eigenschaft. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Eigenschaft.</param>
      <param name="callingConvention">Die Aufrufkonvention der Eigenschaftenzugriffsmethoden.</param>
      <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
      <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
Ein Element des <paramref name="parameterTypes" />-Arrays ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Die definierte Eigenschaft.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Fügt dem Typ eine neue Eigenschaft hinzu, die den angegebenen Namen, die angegebene Aufrufkonvention, die angegebene Eigenschaftensignatur und die angegebenen benutzerdefinierten Modifizierer hat.</summary>
      <param name="name">Den Namen der Eigenschaft. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Eigenschaft.</param>
      <param name="callingConvention">Die Aufrufkonvention der Eigenschaftenzugriffsmethoden.</param>
      <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
      <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" />an.</param>
      <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
      <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
      <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
Ein Element des <paramref name="parameterTypes" />-Arrays ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Die definierte Eigenschaft.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary>Fügt dem Typ eine neue Eigenschaft mit dem angegebenen Namen und der angegebenen Eigenschaftensignatur hinzu.</summary>
      <param name="name">Den Namen der Eigenschaft. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Eigenschaft.</param>
      <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
      <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
Ein Element des <paramref name="parameterTypes" />-Arrays ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Die definierte Eigenschaft.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>Fügt dem Typ eine neue Eigenschaft hinzu, die den angegebenen Namen, die angegebene Eigenschaftensignatur und die angegebenen benutzerdefinierten Modifizierer hat.</summary>
      <param name="name">Den Namen der Eigenschaft. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="attributes">Die Attribute der Eigenschaft.</param>
      <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
      <param name="returnTypeRequiredCustomModifiers">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" />an.</param>
      <param name="returnTypeOptionalCustomModifiers">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <see cref="T:System.Runtime.CompilerServices.IsConst" />, für den Rückgabetyp der Eigenschaft darstellen. Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> an.</param>
      <param name="parameterTypes">Die Typen der Parameter der Eigenschaft.</param>
      <param name="parameterTypeRequiredCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <param name="parameterTypeOptionalCustomModifiers">Ein Array mit Arrays von Typen. Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <see cref="T:System.Runtime.CompilerServices.IsConst" />. Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays von Typen an. Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <see langword="null" /> anstelle eines Arrays mit Arrays an.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist gleich <see langword="null" />.  
  
- oder - 
Irgendeines der Elemente des <paramref name="parameterTypes" />-Arrays ist gleich <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Die definierte Eigenschaft.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary>Definiert den Initialisierer für diesen Typ.</summary>
      <exception cref="T:System.InvalidOperationException">Der enthaltende Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> erstellt.</exception>
      <returns>Gibt einen Typinitialisierer zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>Definiert das initialisierte Datenfeld im <see langword=".sdata" />-Abschnitt der portierbaren ausführbaren Datei (Portable Executable, PE).</summary>
      <param name="name">Der Name, der zum Verweisen auf die Daten verwendet wird. <paramref name="name" /> darf keine eingebetteten NULL-Werte enthalten.</param>
      <param name="size">Die Größe des Datenfelds.</param>
      <param name="attributes">Die Attribute für das Feld.</param>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="name" /> ist 0 (null).  
  
- oder - 
 <paramref name="size" /> ist kleiner gleich 0 oder größer gleich 0x003f0000.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.</exception>
      <returns>Ein Feld zum Verweisen auf die Daten.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary>Gibt den Konstruktor des angegebenen konstruierten generischen Typs zurück, der dem angegebenen Konstruktor der generischen Typdefinition entspricht.</summary>
      <param name="type">Der konstruierte generische Typ, dessen Konstruktor zurückgegeben wird.</param>
      <param name="constructor">Ein Konstruktor für die generische Typdefinition von <paramref name="type" />, die angibt, welcher Konstruktor von <paramref name="type" /> zurückgegeben werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> stellt keinen generischen Typ dar.  
  
- oder - 
 <paramref name="type" /> ist nicht vom Typ <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- oder - 
Der deklarierende Typ von <paramref name="constructor" /> ist keine generische Typdefinition.  
  
- oder - 
Der deklarierende Typ von <paramref name="constructor" /> ist nicht die generische Typdefinition von <paramref name="type" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor von <paramref name="type" /> entsprechend <paramref name="constructor" /> darstellt und einen Konstruktor angibt, der zur generischen Typdefinition von <paramref name="type" /> gehört.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten zurück, die die für diese Klasse angegebenen definierten öffentlichen und nicht öffentlichen Konstruktoren darstellen.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw. sein.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten zurück, die die angegebenen Konstruktoren darstellen, die für diese Klasse definiert sind. Wenn keine Konstruktoren definiert sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary>Gibt alle für diesen Typ definierten benutzerdefinierten Attribute zurück.</summary>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt. Rufen Sie den Typ mithilfe von <see cref="M:System.Type.GetType" /> ab, und rufen Sie <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> für den zurückgegebenen <see cref="T:System.Type" />auf.</exception>
      <returns>Gibt ein Objektarray zurück, das alle benutzerdefinierten Attribute dieses Typs darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Gibt alle benutzerdefinierten Attribute des aktuellen Typs zurück, die einem angegebenen Typ zugewiesen werden können.</summary>
      <param name="attributeType">Der Typ des zu suchenden Attributs. Nur Attribute, die diesem Typ zugeordnet werden können, werden zurückgegeben.</param>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt. Rufen Sie den Typ mithilfe von <see cref="M:System.Type.GetType" /> ab, und rufen Sie <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> für den zurückgegebenen <see cref="T:System.Type" />auf.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Der Typ muss ein vom zugrunde liegenden Laufzeitsystem bereitgestellter Typ sein.</exception>
      <returns>Ein Array benutzerdefinierter Attribute, die für den aktuellen Typ definiert sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary>Beim Aufrufen dieser Methode wird immer eine <see cref="T:System.NotSupportedException" /> ausgelöst.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
      <returns>Diese Methode wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>Gibt das Ereignis mit dem angegebenen Namen zurück.</summary>
      <param name="name">Der Name des Ereignisses, nach dem gesucht werden soll.</param>
      <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten, die die Suche einschränkt.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Ein <see cref="T:System.Reflection.EventInfo" />-Objekt, das das Ereignis darstellt, das von diesem Typ mit dem angegebenen Namen deklariert oder geerbt wurde, oder <see langword="null" />, wenn keine Übereinstimmungen vorhanden sind.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary>Gibt die öffentlichen Ereignisse zurück, die von diesem Typ deklariert oder geerbt wurden.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" /> -Objekten zurück, die die öffentlichen Ereignisse darstellen, die von diesem Typ deklariert oder geerbt wurden. Wenn keine öffentlichen Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>Gibt die öffentlichen und nicht öffentlichen Ereignisse zurück, die von diesem Typ deklariert werden.</summary>
      <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten, die die Suche einschränkt.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die die von diesem Typ deklarierten oder geerbten Ereignisse darstellen, die mit den angegebenen Bindungsflags übereinstimmen. Wenn keine übereinstimmenden Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Gibt das vom angegebenen Namen angegebene Feld zurück.</summary>
      <param name="name">Der Name des abzurufenden Felds.</param>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw. sein.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt das <see cref="T:System.Reflection.FieldInfo" />-Objekt zurück, das das Feld darstellt, das von diesem Typ mit dem angegebenen Namen und dem öffentlichen oder nicht öffentlichen Modifizierer deklariert oder geerbt wurde. Wenn keine Übereinstimmungen vorhanden sind, wird <see langword="null" /> zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary>Gibt das Feld des angegebenen konstruierten generischen Typs zurück, der dem angegebenen Feld der generischen Typdefinition entspricht.</summary>
      <param name="type">Der konstruierte generische Typ, dessen Feld zurückgegeben wird.</param>
      <param name="field">Ein Feld zur generischen Typdefinition von <paramref name="type" />, das angibt, welches Feld von <paramref name="type" /> zurückgegeben werden muss.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> stellt keinen generischen Typ dar.  
  
- oder - 
 <paramref name="type" /> ist nicht vom Typ <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- oder - 
Der deklarierende Typ von <paramref name="field" /> ist keine generische Typdefinition.  
  
- oder - 
Der deklarierende Typ von <paramref name="field" /> ist nicht die generische Typdefinition von <paramref name="type" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.FieldInfo" />-Objekt, das das Feld von <paramref name="type" /> darstellt, das <paramref name="field" /> entspricht, welches ein Feld angibt, das zur generischen Typdefinition von <paramref name="type" /> gehört.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>Gibt die öffentlichen und nicht öffentlichen Felder zurück, die von diesem Typ deklariert werden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Felder darstellen, die von diesem Typ deklariert oder geerbt werden. Wenn keine Felder vorhanden sind, wird ein leeres Array zurückgegeben, wie angegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Typargumente eines generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</summary>
      <returns>Ein Array von <see cref="T:System.Type" />-Objekten. Die Elemente des Arrays stellen die Typargumente eines generischen Typs oder die Typparameter einer generischen Typdefinition dar.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle Typ abgerufen werden kann.</summary>
      <exception cref="T:System.InvalidOperationException">Der aktuelle Typ ist nicht generisch. Das heißt, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> gibt <see langword="false" /> zurück.</exception>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das eine generische Typdefinition darstellt, aus der der aktuelle Typ abgerufen werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary>Gibt die von dieser Klasse (direkt oder indirekt) implementierte Schnittstelle mit dem vollqualifizierten Namen zurück, der dem angegebenen Namen der Schnittstelle entspricht.</summary>
      <param name="name">Der Name der Schnittstelle.</param>
      <param name="ignoreCase">Falls <see langword="true" />, wird Groß- und Kleinschreibung bei der Suche nicht berücksichtigt. Falls <see langword="false" />, wird Groß- und Kleinschreibung bei der Suche berücksichtigt.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das die implementierte Schnittstelle darstellt. Gibt NULL zurück, wenn kein mit der Schnittstelle übereinstimmender Name gefunden wird.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary>Gibt eine Schnittstellenzuordnung für die angeforderte Schnittstelle zurück.</summary>
      <param name="interfaceType">Der <see cref="T:System.Type" /> der Schnittstelle, für die die Zuordnung abgerufen werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt die angeforderte Schnittstellenzuordnung zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary>Gibt ein Array aller für diesen Typ und die zugehörigen Basistypen implementierten Schnittstellen zurück.</summary>
      <returns>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die implementierten Schnittstellen darstellen. Wenn keine definiert sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>Gibt alle öffentlichen und nicht öffentlichen Member zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="name">Der Name des Members.</param>
      <param name="type">Der Typ des zurückzugebenden Members.</param>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw. sein.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Member darstellen, die für diesen Typ definiert wurden, wenn <paramref name="nonPublic" /> verwendet wird. Andernfalls werden nur die öffentlichen Member zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>Gibt alle Member für die öffentlichen und nicht öffentlichen Member zurück, die von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein, z. B. <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Member darstellen, die von diesem Typ deklariert oder geerbt werden. Wenn keine übereinstimmenden Member vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>Gibt die Methode des angegebenen konstruierten generischen Typs zurück, der der angegebenen Methode der generischen Typdefinition entspricht.</summary>
      <param name="type">Der konstruierte generische Typ, dessen Methode zurückgegeben wird.</param>
      <param name="method">Eine Methode für die generische Typdefinition von <paramref name="type" />, die angibt, welche Methode von <paramref name="type" /> zurückgegeben werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist eine generische Methode, aber keine generische Methodendefinition.  
  
- oder - 
 <paramref name="type" /> stellt keinen generischen Typ dar.  
  
- oder - 
 <paramref name="type" /> ist nicht vom Typ <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- oder - 
Der deklarierende Typ von <paramref name="method" /> ist keine generische Typdefinition.  
  
- oder - 
Der deklarierende Typ von <paramref name="method" /> ist nicht die generische Typdefinition von <paramref name="type" />.</exception>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />-Objekt, das die Methode von <paramref name="type" /> entsprechend <paramref name="method" /> darstellt und eine Methode angibt, die zur generischen Typdefinition von <paramref name="type" /> gehört.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>Gibt alle öffentlichen und nicht öffentlichen Methoden zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw. sein.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Methoden darstellen, die für diesen Typ definiert wurden, wenn <paramref name="nonPublic" /> verwendet wird. Andernfalls werden nur die öffentlichen Methoden zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>Gibt die öffentlichen und nicht öffentlichen geschachtelten Typen zurück, die von diesem Typ deklariert werden.</summary>
      <param name="name">Das <see cref="T:System.String" />, das den Namen des abzurufenden geschachtelten Typs enthält.</param>
      <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder - 
Null, um eine Suche nach öffentlichen Methoden mit Beachtung der Groß-/Kleinschreibung durchzuführen.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>Gibt die öffentlichen und nicht öffentlichen geschachtelten Typen zurück, die von diesem Typ deklariert oder geerbt werden.</summary>
      <param name="bindingAttr">Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> wie in <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw. sein.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die sämtliche im aktuellen <see cref="T:System.Type" /> geschachtelten Typen darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
Ein leeres Array vom Typ <see cref="T:System.Type" />, wenn im aktuellen <see cref="T:System.Type" /> keine Typen geschachtelt sind oder keiner der geschachtelten Typen den Bindungseinschränkungen entspricht.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>Gibt alle öffentlichen und nicht öffentlichen Eigenschaften zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</summary>
      <param name="bindingAttr">Dieses Aufrufattribut. Dies muss ein Bitflag aus <see cref="T:System.Reflection.BindingFlags" /> sein: <see langword="InvokeMethod" />, <see langword="NonPublic" /> usw.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode ist für unvollständige Typen nicht implementiert.</exception>
      <returns>Gibt ein Array von <see langword="PropertyInfo" />-Objekten zurück, die die öffentlichen und nicht öffentlichen Eigenschaften darstellen, die für diesen Typ definiert wurden, wenn <paramref name="nonPublic" /> verwendet wird. Andernfalls werden nur die öffentlichen Eigenschaften zurückgegeben.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>Ruft den angegebenen Member auf. Die Methode, die aufgerufen werden soll, muss zugänglich sein und mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und der Aufrufattribute die spezifischste Übereinstimmung bereitstellen.</summary>
      <param name="name">Der Name des aufzurufenden Members. Dies kann ein Konstruktor, eine Methode, eine Eigenschaft oder ein Feld sein. Es muss ein geeignetes Aufrufattribut angegeben werden. Beachten Sie, dass es möglich ist, den Standardmember einer Klasse aufzurufen, indem Sie eine leere Zeichenfolge als Name des Members übergeben.</param>
      <param name="invokeAttr">Das Attribut für den Aufruf. Dies muss ein Bitflag aus <see langword="BindingFlags" /> sein.</param>
      <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn „binder“ gleich <see langword="null" />ist, wird der Standardbinder verwendet. Siehe <see cref="T:System.Reflection.Binder" />.</param>
      <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll. Wenn der Member statisch ist, wird dieser Parameter ignoriert.</param>
      <param name="args">Eine Argumentliste. Dies ist ein Array von Objekten, das die Anzahl, Reihenfolge und den Typ der Parameter des aufzurufenden Members enthält. Wenn keine Parameter vorhanden sind, muss dies gleich NULL sein.</param>
      <param name="modifiers">Ein Array derselben Länge wie <paramref name="args" /> mit Elementen, die die Argumente darstellen, die den Argumenten des aufzurufenden Members zugeordnet sind. Ein Parameter verfügt über Attribute, die ihm in den Metadaten zugeordnet werden. Sie werden von verschiedenen Interoperabilitätsdiensten verwendet. Weitere Informationen finden Sie in den Metadatenspezifikationen.</param>
      <param name="culture">Eine Instanz von <see langword="CultureInfo" /> für die Steuerung der Umwandlung von Typen. Ist diese gleich NULL, wird das <see langword="CultureInfo" /> -Objekt des aktuellen Threads verwendet. (Dies ist z. B. erforderlich, um eine Zeichenfolge, die 1000 darstellt, in einen Double-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.)</param>
      <param name="namedParameters">Jeder Parameter im <paramref name="namedParameters" />-Array ruft den Wert im entsprechenden Element im <paramref name="args" />-Array ab. Wenn die Länge von <paramref name="args" /> größer als die Länge von <paramref name="namedParameters" /> ist, werden die restlichen Argumentwerte in der Reihenfolge übergeben.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt.</exception>
      <returns>Gibt den Rückgabewert des aufgerufenen Members zurück.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary>Ruft einen Wert ab, der angibt, ob ein angegebenes <see cref="T:System.Type" /> diesem Objekt zugeordnet werden kann.</summary>
      <param name="c">Das zu überprüfende Objekt.</param>
      <returns>
        <see langword="true" />, wenn der <paramref name="c" />-Parameter und der aktuelle Typ denselben Typ darstellen, oder wenn sich der aktuelle Typ in der Vererbungshierarchie von <paramref name="c" /> befindet, oder wenn der aktuelle Typ eine Schnittstelle ist, die von <paramref name="c" /> unterstützt wird. <see langword="false" />, wenn keine dieser Bedingungen gültig sind oder wenn <paramref name="c" /><see langword="null" /> ist.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary>Gibt einen Wert zurück, der angibt, ob der aktuelle dynamische Typ erstellt wurde.</summary>
      <returns>
        <see langword="true" />, wenn die <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode aufgerufen wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>Bestimmt, ob ein benutzerdefiniertes Attribut auf den aktuellen Typ angewendet wird.</summary>
      <param name="attributeType">Der Typ des zu suchenden Attributs. Nur Attribute, die diesem Typ zugeordnet werden können, werden zurückgegeben.</param>
      <param name="inherit">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</param>
      <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt. Rufen Sie den Typ mithilfe von <see cref="M:System.Type.GetType" /> ab, und rufen Sie <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> für den zurückgegebenen <see cref="T:System.Type" />auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> ist nicht definiert.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> ist <see langword="null" />.</exception>
      <returns>
        <see langword="true" />, wenn mindestens eine Instanz von <paramref name="attributeType" /> oder ein von <paramref name="attributeType" /> abgeleitetes Attribut für diesen Typ definiert ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary>Bestimmt, ob dieser Typ von einem angegebenen Typ abgeleitet ist.</summary>
      <param name="c">Ein zu prüfender <see cref="T:System.Type" />.</param>
      <returns>Schreibgeschützt. Gibt <see langword="true" /> zurück, wenn dieser Typ dem Typ <paramref name="c" /> entspricht oder ein Untertyp von Typ <paramref name="c" /> ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das einen eindimensionalen Arraytyp, dessen Elementtyp dem aktuellen Typ entspricht, mit einer unteren Grenze von 0 (null) darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</summary>
      <param name="rank">Die Anzahl von Dimensionen für das Array.</param>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> ist keine gültige Arraydimension.</exception>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array des aktuellen Typs darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" /> in Visual Basic) den aktuellen Typ darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" /> in Visual Basic) den aktuellen Typ darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary>Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt den resultierenden konstruierten Typ zurück.</summary>
      <param name="typeArguments">Ein Array von Typen, die die Typparameter der aktuellen generischen Typdefinition ersetzen sollen.</param>
      <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keine Definition eines generischen Typs dar. Das heißt, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> gibt <see langword="false" /> zurück.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArguments" /> ist <see langword="null" />.  
  
- oder - 
Eines der Elemente von <paramref name="typeArguments" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Type.Module" />-Eigenschaft eines beliebigen Elements von <paramref name="typeArguments" /> ist <see langword="null" />.  
  
- oder - 
Die <see cref="P:System.Reflection.Module.Assembly" />-Eigenschaft des Moduls eines beliebigen Elements von <paramref name="typeArguments" /> ist <see langword="null" />.</exception>
      <returns>Ein <see cref="T:System.Type" />, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <paramref name="typeArguments" /> erstellt wurde.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das den Typ eines nicht verwalteten Zeigers auf den aktuellen Typ darstellt.</summary>
      <returns>Ein <see cref="T:System.Type" />-Objekt, das den Typ eines nicht verwalteten Zeigers auf den aktuellen Typ darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</summary>
      <param name="con">Der Konstruktor für das benutzerdefinierte Attribut.</param>
      <param name="binaryAttribute">Ein Byte-BLOB, das die Attribute darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> oder <paramref name="binaryAttribute" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</summary>
      <param name="customBuilder">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary>Legt den Basistyp des Typs fest, der sich derzeit in Bearbeitung befindet.</summary>
      <param name="parent">Der neue Basistyp.</param>
      <exception cref="T:System.InvalidOperationException">Der Typ wurde zuvor mit <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />erstellt.  
  
- oder - 
 <paramref name="parent" /> ist <see langword="null" />, und die aktuelle Instanz stellt eine Schnittstelle dar, deren Attribute <see cref="F:System.Reflection.TypeAttributes.Abstract" /> nicht einbeziehen.  
  
- oder - 
Für den aktuellen dynamischen Typ ist die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />-Eigenschaft <see langword="true" />, aber die <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />-Eigenschaft ist <see langword="false" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> ist eine Schnittstelle. Diese Ausnahmebedingung ist neu in .NET Framework, Version 2.0.</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary>Gibt den Namen des Typs ohne den Namespace zurück.</summary>
      <returns>Schreibgeschützt. Der Name des Typs ohne den Namespace.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary>Ruft die dynamische Assembly ab, die diese Typdefinition enthält.</summary>
      <returns>Schreibgeschützt. Ruft die dynamische Assembly ab, die diese Typdefinition enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary>Gibt den vollständigen Name des Typs zurück, der durch den Anzeigenamen der Assembly gekennzeichnet ist.</summary>
      <returns>Schreibgeschützt. Der vollständige Name des Typs, der durch den Anzeigenamen der Assembly gekennzeichnet ist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary>Ruft den Basistyp dieses Typs ab.</summary>
      <returns>Schreibgeschützt. Ruft den Basistyp dieses Typs ab.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary>Ruft die Methode ab, die den aktuellen generischen Typparameter deklariert hat.</summary>
      <returns>Eine <see cref="T:System.Reflection.MethodBase" /> zur Darstellung der Methode, die den aktuellen Typ deklariert hat, wenn der aktuelle Typ ein generischer Typparameter ist, andernfalls <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary>Gibt den Typ zurück, der diesen Typ deklariert hat.</summary>
      <returns>Schreibgeschützt. Der Typ, der diesen Typ deklariert hat.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary>Ruft den vollständigen Pfad dieses Typs ab.</summary>
      <returns>Schreibgeschützt. Ruft den vollständigen Pfad dieses Typs ab.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary>Ruft einen Wert ab, der die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters angibt.</summary>
      <returns>Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary>Ruft die Position eines Typparameters in der Typparameterliste des generischen Typs ab, der den Parameter deklariert hat.</summary>
      <returns>Die Position des Typparameters in der Typparameterliste des generischen Typs, der den Parameter deklariert hat, wenn das aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt einen generischen Typparameter darstellt, andernfalls nicht definiert.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary>Ruft die GUID dieses Typs ab.</summary>
      <exception cref="T:System.NotSupportedException">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt.</exception>
      <returns>Schreibgeschützt. Ruft die GUID dieses Typs ab.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</summary>
      <returns>
        <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typparameter ist.</summary>
      <returns>
        <see langword="true" />, wenn das aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt einen generischen Typparameter darstellt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</summary>
      <returns>
        <see langword="true" />, wenn der durch das aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt dargestellte Typ generisch ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Reflection.Emit.TypeBuilder" /> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</summary>
      <returns>
        <see langword="true" />, wenn dieses <see cref="T:System.Reflection.Emit.TypeBuilder" />-Objekt eine generische Typdefinition darstellt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</summary>
      <exception cref="T:System.NotSupportedException">Der aktuelle dynamische Typ wurde nicht durch Aufrufen der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode erstellt.</exception>
      <returns>
        <see langword="true" />, wenn der aktuelle Typ sicherheitsrelevant ist. <see langword="false" />, wenn er sicherheitstransparent ist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ sicherheitsgeschützt ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</summary>
      <exception cref="T:System.NotSupportedException">Der aktuelle dynamische Typ wurde nicht durch Aufrufen der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode erstellt.</exception>
      <returns>
        <see langword="true" />, wenn der aktuelle Typ sicherheitsgeschützt ist. <see langword="false" />, wenn er sicherheitsgeschützt oder transparent ist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ transparent ist und daher keine wichtigen Vorgänge ausführen kann.</summary>
      <exception cref="T:System.NotSupportedException">Der aktuelle dynamische Typ wurde nicht durch Aufrufen der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode erstellt.</exception>
      <returns>
        <see langword="true" />, wenn der Typ sicherheitstransparent ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary>Ruft das dynamische Modul ab, das diese Typdefinition enthält.</summary>
      <returns>Schreibgeschützt. Ruft das dynamische Modul ab, das diese Typdefinition enthält.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary>Ruft den Namen dieses Typs ab.</summary>
      <returns>Schreibgeschützt. Ruft den <see cref="T:System.String" />-Namen dieses Typs ab.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary>Ruft den Namespace ab, in dem dieser <see langword="TypeBuilder" /> definiert ist.</summary>
      <returns>Schreibgeschützt. Ruft den Namespace ab, in dem dieser <see langword="TypeBuilder" /> definiert ist.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary>Ruft die Komprimierungsgröße dieses Typs ab.</summary>
      <returns>Schreibgeschützt. Ruft die Komprimierungsgröße dieses Typs ab.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary>Gibt den Typ zurück, mit dem dieser Typ abgerufen wurde.</summary>
      <returns>Schreibgeschützt. Der Typ, mit dem dieser Typ abgerufen wurde.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary>Ruft die Gesamtgröße eines Typs ab.</summary>
      <returns>Schreibgeschützt. Ruft die Gesamtgröße dieses Typs ab.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary>Wird in dynamischen Modulen nicht unterstützt.</summary>
      <exception cref="T:System.NotSupportedException">Wird in dynamischen Modulen nicht unterstützt.</exception>
      <returns>Schreibgeschützt.</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary>Gibt den zugrunde liegenden Systemtyp für diesen <see langword="TypeBuilder" /> zurück.</summary>
      <exception cref="T:System.InvalidOperationException">Dieser Typ ist eine Enumeration, aber es ist kein zugrunde liegender Systemtyp vorhanden.</exception>
      <returns>Schreibgeschützt. Gibt den zugrunde liegenden Systemtyp zurück.</returns>
    </member>
  </members>
</doc>