<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary vsli:raw="Content type masked bits that correspond to values of &lt;see cref=&quot;T:System.Reflection.AssemblyContentType&quot; /&gt;.">Maskierte Inhaltstypbits, die Werten von <see cref="T:System.Reflection.AssemblyContentType" /> entsprechen.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary vsli:raw="Just-In-Time (JIT) compiler optimization is disabled for the assembly.">JIT-Compileroptimierung (Just-In-Time) ist für die Assembly deaktiviert.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary vsli:raw="Just-In-Time (JIT) compiler tracking is enabled for the assembly.">JIT-Compilernachverfolgung (Just-In-Time) ist für die Assembly aktiviert.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary vsli:raw="The assembly reference holds the full (unhashed) public key. Not applicable on assembly definition.">Der Assemblyverweis enthält den vollständigen (nicht gehashten) öffentlichen Schlüssel. Für Assemblydefinition nicht zutreffend.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary vsli:raw="The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.">Von der Implementierung der referenzierten Assembly, die zur Laufzeit verwendet wird, wird nicht erwartet, dass sie der Version entspricht, die zur Kompilierzeit angezeigt wird.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary vsli:raw="The assembly contains Windows Runtime code.">Die Assembly enthält Windows-Runtime-Code.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary vsli:raw="Specifies the hash algorithms used for hashing assembly files and for generating the strong name.">Legt die Hashalgorithmen fest, die für das Hashing von Assemblydateien und das Generieren des starken Namens verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary vsli:raw="&lt;para&gt;Retrieves the MD5 message-digest algorithm.&lt;/para&gt;&lt;para&gt;Due to collision problems with MD5, Microsoft recommends SHA256.&lt;/para&gt;&lt;para&gt;MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and, while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.&lt;/para&gt;">Ruft den Message Digest-Algorithmus MD5 ab.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary vsli:raw="&lt;para&gt;A mask indicating that there is no hash algorithm.&lt;/para&gt;&lt;para&gt;If you specify &lt;see cref=&quot;F:System.Reflection.AssemblyHashAlgorithm.None&quot; /&gt; for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.&lt;/para&gt;">Eine Maske, die angibt, dass kein Hashalgorithmus verfügbar ist.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary vsli:raw="&lt;para&gt;Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.&lt;/para&gt;&lt;para&gt;Due to collision problems with SHA1, Microsoft recommends SHA256.&lt;/para&gt;">Ruft eine Revision des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) ab, die einen nicht veröffentlichten Fehler in SHA korrigiert</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.">Ruft eine Version des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) mit einer Hashgröße von 256 Bits ab</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.">Ruft eine Version des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) mit einer Hashgröße von 384 Bits ab</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.">Ruft eine Version des SHA (Secure Hash Algorithm, sicherer Hashalgorithmus) mit einer Hashgröße von 512 Bits ab</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary vsli:raw="Specifies the security actions that can be performed using declarative security.">Gibt die Sicherheitsaktionen an, die mit deklarativer Sicherheit ausgeführt werden können.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary vsli:raw="The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.">Der aufrufende Code kann auch dann auf die durch das aktuelle Berechtigungsobjekt angegebene Ressource zugreifen, wenn übergeordnete Aufrufer in der Aufrufliste keine Zugriffsberechtigung für die Ressource besitzen.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary vsli:raw="Check that all callers in the call chain have been granted the specified permission.">Überprüft, ob allen Aufrufern in der Aufrufkette die angegebene Berechtigung erteilt wurde.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary vsli:raw="Without further checks refuse Demand for the specified permission.">Ohne weitere Überprüfungen wird die Anforderung für die angegebene Berechtigung abgelehnt.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary vsli:raw="The derived class inheriting the class or overriding a method is required to have the specified permission.">Der abgeleiteten Klasse, die die Klasse erbt oder eine Methode überschreibt, muss die angegebene Berechtigung erteilt worden sein.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary vsli:raw="Check that the immediate caller has been granted the specified permission.">Stellt sicher, dass dem unmittelbaren Aufrufer die angegebene Berechtigung erteilt wurde.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary vsli:raw="No declarative security action.">Keine deklarative Sicherheitsaktion.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary vsli:raw="Without further checks, refuse the demand for all permissions other than those specified.">Verweigert ohne weitere Überprüfungen die Anforderung für alle Berechtigungen mit Ausnahme der angegebenen.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary vsli:raw="Request the minimum permissions required for code to run. This action can only be used within the scope of the assembly.">Fordert die Mindestberechtigungen an, die zum Ausführen des Codes erforderlich sind. Diese Aktion kann nur innerhalb des Gültigkeitsbereichs der Assembly verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary vsli:raw="Request additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly.">Fordert weitere Berechtigungen an, die optional sind (für Ausführung nicht erforderlich). Diese Anforderung lehnt implizit alle anderen nicht speziell angeforderten Berechtigungen ab. Diese Aktion kann nur innerhalb des Gültigkeitsbereichs der Assembly verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary vsli:raw="Request that permissions that might be misused not be granted to the calling code. This action can only be used within the scope of the assembly.">Fordert an, dass dem aufrufenden Code keine Berechtigungen erteilt werden, die missbraucht werden könnten. Diese Aktion kann nur innerhalb des Gültigkeitsbereichs der Assembly verwendet werden.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary vsli:raw="The resource is not exported from the assembly.">Die Ressource wird nicht aus der Assembly exportiert.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary vsli:raw="The resource is exported from the assembly.">Die Ressource wird aus der Assembly exportiert.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary vsli:raw="Masks just the visibility-related attributes.">Maskiert nur die sichtbarkeitsbezogenen Attribute.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary vsli:raw="Represents the shape of an array type.">Stellt die Form eines Arraytyps dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ArrayShape&quot; /&gt; structure.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ArrayShape" />-Struktur.</summary>
      <param name="rank" vsli:raw="The number of dimensions in the array.">Die Anzahl der Dimensionen im Array.</param>
      <param name="sizes" vsli:raw="The size of each dimension.">Die Größe jeder Dimension.</param>
      <param name="lowerBounds" vsli:raw="The lower-bound of each dimension.">Die untere Begrenzung jeder Dimension.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary vsli:raw="Gets the lower-bounds of all dimensions. Length may be smaller than rank, in which case the trailing dimensions have unspecified lower bounds.">Ruft die unteren Begrenzungen aller Dimensionen ab. Der Wert für „Length“ ist möglicherweise kleiner als der für „Rank“. In diesem Fall verfügen die nachstehenden Dimensionen über nicht angegebene untere Grenzen.</summary>
      <returns vsli:raw="An array of lower-bounds.">Ein Array mit unteren Grenzen.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary vsli:raw="Gets the number of dimensions in the array.">Ruft die Anzahl der Dimensionen im Array ab.</summary>
      <returns vsli:raw="The number of dimensions.">Die Anzahl der Dimensionen.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary vsli:raw="Gets the sizes of all dimensions.">Ruft die Größen alle Dimensionen ab.</summary>
      <returns vsli:raw="An array of sizes.">Ein Array von Größen.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary vsli:raw="Gets a value that indicates whether the file contains metadata.">Ruft einen Wert ab, der angibt, ob die Datei Metadaten enthält.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the file contains metadata, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> , wenn die Datei Metadaten enthält; <see langword="false" /> andernfalls.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary vsli:raw="Gets the hash value of the file content calculated using &lt;see cref=&quot;P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm&quot; /&gt;.">Ruft den Hashwert des Dateiinhalts ab, der mit <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" /> berechnet wird.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; instance representing the hash value of the file content.">Eine- <see cref="T:System.Reflection.Metadata.BlobHandle" /> Instanz, die den Hashwert des Datei Inhalts darstellt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary vsli:raw="Gets the file name, including its extension.">Ruft den Dateinamen einschließlich der Erweiterung ab.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; instance representing the file name with its extension.">Eine- <see cref="T:System.Reflection.Metadata.StringHandle" /> Instanz, die den Dateinamen mit der Erweiterung darstellt.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;.">Stellt eine <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />-Auflistung dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary vsli:raw="A collection of assembly references.">Eine Sammlung von Assemblyverweisen.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Compares the current content of this writer with another one.">Vergleicht den aktuellen Inhalt dieses Writers mit einem anderen Writer.</summary>
      <param name="other" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; instance to compare with this one.">Eine <see cref="T:System.Reflection.Metadata.BlobBuilder" />-Instanz, die mit dieser Instanz verglichen werden soll.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn Gleichheit vorliegt, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary vsli:raw="Returns a sequence of all blobs that represent the content of the builder.">Gibt eine Sequenz aller Blobs zurück, die den Inhalt des Generators darstellen.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
      <returns vsli:raw="A sequence of blobs.">Eine Sequenz von Blobs.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;prefix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="prefix" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;suffix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="suffix" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary vsli:raw="Reserves a contiguous block of bytes.">Reserviert einen zusammenhängenden Block von Bytes.</summary>
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Attempts to write a sequence of bytes to the builder. A return value indicates the number of bytes successfully written.">Versucht, eine Sequenz von Bytes in den Generator zu schreiben. Ein Rückgabewert gibt die Anzahl der erfolgreich geschriebenen Bytes an.</summary>
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
      <returns vsli:raw="The number of bytes successfully written from &lt;paramref name=&quot;source&quot; /&gt;.">Die Anzahl der Bytes, die erfolgreich aus <paramref name="source" /> geschrieben wurden.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; value to the builder.">Schreibt einen <see cref="T:System.Boolean" />-Wert in den Generator.</summary>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Byte&quot; /&gt; value to the builder.">Schreibt einen <see cref="T:System.Byte" />-Wert in den Generator.</summary>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes from a buffer to the builder.">Schreibt eine angegebene Anzahl von Bytes aus einem Puffer in den Generator.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">Die Anzahl der zu schreibenden Bytes.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary vsli:raw="Writes a specified number of occurrences of a byte value to the builder.">Schreibt eine angegebene Anzahl von Vorkommen eines Bytewerts in den Generator.</summary>
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of occurences of &lt;paramref name=&quot;value&quot; /&gt; to write.">Die Anzahl der Vorkommen von <paramref name="value" />, die geschrieben werden sollen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary vsli:raw="Writes the contents of a byte array to the builder.">Schreibt den Inhalt eines Bytearrays in den Generator.</summary>
      <param name="buffer" vsli:raw="The byte array to write.">Das zu schreibende Bytearray.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index in a byte array to the builder.">Schreibt eine angegebene Anzahl von Bytes ab einem angegebenen Index in einem Bytearray in den Generator.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">Die Anzahl der zu schreibenden Bytes.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of &lt;paramref name=&quot;buffer&quot; /&gt;.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Writes the contents of an immutable byte array to the builder.">Schreibt den Inhalt eines unveränderlichen Bytearrays in den Generator.</summary>
      <param name="buffer" vsli:raw="The array to write.">Das zu schreibende Array.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index of an immutable array to the builder.">Schreibt eine angegebene Anzahl von Bytes ab einem angegebenen Index eines unveränderlichen Arrays in den Generator.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">Die Anzahl der zu schreibenden Bytes.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementiert komprimierte ganzzahlige Codierungen ohne Vorzeichen gemäß ECMA-335-II-Kapitel 23,2: BLOB-und Signaturen.</summary>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> kann nicht als komprimierter Integerwert ohne Vorzeichen dargestellt werden.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementiert eine komprimierte ganzzahlige Codierung mit Vorzeichen gemäß ECMA-335-II-Kapitel 23,2: BLOB-und Signaturen.</summary>
      <param name="value" vsli:raw="The value to write.">Der zu schreibende Wert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> kann nicht als komprimierter Integerwert mit Vorzeichen dargestellt werden.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">Schreibt einen konstanten Wert (siehe ECMA-335, Partition II, Abschnitt 22.9) an der aktuellen Position.</summary>
      <param name="value" vsli:raw="The constant value to write.">Der zu schreibende konstante Wert.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> ist kein konstanter Typ.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is default (&lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt;).">
        <paramref name="destination" /> ist der Standardwert (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">Inhalt ist nicht verfügbar. Der Generator wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">Schreibt einen Verweis auf einen Heap (Heapoffset) oder eine Tabelle (Zeilennummer).</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">Heapoffset oder Tabellenzeilennummer.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as a 16-bit integer; &lt;see langword=&quot;false&quot; /&gt; to encode it as a 32-bit integer.">
        <see langword="true" />, um den Verweis als 16-Bit-Integerwert zu codieren. <see langword="false" />, um ihn als 32-Bit-Integerwert zu codieren.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">Schreibt eine Zeichenfolge im SerString-Format (siehe ECMA-335-II 23.3: Benutzerdefinierte Attribute).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">Schreibt eine Zeichenfolge im Benutzerzeichenfolgen-Heapformat (#US) (siehe ECMA-335-II 24.2.4: #US- und #Blob-Heaps).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded character array at the current position.">Schreibt ein im UTF16-Format (Little-Endian) codiertes Zeichenarray an der aktuellen Position.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary vsli:raw="Writes UTF16 (little-endian) encoded string at the current position.">Schreibt eine im UTF16-Format (Little-Endian) codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">Schreibt eine im UTF8-Format codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" vsli:raw="Constant value.">Ein konstanter Wert.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with a U+FFFD character.">
        <see langword="true" />, um nicht gepaarte Ersatzzeichen wie angegeben zu codieren, <see langword="false" />, um sie durch ein U+FFFD-Zeichen zu ersetzen.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" vsli:raw="" />
      <param name="stamp" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a reader of the specified memory block.">Erstellt einen Reader des angegebenen Speicherblocks.</summary>
      <param name="buffer" vsli:raw="A pointer to the start of the memory block.">Ein Zeiger auf den Anfang des Speicherblocks.</param>
      <param name="length" vsli:raw="Length in bytes of the memory block.">Die Länge des Speicherblocks in Bytes.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; is greater than zero.">
        <paramref name="buffer" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is negative.">
        <paramref name="length" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is not little-endian.">Die aktuelle Plattform ist nicht Little-Endian.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary vsli:raw="Repositions the reader forward by the number of bytes required to satisfy the given alignment.">Positioniert den Reader um die Anzahl von Bytes nach vorn, die benötigt wird, um die angegebene Ausrichtung zu erfüllen.</summary>
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary vsli:raw="Searches for a specified byte in the blob following the current position.">Sucht nach einem angegebenen Byte im Blob, das auf die aktuelle Position folgt.</summary>
      <param name="value" vsli:raw="The byte value to find.">Der zu suchende Bytewert.</param>
      <returns vsli:raw="The index relative to the current position, or -1 if the byte is not found in the blob following the current position.">Der Index relativ zur aktuellen Position oder -1, wenn das Byte im Blob nach der aktuellen Position nicht gefunden wurde.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary vsli:raw="Reads a Blob heap handle encoded as a compressed integer.">Liest ein Blobheaphandle, das als komprimierter Integerwert codiert ist.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position.">Liest Bytes ab der aktuellen Position.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Die Anzahl der zu lesenden Bytes.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
      <returns vsli:raw="The byte array.">Das Bytearray.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position and writes them to the specified buffer starting at the specified offset.">Liest Bytes ab der aktuellen Position und schreibt sie in den angegebenen Puffer, beginnend am angegebenen Offset.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Die Anzahl der zu lesenden Bytes.</param>
      <param name="buffer" vsli:raw="The destination buffer the bytes read will be written to.">Der Zielpuffer, in den der Bytelesevorgang schreibt.</param>
      <param name="bufferOffset" vsli:raw="The offset in the destination buffer where the bytes read will be written.">Der Offset im Zielpuffer, in den der Bytelesevorgang geschrieben wird.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Liest einen komprimierten Integerwert ohne Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II. 23.2: blosb und Signaturen.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">Die Daten an der aktuellen Position waren kein komprimierter gültiger Integerwert.</exception>
      <returns vsli:raw="The value of the compressed integer that was read.">Der Wert des komprimierten Integerwerts, der gelesen wurde.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Liest einen komprimierten Integerwert mit Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II. 23.2: blosb und Signaturen.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">Die Daten an der aktuellen Position waren kein komprimierter gültiger Integerwert.</exception>
      <returns vsli:raw="The value of the compressed integer that was read.">Der Wert des komprimierten Integerwerts, der gelesen wurde.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary vsli:raw="Reads a constant value (see ECMA-335 Partition II section 22.9) from the current position.">Liest einen konstanten Wert (siehe ECMA-335, Partition II, Abschnitt 22.9) ab der aktuellen Position.</summary>
      <param name="typeCode" vsli:raw="" />
      <exception cref="T:System.BadImageFormatException" vsli:raw="Error while reading from the blob.">Fehler beim Lesen aus dem Blob.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;typeCode&quot; /&gt; is not a valid &lt;see cref=&quot;T:System.Reflection.Metadata.ConstantTypeCode&quot; /&gt;.">
        <paramref name="typeCode" /> ist kein gültiger <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />.</exception>
      <returns vsli:raw="A boxed constant value. To avoid allocating the object use Read* methods directly.">Ein geschachtelter konstanter Wert. Um die Zuordnung von Objekten zu vermeiden, verwenden Sie Read*-Methoden direkt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">Liest eine <see cref="T:System.Decimal" />-Zahl.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">Die Daten an der aktuellen Position waren keine gültige <see cref="T:System.Decimal" />-Zahl.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary vsli:raw="Reads a type code encoded in a serialized custom attribute value.">Liest einen Typcode, der in einem serialisierten benutzerdefinierten Attributwert codiert ist.</summary>
      <returns vsli:raw="&lt;see cref=&quot;F:System.Reflection.Metadata.SerializationTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />, wenn die Codierung ungültig ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary vsli:raw="Reads a string encoded as a compressed integer containing its length followed by its contents in UTF8. Null strings are encoded as a single 0xFF byte.">Liest eine Zeichenfolge, die als komprimierter Integerwert codiert ist, und enthält ihre Länge, gefolgt von ihrem Inhalt im UTF8-Format. NULL-Zeichenfolgen werden als ein einzelnes 0xFF-Byte codiert.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The encoding is invalid.">Die Codierung ist ungültig.</exception>
      <returns vsli:raw="A string value, or &lt;see langword=&quot;null&quot; /&gt;.">Ein Zeichenfolgenwert oder <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary vsli:raw="Reads a type code encoded in a signature.">Liest einen Typcode, der in einer Signatur codiert ist.</summary>
      <returns vsli:raw="The type code encoded in the serialized custom attribute value if the encoding is valid, or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">Der Typcode, der im serialisierten benutzerdefinierten Attributwert codiert ist, wenn die Codierung gültig ist, oder <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />, wenn die Codierung ungültig ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary vsli:raw="Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).">Liest ein Typhandle, das in einer Signatur als TypeDefOrRefOrSpecEncoded codiert (siehe ECMA-335 II.23.2.8).</summary>
      <returns vsli:raw="The handle when the encoding is valid. Otherwise, a handle where the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">Das Handle, wenn die Codierung gültig ist. Andernfalls ein Handle, für das die <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" />-Eigenschaft <see langword="true" /> ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary vsli:raw="Reads a UTF16 (little-endian) encoded string starting at the current position.">Liest eine im UTF16-Format (Little-Endian) codierte Zeichenfolge ab der aktuellen Position.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Die Anzahl der zu lesenden Bytes.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
      <returns vsli:raw="The string.">Die Zeichenfolge.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary vsli:raw="Reads a UTF8 encoded string starting at the current position.">Liest eine im UTF8-Format codierte Zeichenfolge ab der aktuellen Position.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">Die Anzahl der zu lesenden Bytes.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> Bytes nicht verfügbar.</exception>
      <returns vsli:raw="The string.">Die Zeichenfolge.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary vsli:raw="Repositions the reader to the start of the underlying memory block.">Positioniert den Reader erneut am Anfang des zugrunde liegenden Speicherblocks.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Liest einen komprimierten Integerwert ohne Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II. 23.2: blosb und Signaturen.</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">Der Wert des komprimierten Integerwerts, der gelesen wurde.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">
        <see langword="true" />, wenn der Wert erfolgreich gelesen wurde. <see langword="false" />, wenn die Daten an der aktuellen Position kein komprimierter gültiger Integerwert waren.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Liest einen komprimierten Integerwert mit Vorzeichen. Siehe Metadatenspezifikation, Abschnitt II. 23.2: blosb und Signaturen.</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">Der Wert des komprimierten Integerwerts, der gelesen wurde.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">
        <see langword="true" />, wenn der Wert erfolgreich gelesen wurde. <see langword="false" />, wenn die Daten an der aktuellen Position kein komprimierter gültiger Integerwert waren.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary vsli:raw="Gets a pointer to the byte at the current position of the reader.">Ruft einen Zeiger auf das Byte an der aktuellen Position des Readers ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary vsli:raw="Gets the total length of the underlying memory block.">Ruft die Gesamtlänge des zugrunde liegenden Speicherblocks ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary vsli:raw="Gets or sets the offset from the start of the blob to the current position.">Ruft den Offset vom Beginn des Blobs bis zur aktuellen Position ab oder legt ihn fest.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The offset is set outside the bounds of the underlying reader.">Der Offset wird außerhalb der Grenzen des zugrunde liegenden Readers festgelegt.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary vsli:raw="Gets the number of bytes remaining from current position to the end of the underlying memory block.">Ruft die Anzahl der Bytes ab, die ab der aktuellen Position bis zum Ende des zugrunde liegenden Speicherblocks verbleiben.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary vsli:raw="Gets a pointer to the byte at the start of the underlying memory block.">Ruft einen Zeiger auf das Byte am Anfang des zugrunde liegenden Speicherblocks ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="count" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary vsli:raw="Compares the current content of this writer with another one.">Vergleicht den aktuellen Inhalt dieses Writers mit einem anderen Writer.</summary>
      <param name="other" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des Pufferinhalts.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">Der von <paramref name="start" /> und <paramref name="byteCount" /> angegebene Bereich liegt außerhalb der Grenzen des <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementiert komprimierte ganzzahlige Codierungen ohne Vorzeichen gemäß ECMA-335-II-Kapitel 23,2: BLOB-und Signaturen.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> kann nicht als komprimierter Integerwert ohne Vorzeichen dargestellt werden.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementiert eine komprimierte ganzzahlige Codierung mit Vorzeichen gemäß ECMA-335-II-Kapitel 23,2: BLOB-und Signaturen.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> kann nicht als komprimierter Integerwert mit Vorzeichen dargestellt werden.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">Schreibt einen konstanten Wert (siehe ECMA-335, Partition II, Abschnitt 22.9) an der aktuellen Position.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> ist kein konstanter Typ.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">Schreibt einen Verweis auf einen Heap (Heapoffset) oder eine Tabelle (Zeilennummer).</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">Heapoffset oder Tabellenzeilennummer.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as 16-bit integer, &lt;see langword=&quot;false&quot; /&gt; to encode as 32-bit integer.">
        <see langword="true" />, um den Verweis als 16-Bit-Integerwert zu codieren. <see langword="false" />, um ihn als 32-Bit-Integerwert zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">Schreibt eine Zeichenfolge im SerString-Format (siehe ECMA-335-II 23.3: Benutzerdefinierte Attribute).</summary>
      <param name="str" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">Schreibt eine Zeichenfolge im Benutzerzeichenfolgen-Heapformat (#US) (siehe ECMA-335-II 24.2.4: #US- und #Blob-Heaps).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">Der Generator ist nicht beschreibbar. Er wurde mit einem anderen Generator verknüpft.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">Schreibt eine im UTF16-Format (Little-Endian) codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">Schreibt eine im UTF16-Format (Little-Endian) codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">Schreibt eine im UTF8-Format codierte Zeichenfolge an der aktuellen Position.</summary>
      <param name="value" vsli:raw="" />
      <param name="allowUnpairedSurrogates" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary vsli:raw="Gets the parent handle (&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;).">Ruft das übergeordnete Handle ab (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary vsli:raw="Gets a type code that identifies the type of the constant value.">Ruft einen Typcode ab, mit dem der Typ des konstanten Werts identifiziert wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary vsli:raw="Gets the constant value.">Ruft den konstanten Wert ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary vsli:raw="Specifies values that represent types of metadata constants.">Gibt Werte an, die Typen von Metadatenkonstanten darstellen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary vsli:raw="A Boolean type.">Ein boolescher Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer.">Ein unsignierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary vsli:raw="A character type.">Ein Zeichentyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">Ein 8-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">Ein signierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">Ein signierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">Ein signierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary vsli:raw="An invalid type.">Ein ungültiger Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary vsli:raw="A null reference.">Ein NULL-Verweis.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">Ein signierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">Ein 4-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Ein <see cref="T:System.String" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">Ein unsignierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">Ein unsignierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">Ein unsignierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary vsli:raw="Decodes the arguments encoded in the value blob.">Decodiert die Argumente, die im Wertblob codiert sind.</summary>
      <param name="provider" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary vsli:raw="Gets the constructor (the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;) of the custom attribute type.">Ruft den Konstruktor (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) des benutzerdefinierten Attributtyps ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary vsli:raw="Gets the handle of the metadata entity the attribute is applied to.">Ruft das Handle für die Metadatenentität ab, auf die das Attribut angewendet wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary vsli:raw="Gets the value of the attribute.">Ruft den Wert des Attributs ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary vsli:raw="Represents a named argument decoded from a custom attribute signature.">Stellt ein benanntes Argument dar, das aus einer benutzerdefinierten Attributsignatur codiert wurde.</summary>
      <typeparam name="TType" vsli:raw="The type used to represent types of values decoded from the custom attribute signature.">Der Typ, der zum Darstellen von Typen von Werten verwendet wird, die von der benutzerdefinierten Attribut Signatur decodiert werden</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeNamedArgument`1&quot; /&gt; structure using the specified name, kind, type, and value.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" />-Struktur mithilfe des angegebenen Namens, der Art, dem Typen und dem Wert.</summary>
      <param name="name" vsli:raw="The name of the argument.">Der Name des Arguments.</param>
      <param name="kind" vsli:raw="The kind of the argument.">Die Art des Arguments.</param>
      <param name="type" vsli:raw="The type of the argument.">Der Typ des Arguments.</param>
      <param name="value" vsli:raw="The value of the argument.">Der Wert des Arguments.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary vsli:raw="Gets the kind of argument.">Ruft die Art des Arguments ab.</summary>
      <returns vsli:raw="The argument kind.">Die argumentart.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary vsli:raw="Gets the name of the argument.">Ruft den Namen des Arguments ab.</summary>
      <returns vsli:raw="The argument name.">Der Argumentname.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">Ruft den Typ des Arguments ab.</summary>
      <returns vsli:raw="The argument type.">Der Argumenttyp.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">Ruft den Wert des Arguments ab.</summary>
      <returns vsli:raw="An object containing the argument value.">Ein-Objekt, das den Argument Wert enthält.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary vsli:raw="Specifies constants that define the kinds of arguments in a custom attribute signature.">Gibt Konstanten an, die die Arten von Argumenten in einer benutzerdefinierten Attributsignatur definieren.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary vsli:raw="A field argument.">Ein Feldargument.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary vsli:raw="A property argument.">Ein Eigenschaftsargument.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary vsli:raw="Represents a typed argument for a custom metadata attribute.">Stellt ein typisiertes Argument für ein benutzerdefiniertes Metadatenattribut dar.</summary>
      <typeparam name="TType" vsli:raw="The type of the argument.">Der Typ des Arguments.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeTypedArgument`1&quot; /&gt; structure using the specified argument type and value.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" />-Struktur mithilfe des angegebenen Argumenttypen und -werts.</summary>
      <param name="type" vsli:raw="The type of the argument.">Der Typ des Arguments.</param>
      <param name="value" vsli:raw="The argument value.">Der Argumentwert.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">Ruft den Typ des Arguments ab.</summary>
      <returns vsli:raw="The argument type.">Der Argumenttyp.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">Ruft den Wert des Arguments ab.</summary>
      <returns vsli:raw="The argument value.">Der Argumentwert.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary vsli:raw="Represents a custom attribute of the type specified by &lt;paramref name=&quot;TType&quot; /&gt;.">Stellt ein benutzerdefiniertes Attribut des von <paramref name="TType" /> angegebenen Typs dar.</summary>
      <typeparam name="TType" vsli:raw="The attribute type.">Der Attributtyp.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; structure using the specified fixed arguments and named arguments.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />-Struktur mithilfe der angegebenen festen und benannten Argumente.</summary>
      <param name="fixedArguments" vsli:raw="The fixed arguments.">Die festen Argumente.</param>
      <param name="namedArguments" vsli:raw="The named arguments.">Die benannten Argumente.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary vsli:raw="Gets the fixed arguments for the custom attribute.">Ruft die festen Argumente für das benutzerdefinierte Argument ab.</summary>
      <returns vsli:raw="An immutable array of arguments.">Ein unveränderliches Array von Argumenten.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary vsli:raw="Gets the named arguments for the custom attribute value.">Ruft die benannten Argumente für das benutzerdefinierte Argument ab.</summary>
      <returns vsli:raw="An immutable array of arguments.">Ein unveränderliches Array von Argumenten.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the metadata blob to the start of the &lt;see cref=&quot;P:System.Reflection.Metadata.DebugMetadataHeader.Id&quot; /&gt; blob.">Ruft den Offset (in Bytes) vom Anfang des Metadatenblobs bis zum Anfang des <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />-Blobs ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary vsli:raw="The source document in the debug metadata.">Das Quelldokument in den Debugmetadaten.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary vsli:raw="Gets the document content hash.">Ruft den Dokumentinhaltshash ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary vsli:raw="Gets the hash algorithm used to calculate the &lt;see cref=&quot;P:System.Reflection.Metadata.Document.Hash&quot; /&gt; (SHA1, SHA256, etc.).">Ruft den Hashalgorithmus ab, der zum Berechnen des <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256, usw.) verwendet wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary vsli:raw="Gets the source code language (C#, VB, F#, etc.).">Ruft die Quellcodesprache (C#, VB, F# usw.) ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary vsli:raw="Gets the document name blob.">Ruft das Dokumentnamenblob ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; representing a blob on #Blob heap in Portable PDB structured as Document Name.">Ein <see cref="T:System.Reflection.Metadata.BlobHandle" />, das ein Blob auf dem #Blob-Heap in Portable PDB darstellt, strukturiert als Dokumentname.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary vsli:raw="Encodes array shape.">Codiert eine Arrayform.</summary>
      <param name="rank" vsli:raw="The number of dimensions in the array (shall be 1 or more).">Die Anzahl der Dimensionen im Array (ist 1 oder mehr).</param>
      <param name="sizes" vsli:raw="Dimension sizes. The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer.">Dimensionsgrößen Das Array kann kürzer als <paramref name="rank" /> sein, aber nicht länger.</param>
      <param name="lowerBounds" vsli:raw="Dimension lower bounds, or default(&lt;see cref=&quot;T:System.Collections.Immutable.ImmutableArray`1&quot; /&gt;) to set all &lt;paramref name=&quot;rank&quot; /&gt; lower bounds to 0.&#xA; The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer.">Untergrenzen der oder Standardwert (<see cref="T:System.Collections.Immutable.ImmutableArray`1" />), um alle Untergrenzen von <paramref name="rank" /> auf 0 festzulegen.
Das Array kann kürzer als <paramref name="rank" /> sein, aber nicht länger.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is outside of range [1, 0xffff], smaller than &lt;see langword=&quot;sizes.Length&quot; /&gt;, or smaller than &lt;see langword=&quot;lowerBounds.Length&quot; /&gt;.">
        <paramref name="rank" /> liegt außerhalb des Bereichs [1, 0xffff] und ist kleiner als <see langword="sizes.Length" /> oder <see langword="lowerBounds.Length" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;sizes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="sizes" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary vsli:raw="Encodes custom attribute signature blob.">Codiert einen benutzerdefinierten Attributsignatur-Blob.</summary>
      <param name="fixedArguments" vsli:raw="Called first, to encode fixed arguments.">Wird zuerst aufgerufen, um feste Argumente zu codieren.</param>
      <param name="namedArguments" vsli:raw="Called second, to encode named arguments.">Wird als Zweites aufgerufen, um benannte Argumente zu codieren.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;fixedArguments&quot; /&gt; or &lt;paramref name=&quot;namedArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="fixedArguments" /> oder <paramref name="namedArguments" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary vsli:raw="Encodes custom attribute signature blob.&#xA; Returns a pair of encoders that must be used in the order they appear in the parameter list.">Codiert einen benutzerdefinierten Attributsignatur-Blob.
Gibt ein Encoderpaar zurück, das in der Reihenfolge verwendet werden muss, in der die Encoder in der Parameterliste angezeigt werden.</summary>
      <param name="fixedArguments" vsli:raw="Use first, to encode fixed arguments.">Zuerst verwenden, um feste Argumente zu codieren.</param>
      <param name="namedArguments" vsli:raw="Use second, to encode named arguments.">Als Zweites verwenden, um benannte Argumente zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary vsli:raw="Encodes field signature blob.">Codiert einen Feldsignatur-Blob.</summary>
      <returns vsli:raw="Encoder of the field type.">Encoder des Feldtyps.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary vsli:raw="Encodes local variable signature.">Codiert die lokale Variablensignatur.</summary>
      <param name="variableCount" vsli:raw="Number of local variables.">Anzahl der lokalen Variablen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;variableCount&quot; /&gt; is not in range [0, 0x1fffffff].">
        <paramref name="variableCount" /> liegt nicht im Bereich [0, 0x1fffffff].</exception>
      <returns vsli:raw="Encoder of a sequence of local variables.">Encoder einer Sequenz von lokalen Variablen.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary vsli:raw="Encodes method signature blob.">Codiert einen Methodensignatur-Blob.</summary>
      <param name="convention" vsli:raw="Calling convention.">Aufrufkonvention.</param>
      <param name="genericParameterCount" vsli:raw="Number of generic parameters.">Anzahl generischer Parameter.</param>
      <param name="isInstanceMethod" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance method signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static method signature.">
        <see langword="true" /> zum Codieren einer Instanzmethodensignatur, <see langword="false" /> zum Codieren einer statischen Methodensignatur.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericParameterCount&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="genericParameterCount" /> liegt nicht im Bereich [0, 0xffff].</exception>
      <returns vsli:raw="An encoder of the rest of the signature including return value and parameters.">Ein Encoder des Rests der Signatur, einschließlich Rückgabewert und Parameter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary vsli:raw="Encodes method specification signature blob.">Codiert einen Methodensignatur-Blob zur Spezifizierung.</summary>
      <param name="genericArgumentCount" vsli:raw="Number of generic arguments.">Anzahl von generischen Argumenten.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericArgumentCount&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="genericArgumentCount" /> liegt nicht im Bereich [0, 0xffff].</exception>
      <returns vsli:raw="Encoder of generic arguments.">Encoder von generischen Argumenten.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary vsli:raw="Encodes permission set arguments.">Codiert Argumente von Berechtigungssätzen.</summary>
      <param name="argumentCount" vsli:raw="Number of arguments in the set.">Anzahl der Argumente im Satz.</param>
      <returns vsli:raw="Encoder of the arguments of the set.">Encoder der Argumente des Satzes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary vsli:raw="Encodes a permission set blob.">Codiert einen Berechtigungssatz-Blob.</summary>
      <param name="attributeCount" vsli:raw="Number of attributes in the set.">Anzahl der Attribute im Satz.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;attributeCount&quot; /&gt; is not in range [0, 0x1fffffff].">
        <paramref name="attributeCount" /> liegt nicht im Bereich [0, 0x1fffffff].</exception>
      <returns vsli:raw="Permission set encoder.">Berechtigungssatz-Encoder.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary vsli:raw="Encodes property signature blob.">Codiert einen Eigenschaftensignatur-Blob.</summary>
      <param name="isInstanceProperty" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance property signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static property signature.">
        <see langword="true" /> zum Codieren einer Instanzeigenschaftssignatur, <see langword="false" /> zum Codieren einer statischen Eigenschaftssignatur.</param>
      <returns vsli:raw="An encoder of the rest of the signature including return value and parameters, which has the same structure as method signature.">Ein Encoder des Rests der Signatur, einschließlich Rückgabewert und Parametern, die die gleiche Struktur wie die Methodensignatur aufweist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary vsli:raw="Encodes type specification signature.">Codiert die Signatur zur Typspezifikation.</summary>
      <returns vsli:raw="Type encoder of the structured type represented by the type specification (it shall not encode a primitive type).">Typencoder vom strukturierten Typ, dargestellt durch die Typspezifikation (er codiert keinen primitiven Typ).</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a CustomAttributeType coded index for the specified handle.">Berechnet einen mit CustomAttributeType codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasConstant coded index for the specified handle.">Berechnet einen mit HasConstant codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasCustomAttribute coded index for the specified handle.">Berechnet einen mit HasCustomAttribute codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasCustomDebugInformation coded index for the specified handle.">Berechnet einen mit HasCustomDebugInformation codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> oder <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasDeclSecurity coded index for the specified handle.">Berechnet einen mit HasDeclSecurity codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />oder <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasFieldMarshal coded index for the specified handle.">Berechnet einen mit HasFieldMarshal codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> oder <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasSemantics coded index for the specified handle.">Berechnet einen mit HasSemantics codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates an implementation coded index for the specified handle.">Berechnet einen implementierungscodierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> oder <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a MemberForwarded coded index for the specified handle.">Berechnet einen mit MemberForwarded codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinition&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a MemberRefParent coded index for the specified handle.">Berechnet einen mit MemberRefParent codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a MethodDefOrRef coded index for the specified handle.">Berechnet einen mit MethodDefOrRef codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a ResolutionScope coded index for the specified handle.">Berechnet einen mit ResolutionScope codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a TypeDefOrRef coded index for the specified handle.">Berechnet einen mit TypeDefOrRef codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a TypeDefOrRefOrSpec coded index for the specified handle.">Berechnet einen mit TypeDefOrRefOrSpec codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a TypeOrMethodDef coded index for the specified handle.">Berechnet einen mit TypeOrMethodDef codierten Index für das angegebene Handle.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">Unerwarteter Handletyp.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds catch region.">Fügt den Catch-Bereich hinzu.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Bezeichnung, die die erste Anweisung des Try-Blocks markiert.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Bezeichnung, die die Anweisung unmittelbar nach dem Try-Block markiert.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Bezeichnung, die die erste Anweisung des Handlers markiert.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Bezeichnung, die die Anweisung unmittelbar nach dem Handler markiert.</param>
      <param name="catchType" vsli:raw="The type of exception to be caught: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Der Typ der Ausnahme, die abgefangen werden soll: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;catchType&quot; /&gt; is not a valid type handle.">Eine Bezeichnung wurde nicht durch einen Anweisungsencoder definiert, dem dieser Generator zugeordnet ist.

- oder -

<paramref name="catchType" /> ist kein gültiges Typhandle.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Eine Bezeichnung weist den Standardwert auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Adds fault region.">Fügt einen Fault-Bereich hinzu.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Bezeichnung, die die erste Anweisung des Try-Blocks markiert.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Bezeichnung, die die Anweisung unmittelbar nach dem Try-Block markiert.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Bezeichnung, die die erste Anweisung des Handlers markiert.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Bezeichnung, die die Anweisung unmittelbar nach dem Handler markiert.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.">Eine Bezeichnung wurde nicht durch einen Anweisungsencoder definiert, dem dieser Generator zugeordnet ist.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Eine Bezeichnung weist den Standardwert auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Adds catch region.">Fügt den Catch-Bereich hinzu.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Bezeichnung, die die erste Anweisung des Try-Blocks markiert.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Bezeichnung, die die Anweisung unmittelbar nach dem Try-Block markiert.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Bezeichnung, die die erste Anweisung des Handlers markiert.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Bezeichnung, die die Anweisung unmittelbar nach dem Handler markiert.</param>
      <param name="filterStart" vsli:raw="Label marking the first instruction of the filter block.">Bezeichnung, die die erste Anweisung des Filterblocks markiert.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.">Eine Bezeichnung wurde nicht durch einen Anweisungsencoder definiert, dem dieser Generator zugeordnet ist.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Eine Bezeichnung weist den Standardwert auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Adds finally region.">Fügt den Finally-Bereich hinzu.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Bezeichnung, die die erste Anweisung des Try-Blocks markiert.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Bezeichnung, die die Anweisung unmittelbar nach dem Try-Block markiert.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Bezeichnung, die die erste Anweisung des Handlers markiert.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Bezeichnung, die die Anweisung unmittelbar nach dem Handler markiert.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.">Eine Bezeichnung wurde nicht durch einen Anweisungsencoder definiert, dem dieser Generator zugeordnet ist.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Eine Bezeichnung weist den Standardwert auf.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary vsli:raw="Encodes a custom modifier.">Codiert einen benutzerdefinierten Modifizierer.</summary>
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="isOptional" vsli:raw="Is optional modifier.">Ist ein optionaler Modifizierer.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or of an unexpected kind.">
        <paramref name="type" /> ist <see langword="null" /> oder ein unerwarteter Wert.</exception>
      <returns vsli:raw="Encoder of subsequent modifiers.">Encoder nachfolgender Modifizierer.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" vsli:raw="" />
      <param name="operation" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary vsli:raw="Adds an exception clause.">Fügt eine Ausnahmeklausel hinzu.</summary>
      <param name="kind" vsli:raw="Clause kind.">Klauselart.</param>
      <param name="tryOffset" vsli:raw="Try block start offset.">Try-Block-Startoffset.</param>
      <param name="tryLength" vsli:raw="Try block length.">Länge des Try-Blocks.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Startoffset des Handlers.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Länge des Handlers.</param>
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or nil if &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Catch&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> oder Nil, wenn <paramref name="kind" /> nicht <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" /> ist.</param>
      <param name="filterOffset" vsli:raw="Offset of the filter block, or 0 if the &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Filter&quot; /&gt;.">Offset des Filterblocks oder 0, wenn <paramref name="kind" /> nicht <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />ist.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;catchType&quot; /&gt; is invalid.">
        <paramref name="catchType" /> ist ungültig.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;kind&quot; /&gt; has an invalid value.&#xA;          &#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt;, or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="kind" /> besitzt einen ungültigen Wert.
          
- oder -

<paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> oder <paramref name="handlerLength" /> liegt außerhalb des Bereichs.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Im Methodenkörper wurden keine Ausnahmebereiche deklariert.</exception>
      <returns vsli:raw="Encoder for the next clause.">Encoder für die Next-Klausel.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds a fault clause.">Fügt eine Fault-Klausel hinzu.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Try-Block-Startoffset.</param>
      <param name="tryLength" vsli:raw="Try block length.">Länge des Try-Blocks.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Startoffset des Handlers.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Länge des Handlers.</param>
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;catchType&quot; /&gt; is invalid.">
        <paramref name="catchType" /> ist ungültig.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> oder <paramref name="handlerLength" /> liegt außerhalb des Bereichs.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Im Methodenkörper wurden keine Ausnahmebereiche deklariert.</exception>
      <returns vsli:raw="Encoder for the next clause.">Encoder für die Next-Klausel.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Adds a fault clause.">Fügt eine Fault-Klausel hinzu.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Try-Block-Startoffset.</param>
      <param name="tryLength" vsli:raw="Try block length.">Länge des Try-Blocks.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Startoffset des Handlers.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Länge des Handlers.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> oder <paramref name="handlerLength" /> liegt außerhalb des Bereichs.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Im Methodenkörper wurden keine Ausnahmebereiche deklariert.</exception>
      <returns vsli:raw="Encoder for the next clause.">Encoder für die Next-Klausel.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Adds a fault clause.">Fügt eine Fault-Klausel hinzu.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Try-Block-Startoffset.</param>
      <param name="tryLength" vsli:raw="Try block length.">Länge des Try-Blocks.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Startoffset des Handlers.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Länge des Handlers.</param>
      <param name="filterOffset" vsli:raw="Offset of the filter block.">Offset des Filterblocks.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> oder <paramref name="handlerLength" /> liegt außerhalb des Bereichs.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Im Methodenkörper wurden keine Ausnahmebereiche deklariert.</exception>
      <returns vsli:raw="Encoder for the next clause.">Encoder für die Next-Klausel.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Adds a finally clause.">Fügt eine Finally-Klausel hinzu.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Try-Block-Startoffset.</param>
      <param name="tryLength" vsli:raw="Try block length.">Länge des Try-Blocks.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Startoffset des Handlers.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Länge des Handlers.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> oder <paramref name="handlerLength" /> liegt außerhalb des Bereichs.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Im Methodenkörper wurden keine Ausnahmebereiche deklariert.</exception>
      <returns vsli:raw="Encoder for the next clause.">Encoder für die Next-Klausel.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the region fits small format.">Gibt <see langword="true" /> zurück, wenn der Bereich für ein kleines Format geeignet ist.</summary>
      <param name="startOffset" vsli:raw="Start offset of the region.">Der Startoffset des Bereichs.</param>
      <param name="length" vsli:raw="Length of the region.">Die Länge des Bereichs.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the number of exception regions first small format.">Gibt <see langword="true" /> zurück, wenn die Anzahl der Ausnahmebereiche für ein kleines Format geeignet ist.</summary>
      <param name="exceptionRegionCount" vsli:raw="Number of exception regions.">Die Anzahl der Ausnahmebereiche.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary vsli:raw="The underlying builder.">Der zugrundeliegende Generator.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the encoder uses small format.">
        <see langword="true" />, wenn der Encoder ein kleines Format verwendet.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary vsli:raw="Provides an extension method to access the TypeDefinitionId column of the ExportedType table.">Stellt eine Erweiterungsmethode für den Zugriff auf die TypeDefinitionId-Spalte der ExportedType-Tabelle bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary vsli:raw="Gets a hint at the likely row number of the target type in the TypeDef table of its module.&#xA; If the namespaces and names do not match, resolution falls back to a full search of the target TypeDef table. Ignored and should be zero if &lt;see cref=&quot;P:System.Reflection.Metadata.ExportedType.IsForwarder&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">Ruft einen Hinweis auf die wahrscheinliche Zeilennummer des Zieltyps in der TypeDef-Tabelle des Moduls ab.
Wenn die Namespaces und Namen nicht übereinstimmen, wird für die Auflösung auf eine vollständige Suche in der TypeDef-Zieltabelle zurückgegriffen. Wird ignoriert und sollte 0 (null) sein, wenn <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /><see langword="true" />ist.</summary>
      <param name="exportedType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary vsli:raw="Encodes Common Intermediate Language (CIL) instructions.">Codiert Anweisungen.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary vsli:raw="Creates an encoder backed by code and control-flow builders.">Erstellt einen durch Code und Ablaufsteuerungsgeneratoren gestützten Encoder.</summary>
      <param name="codeBuilder" vsli:raw="Builder to write encoded instructions to.">Generator, in den codierte Anweisungen geschrieben werden.</param>
      <param name="controlFlowBuilder" vsli:raw="Builder tracking labels, branches and exception handlers.&#xA; Must be specified to be able to use some of the control-flow factory methods of &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.InstructionEncoder&quot; /&gt;, such as &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt; etc.">Generator-Nachverfolgungsbezeichnungen, Branches und Ausnahmehandler.
Müssen angegeben werden, um einige der Factorymethoden zur Ablaufsteuerung von <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" /> zu verwenden, wie etwa <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /> usw.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Encodes a branch instruction.">Codiert eine Verzweigungsanweisung.</summary>
      <param name="code" vsli:raw="Branch instruction to encode.">Zu codierende Verzweigungsanweisung.</param>
      <param name="label" vsli:raw="Label of the target location in instruction stream.">Bezeichnung des Zielspeicherorts im Anweisungsstream.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;code&quot; /&gt; is not a branch instruction.&#xA;&#xA;-or-&#xA;                    &#xA;&lt;paramref name=&quot;label&quot; /&gt; was not defined by this encoder.">
        <paramref name="code" /> ist keine Branchanweisung.

- oder - 
<paramref name="label" /> wurde nicht von diesem Encoder definiert.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;label&quot; /&gt; has default value.">
        <paramref name="label" /> weist den Standardwert auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Hiermit werden <c>call</c>-Anweisungen und deren Operanden codiert.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Hiermit werden <c>call</c>-Anweisungen und deren Operanden codiert.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Hiermit werden <c>call</c>-Anweisungen und deren Operanden codiert.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Hiermit werden <c>call</c>-Anweisungen und deren Operanden codiert.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;calli&lt;/c&gt; instruction and its operand.">Hiermit werden <c>calli</c>-Anweisungen und deren Operanden codiert.</summary>
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary vsli:raw="Defines a label that can later be used to mark and refer to a location in the instruction stream.">Definiert eine Bezeichnung, die später verwendet werden kann, um einen Speicherort im Anweisungsstream zu markieren und auf ihn zu verweisen.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="Label handle.">Bezeichnungshandle.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary vsli:raw="Encodes argument load instruction.">Codiert die Ladeanweisung des Arguments.</summary>
      <param name="argumentIndex" vsli:raw="Index of the argument.">Index des Arguments.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;argumentIndex&quot; /&gt; is negative.">
        <paramref name="argumentIndex" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary vsli:raw="Encodes argument address load instruction.">Codiert die Ladeanweisung der Argumentadresse.</summary>
      <param name="argumentIndex" vsli:raw="Index of the argument.">Index des Arguments.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;argumentIndex&quot; /&gt; is negative.">
        <paramref name="argumentIndex" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Int32&quot; /&gt; constant load instruction.">Codiert die Ladeanweisung der <see cref="T:System.Int32" />-Konstante.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Int64&quot; /&gt; constant load instruction.">Codiert die Ladeanweisung der <see cref="T:System.Int64" />-Konstante.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Single&quot; /&gt; constant load instruction.">Codiert die Ladeanweisung der <see cref="T:System.Single" />-Konstante.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Double&quot; /&gt; constant load instruction.">Codiert die Ladeanweisung der <see cref="T:System.Double" />-Konstante.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary vsli:raw="Encodes local variable load instruction.">Codiert die Ladeanweisung für lokale Variablen.</summary>
      <param name="slotIndex" vsli:raw="Index of the local variable slot.">Index des Slots der lokalen Variable.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;slotIndex&quot; /&gt; is negative.">
        <paramref name="slotIndex" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary vsli:raw="Encodes local variable address load instruction.">Codiert die Ladeanweisung für Adressen von lokalen Variablen.</summary>
      <param name="slotIndex" vsli:raw="Index of the local variable slot.">Index des Slots der lokalen Variable.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;slotIndex&quot; /&gt; is negative.">
        <paramref name="slotIndex" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;ldstr&lt;/c&gt; instruction and its operand.">Hiermit werden <c>ldstr</c>-Anweisungen und deren Operanden codiert.</summary>
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Associates specified label with the current IL offset.">Ordnet die angegebene Bezeichnung dem aktuellen IL-Offset zu.</summary>
      <param name="label" vsli:raw="Label to mark.">Zu markierende Bezeichnung.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;label&quot; /&gt; was not defined by this encoder.">
        <paramref name="label" /> wurde nicht von diesem Encoder definiert.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;label&quot; /&gt; has default value.">
        <paramref name="label" /> weist den Standardwert auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Encodes specified op-code.">Codiert den angegebenen OP-Code.</summary>
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary vsli:raw="Encodes argument store instruction.">Codiert die Speicheranweisung des Arguments.</summary>
      <param name="argumentIndex" vsli:raw="Index of the argument.">Index des Arguments.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;argumentIndex&quot; /&gt; is negative.">
        <paramref name="argumentIndex" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary vsli:raw="Encodes local variable store instruction.">Codiert die Speicheranweisung für lokale Variablen.</summary>
      <param name="slotIndex" vsli:raw="Index of the local variable slot.">Index des Slots der lokalen Variable.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;slotIndex&quot; /&gt; is negative.">
        <paramref name="slotIndex" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary vsli:raw="Encodes a token.">Codiert ein Token.</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Encodes a token.">Codiert ein Token.</summary>
      <param name="handle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary vsli:raw="Underlying builder where encoded instructions are written to.">Zugrundeliegender Generator, in den codierte Anweisungen geschrieben werden.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary vsli:raw="Builder tracking labels, branches and exception handlers.">Generator-Nachverfolgungsbezeichnungen, Branches und Ausnahmehandler.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary vsli:raw="Offset of the next encoded instruction.">Offset der nächsten codierten Anweisung.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary vsli:raw="1-based id identifying the label within the context of a &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder&quot; /&gt;.">ID mit der Basis 1 zur Identifizierung der Bezeichnung im Kontext eines <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary vsli:raw="Provides methods for encoding literals.">Stellt Methoden zum Codieren von Literalen bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.LiteralEncoder&quot; /&gt; class with the specified blob builder.">Erstellt eine neue Instanz der <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" />-Klasse mit dem angegebenen Blob-Generator.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary vsli:raw="Returns the encoder used to encode the literal value.">Gibt den Encoder zurück, der zum Codieren des Literalwerts verwendet wird.</summary>
      <returns vsli:raw="The encoder of the literal value.">Der Encoder des Literalwerts.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary vsli:raw="Encodes the type and the value of a literal using the specified delegates.">Codiert den Typ und den Wert eines Literals mithilfe der angegebenen Delegaten.</summary>
      <param name="type" vsli:raw="A delegate used to encode the type of the literal. Called first by this method.">Ein Delegat, der verwendet wird, um den Typ des Literals zu codieren. Wird von dieser Methode zuerst aufgerufen.</param>
      <param name="scalar" vsli:raw="A delegate used to encode the value of the literal. Called second by this method.">Ein Delegat, der verwendet wird, um den Wert des Literals zu codieren. Wird von dieser Methode als zweites aufgerufen.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;scalar&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> oder <paramref name="scalar" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and value of a literal in the order they appear in the parameter list.">Gibt ein Encoderpaar zurück, das zum Codieren des Typs und des Werts eines Literals in der Reihenfolge verwendet werden muss, in der sie in der Parameterliste stehen.</summary>
      <param name="type" vsli:raw="When this method returns, a custom attribute element type encoder used to encode the type of the literal.">Nach Ausführung dieser Methode ein benutzerdefinierter Attributelementtyp-Encoder, der verwendet wird, um den Typ des Literals zu codieren.</param>
      <param name="scalar" vsli:raw="When this method returns, a scalar encoded used to encode the value of the literal.">Nach Ausführung dieser Methode ein codierter Skalarwert, der verwendet wird, um den Wert des Literals zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary vsli:raw="Encodes the type and the items of a vector literal using the specified delegates.">Codiert den Typ und die Elemente eines Vektors mithilfe der angegebenen Delegaten.</summary>
      <param name="arrayType" vsli:raw="A delegate used to encode the type of the vector. Called first by this method.">Ein Delegat, der verwendet wird, um den Typ des Vektors zu codieren. Wird von dieser Methode zuerst aufgerufen.</param>
      <param name="vector" vsli:raw="A delegate used to encode the items of the vector. Called second by this method.">Ein Delegat, der verwendet wird, um die Elemente des Vektors zu codieren. Wird von dieser Methode als zweites aufgerufen.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;arrayType&quot; /&gt; or &lt;paramref name=&quot;vector&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="arrayType" /> oder <paramref name="vector" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and the items of a vector literal in the order they appear in the parameter list.">Gibt ein Encoderpaar zurück, das zum Codieren des Typs und der Elemente eines Vektorliterals in der Reihenfolge verwendet werden muss, in der sie in der Parameterliste stehen.</summary>
      <param name="arrayType" vsli:raw="When this method returns, a custom attribute array type encoder used to encode the type of the vector.">Nach Ausführung dieser Methode ein benutzerdefinierter Attributarraytyp-Encoder, der verwendet wird, um den Typ des Vektors zu codieren.</param>
      <param name="vector" vsli:raw="When this method returns, a vector encoder used to encode the items of the vector.">Nach Ausführung dieser Methode ein codierter Vektor, der verwendet wird, um die Elemente des Vektors zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary vsli:raw="Gets a vector encoder used to encode the items of a vector.">Ruft einen Vektorencoder ab, der zum Codieren der Elemente eines Vektors verwendet wird.</summary>
      <returns vsli:raw="A vector encoder used to encode the items of a vector.">Ein Vektorencoder, der zum Codieren der Elemente eines Vektors verwendet wird.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" vsli:raw="" />
      <param name="isPinned" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" vsli:raw="" />
      <param name="baseHeapSizes" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary vsli:raw="Calculates the handle of the entity within the metadata generation it is defined in, given a handle of an entity in an aggregate metadata.">Berechnet das Handle der Entität in der Metadatengenerierung, in der sie definiert ist, wenn ein Handle einer Entität in Aggregatmetadaten angegeben ist.</summary>
      <param name="handle" vsli:raw="Handle of an entity in an aggregate metadata.">Handle einer Entität in Aggregatmetadaten.</param>
      <param name="generation" vsli:raw="The generation the entity is defined in.">Die Generierung, in der die Entität definiert ist.</param>
      <returns vsli:raw="Handle of the entity within the metadata &lt;paramref name=&quot;generation&quot; /&gt;.">Handle der Entität in der Metadaten-<paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary vsli:raw="The MetadataBuilder class writes metadata for an assembly in a highly performant manner. It is designed for use by compilers and other assembly generation tools.">Die MetadataBuilder-Klasse liest und schreibt Metadaten für eine Assembly auf sehr leistungsfähige Weise. Sie dient der Verwendung durch Compiler und andere Tools zum Generieren von Assemblys.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a builder for metadata tables and heaps.">Erstellt einen Generator für Metadatentabellen und Heaps.</summary>
      <param name="userStringHeapStartOffset" vsli:raw="The start offset of the User String heap. The cumulative size of User String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Das Anfangsoffset des Benutzerzeichenfolgenheaps. Die kumulierte Größe von Benutzerzeichenfolgenheaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
      <param name="stringHeapStartOffset" vsli:raw="The start offset of the String heap. The cumulative size of String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Das Anfangsoffset des Zeichenfolgenheaps. Die kumulierte Größe von Zeichenfolgenheaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
      <param name="blobHeapStartOffset" vsli:raw="The start offset of the Blob heap. The cumulative size of Blob heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Das Anfangsoffset des Blobheaps. Die kumulierte Größe von Blobheaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
      <param name="guidHeapStartOffset" vsli:raw="The start offset of the Guid heap. The cumulative size of Guid heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">Das Anfangsoffset des GUID-Heaps. Die kumulierte Größe von GUID-Heaps aller früheren EnC-Generationen muss 0 sein, außer es handelt sich bei den Metadaten um EnC-Delta-Metadaten.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="Offset is too big.">Der Offset ist zu groß.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Offset is negative.">Der Offset ist negativ.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;guidHeapStartOffset&quot; /&gt; is not a multiple of size of GUID.">
        <paramref name="guidHeapStartOffset" /> ist kein Vielfaches der GUID-Größe.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKey" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashAlgorithm" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
      <param name="containsMetadata" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKeyOrToken" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary vsli:raw="Adds a default value for a parameter, field or property.">Fügt einen Standardwert für einen Parameter, ein Feld oder eine Eigenschaft hinzu.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value" vsli:raw="The constant value.">Der konstante Wert.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added constant.">Ein Handle für die hinzugefügte Konstante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a custom attribute.">Fügt ein benutzerdefiniertes Attribut hinzu.</summary>
      <param name="parent" vsli:raw="An entity to attach the custom attribute to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;.">Eine Entität zum Anfügen des benutzerdefinierten Attributs an folgende Handles: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor" vsli:raw="A custom attribute constructor: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Ein benutzerdefinierter Attributkonstruktor: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value" vsli:raw="A custom attribute value blob.">Ein benutzerdefiniertes Attributwertblob.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added custom attribute.">Ein Handle für das hinzugefügte benutzerdefinierte Attribut.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds custom debug information.">Fügt benutzerdefinierte Debuginformationen hinzu.</summary>
      <param name="parent" vsli:raw="An entity to attach the debug information to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;.">Eine Entität zum Anfügen der Debuginformationen an folgende Handles: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> oder <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind" vsli:raw="The information kind. Determines the structure of the &lt;paramref name=&quot;value&quot; /&gt; blob.">Die Art der Informationen. Bestimmt die Struktur des <paramref name="value" />-Blobs.</param>
      <param name="value" vsli:raw="The custom debug information blob.">Das Blob für benutzerdefinierte Debuginformationen.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added custom debug information.">Ein Handle für die hinzugefügten benutzerdefinierten Debuginformationen.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a declarative security attribute to a type, method, or assembly.">Fügt einem Typ, einer Methode oder einer Assembly ein deklaratives Sicherheitsattribut hinzu.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;.">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action" vsli:raw="A declarative security action.">Eine deklarative Sicherheitsaktion.</param>
      <param name="permissionSet" vsli:raw="The permission set blob.">Das Blob für den Berechtigungssatz.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added declarative security attribute.">Ein Handle für das hinzugefügte deklarative Sicherheitsattribut.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Adds document debug information.">Fügt Dokumentdebuginformationen hinzu.</summary>
      <param name="name" vsli:raw="The document name blob.">Das Dokumentnamenblob.</param>
      <param name="hashAlgorithm" vsli:raw="THe GUID of the hash algorithm used to calculate the value of &lt;paramref name=&quot;hash&quot; /&gt;.">Die GUID des Hashalgorithmus, die zum Berechnen des Werts von <paramref name="hash" /> verwendet wird.</param>
      <param name="hash" vsli:raw="The hash of the document content.">Der Hash des Dokumenteninhalts.</param>
      <param name="language" vsli:raw="The GUID of the language.">Die GUID der Sprache.</param>
      <returns vsli:raw="A handle to the added document.">Ein Handle für das hinzugefügte Dokument.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" vsli:raw="" />
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an event definition.">Fügt eine Ereignisdefinition hinzu.</summary>
      <param name="attributes" vsli:raw="The event attributes.">Die Ereignisattribute.</param>
      <param name="name" vsli:raw="The event name.">Der Name des Ereignisses.</param>
      <param name="type" vsli:raw="The type of the event: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Der Typ des Ereignisses: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="type" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added event definition.">Ein Handle für die hinzugefügte Ereignisdefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="eventList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary vsli:raw="Adds an exported type.">Fügt einen exportierten Typ hinzu.</summary>
      <param name="attributes" vsli:raw="The type attributes.">Die Typattribute.</param>
      <param name="namespace" vsli:raw="The type namespace.">Der Typnamespace.</param>
      <param name="name" vsli:raw="The type name.">Der Typname.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: an &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;.">Das Handle der Implementierungsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> oder <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId" vsli:raw="The type definition ID.">Die Typdefinitions-ID.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;implementation&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="implementation" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added exported type.">Ein Handle für den hinzugefügten exportierten Typ.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a field definition.">Fügt eine Felddefinition hinzu.</summary>
      <param name="attributes" vsli:raw="The field attributes.">Die Feldattribute.</param>
      <param name="name" vsli:raw="The field name.">Der Feldname.</param>
      <param name="signature" vsli:raw="The field signature. Use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature&quot; /&gt; to construct the blob.">Die Feldsignatur. Verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" />, um das Blob zu erstellen.</param>
      <returns vsli:raw="A handle to the added field definition.">Ein Handle für die hinzugefügte Felddefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Defines a field layout of a field definition.">Definiert ein Feldlayout einer Felddefinition.</summary>
      <param name="field" vsli:raw="The field definition handle.">Das Felddefinitionshandle.</param>
      <param name="offset" vsli:raw="The byte offset of the field within the declaring type instance.">Der Byteoffset des Felds in der deklarierenden Typinstanz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Adds a mapping from a field to its initial value stored in the PE image.">Fügt dem im PE-Image gespeicherten Anfangswert eine Zuordnung von einem Feld hinzu.</summary>
      <param name="field" vsli:raw="The field definition handle.">Das Felddefinitionshandle.</param>
      <param name="offset" vsli:raw="The offset within the block in the PE image that stores initial values of mapped fields (usually in the .text section).">Der Offset innerhalb des Blocks im PE-Image, das Anfangswerte zugeordneter Felder speichert (normalerweise im .text-Abschnitt).</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;offset&quot; /&gt; is negative.">
        <paramref name="offset" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a generic parameter definition.">Fügt eine generische Parameterdefinition hinzu.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be either a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;.">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes" vsli:raw="The generic parameter attributes.">Die generischen Parameterattribute.</param>
      <param name="name" vsli:raw="The parameter name.">Der Name des Parameters.</param>
      <param name="index" vsli:raw="The zero-based parameter index.">Der nullbasierte Parameterindex.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> weist nicht das erwartete Handle auf.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is greater than &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;.">
        <paramref name="index" /> ist größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns vsli:raw="A handle to the added generic parameter.">Ein Handle für den hinzugefügten generischen Parameter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds a type constraint to a generic parameter.">Fügt einem generischen Parameter eine Typeinschränkung hinzu.</summary>
      <param name="genericParameter" vsli:raw="The generic parameter to constrain.">Der einzuschränkende generischen Parameter.</param>
      <param name="constraint" vsli:raw="The type constraint, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Die Typeinschränkung. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;genericParameter&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="genericParameter" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added generic parameter constraint.">Ein Handle für die hinzugefügte Einschränkung des generischen Parameters.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local scope debug information.">Fügt Debuginformationen für den lokalen Bereich hinzu.</summary>
      <param name="parentScope" vsli:raw="The parent scope handle.">Das übergeordnete Bereichshandle.</param>
      <param name="imports" vsli:raw="The import scope handle.">Das Importbereichshandle.</param>
      <returns vsli:raw="A handle to the added import scope.">Ein Handle für den hinzugefügten Importbereich.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an interface implementation to a type.">Fügt einem Typ eine Schnittstellenimplementierung hinzu.</summary>
      <param name="type" vsli:raw="The type implementing the interface.">Der Typ, der die Schnittstelle implementiert.</param>
      <param name="implementedInterface" vsli:raw="The interface being implemented, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Die Schnittstelle, die implementiert wird. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;implementedInterface&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="implementedInterface" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added interface implementation.">Ein Handle für die hinzugefügte Schnittstellenimplementierung.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local constant debug information.">Fügt Debuginformationen für die lokale Konstante hinzu.</summary>
      <param name="name" vsli:raw="The name of the variable.">Der Name der Variablen.</param>
      <param name="signature" vsli:raw="The LocalConstantSig blob.">Das LocalConstantSig-Blob.</param>
      <returns vsli:raw="A handle to the added local constant.">Ein Handle für die hinzugefügte lokale Konstante.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary vsli:raw="Adds local scope debug information.">Fügt Debuginformationen für den lokalen Bereich hinzu.</summary>
      <param name="method" vsli:raw="The containing method.">Die Methode mit Inhalt.</param>
      <param name="importScope" vsli:raw="The handle of the associated import scope.">Das Handle des zugeordneten Importbereichs.</param>
      <param name="variableList" vsli:raw="If the scope declares variables, set this to the handle of the first one. Otherwise, set this to the handle of the first variable declared by the next scope definition. If no scope defines any variables, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)&quot; /&gt;.">Wenn mit dem Bereich Variablen deklariert werden, legen Sie hierfür das Handle der ersten Variablen fest. Oder legen Sie hierfür das Handle der ersten Variablen fest, die mit der nächsten Bereichsdefinition deklariert wird. Wenn mit keinem Bereich Variablen definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
      <param name="constantList" vsli:raw="If the scope declares constants, set this the handle of the first one. Otherwise, set this to the handle of the first constant declared by the next scope definition. If no scope defines any constants, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)&quot; /&gt;.">Wenn mit dem Bereich Konstanten deklariert werden, legen Sie hierfür das Handle der ersten Variablen fest. Oder legen Sie hierfür das Handle der ersten Konstante fest, die mit der nächsten Bereichsdefinition deklariert wird. Wenn mit keinem Bereich Konstanten definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
      <param name="startOffset" vsli:raw="The offset of the first instruction covered by the scope.">Der vom Bereich abgedeckte Offset der ersten Anweisung.</param>
      <param name="length" vsli:raw="The length (in bytes) of the scope.">Die Länge des Bereichs (in Byte).</param>
      <returns vsli:raw="A handle to the added local scope.">Ein Handle für den hinzugefügten lokalen Bereich.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds local variable debug information.">Fügt Debuginformationen für die lokale Variable hinzu.</summary>
      <param name="attributes" vsli:raw="The local variable attributes.">Die Attribute der lokalen Variable.</param>
      <param name="index" vsli:raw="The zero-base index of the local variable in the local signature.">Der nullbasierte Index der lokalen Variable in der lokalen Signatur.</param>
      <param name="name" vsli:raw="The name of the variable.">Der Name der Variablen.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is greater than &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;.">
        <paramref name="index" /> ist größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns vsli:raw="A handle to the added local variable.">Ein Handle für die hinzugefügte lokale Variable.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary vsli:raw="Adds a manifest resource.">Fügt eine Manifestressource hinzu.</summary>
      <param name="attributes" vsli:raw="The manifest resource attributes.">Die Attribute der Manifestressource.</param>
      <param name="name" vsli:raw="The name of the manifest resource.">Der Name der Manifestressource.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">Das Handle der Implementierungsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> oder <see langword="null" />.</param>
      <param name="offset" vsli:raw="Specifies the byte offset within the referenced file at which this resource record begins.">Gibt den Byteoffset in der referenzierten Datei an, an dem dieser Ressourceneintrag beginnt.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;implementation&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="implementation" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added manifest resource.">Ein Handle für die hinzugefügte Manifestressource.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds marshalling information to a field or a parameter.">Fügt einem Feld oder einem Parameter Marshallinginformationen hinzu.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;.">Das Handle der übergeordneten Entität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> oder <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor" vsli:raw="The descriptor blob.">Das Deskriptorblob.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> weist nicht das erwartete Handle auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a MemberRef table row.">Fügt eine MemberRef-Tabellenzeile hinzu.</summary>
      <param name="parent" vsli:raw="The containing entity, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">Die Entität mit Inhalt. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name" vsli:raw="The member name.">Der Membername.</param>
      <param name="signature" vsli:raw="The member signature.">Die Membersignatur.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added member reference.">Ein Handle für den hinzugefügten Memberverweis.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds method debug information.">Fügt Debuginformationen für die Methode hinzu.</summary>
      <param name="document" vsli:raw="The handle of a single document containing all sequence points of the method, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">Das Handle eines einzelnen Dokuments, das alle Sequenzpunkte der Methode enthält, oder <see langword="null" />, wenn die Methode keine Sequenzpunkte enthält oder mehrere Dokumente umfasst.</param>
      <param name="sequencePoints" vsli:raw="The sequence Points blob, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points.">Das Sequenzpunkteblob, oder <see langword="null" />, wenn die Methode keine Sequenzpunkte enthält.</param>
      <returns vsli:raw="A handle to the added method debug information.">Ein Handle für die hinzugefügten Debuginformationen für die Methode.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary vsli:raw="Adds a method definition.">Fügt eine Methodendefinition hinzu.</summary>
      <param name="attributes" vsli:raw="The method attributes.">Die Methodenattribute.</param>
      <param name="implAttributes" vsli:raw="The method implementation attributes.">Die Methodenimplementierungsattribute.</param>
      <param name="name" vsli:raw="The method name.">Der Methodenname.</param>
      <param name="signature" vsli:raw="The method signature.">Die Methodensignatur.</param>
      <param name="bodyOffset" vsli:raw="Offset within the block in the PE image that stores method bodies (the IL stream), or -1 if the method doesn't have a body.">Offset innerhalb des Blocks im PE-Image, das Methodenkörper (IL-Stream) speichert, oder-1, wenn die Methode keinen Körper enthält.</param>
      <param name="parameterList" vsli:raw="If the method declares parameters in the Params table, set this to the handle of the first one. Otherwise, set this to the handle of the first parameter declared by the next method definition. If no parameters are declared in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)&quot; /&gt;.">Wenn mit der Methode in der Parametertabelle Parameter deklariert werden, legen Sie hierfür das Handle des ersten Parameters fest. Oder legen Sie hierfür das Handle des ersten Parameters fest, der mit der nächsten Methodendefinition deklariert wird. Wenn im Modul keine Parameter deklariert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;bodyOffset&quot; /&gt; is less than -1.">
        <paramref name="bodyOffset" /> ist kleiner als -1.</exception>
      <returns vsli:raw="A handle to the added method definition.">Ein Handle für die hinzugefügte Methodendefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Defines an implementation for a method declaration within a type.">Definiert eine Implementierung für eine Methodendeklaration innerhalb eines Typs.</summary>
      <param name="type" vsli:raw="The type definition.">Die Typdefinition.</param>
      <param name="methodBody" vsli:raw="The method body entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Das Handle der Methodenkörperentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration" vsli:raw="The method declaration entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Das Handle der Methodendeklarationsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;methodBody&quot; /&gt; or &lt;paramref name=&quot;methodDeclaration&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="methodBody" /> oder <paramref name="methodDeclaration" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added method implementation.">Ein Handle für die hinzugefügte Methodenimplementierung.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary vsli:raw="Adds import information to a method definition.">Fügt einer Methodendefinition Importinformationen hinzu.</summary>
      <param name="method" vsli:raw="The method definition handle.">Das Handle der Methodendefinition.</param>
      <param name="attributes" vsli:raw="The method import attributes.">Die Methodenimportattribute.</param>
      <param name="name" vsli:raw="The unmanaged method name.">Der Name der nicht verwalteten Methode.</param>
      <param name="module" vsli:raw="The module containing the unmanaged method.">Das Modul, das die nicht verwaltete Methode enthält.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Associates a method (a getter, a setter, an adder, etc.) with a property or an event.">Ordnet eine Methode (Getter, Setter, Adder usw.) einer Eigenschaft oder einem Ereignis zu.</summary>
      <param name="association" vsli:raw="The association entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">Das Handle der Zuordnungsentität. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics" vsli:raw="The method semantics attributes.">Die Attribute der Methodensemantik.</param>
      <param name="methodDefinition" vsli:raw="The method definition.">Die Methodendefinition.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;association&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="association" /> weist nicht das erwartete Handle auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a method specification (an instantiation).">Fügt eine Methodenspezifikation (Instanziierung) hinzu.</summary>
      <param name="method" vsli:raw="The generic method entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Das Handle der Entität der generischen Methode. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation" vsli:raw="The instantiation blob encoding the generic arguments of the method.">Das Instanziierungsblob, das die generischen Argumente der Methode codiert.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="method" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added method specification.">Ein Handle für die hinzugefügte Methodenspezifikation.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" vsli:raw="" />
      <param name="moduleName" vsli:raw="" />
      <param name="mvid" vsli:raw="" />
      <param name="encId" vsli:raw="" />
      <param name="encBaseId" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary vsli:raw="Defines a nesting relationship to specified type definitions.">Definiert eine Schachtelungsbeziehung mit angegebenen Typdefinitionen.</summary>
      <param name="type" vsli:raw="The nested type definition handle.">Das Handle der Definition des geschachtelten Typs.</param>
      <param name="enclosingType" vsli:raw="The enclosing type definition handle.">Das Handle der Definition des einschließenden Typs.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a parameter definition.">Fügt eine Parameterdefinition hinzu.</summary>
      <param name="attributes" vsli:raw="The parameter attributes.">Die Parameterattribute.</param>
      <param name="name" vsli:raw="Optional. The parameter name.">Dies ist optional. Der Name des Parameters.</param>
      <param name="sequenceNumber" vsli:raw="The sequence number of the parameter. A value of 0 refers to the owner method's return type; its parameters are then numbered from 1 onward.">Die Sequenznummer des Parameters. Der Wert 0 bezieht sich auf den Rückgabetyp der Besitzermethode. Die zugehörigen Parameter werden ab hier beginnend mit 1 nummeriert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sequenceNumber&quot; /&gt; is greater than &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;.">
        <paramref name="sequenceNumber" /> ist größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns vsli:raw="A handle to the added parameter.">Ein Handle für den hinzugefügten Parameter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a property definition.">Fügt eine Eigenschaftsdefinition hinzu.</summary>
      <param name="attributes" vsli:raw="The property attributes.">Die Eigenschaftsattribute.</param>
      <param name="name" vsli:raw="The property name.">Der Eigenschaftenname.</param>
      <param name="signature" vsli:raw="The signature of the property.">Die Signatur der Eigenschaft.</param>
      <returns vsli:raw="A handle to the added property definition.">Ein Handle für die hinzugefügte Eigenschaftsdefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="propertyList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds state machine method debug information.">Fügt Debuginformationen für die Zustandsautomatenmethode hinzu.</summary>
      <param name="moveNextMethod" vsli:raw="The handle of the &lt;see langword=&quot;MoveNext&quot; /&gt; method of the state machine (the compiler-generated method).">Das Handle der <see langword="MoveNext" />-Methode des Zustandsautomaten (die vom Compiler generierte Methode).</param>
      <param name="kickoffMethod" vsli:raw="The handle of the kickoff method (the user defined iterator/async method).">Das Handle der Kickoffmethode (die benutzerdefinierte Iterator-/Async-Methode).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds a type definition.">Fügt eine Typdefinition hinzu.</summary>
      <param name="attributes" vsli:raw="The type attributes.">Die Typattribute.</param>
      <param name="namespace" vsli:raw="The type namespace.">Der Typnamespace.</param>
      <param name="name" vsli:raw="The type name.">Der Typname.</param>
      <param name="baseType" vsli:raw="The base type entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">Das Handle der Basistypentität. Hierbei kann es sich um eines der folgenden Handels handeln<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> oder <see langword="null" />.</param>
      <param name="fieldList" vsli:raw="If the type declares fields, set this to the handle of the first one. Otherwise, set this to the handle of the first field declared by the next type definition. If no type defines any fields in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)&quot; /&gt;.">Wenn mit dem Typ Felder deklariert werden, legen Sie hierfür das Handle des ersten Felds fest. Oder legen Sie hierfür das Handle des ersten Felds fest, das mit der nächsten Typdefinition deklariert wird. Wenn im Modul durch den Typ keine Felder definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
      <param name="methodList" vsli:raw="If the type declares methods, the handle of the first one. Otherwise, the handle of the first method declared by the next type definition. If no type defines any methods in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)&quot; /&gt;.">Wenn mit dem Typ Methoden deklariert werden, legen Sie hierfür das Handle der ersten Methode fest. Oder legen Sie hierfür das Handle der ersten Methode fest, die mit der nächsten Typdefinition deklariert wird. Wenn im Modul durch den Typ keine Methoden definiert werden, gilt: <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;baseType&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="baseType" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added type definition.">Ein Handle für die hinzugefügte Typdefinition.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary vsli:raw="Defines a type layout of a type definition.">Definiert ein Typlayout einer Typdefinition.</summary>
      <param name="type" vsli:raw="The type definition.">Die Typdefinition.</param>
      <param name="packingSize" vsli:raw="Specifies that fields should be placed within the type instance at byte addresses which are a multiple of &lt;paramref name=&quot;packingSize&quot; /&gt;, or at natural alignment for that field type, whichever is smaller. Its value should be one of the following: 0, 1, 2, 4, 8, 16, 32, 64, or 128. A value of zero indicates that the packing size used should match the default for the current platform.">Gibt an, dass Felder in der Typinstanz mit Byteadressen platziert werden müssen, bei denen es sich um ein Vielfaches von <paramref name="packingSize" /> handelt, oder mit einer natürlichen Ausrichtung für diesen Feldtyp, je nachdem, welcher Wert kleiner ist. Der Wert muss einer der folgenden sein: 0, 1, 2, 4, 8, 16, 32, 64 oder 128. Der Wert 0 (null) gibt an, dass die verwendete Paketgröße mit der Standardeinstellung für die aktuelle Plattform übereinstimmen muss.</param>
      <param name="size" vsli:raw="Indicates a minimum size of the type instance and is intended to allow for padding. The amount of memory allocated is the maximum of the size calculated from the layout and &lt;paramref name=&quot;size&quot; /&gt;. Note that if this directive applies to a value type, then the size will be less than 1 MB.">Gibt eine Mindestgröße für die Typinstanz an, und soll ein Auffüllen ermöglichen. Der zugeordnete Arbeitsspeicher entspricht dem Maximalwert für die Größe, die für das Layout und <paramref name="size" /> berechnet wird. Wenn diese Direktive auf einen Werttyp angewendet wird, ist die Größe kleiner als 1 MB.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds a type reference.">Fügt einen Typverweis hinzu.</summary>
      <param name="resolutionScope" vsli:raw="The entity declaring the target type, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">Die Entität, mit der der Zieltyp deklariert wird. Hierbei kann es sich um eines der folgenden Handels handeln: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see langword="null" />.</param>
      <param name="namespace" vsli:raw="The type reference namespace.">Der Namespace des Typverweises.</param>
      <param name="name" vsli:raw="The type reference name.">Der Name des Typverweises.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;resolutionScope&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="resolutionScope" /> weist nicht das erwartete Handle auf.</exception>
      <returns vsli:raw="A handle to the added type reference.">Ein Handle für den hinzugefügten Typverweis.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary vsli:raw="Adds the specified blob to the Blob heap, if it's not there already.">Fügt dem Blobheap das angegebene Blob hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The array containing the blob.">Das Array, welches das Blob enthält.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds the specified blob from a byte array to the Blob heap, if it's not there already.">Fügt dem Blobheap das angegebene Blob aus dem Bytearray hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The array containing the blob.">Das Array, welches das Blob enthält.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Adds the specified blob from an immutable byte array to the Blob heap, if it's not there already.">Fügt dem Blobheap das angegebene Blob aus einem unveränderlichen Bytearray hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The blob builder instance containing the blob.">Die Blobgeneratorinstanz, die das Blob enthält.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary vsli:raw="Encodes a string using UTF16 encoding to a blob and adds it to the Blob heap, if it's not there already.">Codiert eine Zeichenfolge mithilfe der UTF16-Codierung in ein Blob, und fügt sie dem Blobheap hinzu, wenn sie nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The string to add.">Die hinzuzufügende Zeichenfolge.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Encodes a string using UTF8 encoding to a blob and adds it to the Blob heap, if it's not there already.">Codiert eine Zeichenfolge mithilfe der UTF8-Codierung in ein Blob, und fügt es dem Blobheap hinzu, sofern es nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The value to add.">Der hinzuzufügende Wert.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with the U+FFFD character.">
        <see langword="true" />, um die nicht gepaarten Ersatzzeichen wie angegeben zu codieren, <see langword="false" />, um sie durch das U+FFFD-Zeichen zu ersetzen.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary vsli:raw="Encodes a constant value to a blob and adds it to the Blob heap, if it's not there already. Uses UTF16 to encode string constants.">Codiert einen konstanten Wert in ein Blob, und fügt es dem Blobheap hinzu, sofern es nicht bereits enthalten ist. Verwendet UTF16 zum Codieren von Zeichenfolgenkonstanten.</summary>
      <param name="value" vsli:raw="The constant value to add.">Der hinzuzufügende konstante Wert.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Ein Handle für das hinzugefügte oder vorhandene Blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary vsli:raw="Encodes a debug document name and adds it to the Blob heap, if it's not there already.">Codiert einen Debugdokumentnamen, und fügt ihn dem Blobheap hinzu, sofern er nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The document name to add.">Der Dokumentname, der hinzugefügt werden soll.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing document name blob.">Ein Handle für das hinzugefügte oder vorhandene Dokumentnamenblob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary vsli:raw="Adds the specified Guid to the Guid heap, if it's not there already.">Fügt dem GUID-Heap die angegebene GUID hinzu, sofern sie nicht bereits enthalten ist.</summary>
      <param name="guid" vsli:raw="The Guid to add.">Die GUID, die hinzugefügt werden soll.</param>
      <returns vsli:raw="A handle to the added or existing Guid.">Ein Handle für die hinzugefügte oder vorhandene GUID.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary vsli:raw="Adds the specified string to the string heap, if it's not there already.">Fügt dem Zeichenfolgenheap die angegebene Zeichenfolge hinzu, sofern sie nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The string to add.">Die hinzuzufügende Zeichenfolge.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing string.">Ein Handle für die hinzugefügte oder vorhandene Zeichenfolge.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary vsli:raw="Adds the specified string to the user string heap, if it's not there already.">Fügt dem Benutzerzeichenfolgenheap die angegebene Zeichenfolge hinzu, sofern sie nicht bereits enthalten ist.</summary>
      <param name="value" vsli:raw="The string to add.">Die hinzuzufügende Zeichenfolge.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="The remaining space on the heap is too small to fit the string.">Der verbleibende Speicherplatz auf dem Heap ist zu klein für die Zeichenfolge.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing string. This value may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.">Ein Handle für die hinzugefügte oder vorhandene Zeichenfolge. Dieser Wert kann in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> verwendet werden.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the current number of items in the specified table.">Gibt die aktuelle Anzahl der Elemente in der angegebenen Tabelle zurück.</summary>
      <param name="table" vsli:raw="The table index.">Der Tabellenindex.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;table&quot; /&gt; is not a valid table index.">
        <paramref name="table" /> ist kein gültiger Tabellenindex.</exception>
      <returns vsli:raw="The number of items in the table.">Die Anzahl der Elemente in der Tabelle.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary vsli:raw="Returns the current number of items in each table.">Gibt die aktuelle Anzahl der Elemente in den einzelnen Tabellen zurück.</summary>
      <returns vsli:raw="An array of size &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;, with each item filled with the current row count of the corresponding table.">Ein Array der Größe <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, wobei jedes Element die aktuelle Zeilenanzahl der entsprechenden Tabelle enthält.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary vsli:raw="Reserves space on the Guid heap for a GUID.">Reserviert im GUID-Heap Speicherplatz für eine GUID.</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="The remaining space on the heap is too small to fit the string.">Der verbleibende Speicherplatz auf dem Heap ist zu klein für die Zeichenfolge.</exception>
      <returns vsli:raw="A handle to the reserved Guid and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the GUID blob as stored on the heap.">Ein Handle für die reservierte GUID und ein <see cref="T:System.Reflection.Metadata.Blob" />, welches das GUID-Blob wie im Heap gespeichert darstellt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary vsli:raw="Reserves space on the user string heap for a string of the specified length.">Reserviert im Benutzerzeichenfolgenheap Speicherplatz für eine Zeichenfolge der angegebenen Länge.</summary>
      <param name="length" vsli:raw="The number of characters to reserve.">Die Anzahl der zu reservierenden Zeichen.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="The remaining space on the heap is too small to fit the string.">Der verbleibende Speicherplatz auf dem Heap ist zu klein für die Zeichenfolge.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is negative.">
        <paramref name="length" /> ist ein negativer Wert.</exception>
      <returns vsli:raw="A handle to the reserved user string and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the entire User String blob (including its length and terminal character). The handle may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.&#xA; Use &lt;see cref=&quot;M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)&quot; /&gt; to fill in the blob content.">Ein Handle für die reservierte Benutzerzeichenfolge und ein <see cref="T:System.Reflection.Metadata.Blob" />, welches das gesamte Benutzerzeichenfolgenblob (einschließlich Länge und Terminalzeichen) darstellt. Das Handle kann in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> verwendet werden.
Verwenden Sie <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" />, um den Blobinhalt aufzufüllen.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified heap.">Legt die Kapazität des angegebenen Heaps fest.</summary>
      <param name="heap" vsli:raw="The heap index.">Der Heapindex.</param>
      <param name="byteCount" vsli:raw="The number of bytes.">Die Anzahl der Bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;heap&quot; /&gt; is not a valid heap index.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="heap" /> ist kein gültiger Heapindex.

- oder -

<paramref name="byteCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified table.">Legt die Kapazität der angegebenen Tabelle fest.</summary>
      <param name="table" vsli:raw="The table index.">Der Tabellenindex.</param>
      <param name="rowCount" vsli:raw="The number of rows in the table.">Die Anzahl der Zeilen in der Tabelle.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;table&quot; /&gt; is not a valid table index.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;rowCount&quot; /&gt; is negative.">
        <paramref name="table" /> ist kein gültiger Tabellenindex.

- oder -

<paramref name="rowCount" /> ist ein negativer Wert.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary vsli:raw="Provides extension methods for working with certain raw elements of the ECMA-335 metadata tables and heaps.">Stellt Erweiterungsmethoden für die Verwendung von bestimmten Rohelementen der ECMA-335-Metadatentabellen und -Heaps bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC log.">Listet Einträge des EnC-Protokolls auf.</summary>
      <param name="reader" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC map.">Listet Einträge der EnC-Zuordnung auf.</summary>
      <param name="reader" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified heap.">Gibt den Offset vom Beginn der Metadaten zum angegebenen Heap zurück.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;heapIndex&quot; /&gt; is not a valid heap index.">
        <paramref name="heapIndex" /> ist kein gültiger Heapindex.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the size of the specified heap.">Gibt die Größe des angegebenen Heaps zurück.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;heapIndex&quot; /&gt; is not a valid heap index.">
        <paramref name="heapIndex" /> ist kein gültiger Heapindex.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Returns the handle to the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; that follows the given one in the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; heap or a nil handle if it is the last one.">Gibt das Handle für den <see cref="T:System.Reflection.Metadata.Blob" /> zurück, der auf den im <see cref="T:System.Reflection.Metadata.Blob" /> Heap angegebenen folgt, oder ein Nil-Handle, wenn es sich um das letzte Handle handelt.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Returns the a handle to the string that follows the given one in the string heap, or a nil handle if it is the last one.">Gibt das Handle für die Zeichenfolge zurück, die auf die im Zeichenfolgenheap angegebene folgt, oder ein Nil-Handle, wenn es sich um das letzte Handle handelt.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.">Gibt das Handle für den UserString zurück, der auf den im UserString-Heap angegebenen folgt, oder ein Nil-Handle, wenn es sich um das letzte Handle handelt.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified table.">Gibt den Offset vom Beginn der Metadaten zur angegebenen Tabelle zurück.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> ist kein gültiger Tabellenindex.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the number of rows in the specified table.">Gibt die Anzahl von Zeilen in der angegebenen Tabelle zurück.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> ist kein gültiger Tabellenindex.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the size of a row in the specified table.">Gibt die Größe einer Zeile in der angegebenen Tabelle zurück.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> ist kein gültiger Tabellenindex.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more events.">Enumeriert Typen, die mindestens ein Ereignis definieren.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in EventMap table, i.e. n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of EventMap.">Die resultierende Sequenz entspricht genau den Einträgen in der EventMap-Tabelle, d. h., das n-te zurückgegebene <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> wird in der n-ten Zeile von EventMap gespeichert.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more properties.">Enumeriert Typen, die mindestens eine Eigenschaft definieren.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in the property map table, that is, the n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of the property map.">Die resultierende Sequenz entspricht genau den Einträgen in der Eigenschaftszuordnungstabelle, d. h., das n-te zurückgegebene <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> wird in der n-ten Zeile der Eigenschaftenzuordnung gespeichert.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary vsli:raw="Given a type handle and a raw type kind found in a signature blob determines whether the target type is a value type or a reference type.">Bestimmt bei Vorliegen eines Typhandles und einer in einem Signaturblob gefundenen Rohtypart, ob der Zieltyp ein Werttyp oder ein Verweistyp ist.</summary>
      <param name="reader" vsli:raw="" />
      <param name="typeHandle" vsli:raw="" />
      <param name="rawTypeKind" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary vsli:raw="Builder of a Metadata Root to be embedded in a Portable Executable image.">Der Generator eines Metadatenstamms, der in ein portierbares ausführbares Image eingebettet werden soll.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary vsli:raw="Creates a builder of a metadata root.">Erstellt einen Generator eines Metadatenstamms.</summary>
      <param name="tablesAndHeaps" vsli:raw="Builder populated with metadata entities stored in tables and values stored in heaps. The entities and values will be enumerated when serializing the metadata root.">Generator, der mit in Tabellen gespeicherten Metadatenentitäten und in Heaps gespeicherten Werten aufgefüllt wird. Die Entitäten und Werte werden aufgezählt, wenn der Metadatenstamm serialisiert wird.</param>
      <param name="metadataVersion" vsli:raw="The version string written to the metadata header. The default value is &quot;v4.0.30319&quot;.">Die in den Metadatenheader geschriebene Versionszeichenfolge. Der Standardwert lautet „v4.0.30319“.</param>
      <param name="suppressValidation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables during serialization; otherwise, &lt;paramref name=&quot;false&quot; /&gt;.">
        <see langword="true" />, um eine grundlegende Validierung von Metadatentabellen während der Serialisierung zu unterdrücken, andernfalls <paramref name="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;tablesAndHeaps&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="tablesAndHeaps" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataVersion&quot; /&gt; is too long (the number of bytes when UTF8-encoded must be less than 255).">
        <paramref name="metadataVersion" /> ist zu lang (bei der UTF-8-Codierung muss die Anzahl der Bytes kleiner als 255 sein).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary vsli:raw="Serializes metadata root content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Serialisiert den Metadatenstamminhalt in den angegebenen <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder" vsli:raw="Builder to write to.">Der Generator, in den geschrieben werden soll.</param>
      <param name="methodBodyStreamRva" vsli:raw="The relative virtual address of the start of the method body stream. Used to calculate the final value of RVA fields of MethodDef table.">Die relative virtuelle Adresse des Starts des Methodenkörper-Datenstroms. Wird verwendet, um den endgültigen Wert der RVA-Felder der MethodDef-Tabelle zu berechnen.</param>
      <param name="mappedFieldDataStreamRva" vsli:raw="The relative virtual address of the start of the field init data stream. Used to calculate the final value of RVA fields of FieldRVA table.">Die relative virtuelle Adresse des Starts des Feldinitialisierungs-Datenstroms. Wird verwendet, um den endgültigen Wert der RVA-Felder der FieldRVA-Tabelle zu berechnen.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;builder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="builder" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;methodBodyStreamRva&quot; /&gt; or &lt;paramref name=&quot;mappedFieldDataStreamRva&quot; /&gt; is negative.">
        <paramref name="methodBodyStreamRva" /> oder <paramref name="mappedFieldDataStreamRva" /> ist ein negativer Wert.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="A metadata table is not ordered as required by the specification and &lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation&quot; /&gt; is &lt;see langword=&quot;false&quot; /&gt;.">Eine Metadatentabelle ist nicht wie für die Spezifikation erforderlich sortiert, und <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> ist <see langword="false" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary vsli:raw="The metadata version.">Die Metadatenversion.</summary>
      <returns vsli:raw="A string that represents the metadata version.">Eine Zeichenfolge, die die Metadatenversion darstellt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary vsli:raw="Returns sizes of various metadata structures.">Gibt die Größen verschiedener Metadatenstrukturen zurück.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary vsli:raw="Determines if basic validation of metadata tables should be suppressed. The validation verifies that entries in the tables were added in order required by the ECMA specification. It does not enforce all specification requirements on metadata tables.">Bestimmt, ob die grundlegende Validierung von Metadatentabellen unterdrückt werden soll. Mit der Validierung wird überprüft, ob Einträge in den Tabellen in der von der ECMA-Spezifikation benötigten Reihenfolge hinzugefügt wurden. Damit werden nicht alle Spezifikationsanforderungen für Metadatentabellen erzwungen.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> So unterdrücken Sie die grundlegende Validierung von Metadatentabellen andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary vsli:raw="Provides information on sizes of various metadata structures.">Stellt Informationen zu den Größen verschiedener Metadatenstrukturen bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns aligned size of the specified heap.">Gibt die ausgerichtete Größe des angegebenen Heaps zurück.</summary>
      <param name="index" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary vsli:raw="External table row count.">Anzahl der Zeilen externer Tabellen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary vsli:raw="Exact (unaligned) heap sizes.">Exakte (nicht ausgerichtete) Heapgrößen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary vsli:raw="Table row counts.">Anzahl der Tabellenzeilen.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Maximale Anzahl von Tabellen, die in Ecma335-Metadaten vorhanden sein können.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Maximale Anzahl von Tabellen, die in Ecma335-Metadaten vorhanden sein können.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary vsli:raw="Creates an entity handle from a token value.">Erstellt aus einem Tokenwert ein Entitätshandle.</summary>
      <param name="token" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;token&quot; /&gt; is not a valid metadata entity token.">
        <paramref name="token" /> ist kein gültiges Metadatenentitätstoken.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">Erstellt aus einem Tokenwert ein <see cref="T:System.Reflection.Metadata.EntityHandle" />.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> ist kein gültiger Tabellenindex.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Nullbasierter Offset, oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> oder <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="1-based index into the #Guid heap. Unlike other heaps, which are essentially byte arrays, the #Guid heap is an array of 16-byte GUIDs.">1-basierter Index im #Guid-Heap. Im Gegensatz zu anderen Heaps, bei denen es sich im Wesentlichen um Bytearrays handelt, ist der #Guid-Heap ein Array aus 16-Byte-GUIDs.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="An offset in the corresponding heap, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Offset im entsprechenden Heap oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> oder <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Ruft den Offset von Metadatenheap-Daten ab, der dem angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> entspricht.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.NotSupportedException" vsli:raw="The operation is not supported for the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Der Vorgang wird für den angegebenen Parameter <paramref name="handle" /> nicht unterstützt.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;handle&quot; /&gt; is invalid.">
        <paramref name="handle" /> ist ungültig.</exception>
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; isn't a metadata heap handle.">Nullbasierter Offset oder-1, wenn <paramref name="handle" /> kein Metadatenheap Handle ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Nullbasierter Offset oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> oder <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft den Offset von Metadatenheapdaten ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset.">Nullbasierter Offset.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft die Zeilennummer eines Metadaten-Tabelleneintrags ab, der dem angegebenen <paramref name="handle" /> entspricht.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.&#xA; See &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)&quot; /&gt;.">Nullbasierte Zeilennummer oder -1, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> interpretiert werden kann.
Siehe <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Ruft die Zeilennummer eines Metadaten-Tabelleneintrags ab, der dem angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> entspricht.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;handle&quot; /&gt; is not a valid metadata table handle.">
        <paramref name="handle" /> ist kein gültiges Metadatentabellenhandle.</exception>
      <returns vsli:raw="One based row number.">Zeilennummer mit der Basis 1.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft das Metadatentoken des angegebenen <paramref name="handle" /> ab.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">Metadatentoken oder 0, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Ruft das Metadatentoken des angegebenen <paramref name="handle" /> ab.</summary>
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="Handle represents a metadata entity that doesn't have a token.&#xA;            A token can only be retrieved for a metadata table handle or a heap handle of type &lt;see cref=&quot;F:System.Reflection.Metadata.HandleKind.UserString&quot; /&gt;.">Das Handle stellt eine Metadatenentität dar, die kein Token aufweist.
Ein Token kann nur für ein Metadatentabellenhandle oder ein Heaphandle vom Typ <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> abgerufen werden.</exception>
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">Metadatentoken oder 0, wenn <paramref name="handle" /> nur im Kontext eines bestimmten <see cref="T:System.Reflection.Metadata.MetadataReader" /> interpretiert werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Ruft das Metadatentoken des angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> ab.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.NotSupportedException" vsli:raw="The operation is not supported for the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Der Vorgang wird für den angegebenen Parameter <paramref name="handle" /> nicht unterstützt.</exception>
      <returns vsli:raw="Metadata token.">Metadatentoken.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Ruft das Metadatentoken des angegebenen <paramref name="handle" /> im Kontext des <paramref name="reader" /> ab.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="Handle represents a metadata entity that doesn't have a token.&#xA;            A token can only be retrieved for a metadata table handle or a heap handle of type &lt;see cref=&quot;F:System.Reflection.Metadata.HandleKind.UserString&quot; /&gt;.">Das Handle stellt eine Metadatenentität dar, die kein Token aufweist.
Ein Token kann nur für ein Metadatentabellenhandle oder ein Heaphandle vom Typ <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> abgerufen werden.</exception>
      <exception cref="T:System.NotSupportedException" vsli:raw="The operation is not supported for the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Der Vorgang wird für den angegebenen Parameter <paramref name="handle" /> nicht unterstützt.</exception>
      <returns vsli:raw="Metadata token.">Metadatentoken.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary vsli:raw="Creates a handle from a token value.">Erstellt ein Handle aus einem Tokenwert.</summary>
      <param name="token" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;token&quot; /&gt; is not a valid metadata token.&#xA;            It must encode a metadata table entity or an offset in the &lt;see cref=&quot;F:System.Reflection.Metadata.HandleKind.UserString&quot; /&gt; heap.">
        <paramref name="token" /> ist kein gültiges Metadatentoken.
Es muss eine Metadatentabellenentität oder einen Offset im Heap <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> codieren.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">Erstellt aus einem Tokenwert ein <see cref="T:System.Reflection.Metadata.EntityHandle" />.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> ist kein gültiger Tabellenindex.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.HeapIndex&quot; /&gt; of the heap corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">Ruft den <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> des Heaps ab, der der angegebenen <see cref="T:System.Reflection.Metadata.HandleKind" /> entspricht.</summary>
      <param name="type" vsli:raw="Handle type.">Handletyp.</param>
      <param name="index" vsli:raw="Heap index.">Heapindex.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 heap; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn der Handletyp einem Ecma335-Heap entspricht. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt; of the table corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">Ruft den <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> der Tabelle ab, die der angegebenen <see cref="T:System.Reflection.Metadata.HandleKind" /> entspricht.</summary>
      <param name="type" vsli:raw="Handle type.">Handletyp.</param>
      <param name="index" vsli:raw="Table index.">Tabellenindex.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 or Portable PDB table; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn der Handletyp einer Ecma335- oder portablen PDB-Tabelle entspricht. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary vsli:raw="Defines method body attributes.">Definiert Methodentextattribute.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary vsli:raw="Initializes any locals the method defines to zero and dynamically allocates local memory.">Initialisiert alle von der Methode definierten lokalen Variablen mit null und weist lokalen Arbeitsspeicher dynamisch zu.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary vsli:raw="Performs no local memory initialization.">Führt keine lokale Arbeitsspeicherinitialisierung aus.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary vsli:raw="Provides an encoder for a method body stream.">Stellt einen Encoder für einen Methodentext-Datenstrom bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes and allowing to indicate whether the exception regions should be encoded in small format or not.">Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom mithilfe der bereitgestellten Codegröße, der maximalen Stapelgröße, der Anzahl der Ausnahmebereiche, des Signaturhandles der lokalen Variablen und der Methodentextattribute hinzu. Ermöglicht außerdem die Angabe, ob die Ausnahmebereiche im kleinen Format codiert werden sollen.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">Die Anzahl von Bytes, die für Anweisungen reserviert werden soll.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Die maximale Stapelgröße.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">Die Anzahl der Ausnahmebereiche.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn die Ausnahmebereiche im kleinem Format codiert werden sollen, andernfalls <see langword="false" />.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Die Methodentextattribute.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;codeSize&quot; /&gt;, &lt;paramref name=&quot;exceptionRegionCount&quot; /&gt;, or &lt;paramref name=&quot;maxStack&quot; /&gt; is out of the allowed range.">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> oder <paramref name="maxStack" /> liegt außerhalb des zulässigen Bereichs.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes, allowing to indicate whether the exception regions should be encoded in small format or not, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom mithilfe der bereitgestellten Codegröße, der maximalen Stapelgröße, der Anzahl der Ausnahmebereiche, des Signaturhandles der lokalen Variablen und der Methodentextattribute hinzu. Ermöglicht außerdem die Angabe, ob die Ausnahmebereiche im kleinen Format codiert werden sollen. Ermöglicht auch die Angabe, ob die Methode aus dem dynamischen lokalen Speicherpool zugeordnet werden soll.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">Die Anzahl von Bytes, die für Anweisungen reserviert werden soll.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Die maximale Stapelgröße.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">Die Anzahl der Ausnahmebereiche.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn die Ausnahmebereiche im kleinem Format codiert werden sollen, andernfalls <see langword="false" />.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Die Methodentextattribute.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn die Methode aus dem dynamischen lokalen Speicherpool zugeordnet wird (die <see langword="localloc" />-Anweisung), andernfalls <see langword="false" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;codeSize&quot; /&gt;, &lt;paramref name=&quot;exceptionRegionCount&quot; /&gt;, or &lt;paramref name=&quot;maxStack&quot; /&gt; is out of the allowed range.">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> oder <paramref name="maxStack" /> liegt außerhalb des zulässigen Bereichs.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream.">Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom hinzu.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">Der Anweisungsencoder.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Die maximale Stapelgröße.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Die Methodentextattribute.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;instructionEncoder&quot; /&gt; has default value.">
        <paramref name="instructionEncoder" /> weist den Standardwert auf.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maxStack&quot; /&gt; is out of range [0, &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;].">
        <paramref name="maxStack" /> liegt außerhalb des gültigen Bereichs [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="A label targeted by a branch in the instruction stream has not been marked, or the distance between a branch instruction and the target label doesn't fit the size of the instruction operand.">Eine Bezeichnung, die das Ziel eines Branches im Anweisungsstream ist, wurde nicht gekennzeichnet, oder der Abstand zwischen einer Branchanweisung und der Zielbezeichnung entspricht nicht der Größe des Anweisungsoperanden.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided instruction encoder, maximum stack size, local variables' signature handle, method body attributes, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">Codiert einen Methodentext und fügt ihn dem Methodentext-Datenstrom mithilfe des bereitgestellten Anweisungsencoders, der maximalen Stapelgröße, des Signaturhandles der lokalen Variablen und der Methodentextattribute hinzu. Ermöglicht außerdem die Angabe, ob die Methode Zuordnungen aus dem dynamischen lokalen Speicherpool vornehmen soll.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">Der Anweisungsencoder.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">Die maximale Stapelgröße.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">Das Signaturhandle der lokalen Variablen.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Die Methodentextattribute.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the IL contains the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn die Methode aus dem dynamischen lokalen Speicherpool zugeordnet wird (die IL enthält die <see langword="localloc" />-Anweisung), andernfalls <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;instructionEncoder&quot; /&gt; has default value.">
        <paramref name="instructionEncoder" /> weist den Standardwert auf.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maxStack&quot; /&gt; is out of range [0, &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;].">
        <paramref name="maxStack" /> liegt außerhalb des gültigen Bereichs [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="A label targeted by a branch in the instruction stream has not been marked, or the distance between a branch instruction and the target label doesn't fit the size of the instruction operand.">Eine Bezeichnung, die das Ziel eines Branches im Anweisungsstream ist, wurde nicht gekennzeichnet, oder der Abstand zwischen einer Branchanweisung und der Zielbezeichnung entspricht nicht der Größe des Anweisungsoperanden.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">Der Offset des codierten Texts im Methodentext-Datenstrom.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary vsli:raw="Describes a method body. This class is meant to used along with the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder&quot; /&gt; class.">Beschreibt einen Methodentext. Diese Klasse ist für die Verwendung mit der <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />-Klasse gedacht.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary vsli:raw="Gets an encoder object that can be used to encode exception regions to the method body.">Ruft ein Encoderobjekt ab, das verwendet werden kann, um Ausnahmebereiche für den Methodentext zu codieren.</summary>
      <returns vsli:raw="An exception region encoder instance.">Eine Ausnahme Regions-Encoder-Instanz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary vsli:raw="Gets a blob reserved for instructions.">Ruft ein Blob ab, das für Anweisungen reserviert ist.</summary>
      <returns vsli:raw="A blob reserved for instructions.">Ein BLOB, das für Anweisungen reserviert ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary vsli:raw="Gets the offset of the encoded method body in the method body stream.">Ruft den Offset des codierten Methodentexts im Methodentext-Datenstrom ab.</summary>
      <returns vsli:raw="The offset of the encoded method body in the method body stream.">Der Offset des codierten Methoden Texts im Text Datenstrom der Methode.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary vsli:raw="Provides an encoder for method signatures.">Stellt einen Encoder für Methodensignaturen bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary vsli:raw="Encodes the provided return type and parameters.">Codiert den bereitgestellten Rückgabetyp und die Parameter.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">Die Anzahl der Parameter.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return type.">Die Methode, die zuerst aufgerufen wird, um den Rückgabetyp zu codieren.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">Die Methode, die als Zweites aufgerufen wird, um die Parameter zu codieren.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;returnType&quot; /&gt; or &lt;paramref name=&quot;parameters&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="returnType" /> oder <paramref name="parameters" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary vsli:raw="Encodes the provided return type and parameters, which must be used in the order they appear in the parameter list.">Codiert den bereitgestellten Rückgabetyp und die Parameter, die in der Reihenfolge verwendet werden müssen, in der sie in der Parameterliste angezeigt werden.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">Die Anzahl der Parameter.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return types.">Die Methode, die zuerst aufgerufen wird, um die Rückgabetypen zu codieren.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">Die Methode, die als Zweites aufgerufen wird, um die Parameter zu codieren.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder&quot; /&gt; structure.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />-Struktur.</summary>
      <param name="builder" vsli:raw="A builder for encoding the named argument.">Ein Generator zum Codieren des benannten Arguments.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary vsli:raw="Encodes a named argument (a field or property).">Codiert ein benanntes Argument (ein Feld oder eine Eigenschaft).</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" />, um ein Feld zu codieren, <see langword="false" />, um eine Eigenschaft zu codieren.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">Die Methode, die zuerst aufgerufen werden soll, um den Typ des Arguments zu codieren.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">Die Methode, die als Zweites aufgerufen werden soll, um den Namen des Felds oder der Eigenschaft zu codieren.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">Die Methode, die als Drittes aufgerufen werden soll, um den Literalwert des Arguments zu codieren.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt;, &lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;literal&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" />, <paramref name="name" /> oder <paramref name="literal" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary vsli:raw="Encodes a named argument (a field or property) and returns three encoders that must be used in the order they appear in the parameter list.">Codiert ein benanntes Argument (ein Feld oder eine Eigenschaft) und gibt drei Encoder zurück, die in der Reihenfolge verwendet werden müssen, in der sie in der Parameterliste angezeigt werden.</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" />, um ein Feld zu codieren, <see langword="false" />, um eine Eigenschaft zu codieren.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">Die Methode, die zuerst aufgerufen werden soll, um den Typ des Arguments zu codieren.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">Die Methode, die als Zweites aufgerufen werden soll, um den Namen des Felds oder der Eigenschaft zu codieren.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">Die Methode, die als Drittes aufgerufen werden soll, um den Literalwert des Arguments zu codieren.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary vsli:raw="Represents the builder of a Portable PDB image.">Stellt den Generator eines Portable PDB-Images dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary vsli:raw="Creates a builder of a Portable PDB image.">Erstellt einen Generator eines Portable PDB-Image.</summary>
      <param name="tablesAndHeaps" vsli:raw="A builder populated with debug metadata entities stored in tables and values stored in heaps. The entities and values are enumerated when serializing the Portable PDB image.">Ein Generator, der mit in Tabellen gespeicherten Metadatenentitäten und in Heaps gespeicherten Werten aufgefüllt wird. Die Entitäten und Werte werden aufgezählt, wenn das Portable PDB-Image serialisiert wird.</param>
      <param name="typeSystemRowCounts" vsli:raw="The row counts of all tables that the associated type system metadata contain. Each slot in the array corresponds to a table (&lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt;). The length of the array must be equal &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;.">Die Zeilenanzahl aller Tabellen, die die zugeordneten Typsystemmetadaten enthalten. Jeder Slot im Array entspricht einer Tabelle (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). Die Länge des Arrays muss gleich <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> sein.</param>
      <param name="entryPoint" vsli:raw="An entry point method definition handle.">Ein Einstiegspunktmethoden-Definitionshandle.</param>
      <param name="idProvider" vsli:raw="A function that calculates the ID of content represented as a sequence of blobs. If not specified, a default function that ignores the content and returns a content ID based on the current time is used (&lt;see cref=&quot;M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider&quot; /&gt;). You must specify a deterministic function to produce a deterministic Portable PDB image.">Eine Funktion, die die ID von Inhalts berechnet, der als Sequenz von Blobs dargestellt wird. Wenn nicht angegeben, wird eine Standardfunktion verwendet, die den Inhalt ignoriert und eine Inhalts-ID basierend auf der aktuellen Uhrzeit zurückgibt (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Sie müssen eine deterministische Funktion angeben, um ein deterministisches Portable PDB-Image zu generieren.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;tablesAndHeaps&quot; /&gt; or &lt;paramref name=&quot;typeSystemRowCounts&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="tablesAndHeaps" /> oder <paramref name="typeSystemRowCounts" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Serializes portable PDB content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Serialisiert den portablen PDB-Inhalt in den angegebenen <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</summary>
      <param name="builder" vsli:raw="The builder to write to.">Der Generator, in den geschrieben werden soll.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;builder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="builder" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The ID of the serialized content.">Die ID des serialisierten Inhalts.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary vsli:raw="Encodes a constant literal.">Codiert ein konstantes Literal.</summary>
      <param name="value" vsli:raw="A constant of type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;, &lt;see cref=&quot;T:System.Byte&quot; /&gt;, &lt;see cref=&quot;T:System.SByte&quot; /&gt;, &lt;see cref=&quot;T:System.Int16&quot; /&gt;, &lt;see cref=&quot;T:System.UInt16&quot; /&gt;, &lt;see cref=&quot;T:System.Int32&quot; /&gt;, &lt;see cref=&quot;T:System.UInt32&quot; /&gt;, &lt;see cref=&quot;T:System.Int64&quot; /&gt;, &lt;see cref=&quot;T:System.UInt64&quot; /&gt;, &lt;see cref=&quot;T:System.Single&quot; /&gt;, &lt;see cref=&quot;T:System.Double&quot; /&gt;, &lt;see cref=&quot;T:System.Char&quot; /&gt; (encoded as a two-byte Unicode character), &lt;see cref=&quot;T:System.String&quot; /&gt; (encoded as SerString), or &lt;see cref=&quot;T:System.Enum&quot; /&gt; (encoded as the underlying integer value).">Eine Konstante vom Typ <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (als Zwei-Byte-Unicode-Zeichen codiert), <see cref="T:System.String" /> (als SerString codiert) oder <see cref="T:System.Enum" /> (als zugrunde liegender Integerwert codiert).</param>
      <exception cref="T:System.ArgumentException" vsli:raw="Unexpected constant type.">Unerwarteter Konstantentyp.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary vsli:raw="Encodes a &lt;see langword=&quot;null&quot; /&gt; literal of type &lt;see cref=&quot;T:System.Array&quot; /&gt;.">Codiert ein <see langword="null" />-Literal vom Typ <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary vsli:raw="Encodes a literal of type &lt;see cref=&quot;T:System.Type&quot; /&gt; (which can possibly be &lt;see langword=&quot;null&quot; /&gt;).">Codiert ein Literal vom Typ <see cref="T:System.Type" /> (das möglicherweise <see langword="null" /> sein kann).</summary>
      <param name="serializedTypeName" vsli:raw="The name of the type, or &lt;see langword=&quot;null&quot; /&gt;.">Der Name des Typs oder <see langword="null" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;serializedTypeName&quot; /&gt; is empty.">
        <paramref name="serializedTypeName" /> ist leer.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary vsli:raw="Decodes signature blobs.">Decodiert Signaturblobs.</summary>
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary vsli:raw="Creates a new &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2&quot; /&gt;.">Erstellt einen neuen <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider" vsli:raw="The provider used to obtain type symbols as the signature is decoded.">Der Anbieter, der zum Abrufen von Typsymbolen beim Decodieren der Signatur verwendet wird.</param>
      <param name="metadataReader" vsli:raw="The metadata reader from which the signature was obtained. It may be &lt;see langword=&quot;null&quot; /&gt; if the given provider allows it.">Der Metadatenreader, von dem die Signatur abgerufen wurde. Dies kann <see langword="null" /> sein, wenn der angegebene Anbieter dies zulässt.</param>
      <param name="genericContext" vsli:raw="Additional context needed to resolve generic parameters.">Zusätzlicher Kontext, der zum Auflösen generischer Parameter benötigt wird.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a field signature blob and advances the reader past the signature.">Decodiert ein Feldsignaturblob und positioniert den Reader hinter der Signatur.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a field signature.">Der bei einer Feldsignatur positionierte Blobreader.</param>
      <returns vsli:raw="The decoded field type.">Der decodierte Feldtyp.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a local variable signature blob and advances the reader past the signature.">Decodiert ein Signaturblob einer lokalen Variablen und positioniert den Reader hinter der Signatur.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a local variable signature.">Der bei einer Signatur einer lokalen Variable positionierte Blobreader.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The local variable signature is invalid.">Die Signatur der lokalen Variablen ist ungültig.</exception>
      <returns vsli:raw="The local variable types.">Die Typen der lokalen Variable.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method (definition, reference, or standalone) or a property signature blob.">Decodiert ein Methoden- (Definition, Verweis, oder eigenständig) oder ein Eigenschaftensignaturblob.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a method signature.">Ein bei einer Methodensignatur positionierter Blobreader.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The method signature is invalid.">Die Methodensignatur ist ungültig.</exception>
      <returns vsli:raw="The decoded method signature.">Die decodierte Methodensignatur.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method specification signature blob and advances the reader past the signature.">Decodiert ein Methodenspezifikationssignatur-Blob und positioniert den Reader hinter der Signatur.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a valid method specification signature.">Ein Blobreader, der an einer gültigen Methodenspezifikationssignatur positioniert ist.</param>
      <returns vsli:raw="The types used to instantiate a generic method via the method specification.">Die Typen, die zum Instanziieren einer generischen Methode über die Methodenspezifikation verwendet werden.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary vsli:raw="Decodes a type embedded in a signature and advances the reader past the type.">Decodiert einen Typ, der in eine Signatur eingebettet ist, und positioniert den Reader hinter dem Typ.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at the leading &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureTypeCode&quot; /&gt;.">Der bei einem führenden <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> positionierte Blobreader.</param>
      <param name="allowTypeSpecifications" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to allow a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt; to follow a (CLASS | VALUETYPE) in the signature; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, um zuzulassen, dass einem <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> (CLASS | VALUETYPE) in der Signatur gefolgt wird, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The reader was not positioned at a valid signature type.">Der Reader befindet sich nicht bei einem gültigen Signaturtyp.</exception>
      <returns vsli:raw="The decoded type.">Der decodierte Typ.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; where the signature will be written." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary vsli:raw="Encodes an array type.">Codiert einen Arraytyp.</summary>
      <param name="elementType" vsli:raw="Called first, to encode the type of the element.">Wird zuerst aufgerufen, um den Typ des Elements zu codieren.</param>
      <param name="arrayShape" vsli:raw="Called second, to encode the shape of the array.">Wird als Zweites aufgerufen, um die Form des Arrays zu codieren.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;elementType&quot; /&gt; or &lt;paramref name=&quot;arrayShape&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="elementType" /> oder <paramref name="arrayShape" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary vsli:raw="Encodes an array type. Returns a pair of encoders that must be used in the order they appear in the parameter list.">Codiert einen Arraytyp. Gibt ein Encoderpaar zurück, das in der Reihenfolge verwendet werden muss, in der die Encoder in der Parameterliste angezeigt werden.</summary>
      <param name="elementType" vsli:raw="Use first, to encode the type of the element.">Wird zuerst verwendet, um den Typ des Elements zu codieren.</param>
      <param name="arrayShape" vsli:raw="Use second, to encode the shape of the array.">Wird als Zweites verwendet, um die Form des Arrays zu codieren.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary vsli:raw="Starts a signature of a type with custom modifiers.">Startet eine Signatur eines Typs mit benutzerdefinierten Modifizierern.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary vsli:raw="Starts a function pointer signature.">Startet eine Funktionszeigersignatur.</summary>
      <param name="convention" vsli:raw="Calling convention.">Aufrufkonvention.</param>
      <param name="attributes" vsli:raw="Function pointer attributes.">Funktionszeigerattribute.</param>
      <param name="genericParameterCount" vsli:raw="Generic parameter count.">Anzahl generischer Parameter.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributes&quot; /&gt; is invalid.">
        <paramref name="attributes" /> ist ungültig.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericParameterCount&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="genericParameterCount" /> liegt nicht im Bereich [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary vsli:raw="Starts a generic instantiation signature.">Startet eine generische Instanziierungssignatur.</summary>
      <param name="genericType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount" vsli:raw="Generic argument count.">Anzahl generischer Argumente.</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" />, um den Typ als Werttyp zu markieren, <see langword="false" />, um ihn als Verweistyp in der Signatur zu markieren.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;genericType&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="genericType" /> weist nicht das erwartete Handle auf.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericArgumentCount&quot; /&gt; is not in range [1, 0xffff].">
        <paramref name="genericArgumentCount" /> liegt nicht im Bereich [1, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic method.">Codiert einen Verweis auf den Typparameter einer enthaltenden generischen Methode.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">Parameterindex.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;parameterIndex&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="parameterIndex" /> liegt nicht im Bereich [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic type.">Codiert einen Verweis auf den Typparameter eines enthaltenden generischen Typs.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">Parameterindex.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;parameterIndex&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="parameterIndex" /> liegt nicht im Bereich [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary vsli:raw="Starts pointer signature.">Startet die Zeigersignatur.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Writes primitive type code.">Schreibt primitiven Typcode.</summary>
      <param name="type" vsli:raw="Any primitive type code except for &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference&quot; /&gt; and &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.Void&quot; /&gt;.">Beliebiger primitiver Typcode mit Ausnahme von <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> und <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is not valid in this context.">
        <paramref name="type" /> ist in diesem Kontext nicht gültig.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary vsli:raw="Starts SZ array (vector) signature.">Startet die Signatur des SZ-Arrays (Vektor).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary vsli:raw="Encodes a reference to a type.">Codiert einen Verweis auf einen Typ.</summary>
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" />, um den Typ als Werttyp zu markieren, <see langword="false" />, um ihn als Verweistyp in der Signatur zu markieren.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="type" /> weist nicht das erwartete Handle auf.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary vsli:raw="Encodes a void pointer (&lt;c&gt;void*&lt;/c&gt;).">Codiert einen void-Zeiger (<c>void*</c>).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary vsli:raw="Represents a metadata entity (such as a type reference, type definition, type specification, method definition, or custom attribute).">Stellt eine Metadatenentität dar (z. B. einen Typverweis, eine Typdefinition, eine Typspezifikation, eine Methodendefinition oder ein benutzerdefiniertes Attribut).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified object are equal.">Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und das angegebene Objekt gleich sind.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn <paramref name="obj" /> eine <see cref="T:System.Reflection.Metadata.EntityHandle" />-Struktur ist und der aktuellen Instanz entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; are equal.">Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und die angegebene <see cref="T:System.Reflection.Metadata.EntityHandle" />-Struktur gleich sind.</summary>
      <param name="other" vsli:raw="The value to compare with the current instance.">Der Wert, der mit der aktuellen Instanz verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance and &lt;paramref name=&quot;other&quot; /&gt; are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die angegebene Instanz und <paramref name="other" /> gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Gibt den Hashcode für diese Instanz zurück.</summary>
      <returns vsli:raw="The hash code for this instance.">Der Hashcode für diese Instanz.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary vsli:raw="Gets a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, or a nil token otherwise (&lt;see langword=&quot;default&quot; /&gt;(&lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt;)).">Ruft ein TypeRef-, TypeDef- oder TypeSpec-Handle ab, wenn die Region ein Treffer ist, andernfalls ein NULL-Token (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary vsli:raw="Gets the IL offset of the start of the filter block, or -1 if the region is not a filter.">Ruft den IL-Offset am Anfang des Filterblocks oder -1 ab, wenn die Region kein Filter ist.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary vsli:raw="Gets the length in bytes of the exception handler.">Ruft die Länge des Ausnahmehandlers in Bytes ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary vsli:raw="Gets the starting IL offset of the exception handler.">Ruft den IL-Anfangsoffset des Ausnahmehandlers ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary vsli:raw="Gets the length in bytes of the try block.">Ruft die Länge des try-Blocks in Bytes ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary vsli:raw="Gets the starting IL offset of the try block.">Ruft den IL-Anfangsoffset des try-Blocks ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary vsli:raw="Gets a handle to resolve the implementation of the target type.">Ruft ein Handle zum Auflösen der Implementierung des Zieltyps ab.</summary>
      <returns vsli:raw="&lt;list type=&quot;bullet&quot;&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt; representing another module in the assembly.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; representing another assembly if &lt;see cref=&quot;P:System.Reflection.Metadata.ExportedType.IsForwarder&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; representing the declaring exported type in which this was is nested.&lt;/description&gt;&lt;/item&gt;&lt;/list&gt;">
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> ein anderes Modul in der Assembly.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> eine andere Assembly, wenn <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> ist <see langword="true" /> .</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ein, der den deklarierenden exportierten Typ darstellt, in dem dieses gescheitet ist.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary vsli:raw="Gets the name of the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Ruft den Namen des Zieltyps oder <see langword="default" /> ab, wenn der Typ geschachtelt ist oder in einem Stammnamespace definiert wird.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; struct instance.">Eine <see cref="T:System.Reflection.Metadata.StringHandle" /> Struktur Instanz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary vsli:raw="Gets the full name of the namespace that contains the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Ruft den vollständigen Namen des Namespaces ab, der den Zieltyp enthält, oder <see langword="default" />, wenn der Typ geschachtelt ist oder in einem Stammnamespace definiert wird.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the target type is defined, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Ruft das Definitionshandle des Namespaces ab, in dem der Zieltyp definiert wird, oder <see langword="default" />, wenn der Typ geschachtelt ist oder in einem Stammnamespace definiert wird.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">Stellt eine Auflistung von <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />-Instanzen dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary vsli:raw="Returns the field layout offset, or -1 if it is not available.">Gibt den Feldlayoutoffset zurück, oder -1, wenn er nicht verfügbar ist.</summary>
      <returns vsli:raw="The field definition offset, or -1 if it is not available.">Der Felddefinitionsoffset, oder -1, wenn er nicht verfügbar ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary vsli:raw="Gets the attributes specifying variance and constraints.">Ruft die Attribute ab, die Varianz und Einschränkungen angeben.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary vsli:raw="Gets the zero-based index of the parameter within the declaring generic type or method declaration.">Ruft den nullbasierten (0) Index des Parameters innerhalb des deklarierenden generischen Typs oder einer Methodendeklaration ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary vsli:raw="Gets the name of the generic parameter.">Ruft den Namen des generischen Parameters ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; that represents the parent of this generic parameter.">Ruft ein <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> oder <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ab, das das übergeordnete Element dieses generischen Parameters darstellt.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary vsli:raw="Gets the constrained &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;.">Ruft das eingeschränkte <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> ab.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary vsli:raw="Gets a handle (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;) &#xA;            specifying from which type this generic parameter is constrained to derive,&#xA;            or which interface this generic parameter is constrained to implement.">Ruft ein Handle ab (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />), das angibt, von welchem Typ dieser generische Parameter ausschließlich abgeleitet werden kann, oder die Schnittstelle, die dieser generische Parameter ausschließlich implementieren kann.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; instance.">Eine <see cref="T:System.Reflection.Metadata.EntityHandle" />-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary vsli:raw="Represents a collection of constraints of a generic type parameter.">Stellt eine Sammlung von Einschränkungen eines generischen Typparameters dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary vsli:raw="Gets the element at the specified index in the read-only list.">Ruft das Element am angegebenen Index in der schreibgeschützten Liste ab.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get.">Der nullbasierte Index des abzurufenden Elements.</param>
      <returns vsli:raw="The element at the specified index in the read-only list.">Das Element am angegebenen Index in der schreibgeschützten Liste.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary vsli:raw="Represents a collection of generic type parameters of a method or type.">Stellt eine Sammlung von generischen Typparametern einer Methode oder eines Typs dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary vsli:raw="Gets the element at the specified index in the read-only list.">Ruft das Element am angegebenen Index in der schreibgeschützten Liste ab.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get.">Der nullbasierte Index des abzurufenden Elements.</param>
      <returns vsli:raw="The element at the specified index in the read-only list.">Das Element am angegebenen Index in der schreibgeschützten Liste.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary vsli:raw="Represents any metadata entity (such as a type reference, a type definition, a type specification, a method definition, or a custom attribute) or value (a string, blob, guid, or user string).">Stellt eine beliebige Metadatenentität (z.B. einen Typverweis, eine Typdefinition, eine Typspezifikation, eine Methodendefinition oder ein benutzerdefiniertes Attribut) oder einen Wert (eine Zeichenfolge, ein Blob, eine GUID oder eine Benutzerzeichenfolge) dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Compares two entity handles.">Vergleicht zwei Entitätshandles.</summary>
      <param name="x" vsli:raw="The first entity handle to compare.">Das erste zu vergleichende Entitätshandle.</param>
      <param name="y" vsli:raw="The second entity handle to compare.">Das zweite zu vergleichende Entitätshandle.</param>
      <returns vsli:raw="Zero if the two entity handles are equal, and a non-zero value of they are not.">Null (0), wenn die zwei Entitätshandles gleich sind, und ein Wert ungleich null (0), wenn nicht.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Compares two handles.">Vergleicht zwei Handles.</summary>
      <param name="x" vsli:raw="The first handle to compare.">Das erste zu vergleichende Handle.</param>
      <param name="y" vsli:raw="The second handle to compare.">Das zweite zu vergleichende Handle.</param>
      <returns vsli:raw="Zero if the two handles are equal, and a non-zero value if they are not.">Null (0), wenn die beiden Handles gleich sind, und ein Wert ungleich null (0), wenn nicht.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Determines whether the specified objects are equal.">Bestimmt, ob die angegebenen Objekte gleich sind.</summary>
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">Das erste zu vergleichende Objekt vom Typ <paramref name="T" />.</param>
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">Das zweite zu vergleichende Objekt vom Typ <paramref name="T" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die angegebenen Objekte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Determines whether the specified objects are equal.">Bestimmt, ob die angegebenen Objekte gleich sind.</summary>
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">Das erste zu vergleichende Objekt vom Typ <paramref name="T" />.</param>
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">Das zweite zu vergleichende Objekt vom Typ <paramref name="T" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die angegebenen Objekte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Returns a hash code for the specified object.">Gibt einen Hashcode für das angegebene Objekt zurück.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned.">Das <see cref="T:System.Object" />, für das ein Hashcode zurückgegeben werden soll.</param>
      <returns vsli:raw="A hash code for the specified object.">Ein Hashcode für das angegebene Objekt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Returns a hash code for the specified object.">Gibt einen Hashcode für das angegebene Objekt zurück.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned.">Das <see cref="T:System.Object" />, für das ein Hashcode zurückgegeben werden soll.</param>
      <returns vsli:raw="A hash code for the specified object.">Ein Hashcode für das angegebene Objekt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary vsli:raw="Gets the type symbol for a generalized array of the given element type and shape.">Ruft das Typsymbol für ein generalisiertes Array des angegebenen Elementtyps und der angegebenen Form ab.</summary>
      <param name="elementType" vsli:raw="The type of the elements in the array.">Der Typ der Elemente im Array.</param>
      <param name="shape" vsli:raw="The shape (rank, sizes, and lower bounds) of the array.">Die Form (Rang, Größen und untere Grenzen) des Arrays.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary vsli:raw="Gets the type symbol for a managed pointer to the given element type.">Ruft das Typsymbol für einen verwalteten Zeiger auf den angegebenen Elementtyp ab.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Gets the type symbol for a generic instantiation of the given generic type with the given type arguments.">Ruft das Typsymbol für eine generische Instanziierung des angegebenen generischen Typs mit den angegebenen Typargumenten ab.</summary>
      <param name="genericType" vsli:raw="" />
      <param name="typeArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary vsli:raw="Gets the type symbol for an unmanaged pointer to the given element type.">Ruft das Typsymbol für einen nicht verwalteten Zeiger auf den angegebenen Elementtyp ab.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary vsli:raw="Gets the &lt;typeparamref name=&quot;TType&quot; /&gt; representation for &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Ruft die <typeparamref name="TType" />-Darstellung für <see cref="T:System.Type" /> ab.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary vsli:raw="Gets the type symbol for the given serialized type name.">Ruft das Typsymbol für den angegebenen serialisierten Typnamen ab.</summary>
      <param name="name" vsli:raw="The serialized type name in so-called &quot;reflection notation&quot; format (as understood by the &lt;see cref=&quot;M:System.Type.GetType(System.String)&quot; /&gt; method.)">Der serialisierte Typname im sogenannten „Reflektionsnotations“-Format (gemäß der <see cref="M:System.Type.GetType(System.String)" />-Methode.)</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The name is malformed.">Der Name ist falsch formatiert.</exception>
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">Eine <typeparamref name="TType" />-Instanz.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary vsli:raw="Gets the underlying type of the given enum type symbol.">Ruft den zugrunde liegenden Typ des angegebenen Enumerationstypsymbols ab.</summary>
      <param name="type" vsli:raw="An enum type.">Ein Enumerationstyp.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The given type symbol does not represent an enum.">Der angegebene Symboltyp stellt keine Enumeration dar.</exception>
      <returns vsli:raw="A type code that indicates the underlying type of the enumeration.">Ein Typcode, der den zugrunde liegenden Typ der Enumeration angibt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary vsli:raw="Verifies if the given type represents &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Überprüft, ob der angegebene Typ <see cref="T:System.Type" /> darstellt.</summary>
      <param name="type" vsli:raw="The type to verify.">Der zu überprüfende Typ.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given type is a &lt;see cref=&quot;T:System.Type&quot; /&gt;, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn der angegebene Typ ein <see cref="T:System.Type" /> ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Calculates the size of the specified branch instruction operand.">Berechnet die Größe des angegebenen Verzweigungsanweisungsoperanden.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">Der Branch-Op-Code.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">Der angegebene <paramref name="opCode" /> ist kein Branch-Op-Code.</exception>
      <returns vsli:raw="1 if &lt;paramref name=&quot;opCode&quot; /&gt; is a short branch, or 4 if it is a long branch.">1, wenn <paramref name="opCode" /> eine kurze Verzweigung ist, oder 4, wenn es sich um eine lange Verzweigung handelt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a long form of the specified branch op-code.">Ruft eine lange Form des angegebenen Branch-Op-Codes ab.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">Der Branch-Op-Code.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">Der angegebene <paramref name="opCode" /> ist kein Branch-Op-Code.</exception>
      <returns vsli:raw="The long form of the branch op-code.">Die Langform des Branch-Op-Codes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a short form of the specified branch op-code.">Ruft eine Kurzform des angegebenen Branch-Op-Codes ab.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">Der Branch-Op-Code.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">Der angegebene <paramref name="opCode" /> ist kein Branch-Op-Code.</exception>
      <returns vsli:raw="The short form of the branch op-code.">Die Kurzform des Branch-Op-Codes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Verifies if the specified op-code is a branch to a label.">Überprüft, ob der angegebene Op-Code eine Verzweigung zu einer Bezeichnung ist.</summary>
      <param name="opCode" vsli:raw="" />
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified op-code is a branch to a label, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn der angegebene Op-Code eine Verzweigung zu einer Bezeichnung ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary vsli:raw="The exception that is thrown when an attempt to write metadata exceeds a limit given by the format specification. For example, when the heap size limit is exceeded.">Die Ausnahme, die ausgelöst wird, wenn ein Versuch, Metadaten zu schreiben, eine von der Formatspezifikation angegebene Grenze überschreitet. Dies ist beispielsweise der Fall, wenn die Heapgrößenbeschränkung überschritten wird.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with serialized data.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse mit serialisierten Daten.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">Das Objekt, das die Daten des serialisierten Objekts enthält.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">Die Kontextinformationen zur Quelle bzw. zum Ziel.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">Die Fehlermeldung, in der die Ursache dieser Ausnahme erklärt wird.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message and the exception that is the cause of this exception.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />-Klasse mit einer angegebenen Fehlermeldung und der Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">Die Fehlermeldung, in der die Ursache dieser Ausnahme erklärt wird.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception, or &lt;see langword=&quot;null&quot; /&gt; if no inner exception is specified.">Die Ausnahme, die die aktuelle Ausnahme verursacht hat, oder <see langword="null" />, wenn keine innere Ausnahme angegeben ist.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Invalid blob format.">Ungültiges Blobformat.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary vsli:raw="Provides information about the lexical scope within which a group of imports are available. This information is stored in debug metadata.">Stellt Informationen zum lexikalischen Bereich bereit, in dem eine Gruppe von Importen verfügbar ist. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary vsli:raw="Gets the interface that is implemented (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;).">Ruft die implementierte Schnittstelle auf (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) ab.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary vsli:raw="Gets the type symbol for the function pointer type of the given method &lt;paramref name=&quot;signature&quot; /&gt;.">Ruft das Typsymbol für den für den Funktionszeigertyp der angegebene Methode <paramref name="signature" /> ab.</summary>
      <param name="signature" vsli:raw="" />
      <returns vsli:raw="The type symbol for the function pointer type.">Das Typsymbol für den Funktionszeigertyp.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic method parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Ruft das Typsymbol für den für den generischen Methodenparameter am angegebenen nullbasierten <paramref name="index" /> ab.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic method parameter at &lt;paramref name=&quot;index&quot; /&gt;.">Das Typsymbol für den generischen Methodenparameter an <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Ruft das Typsymbol für den für den generischen Typparameter am angegebenen nullbasierten <paramref name="index" /> ab.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Das Typsymbol für den für den generischen Typparameter am angegebenen nullbasierten <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary vsli:raw="Gets the type symbol for a type with a custom modifier applied.">Ruft das Typsymbol für einen Typ mit einem angewendeten benutzerdefinierten Modifizierer ab.</summary>
      <param name="modifier" vsli:raw="The modifier type applied.">Der angewendete Modifizierertyp.</param>
      <param name="unmodifiedType" vsli:raw="The type symbol of the underlying type without modifiers applied.">Das Typsymbol des zugrunde liegenden Typs ohne angewendete Modifizierer.</param>
      <param name="isRequired" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the modifier is required, &lt;see langword=&quot;false&quot; /&gt; if it's optional.">
        <see langword="true" />, wenn der Modifizierer erforderlich ist, bzw. <see langword="false" />, wenn er optional ist.</param>
      <returns vsli:raw="The type symbol.">Das Typsymbol.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary vsli:raw="Gets the type symbol for a local variable type that is marked as pinned.">Ruft das Typsymbol für einen lokalen Variablentyp ab, der als „fixiert“ gekennzeichnet ist.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="The type symbol for the local variable type.">Das Typsymbol für den lokalen Variablentyp.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type specification.">Ruft das Typsymbol für eine Typspezifikation ab.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">Der Metadatenleser, der an den Signaturdecoder übergeben wurde. Kann <see langword="null" /> sein.</param>
      <param name="genericContext" vsli:raw="The context that was passed to the signature decoder.">Der Kontext, der an den Signaturdecoder übergeben wurde.</param>
      <param name="handle" vsli:raw="The type specification handle.">Das Typspezifikationshandle.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">Die Art des Typs, wie in der Signatur angegeben. Um diesen Wert zu interpretieren, verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol for the type specification.">Das Typsymbol für die Typspezifikation.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Gets the type symbol for a primitive type.">Ruft das Typsymbol für einen primitiven Typ ab.</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="The type symbol for &lt;paramref name=&quot;typeCode&quot; /&gt;.">Das Typsymbol für <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type definition.">Ruft das Typsymbol für eine Typdefinition ab.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">Der Metadatenleser, der an den Signaturdecoder übergeben wurde. Kann <see langword="null" /> sein.</param>
      <param name="handle" vsli:raw="The type definition handle.">Das Typdefinitionshandle.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">Die Art des Typs, wie in der Signatur angegeben. Um diesen Wert zu interpretieren, verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol.">Das Typsymbol.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type reference.">Ruft das Typsymbol für einen Typverweis ab.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">Der Metadatenleser, der an den Signaturdecoder übergeben wurde. Kann <see langword="null" /> sein.</param>
      <param name="handle" vsli:raw="The type definition handle.">Das Typdefinitionshandle.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">Die Art des Typs, wie in der Signatur angegeben. Um diesen Wert zu interpretieren, verwenden Sie <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol.">Das Typsymbol.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary vsli:raw="Gets the type symbol for a single-dimensional array of the given element type with a lower bounds of zero.">Ruft das Typsymbol für ein eindimensionales Array des angegebenen Elementtyps mit einer Untergrenze von 0 (null) ab.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">Eine <typeparamref name="TType" />-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary vsli:raw="Provides information about local constants. This information is stored in debug metadata.">Stellt Informationen zu lokalen Konstanten bereit. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary vsli:raw="Gets the constant signature.">Ruft die Konstantensignatur ab</summary>
      <returns vsli:raw="The constant signature.">Die Konstante Signatur.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary vsli:raw="Provides information about the scope of local variables and constants. This information is stored in debug metadata.">Stellt Informationen zum Bereich lokaler Variablen und Konstanten bereit. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary vsli:raw="Provides information about local variables. This information is stored in debug metadata.">Stellt Informationen zu lokalen Variablen bereit. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary vsli:raw="Gets the manifest resource attributes.">Ruft die Attribute der Manifestressource ab.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that specify the manifest resource attributes.">Eine bitweise Kombination der Enumerationswerte, die die manifestressourcenattribute angeben.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary vsli:raw="Gets the implementation entity handle.">Ruft das Handle der Implementierungsentität ab.</summary>
      <returns vsli:raw="An EntityHandle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">Eine entityhandle-Instanz. Wenn die- <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> Eigenschaft ist <see langword="true" /> , verfügt das zurückgegebene Handle über Standardwerte.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary vsli:raw="Gets the resource name.">Ruft den Namen der Ressource ab.</summary>
      <returns vsli:raw="The resource name.">Der Name der Ressource.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary vsli:raw="Gets the byte offset within the referenced file at which this resource record begins.">Ruft das Byteoffset in der referenzierten Datei ab, an dem dieser Ressourceneintrag beginnt.</summary>
      <returns vsli:raw="The byte offset within the referenced file at which this resource record begins.">Der Byte Offset in der Datei, auf die verwiesen wird, wenn dieser Ressourcen Daten Satz beginnt.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt; instances.">Stellt eine Auflistung von <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />-Instanzen dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary vsli:raw="Determines if the member reference is to a method or field.">Bestimmt, ob sich der Memberverweis auf eine Methode oder ein Feld bezieht.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The member reference signature is invalid.">Die Signatur des Memberverweises ist ungültig.</exception>
      <returns vsli:raw="One of the enumeration values that indicates the kind of member reference.">Einer der Enumerationswerte, der die Art des Memberverweises angibt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary vsli:raw="Gets the parent entity handle.">Ruft das Handle der übergeordneten Entität ab.</summary>
      <returns vsli:raw="An entity handle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">Eine entitätenhandle-Instanz. Wenn die- <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> Eigenschaft ist <see langword="true" /> , verfügt das zurückgegebene Handle über Standardwerte.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Ruft ein Handle zum Signaturblob ab.</summary>
      <returns vsli:raw="A handle to the signature blob.">Ein Handle für das Signatur-BLOB.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt; instances.">Stellt eine Auflistung von <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />-Instanzen dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary vsli:raw="Specifies constants that indicate whether a &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method or field.">Gibt Konstanten an, die angeben, ob <see cref="T:System.Reflection.Metadata.MemberReference" /> auf eine Methode oder ein Feld verweist.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a field.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> verweist auf ein Feld.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> verweist auf eine Methode.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary vsli:raw="CLI metadata.">CLI-Metadaten.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary vsli:raw="Windows metadata generated by managed compilers.">Windows-Metadaten, die von verwalteten Compilern generiert werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary vsli:raw="Windows metadata.">Windows-Metadaten.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary vsli:raw="Reads metadata as defined by the ECMA 335 CLI specification.">Liest Metadaten gemäß der ECMA 335 CLI-Spezifikation.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse aus den Metadaten, die am angegebenen Speicherort gespeichert sind.</summary>
      <param name="metadata" vsli:raw="A pointer to the first byte in a block of metadata.">Ein Zeiger auf das erste Byte in einem Metadatenblock.</param>
      <param name="length" vsli:raw="The number of bytes in the block.">Die Anzahl von Bytes im Block.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse aus den Metadaten, die am angegebenen Speicherort gespeichert sind.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse aus den Metadaten, die am angegebenen Speicherort gespeichert sind.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
      <param name="utf8Decoder" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is not positive.">
        <paramref name="length" /> ist nicht positiv.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;metadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="metadata" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">Die Codierung von <paramref name="utf8Decoder" /> ist keine <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad metadata header.">Fehlerhafter Metadatenheader.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary vsli:raw="Gets the information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">Ruft die aus dem #Pdb-Datenstrom decodierten Informationen oder <see langword="null" /> ab, wenn der Datenstrom nicht vorhanden ist.</summary>
      <returns vsli:raw="The information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">Die Informationen, die aus #PDB Stream decodiert werden, oder, <see langword="null" /> Wenn der Stream nicht vorhanden ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary vsli:raw="Gets a value that indicates whether the metadata represents an assembly.">Ruft einen Wert ab, der angibt, ob diese Metadaten eine Assembly darstellen.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the metadata represents an assembly; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn die Metadaten eine Assembly darstellen. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary vsli:raw="Gets the metadata kind.">Ruft die Art der Metadaten ab.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the metadata kind.">Einer der Enumerationswerte, der die metadatenart angibt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary vsli:raw="Gets the length of the underlying data.">Ruft die Länge der zugrunde liegenden Daten ab.</summary>
      <returns vsli:raw="The length of the underlying data.">Die Länge der zugrunde liegenden Daten.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary vsli:raw="Gets the pointer to the underlying data.">Ruft den Zeiger auf die zugrunde liegenden Daten ab.</summary>
      <returns vsli:raw="The pointer to the underlying data.">Der Zeiger auf die zugrunde liegenden Daten.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary vsli:raw="Gets the version string read from metadata header.">Ruft die Versionszeichenfolge aus dem Metadatenheader ab.</summary>
      <returns vsli:raw="The version string read from metadata header.">Die Versions Zeichenfolge aus dem Metadatenheader.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; passed to the constructor.">Ruft die an den Konstruktor übergebenen <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> ab.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that describes the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; enum value.">Eine bitweise Kombination der Enumerationswerte, die den <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> Enumerationswert beschreibt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary vsli:raw="Gets the comparer used to compare strings stored in metadata.">Ruft den Comparer ab, der zum Vergleichen von Zeichenfolgen verwendet wird, die in den Metadaten gespeichert sind.</summary>
      <returns vsli:raw="The comparer used to compare strings stored in metadata.">Der Vergleich, der zum Vergleichen von in Metadaten gespeicherten Zeichen folgen verwendet wird.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary vsli:raw="Gets the decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">Ruft den Decoder ab, der vom Reader verwendet wird, um Zeichenfolgeninstanzen aus Bytefolgen zu generieren, die als UTF8 codiertsind.</summary>
      <returns vsli:raw="The decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">Der vom Reader verwendete Decoder, der Zeichen folgen Instanzen aus UTF8-codierten Byte Sequenzen erzeugt.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary vsli:raw="Windows Runtime projections are enabled (on by default).">Projektionen der Windows-Runtime sind aktiviert (standardmäßig aktiviert).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary vsli:raw="The options that are used when a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; is obtained via an overload that does not take a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; argument.">Die Optionen werden verwendet, wenn eine <see cref="T:System.Reflection.Metadata.MetadataReader" />-Klasse über eine Überladung abgerufen wird, die kein <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />-Argument annimmt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary vsli:raw="All options are disabled.">Alle Optionen sind deaktiviert.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; for metadata stored in an array of bytes, a memory block, or a stream.">Stellt einen <see cref="T:System.Reflection.Metadata.MetadataReader" /> für Metadaten bereit, die in einem Bytearray, einem Speicherblock oder einem Stream gespeichert sind.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">Verwirft den gesamten vom Leser zugewiesenen Speicher.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a metadata provider over an image stored in memory.">Erstellt einen Metadatenanbieter über ein im Arbeitsspeicher gespeichertes Image.</summary>
      <param name="start" vsli:raw="Pointer to the start of the metadata blob.">Zeiger auf den Anfang des Metadatenblobs.</param>
      <param name="size" vsli:raw="The size of the metadata blob.">Die Größe des Metadatenblobs.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> ist ein negativer Wert.</exception>
      <returns vsli:raw="The new metadata provider.">Der neue Metadatenanbieter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a provider over a byte array.">Erstellt einen Anbieter über einen Bytearray.</summary>
      <param name="image" vsli:raw="Metadata image.">Metadatenimage.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The new provider.">Der neue Anbieter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">Erstellt einen Anbieter für einen Stream der angegebenen Größe, beginnend an der aktuellen Position.</summary>
      <param name="stream" vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; instance.">Eine <see cref="T:System.IO.Stream" />-Instanz.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">Optionen, die angeben, wie Abschnitte des Images aus dem Stream gelesen werden.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">Größe des Metadatenblobs im Stream. Ist dieser Wert nicht angegeben, wird angenommen, dass sich der Metadatenblob bis zum Ende des Streams erstreckt.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> unterstützt keine Lese- und Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">Größe ist negativ oder erstreckt sich über das Ende des Streams hinaus.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata&quot; /&gt; is specified).">Fehler beim Lesen aus dem Stream (nur wenn <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> angegeben ist).</exception>
      <returns vsli:raw="The new provider.">Der neue Anbieter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a portable PDB metadata provider over a blob stored in memory.">Erstellt einen portablen PDB-Metadatenanbieter über einen im Arbeitsspeicher gespeicherten Blob.</summary>
      <param name="start" vsli:raw="Pointer to the start of the portable PDB blob.">Zeiger auf den Anfang des portablen PDB-Blobs.</param>
      <param name="size" vsli:raw="The size of the portable PDB blob.">Die Größe des portablen PDB-Blobs.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> ist ein negativer Wert.</exception>
      <returns vsli:raw="The new portable PDB metadata provider.">Der neue portable PDB-Metadatenanbieter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a portable PDB metadata provider over a byte array.">Erstellt einen portablen PDB-Metadatenanbieter über einen Bytearray.</summary>
      <param name="image" vsli:raw="A portable PDB image.">Ein portables PDB-Image.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> ist <see langword="null" />.</exception>
      <returns vsli:raw="The new portable PDB metadata provider .">Der neue portable PDB-Metadatenanbieter.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">Erstellt einen Anbieter für einen Stream der angegebenen Größe, beginnend an der aktuellen Position.</summary>
      <param name="stream" vsli:raw="The stream.">Der Datenstrom.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">Optionen, die angeben, wie Abschnitte des Images aus dem Stream gelesen werden.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">Größe des Metadatenblobs im Stream. Ist dieser Wert nicht angegeben, wird angenommen, dass sich der Metadatenblob bis zum Ende des Streams erstreckt.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> unterstützt keine Lese- und Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">Größe ist negativ oder erstreckt sich über das Ende des Streams hinaus.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; instance.">Eine <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />-Instanz.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt;.">Ruft <see cref="T:System.Reflection.Metadata.MetadataReader" /> aus <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> ab.</summary>
      <param name="options" vsli:raw="A bitwise combination of the enumeration values that represent the configuration when reading the metadata.">Eine bitweise Kombination von Enumerationswerten, die die Konfiguration beim Lesen der Metadaten darstellen.</param>
      <param name="utf8Decoder" vsli:raw="The encoding to use.">Die zu verwendende Codierung.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">Die Codierung von <paramref name="utf8Decoder" /> ist keine <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="Provider has been disposed.">Anbieter wurde verworfen.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; instance.">Eine <see cref="T:System.Reflection.Metadata.MetadataReader" />-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed and sections of the PE image are read lazily.">Standardmäßig wird der Datenstrom entfernt, wenn <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> entfernt wird und Abschnitte des PE-Images verzögert gelesen werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed.">Hält den Datenstrom geöffnet, wenn <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> entfernt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads PDB metadata into memory right away.&lt;/para&gt;&lt;para&gt;The underlying file may be closed and even deleted after the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is constructed. &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen&quot; /&gt; is specified.&lt;/para&gt;">
        <para>Liest PDB-Metadaten direkt in den Speicher.</para>
        <para>Die zugrunde liegende Datei kann geschlossen und sogar gelöscht werden, nachdem <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> erstellt wurde. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> schließt den Stream automatisch, wenn der Konstruktor zurückkehrt, es sei denn, <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> wird angegeben.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary vsli:raw="Provides string comparison helpers to query strings in metadata while avoiding allocation if possible.">Stellt Zeichenfolgenvergleichshilfen zum Abfragen von Zeichenfolgen in Metadaten bereit, wobei die Zuordnung nach Möglichkeit vermieden wird.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary vsli:raw="Provides the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; with a custom mechanism for decoding byte sequences in metadata that represent text.">Stellt <see cref="T:System.Reflection.Metadata.MetadataReader" /> mit einem benutzerdefinierten Mechanismus zum Decodieren von Bytesequenzen in Metadaten bereit, die Text darstellen.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataStringDecoder&quot; /&gt; class using the given encoding.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" />-Klasse mit der angegebenen Codierung.</summary>
      <param name="encoding" vsli:raw="The encoding to use.">Die zu verwendende Codierung.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary vsli:raw="Obtains strings for byte sequences in metadata. Override this to cache strings if required. Otherwise, it is implemented by forwarding straight to &lt;see cref=&quot;P:System.Reflection.Metadata.MetadataStringDecoder.Encoding&quot; /&gt; and every call will allocate a new string.">Ruft die Zeichenfolgen für Bytefolgen in den Metadaten ab. Überschreiben Sie diese Einstellung, um Zeichenfolgen bei Bedarf zwischenzuspeichern. Andernfalls wird dies durch direkte Weiterleitung an <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> implementiert, und jeder Aufruf weist eine neue Zeichenfolge zu.</summary>
      <param name="bytes" vsli:raw="Pointer to bytes to decode.">Zeiger auf die zu decodierenden Bytes.</param>
      <param name="byteCount" vsli:raw="Number of bytes to decode.">Die Anzahl der zu decodierenden Bytes.</param>
      <returns vsli:raw="The decoded string.">Die decodierte Zeichenfolge.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary vsli:raw="Gets the default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8 when no decoder is provided to the constructor.">Ruft den Standarddecoder ab, der von <see cref="T:System.Reflection.Metadata.MetadataReader" /> verwendet wird, um UTF-8 zu decodieren, wenn kein Decoder für den Konstruktor bereitgestellt wird.</summary>
      <returns vsli:raw="The default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8.">Der von verwendete Standarddecoder <see cref="T:System.Reflection.Metadata.MetadataReader" /> zum Decodieren von UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary vsli:raw="Gets the encoding used by this instance.">Ruft die von dieser Instanz verwendete Codierung ab.</summary>
      <returns vsli:raw="The encoding used by this instance.">Die von dieser Instanz verwendete Codierung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" vsli:raw="The blob reader to read the method body." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary vsli:raw="Gets the size of the method body, including the header, IL, and exception regions.">Ruft die Größe des Methodentexts einschließlich Header, IL und Ausnahmeregionen ab.</summary>
      <returns vsli:raw="The size of the method body.">Die Größe des Methoden Texts.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary vsli:raw="Provides debug information associated with a method definition. This information is stored in debug metadata.">Stellt Debuginformationen bereit, die einer Methodendefinition zugeordnet sind. Diese Informationen werden in Debugmetadaten gespeichert.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary vsli:raw="Returns a collection of sequence points decoded from &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob&quot; /&gt;.">Gibt eine Sammlung der aus <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" /> decodierten Sequenzpunkte zurück.</summary>
      <returns vsli:raw="A collection of sequence points.">Eine Sammlung von Sequenzpunkten.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary vsli:raw="Returns the kickoff method of the state machine.">Gibt die Kickoffmethode des Zustandsautomaten zurück.</summary>
      <returns vsli:raw="The kickoff method of the state machine, if the method is a &lt;c&gt;MoveNext&lt;/c&gt; method of a state machine. Otherwise, it returns a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">Die Kickoffmethode des Zustandsautomaten, wenn die Methode eine <c>MoveNext</c>-Methode eines Zustandsautomaten ist. Andernfalls wird ein Handle zurückgegeben, dessen <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />-Eigenschaft <see langword="true" /> ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary vsli:raw="Gets the handle of the single document containing all sequence points of the method.">Ruft das Handle des einzelnen Dokuments ab, das alle Sequenzpunkte der Methode enthält.</summary>
      <returns vsli:raw="The handle of the single document containing all sequence points of the method, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.DocumentHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">Das Handle des einzelnen Dokuments, das alle Sequenz Punkte der Methode enthält, oder ein Handle, dessen- <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> Eigenschaft ist, <see langword="true" /> Wenn die Methode keine Sequenz Punkte hat oder mehrere Dokumente umfasst.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary vsli:raw="Returns a local signature handle.">Gibt ein Handle für die lokale Signatur zurück.</summary>
      <returns vsli:raw="A local signature handle, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't define any local variables.">Ein lokales Signatur handle oder ein Handle, dessen- <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> Eigenschaft ist, <see langword="true" /> Wenn die Methode keine lokalen Variablen definiert.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary vsli:raw="Returns a blob encoding sequence points.">Gibt ein Blob zurück, das Sequenzpunkte codiert.</summary>
      <returns vsli:raw="A blob encoding sequence points, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.BlobHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points.">Ein BLOB-Codierungs Sequenz Punkt oder ein Handle, dessen- <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> Eigenschaft ist, <see langword="true" /> Wenn die Methode keine Sequenz Punkte hat.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt; that corresponds to this handle.">Gibt ein Handle zu einem <see cref="T:System.Reflection.Metadata.MethodDefinition" />-Element zurück, das diesem Handle entspricht.</summary>
      <returns vsli:raw="A method definition handle that corresponds to this handle.">Ein Methodendefinitions-Handle, das diesem Handle entspricht.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDebugInformation&quot; /&gt; that corresponds to this handle.">Gibt ein Handle zu einem <see cref="T:System.Reflection.Metadata.MethodDebugInformation" />-Element zurück, das diesem Handle entspricht.</summary>
      <returns vsli:raw="A method debug information handle that corresponds to this handle.">Ein Methodendebug-Informationshandle, das diesem Handle entspricht.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary vsli:raw="Represents a method (definition, reference, or standalone) or property signature. In the case of properties, the signature matches that of a getter with a distinguishing &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt;.">Stellt eine Methode (Definition, Verweis, oder eigenständig) oder eine Signatur der Eigenschaften dar. In Bezug auf Eigenschaften stimmt die Signatur bis auf einen Unterschied im <see cref="T:System.Reflection.Metadata.SignatureHeader" /> mit der Signatur eines Getters überein.</summary>
      <typeparam name="TType" vsli:raw="The method type.">Der Methodentyp.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSignature`1&quot; /&gt; structure using the specified header, return type, and parameter information.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.MethodSignature`1" />-Struktur unter Verwendung der angegebenen Kopfzeile, des Rückgabetyps und der Parameterinformationen.</summary>
      <param name="header" vsli:raw="The information in the leading byte of the signature (kind, calling convention, flags).">Die Informationen im führenden Byte der Signatur (Art, Aufrufkonvention, Kennzeichen).</param>
      <param name="returnType" vsli:raw="The return type of the method.">Der Rückgabetyp der Methode.</param>
      <param name="requiredParameterCount" vsli:raw="The number of required parameters.">Die Anzahl der erforderlichen Parameter.</param>
      <param name="genericParameterCount" vsli:raw="The number of generic type parameters.">Die Anzahl der generischen Typparameter.</param>
      <param name="parameterTypes" vsli:raw="The parameter types.">Die Parametertypen.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary vsli:raw="Gets the number of generic type parameters for the method.">Ruft die Anzahl der generischen Typparameter für diese Methode ab.</summary>
      <returns vsli:raw="The number of generic type parameters, or 0 for non-generic methods.">Die Anzahl der generischen Typparameter oder 0 für nicht generische Methoden.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary vsli:raw="Gets the information in the leading byte of the signature (kind, calling convention, flags).">Ruft die Informationen im führenden Byte der Signatur (Art, Aufrufkonvention, Kennzeichen) ab.</summary>
      <returns vsli:raw="The header signature.">Die Header Signatur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary vsli:raw="Gets the method's parameter types.">Ruft die Parametertypen der Methode ab.</summary>
      <returns vsli:raw="An immutable collection of parameter types.">Eine unveränderliche Auflistung von Parametertypen.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary vsli:raw="Gets the number of parameters that are required for the method.">Ruft die Anzahl der für diese Methode erforderlichen Parameter ab.</summary>
      <returns vsli:raw="The number of required parameters.">Die Anzahl der erforderlichen Parameter.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary vsli:raw="Gets the return type of the method.">Ruft den Rückgabetypen der Methode ab.</summary>
      <returns vsli:raw="The return type.">Der Rückgabetyp.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary vsli:raw="Gets a &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to (that is, which generic method it is an instantiation of).">Ruft ein <see langword="MethodDef" />- oder <see langword="MemberRef" />-Handle ab, das die generische Methode angibt, auf die diese Instanz verweist (d.h. von welcher generischen Methode sie eine Instanziierung ist).</summary>
      <returns vsli:raw="A &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to.">Ein- <see langword="MethodDef" /> oder- <see langword="MemberRef" /> handle, das angibt, auf welche generische Methode diese Instanz verweist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Ruft ein Handle zum Signaturblob ab.</summary>
      <returns vsli:raw="A handle to the signature blob.">Ein Handle für das Signatur-BLOB.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary vsli:raw="Gets all exported types that reside directly in a namespace.">Ruft alle exportierten Typen ab, die sich direkt in einem Namespace befinden.</summary>
      <returns vsli:raw="An immutable array of exported type handles.">Ein unveränderliches Array von exportierten typhandles.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary vsli:raw="Gets the unqualified name of the namespace definition.">Ruft den nicht qualifizierten Name der Namespacedefinition ab.</summary>
      <returns vsli:raw="The unqualified name of the namespace definition.">Der nicht qualifizierte Name der Namespace Definition.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary vsli:raw="Gets the namespace definitions that are direct children of the current namespace definition.">Ruft die Namespacedefinitionen ab, die der aktuellen Namespacedefinition direkt untergeordnet sind.</summary>
      <returns vsli:raw="An immutable array of namespace definitions that are direct children of the current namespace definition.">Ein unveränderliches Array von Namespace Definitionen, die direkte untergeordnete Elemente der aktuellen Namespace Definition sind.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary vsli:raw="Gets the parent namespace.">Ruft den übergeordneten Namespace ab.</summary>
      <returns vsli:raw="The parent namespace.">Der übergeordnete Namespace.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary vsli:raw="Gets all type definitions that reside directly in a namespace.">Ruft alle Typdefinitionen ab, die sich direkt in einem Namespace befinden.</summary>
      <returns vsli:raw="An immutable array of type definition handles.">Ein unveränderliches Array von typdefinitions Handles.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary vsli:raw="Provides a handle to a namespace definition.">Stellt ein Handle für eine Namespacedefinition bereit.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary vsli:raw="Contains a collection of parameters of a specified method.">Enthält eine Sammlung von Parametern einer angegebenen Methode.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Ruft <see cref="T:System.Reflection.Metadata.MetadataReader" /> aus <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ab.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <returns vsli:raw="A metadata reader.">Ein metadatenreader.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Ruft einen Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten aus einem <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ab.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">Ein Enumerationswert, der die Konfiguration zum Lesen von Metadaten angibt.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <returns vsli:raw="A metadata reader with the specified metadata reading configuration.">Ruft einen Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten ab.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration and encoding configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Ruft einen Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten und der Codierungskonfiguration aus einem <see cref="T:System.Reflection.PortableExecutable.PEReader" /> ab.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">Ein Enumerationswert, der die Konfiguration zum Lesen von Metadaten angibt.</param>
      <param name="utf8Decoder" vsli:raw="A metadata string decoder with the encoding configuration.">Ein Metadatenzeichenfolgen-Decoder mit der Codierungskonfiguration.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">Die Codierung von <paramref name="utf8Decoder" /> ist keine <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">Die aktuelle Plattform ist Big-Endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <returns vsli:raw="&amp;gt;A metadata reader with the specified metadata reading configuration and encoding configuration.">&gt;Ein Metadatenleser mit der angegebenen Konfiguration zum Lesen von Metadaten und der Codierungskonfiguration.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary vsli:raw="Returns a body block of a method with the specified Relative Virtual Address (RVA).">Gibt einen Textblock einer Methode mit der angegebenen relativen virtuellen Adresse (RVA) zurück.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">Die aktuelle <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Instanz.</param>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address (RVA).">Die RVA (Relative Virtual Address, relative virtuelle Adresse).</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The body is not found in the metadata or is invalid.">Der Text wurde in den Metadaten nicht gefunden oder ist ungültig.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The section where the method is stored is not available.">Der Abschnitt, in dem die Methode gespeichert ist, ist nicht verfügbar.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error occurred while reading from the underlying stream.">Beim Lesen aus dem zugrunde liegenden Stream ist ein E/A-Fehler aufgetreten.</exception>
      <returns vsli:raw="A method block body instance.">Eine Methodentextblock-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary vsli:raw="Specifies constants that define the type codes used to encode types of primitive values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttribute&quot; /&gt; value blob.">Gibt Konstanten an, die Typcodes definieren, die zum Codieren von Typen primitiver Werte in einem Blob mit dem <see cref="T:System.Reflection.Metadata.CustomAttribute" />-Wert verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">Ein <see cref="T:System.Boolean" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer type.">Ein unsignierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">Ein <see cref="T:System.Char" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">Ein 8-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">Ein signierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">Ein signierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">Ein signierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">Ein signierter 1-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">Ein 4-Byte-Gleitkommatyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Ein <see cref="T:System.String" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">Ein unsignierter 2-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">Ein unsignierter 4-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">Ein unsignierter 8-Byte-Ganzzahltyp.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary vsli:raw="Specifies constants that define primitive types found in metadata signatures.">Gibt Konstanten an, die primitive Typen definieren, die in Signaturen von Metadaten gefunden wurden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">Ein <see cref="T:System.Boolean" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; type.">Ein <see cref="T:System.Byte" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">Ein <see cref="T:System.Char" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Double&quot; /&gt; type.">Ein <see cref="T:System.Double" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int16&quot; /&gt; type.">Ein <see cref="T:System.Int16" /> Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">Ein <see cref="T:System.Int32" /> Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int64&quot; /&gt; type.">Ein <see cref="T:System.Int64" /> Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; type.">Ein <see cref="T:System.IntPtr" /> Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; type.">Ein <see cref="T:System.Object" /> Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.SByte&quot; /&gt; type.">Ein <see cref="T:System.SByte" /> Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Single&quot; /&gt; type.">Ein <see cref="T:System.Single" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Ein <see cref="T:System.String" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary vsli:raw="A typed reference.">Ein typisierter Verweis.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt16&quot; /&gt; type.">Ein <see cref="T:System.UInt16" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt32&quot; /&gt; type.">Ein <see cref="T:System.UInt32" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt64&quot; /&gt; type.">Ein <see cref="T:System.UInt64" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; type.">Ein <see cref="T:System.UIntPtr" />-Typ.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">Ein <see cref="T:System.Void" />-Typ.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary vsli:raw="Represents a handle and a corresponding blob on a metadata heap that was reserved for future content update.">Stellt ein Handle und ein entsprechendes Blob für einen Metadatenheap dar, die für die zukünftige Aktualisierung von Inhalten reserviert wurden.</summary>
      <typeparam name="THandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt; to be used to update the content.">Gibt einen <see cref="T:System.Reflection.Metadata.BlobWriter" /> zurück, der zum Aktualisieren des Inhalts verwendet wird.</summary>
      <returns vsli:raw="A blob writer to be used to update the content.">Ein Blobschreiber, der zum Aktualisieren des Inhalts verwendet wird.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary vsli:raw="Gets the reserved blob handle.">Ruft das reservierte Blobhandle ab.</summary>
      <returns vsli:raw="The reserved bloc handle.">Der reservierte Block handle.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" vsli:raw="The object to compare with the current object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary vsli:raw="Specifies type codes used to encode the types of values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; blob.">Gibt Typcodes an, die zum Codieren der Werttypen in einem <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />-Blob verwendet werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Boolean&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Byte&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Char&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Double&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary vsli:raw="The attribute argument is an Enum instance.">Das Attributargument ist eine Enum-Instanz.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int16&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int32&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int64&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SByte&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Single&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.String&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SZArray&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary vsli:raw="The attribute argument is &quot;boxed&quot; (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.">Das Attributargument wird „geschachtelt“ (d.h., es wird an einen Parameter, ein Feld oder eine Eigenschaft eines Typobjekts weitergegeben) und enthält Typinformationen im Attributblob.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary vsli:raw="The attribute argument is a &lt;see cref=&quot;T:System.Type&quot; /&gt; instance.">Das Attributargument ist eine <see cref="T:System.Type" />-Instanz.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt16&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt32&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" /> entspricht.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt64&quot; /&gt;.">Ein Wert, der <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" /> entspricht.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary vsli:raw="Specifies additional flags that can be applied to method signatures. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Gibt zusätzliche Kennzeichen an, die auf die Methodensignatur angewendet werden können. Die zugrunde liegenden Werte der Felder in diesem Typen entsprechen der Darstellung im führenden Signaturbyte, die von einer <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur dargestellt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary vsli:raw="Indicates the first explicitly declared parameter that represents the instance pointer.">Gibt den ersten explizit angegebenen Parameter an, der den Instanzenzeiger darstellt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary vsli:raw="A generic method.">Eine generische Methode.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary vsli:raw="&lt;para&gt;An instance method.&lt;/para&gt;&lt;para&gt;The Ecma 335 CLI Specification refers to this flag as &lt;see langword=&quot;HAS_THIS&quot; /&gt;.&lt;/para&gt;">Eine Instanzmethode.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary vsli:raw="No flags.">Keine Flags.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary vsli:raw="Specifies how arguments in a given signature are passed from the caller to the callee. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Gibt an, wie Argumente in einer vorhandenen Signatur vom Aufrufer an den Aufgerufenen weitergegeben werden. Die zugrunde liegenden Werte der Felder in diesem Typen entsprechen der Darstellung im führenden Signaturbyte, die von einer <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur dargestellt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary vsli:raw="An unmanaged C/C++ style calling convention where the call stack is cleaned by the caller.">Eine nicht verwaltete Aufrufkonvention im C/C++-Stil, bei der die Aufrufliste vom Aufrufer bereinigt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary vsli:raw="A managed calling convention with a fixed-length argument list.">Eine verwaltete Aufrufkonvention mit einer Liste von Argumenten, die eine feste Länge hat.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary vsli:raw="An unmanaged calling convention where arguments are passed in registers when possible.">Eine nicht verwaltete Aufrufkonvention, bei der die Argumente, wenn möglich, in Registern weitergegeben werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary vsli:raw="An unmanaged calling convention where the call stack is cleaned up by the callee.">Eine nicht verwaltete Aufrufkonvention, bei der die Aufrufliste vom Aufgerufenen bereinigt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary vsli:raw="An unmanaged C++ style calling convention for calling instance member functions with a fixed argument list.">Eine nicht verwaltete Aufrufkonvention im C++-Stil für eine Aufrufinstanz von Memberfunktionen mit einer festen Liste von Argumenten.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary vsli:raw="Indicates that the specifics of the unmanaged calling convention are encoded as modopts.">Diese gibt an, dass die Besonderheiten der nicht verwalteten Aufrufkonvention als modopts codiert werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary vsli:raw="A managed calling convention for passing extra arguments.">Eine verwaltete Aufrufkonvention zum Weitergeben von zusätzlichen Argumenten.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary vsli:raw="Represents the signature characteristics specified by the leading byte of signature blobs.">Stellt die Signatureigenschaften dar, die vom führenden Byte der Signaturblobs dargestellt werden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary vsli:raw="Gets the mask value for the calling convention or signature kind. The default &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask&quot; /&gt; value is 15 (0x0F).">Ruft den Maskenwert für die Aufrufkonvention oder die Art der Signatur ab. Der Standardwert <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> lautet 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified byte value.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur unter Verwendung des angegebenen Byte.</summary>
      <param name="rawValue" vsli:raw="The byte.">Das Byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified signature kind, calling convention and signature attributes.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur mithilfe der angegebenen Art der Signatur, der Abrufkonvention und der Attribute der Signatur.</summary>
      <param name="kind" vsli:raw="The signature kind.">Die Art der Signatur.</param>
      <param name="convention" vsli:raw="The calling convention.">Die Aufrufkonvention.</param>
      <param name="attributes" vsli:raw="The signature attributes.">Die Attribute der Signatur.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary vsli:raw="Compares the specified object with this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; for equality.">Prüft das angegebene Objekt mit diesem <see cref="T:System.Reflection.Metadata.SignatureHeader" /> auf Gleichheit.</summary>
      <param name="obj" vsli:raw="The object to compare.">Das zu vergleichende Objekt.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Objekte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">Überprüft zwei <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Werte auf Gleichheit.</summary>
      <param name="other" vsli:raw="The value to compare.">Der zu vergleichende Wert.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Werte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current object.">Ruft einen Hashcode für das aktuelle Objekt ab.</summary>
      <returns vsli:raw="A hash code for the current object.">Ein Hashcode für das aktuelle Objekt.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">Überprüft zwei <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Werte auf Gleichheit.</summary>
      <param name="left" vsli:raw="The first value to compare.">Der erste zu vergleichende Wert.</param>
      <param name="right" vsli:raw="The second value to compare.">Der zweite zu vergleichende Wert.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Werte gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values are unequal.">Bestimmt, ob zwei <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Werte ungleich sind.</summary>
      <param name="left" vsli:raw="The first value to compare.">Der erste zu vergleichende Wert.</param>
      <param name="right" vsli:raw="The second value to compare.">Der zweite zu vergleichende Wert.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn die Werte ungleich sind; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary vsli:raw="Returns a string that represents the current object.">Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</summary>
      <returns vsli:raw="A string that represents the current object.">Eine Zeichenfolge, die das aktuelle Objekt darstellt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary vsli:raw="Gets the signature attributes.">Ruft die Attribute der Signatur ab.</summary>
      <returns vsli:raw="The attributes.">Die Attribute.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary vsli:raw="Gets the calling convention.">Ruft die Aufrufkonvention ab.</summary>
      <returns vsli:raw="The calling convention.">Die Aufrufkonvention.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; signature attribute.">Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur über das <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />-Attribut der Signatur verfügt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> Attribut vorhanden ist, andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; signature attribute.">Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur über das <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />-Attribut der Signatur verfügt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> Attribut vorhanden ist, andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; signature attribute.">Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur über das <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />-Attribut der Signatur verfügt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> Attribut vorhanden ist, andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary vsli:raw="Gets the signature kind.">Ruft die Art der Signatur ab.</summary>
      <returns vsli:raw="The signature kind.">Die Art der Signatur.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary vsli:raw="Gets the raw value of the header byte.">Ruft den Rohwert des Headerbytes ab.</summary>
      <returns vsli:raw="The raw value of the header byte.">Der Rohwert des Header bytes.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary vsli:raw="Specifies the signature kind. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Gibt die Art der Signatur an. Die zugrunde liegenden Werte der Felder in diesem Typen entsprechen der Darstellung im führenden Signaturbyte, die von einer <see cref="T:System.Reflection.Metadata.SignatureHeader" />-Struktur dargestellt wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary vsli:raw="A field signature.">Eine Feldsignatur.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary vsli:raw="A local variables signature.">Eine Signatur der lokalen Variablen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary vsli:raw="A method reference, method definition, or standalone method signature.">Ein Methodenverweis, eine Methodendefinition oder eine eigenständige Methodensignatur.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary vsli:raw="A method specification signature.">Eine Methodensignatur zur Spezifizierung.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary vsli:raw="A property signature.">Eine Signatureigenschaft.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary vsli:raw="Specifies constants that define type codes used in signature encoding.">Gibt Konstanten an, die in der Signaturcodierung zum Definieren des Typcodes verwendet wurden.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary vsli:raw="Represents a generalized &lt;see cref=&quot;T:System.Array&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.Array" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.Boolean" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary vsli:raw="Represents managed pointers (byref return values and parameters) in signatures. It is followed in the blob by the signature encoding of the underlying type.">Stellt verwaltete Zeiger (ByRef-Rückgabewerte und -Parameter) in Signaturen dar. Im Blob folgt eine Signaturcodierung des zugrunde liegenden Typs.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Byte&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.Byte" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Char&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.Char" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Double&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.Double" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary vsli:raw="Represents function pointer types in signatures.">Stellt Typen von Funktionszeigern in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary vsli:raw="Represents a generic method parameter used within a signature.">Stellt einen generischen Methodenparameter dar, der in einer Signatur verwendet wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary vsli:raw="Represents the instantiation of a generic type in signatures.">Stellt die Instanziierung eines generischen Typs in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary vsli:raw="Represents a generic type parameter used within a signature.">Stellt einen generischen Typparameter dar, der in einer Signatur verwendet wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int16&quot; /&gt; in signatures.">Stellt ein <see cref="T:System.Int16" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int32&quot; /&gt; in signatures.">Stellt ein <see cref="T:System.Int32" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int64&quot; /&gt; in signatures.">Stellt ein <see cref="T:System.Int64" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; in signatures.">Stellt ein <see cref="T:System.IntPtr" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary vsli:raw="Represents an invalid or uninitialized type code. It will not appear in valid signatures.">Stellt einen ungültigen oder nicht initialisierten Typcode dar. Er erscheint nicht in gültigen Signaturen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Object&quot; /&gt; in signatures.">Stellt ein <see cref="T:System.Object" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller can ignore.">Stellt einen benutzerdefinierten Modifizierer dar, der auf einen Typen einer Signatur angewendet wird, die der Aufrufer ignorieren kann.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary vsli:raw="Represents a local variable that is pinned by garbage collector.">Stellt eine lokale Variable dar, die über den Garbage Collector angeheftet wird.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary vsli:raw="Represents an unmanaged pointer in signatures. It is followed in the blob by the signature encoding of the underlying type.">Stellt einen nicht verwalteten Zeiger in Signaturen dar. Im Blob folgt eine Signaturcodierung des zugrunde liegenden Typs.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller must understand.">Stellt einen benutzerdefinierten Modifizierer dar, der auf einen Typen einer Signatur angewendet wird, die der Aufrufer verstehen muss.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.SByte&quot; /&gt; in signatures.">Stellt ein <see cref="T:System.SByte" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary vsli:raw="Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments.">Stellt einen Marker dar, der das Ende der festen Argumente und den Anfang der Variablenargumente anzeigen soll.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Single&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.Single" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.String&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.String" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary vsli:raw="Represents a single dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; with a lower bound of 0.">Stellt einen eindimensionalen <see cref="T:System.Array" /> mit einer Untergrenze von NULL dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary vsli:raw="Represents a typed reference in signatures.">Stellt einen typisierten Verweis in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary vsli:raw="Precedes a type &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; in signatures. In raw metadata, this is encoded as either ELEMENT_TYPE_CLASS (0x12) for reference types or ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single code because Windows Runtime projections can project from class to value type or vice-versa, and the raw code is misleading in those cases.">Steht vor einem <see cref="T:System.Reflection.Metadata.EntityHandle" />-Typen in Signaturen. In den Rohmetadaten wird dies als ELEMENT_TYPE_CLASS (0x12) für Verweistypen oder als ELEMENT_TYPE_VALUETYPE (0x11) für Werttypen codiert. Dies wird auf einen einzigen Code reduziert, da Windows-Runtime-Projektionen von Klasse zu Werttyp oder umgekehrt projizieren können, und der Rohcode ist in diesen Fällen irreführend.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.UInt16" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.UInt32" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.UInt64" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; in signatures.">Stellt einen generalisierten <see cref="T:System.UIntPtr" /> in Signaturen dar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary vsli:raw="Represents &lt;see cref=&quot;T:System.Void&quot; /&gt; in signatures.">Stellt einen <see cref="T:System.Void" /> in Signaturen dar.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary vsli:raw="Indicates the type definition of the signature.">Gibt die Typdefinition der Signatur an.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary vsli:raw="The type definition or reference refers to a class.">Die Typdefinition oder der Verweis deuten auf eine Klasse hin.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary vsli:raw="It isn't known in the current context if the type reference or definition is a class or value type.">Im aktuellen Kontext ist nicht bekannt, ob der Typverweis oder die Definition eine Klasse oder einen Werttypen darstellt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary vsli:raw="The type definition or reference refers to a value type.">Die Typdefinition oder der Verweis deuten auf einen Werttypen hin.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary vsli:raw="Determines the kind of signature, which can be &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.Method&quot; /&gt; or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.LocalVariables&quot; /&gt;.">Bestimmt die Art der Signatur, die möglicherweise <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> oder <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" /> sein kann.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The signature is invalid.">Die Signatur ist ungültig.</exception>
      <returns vsli:raw="An enumeration value that indicates the signature kind.">Ein Enumerationswert, der die Art der Signatur angibt.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Ruft ein Handle zum Signaturblob ab.</summary>
      <returns vsli:raw="A handle to the signature blob.">Ein Handle für das Signatur-BLOB.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary vsli:raw="Indicates whether a &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method or local variable signature.">Gibt an, ob <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> eine eigenständige Methode oder eine Signatur einer lokalen Variablen darstellt.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a local variable signature.">
        <see cref="T:System.Reflection.Metadata.MemberReference" /> verweist auf eine Signatur der lokalen Variablen.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method signature.">
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> stellt eine eigenständige Methodensignatur dar.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary vsli:raw="Returns the enclosing type of a specified nested type.">Gibt den einschließenden Typ für einen angegebenen geschachtelten Typ zurück.</summary>
      <returns vsli:raw="The enclosing type of the specified nested type, or a handle a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is not nested.">Der einschließende Typ des angegebenen geschachtelten Typs, oder ein Handle, dessen <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />-Eigenschaft <see langword="true" /> ist, wenn der Typ nicht geschachtelt ist.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary vsli:raw="Returns an array of types nested in the specified type.">Gibt ein Array von Typen zurück, die in dem angegebenen Typ geschachtelt sind.</summary>
      <returns vsli:raw="An immutable array of type definition handles that represent types nested in the specified type.">Ein unveränderliches Array von Typdefinitionshandles, die in dem angegebenen Typ geschachtelte Typen darstellen.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary vsli:raw="Gets the base type of the type definition: either &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;.">Ruft den Basistyp der Typdefinition ab: entweder <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> oder <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns vsli:raw="The base type of the type definition.">Der Basistyp der Typdefinition.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary vsli:raw="Gets a value that indicates whether this is a nested type.">Ruft einen Wert ab, der angibt, ob dies ein geschachtelter Typ ist.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it is a nested type, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> , wenn es sich um einen Typ handelt, <see langword="false" /> andernfalls.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary vsli:raw="Gets the name of the type.">Ruft den Namen des Typs ab.</summary>
      <returns vsli:raw="The name of the type.">Der Name des Typs.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the type is defined.">Ruft den vollständigen Namen des Namespace ab, in dem der Typ definiert ist.</summary>
      <returns vsli:raw="The full name of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">Der vollständige Name des Namespace, in dem der Typ definiert ist, oder ein Handle, dessen- <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> Eigenschaft ist, <see langword="true" /> Wenn der Typ in einem Stamm Namespace oder in einem Namespace definiert ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the type is defined.">Ruft das Definitionshandle des Namespace ab, in dem der Typ definiert ist.</summary>
      <returns vsli:raw="The definition handle of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;  if the type is nested or defined in a root namespace.">Das Definitions Handle des Namespace, in dem der Typ definiert ist, oder ein Handle, dessen- <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> Eigenschaft ist, <see langword="true" />  Wenn der Typ in einem Stamm Namespace eingebettet oder definiert ist.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; instances.">Enthält eine Auflistung von <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />-Instanzen.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" vsli:raw="" />
      <param name="packingSize" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary vsli:raw="Gets the name of the target type.">Ruft den Namen des Zieltyps ab.</summary>
      <returns vsli:raw="The name of the target type.">Der Name des Zieltyps.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the target type is defined.">Ruft den vollständigen Namen des Namespace ab, in dem der Zieltyp definiert ist.</summary>
      <returns vsli:raw="The full name of the namespace where the target type is defined, or a handle whose the &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">Der vollständige Name des Namespace, in dem der Zieltyp definiert ist, oder ein Handle, dessen- <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> Eigenschaft ist <see langword="true" /> , wenn der Typ in einem Stamm Namespace eingebettet oder definiert ist.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary vsli:raw="Gets the resolution scope in which the target type is defined and is uniquely identified by the specified &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Namespace&quot; /&gt; and &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Name&quot; /&gt;.">Ruft den Auflösungsbereich ab, in dem der Zieltyp definiert ist und eindeutig mit dem angegebenen <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> und <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> identifiziert wird.</summary>
      <returns vsli:raw="The resolution scope in which the target type is uniquely defined.">Der Auflösungs Bereich, in dem der Zieltyp eindeutig definiert ist.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">Enthält eine Auflistung von <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />-Instanzen.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Ruft die Anzahl der Elemente in der Auflistung ab.</summary>
      <returns vsli:raw="The number of elements in the collection.">Die Anzahl der Elemente in der Auflistung.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Setzt den Enumerator auf das nächste Element der Auflistung.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Setzt den Enumerator auf seine anfängliche Position vor dem ersten Element in der Auflistung.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Ruft das Element in der Auflistung an der aktuellen Position des Enumerators ab.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">Das Element in der Auflistung an der aktuellen Position des Enumerators.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary vsli:raw="Represents a handle to the user string heap.">Stellt ein Handle für den Benutzerzeichenfolgenheap dar.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary vsli:raw="&lt;para&gt;Used to add a handler for an event. Corresponds to the &lt;see langword=&quot;AddOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant adders are named the with &lt;see langword=&quot;add_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Wird verwendet, um einen Handler für ein Ereignis hinzuzufügen. Entspricht dem <see langword="AddOn" />-Flag in der ECMA 335 CLI-Spezifikation.</para>
        <para>CLS-kompatible Adder werden mit dem Präfix <see langword="add_" /> benannt.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary vsli:raw="&lt;para&gt;Reads the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant getters are named with get_ prefix.&lt;/para&gt;">
        <para>Liest den Wert der-Eigenschaft.</para>
        <para>CLS-kompatible Getter werden mit dem Präfix get_ benannt.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary vsli:raw="Other method for a property (not a getter or setter) or an event (not an adder, remover, or raiser).">Andere Methode für eine Eigenschaft (kein Getter oder Setter) oder ein Ereignis (kein Adder, Remover oder Raiser).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary vsli:raw="&lt;para&gt;Used to indicate that an event has occurred. Corresponds to the &lt;see langword=&quot;Fire&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt; CLS-compliant raisers are named with the &lt;see langword=&quot;raise_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Wird verwendet, um anzugeben, dass ein Ereignis aufgetreten ist. Entspricht dem <see langword="Fire" />-Flag in der ECMA 335 CLI-Spezifikation.</para>
        <para> CLS-kompatible Raiser werden mit dem Präfix <see langword="raise_" /> benannt.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary vsli:raw="&lt;para&gt;Used to remove a handler for an event. Corresponds to the &lt;see langword=&quot;RemoveOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant removers are named with the &lt;see langword=&quot;remove_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Wird verwendet, um einen Handler für ein Ereignis zu entfernen. Entspricht dem <see langword="RemoveOn" />-Flag in der ECMA 335 CLI-Spezifikation.</para>
        <para>CLS-kompatible Remover werden mit dem Präfix <see langword="remove_" /> benannt.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary vsli:raw="&lt;para&gt;Used to modify the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant setters are named with the &lt;see langword=&quot;set_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Wird verwendet, um den Wert der-Eigenschaft zu ändern.</para>
        <para>CLS-kompatible Setter werden mit dem Präfix <see langword="set_" /> benannt.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary vsli:raw="Provides information about a Program Debug Database (PDB) file.">Stellt Informationen zu einer PDB-Datei (Program Debug Database) bereit.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary vsli:raw="The iteration of the PDB. The first iteration is 1. The iteration is incremented each time the PDB content is augmented.">Die Iteration der PDB-Datei. Die erste Iteration ist 1. Die Iteration wird bei jeder Vergrößerung des PDB-Inhalts erhöht.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary vsli:raw="The Globally Unique Identifier (GUID) of the associated PDB.">Die GUID (Globally Unique Identifier) der zugeordneten PDB-Datei.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary vsli:raw="The path to the .pdb file that contains debug information for the PE/COFF file.">Der Pfad zur PDB-Datei, die Debuginformationen für die PE/COFF-Datei enthält.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary vsli:raw="Represents the header of a COFF file.">Stellt den Header einer COFF-Datei dar.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary vsli:raw="Gets the flags that indicate the attributes of the file.">Ruft die Flags ab, die die Attribute der Datei angeben.</summary>
      <returns vsli:raw="The flags that indicate the attributes of the file.">Die Flags, die die Attribute der Datei angeben.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary vsli:raw="Gets the type of the target machine.">Ruft den Typ des Zielcomputers ab.</summary>
      <returns vsli:raw="The type of the target machine.">Der Typ des Ziel Computers.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary vsli:raw="Gets the number of sections. This indicates the size of the section table, which immediately follows the headers.">Ruft die Anzahl der Abschnitte ab. Dies gibt die Größe der Abschnittstabelle an, die unmittelbar auf die Header folgt.</summary>
      <returns vsli:raw="The number of sections.">Die Anzahl der Abschnitte.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary vsli:raw="Gets the number of entries in the symbol table. This data can be used to locate the string table, which immediately follows the symbol table. This value should be zero for a PE image.">Ruft die Anzahl der Einträge in der Symboltabelle ab. Diese Daten können verwendet werden, um die Zeichenfolgentabelle zu suchen, die unmittelbar auf die Symboltabelle folgt. Dieser Wert sollte für ein PE-Image NULL sein.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary vsli:raw="Gets the file pointer to the COFF symbol table.">Ruft den Dateizeiger auf die COFF-Symboltabelle ab.</summary>
      <returns vsli:raw="The file pointer to the COFF symbol table, or zero if no COFF symbol table is present. This value should be zero for a PE image.">Der Dateizeiger auf die COFF-Symboltabelle oder 0 (null), wenn keine COFF-Symboltabelle vorhanden ist. Dieser Wert sollte für ein PE-Image NULL sein.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary vsli:raw="Gets the size of the optional header, which is required for executable files but not for object files. This value should be zero for an object file.">Ruft die Größe des optionalen-Headers ab, der für ausführbare Dateien, jedoch nicht für Objektdateien erforderlich ist. Dieser Wert sollte für eine Objektdatei NULL sein.</summary>
      <returns vsli:raw="The size of the optional header.">Die Größe des optionalen Headers.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary vsli:raw="Gets a value that indicates when the file was created.">Ruft einen Wert ab, der angibt, wann die Datei erstellt wurde.</summary>
      <returns vsli:raw="The low 32 bits of the number of seconds since 00:00 January 1, 1970, which indicates when the file was created.">Die unteren 32 Bits der Anzahl der Sekunden 00:00 seit dem 1. Januar 1970, der angibt, wann die Datei erstellt wurde.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary vsli:raw="Represents the runtime flags for a .NET executable image.">COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryBuilder&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />-Klasse.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary vsli:raw="Adds a CodeView entry.">Fügt einen CodeView-Eintrag hinzu.</summary>
      <param name="pdbPath" vsli:raw="The path to the PDB. It should not be empty.">Der Pfad zur PDB-Datei. Er darf nicht leer sein.</param>
      <param name="pdbContentId" vsli:raw="The unique id of the PDB content.">Die eindeutige ID des PDB-Inhalts.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0), or 0 if the PDB is not portable.">Die Version des portablen PDB-Formats (z. B. 0x0100 für 1,0) oder 0 (null), wenn die PDB-Datei nicht portabel ist.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="pdbPath" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; contains a NUL character.">
        <paramref name="pdbPath" /> enthält ein NULL-Zeichen.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" /> ist kleiner als 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary vsli:raw="Adds an Embedded Portable PDB entry.">Fügt einen eingebetteten portablen PDB-Eintrag hinzu.</summary>
      <param name="debugMetadata" vsli:raw="A Portable PDB metadata builder.">Ein portabler PDB-Metadatengenerator.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0).">Die Version des portablen PDB-Formats (z. B. 0x0100 für 1,0).</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;debugMetadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="debugMetadata" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" /> ist kleiner als 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary vsli:raw="Adds an entry of the specified type.">Fügt einen Eintrag vom angegebenen Typ hinzu.</summary>
      <param name="type" vsli:raw="The entry type.">Der Eintragstyp.</param>
      <param name="version" vsli:raw="The entry version.">Die Version des Eintrags.</param>
      <param name="stamp" vsli:raw="The entry stamp.">Der Stempel des Eintrags.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary vsli:raw="Adds an entry of the specified type and serializes its data.">Fügt einen Eintrag vom angegebenen Typ hinzu und serialisiert dessen Daten.</summary>
      <param name="type" vsli:raw="The entry type.">Der Eintragstyp.</param>
      <param name="version" vsli:raw="The entry version.">Die Version des Eintrags.</param>
      <param name="stamp" vsli:raw="The entry stamp.">Der Stempel des Eintrags.</param>
      <param name="data" vsli:raw="The data to pass to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">Die Daten, die an <paramref name="dataSerializer" /> übergeben werden sollen.</param>
      <param name="dataSerializer" vsli:raw="A serializer for serializing data to a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Ein Serialisierungsprogramm zum Serialisieren von Daten in eine <see cref="T:System.Reflection.Metadata.BlobBuilder" />-Klasse.</param>
      <typeparam name="TData" vsli:raw="The type of the data passed to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">Der Typ der Daten, die an die übermittelt werden <paramref name="dataSerializer" /> .</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds PDB checksum entry.">Fügt einen PDB-Prüfsummeneintrag hinzu.</summary>
      <param name="algorithmName" vsli:raw="The hash algorithm name (for example, &quot;SHA256&quot;).">Der Name des Hashalgorithmus (z. B. „SHA256“).</param>
      <param name="checksum" vsli:raw="The checksum.">Die Prüfsumme.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="algorithmName" /> oder <paramref name="checksum" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is empty.">
        <paramref name="algorithmName" /> oder <paramref name="checksum" /> ist leer.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary vsli:raw="Adds a reproducible entry.">Fügt einen reproduzierbaren Eintrag hinzu.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary vsli:raw="Identifies the location, size and format of a block of debug information.">Identifiziert den Speicherort, die Größe und das Format eines Debuginformationenblocks.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntry&quot; /&gt; structure.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />-Struktur.</summary>
      <param name="stamp" vsli:raw="" />
      <param name="majorVersion" vsli:raw="" />
      <param name="minorVersion" vsli:raw="" />
      <param name="type" vsli:raw="" />
      <param name="dataSize" vsli:raw="" />
      <param name="dataRelativeVirtualAddress" vsli:raw="" />
      <param name="dataPointer" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary vsli:raw="Gets the file pointer to the debug data.">Ruft den Dateizeiger auf die Debugdaten ab.</summary>
      <returns vsli:raw="The file pointer to the debug data.">Der Dateizeiger auf die Debugdaten.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary vsli:raw="Gets the address of the debug data when loaded, relative to the image base.">Ruft die Adresse der Debugdaten relativ zur Imagebasis ab, wenn sie geladen werden.</summary>
      <returns vsli:raw="The address of the debug data relative to the image base.">Die Adresse der Debugdaten relativ zur Bildbasis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary vsli:raw="Gets the size of the debug data (not including the debug directory itself).">Ruft die Größe der Debugdaten ab (ohne das Debugverzeichnis selbst).</summary>
      <returns vsli:raw="the size of the debug data (excluding the debug directory).">die Größe der Debugdaten (mit Ausnahme des debugverzeichnisses).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary vsli:raw="Gets a value that indicates if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry that points to a Portable PDB.">Ruft einen Wert ab, der darauf hinweist, ob es sich um einen Eintrag vom Typ <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> handelt, der auf eine portable PDB-Dabei zeigt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry pointing to a Portable PDB; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn es sich bei dem Eintrag um einen Eintrag handelt, der <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> auf eine Portable PDB zeigt; andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary vsli:raw="Gets the major version number of the debug data format.">Ruft die Hauptversionsnummer des Debugdatenformats ab.</summary>
      <returns vsli:raw="The major version number of the debug data format.">Die Hauptversionsnummer des debugdatenformats.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary vsli:raw="Gets the minor version number of the debug data format.">Ruft die Nebenversionsnummer des Debugdatenformats ab.</summary>
      <returns vsli:raw="The minor version number of the debug data format.">Die neben Versionsnummer des debugdatenformats.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary vsli:raw="Get the time and date that the debug data was created if the PE/COFF file is not deterministic; otherwise, gets a value based on the hash of the content.">Ruft das Datum und die Uhrzeit der Erstellung der Debugdaten ab, wenn die PE/COFF-Datei nicht deterministisch ist. Andernfalls wird ein Wert abgerufen, der auf dem Hash des Inhalts basiert.</summary>
      <returns vsli:raw="for a non-deterministic PE/COFF file, the time and date that the debug data was created; otherwise, a value based on the hash of the content.">für eine nicht deterministische PE/COFF-Datei das Datum und die Uhrzeit der Erstellung der Debugdaten. andernfalls ein Wert, der auf dem Hashwert des Inhalts basiert.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary vsli:raw="Gets the format of the debugging information.">Ruft das Format der Debuginformationen ab.</summary>
      <returns vsli:raw="The format of the debugging information.">Das Format der Debuginformationen.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary vsli:raw="An enumeration that describes the format of the debugging information of a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntry&quot; /&gt;.">Eine Enumeration, die das Format der Debuginformationen einer <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />-Struktur beschreibt</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary vsli:raw="Associated PDB file description. For more information, see the specification.">Zugehörige PDB-Dateibeschreibung.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary vsli:raw="The COFF debug information (line numbers, symbol table, and string table). This type of debug information is also pointed to by fields in the file headers.">Die COFF-Debuginformationen (Zeilennummern, Symboltabelle und Zeichenfolgentabelle). Auf diese Art von Debuginformationen wird auch von Feldern in Dateiheadern verwiesen.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary vsli:raw="&lt;para&gt;The entry points to a blob containing Embedded Portable PDB. The Embedded Portable PDB blob has the following format:&lt;/para&gt;&lt;para&gt;- blob ::= uncompressed-size data&lt;/para&gt;&lt;para&gt;- Data spans the remainder of the blob and contains a Deflate-compressed Portable PDB.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">
        <para>Der Eintrag verweist auf ein Blob, das eingebettete portierbare PDB-Dateien enthält. Das eingebettete portierbare PDB-Blob weist das folgende Format auf:</para>
        <para>- blob ::= uncompressed-size data (Daten mit nicht komprimierter Größe)</para>
        <para>- Die Daten umfassen den Rest des Blobs und enthalten eine mit einem Deflate-Algorithmus komprimierte portierbare PDB-Datei.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary vsli:raw="The entry stores a crypto hash of the content of the symbol file the PE/COFF file was built with. The hash can be used to validate that a given PDB file was built with the PE/COFF file and not altered in any way. More than one entry can be present if multiple PDBs were produced during the build of the PE/COFF file (for example, private and public symbols). For more information, see the specification.">Der Eintrag enthält einen Kryptografiehash des Inhalts der Symboldatei, mit dem die PE/COFF-Datei erstellt wurde. Der Hash kann verwendet werden, um zu überprüfen, ob eine bestimmte PDB-Datei mit der PE/COFF-Datei erstellt wurde und in keiner Weise geändert wurde. Wenn mehrere PDB-Dateien während der Erstellung der PE/COFF-Datei erstellt wurden (z. B. private und öffentliche Symbole), können mehrere Einträge vorhanden sein.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary vsli:raw="&lt;para&gt;The presence of this entry indicates a deterministic PE/COFF file. See the Remarks section for more information.&lt;/para&gt;&lt;para&gt;The tool that produced the deterministic PE/COFF file guarantees that the entire content of the file is based solely on documented inputs given to the tool (such as source files, resource files, and compiler options) rather than ambient environment variables (such as the current time, the operating system, and the bitness of the process running the tool).&#xA;          The value of field TimeDateStamp in COFF File Header of a deterministic PE/COFF file does not indicate the date and time when the file was produced and should not be interpreted that way. Instead, the value of the field is derived from a hash of the file content. The algorithm to calculate this value is an implementation detail of the tool that produced the file.&#xA;          The debug directory entry of type &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible&quot; /&gt; must have all fields, except for Type zeroed.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">Das Vorhandensein dieses Eintrags deutet auf eine deterministische PE/COFF-Datei hin. Weitere Informationen finden Sie im Abschnitt Hinweise.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary vsli:raw="An unknown value that should be ignored by all tools.">Ein unbekannter Wert, der von allen Tools ignoriert werden sollte.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="size" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary vsli:raw="Describes the characteristics of a dynamic link library.">Beschreibt die Eigenschaften einer Dynamic Link Library.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary vsli:raw="The image must run inside an AppContainer.">Das Image muss in einem AppContainer ausgeführt werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary vsli:raw="The DLL can be relocated.">Die DLL kann verschoben werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary vsli:raw="The image can handle a high entropy 64-bit virtual address space.">Das Image kann einen virtuellen 64-Bit-Adressraum mit hoher Entropie verarbeiten.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary vsli:raw="Do not bind this image.">Binden Sie dieses Image nicht.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary vsli:raw="The image understands isolation and doesn't want it.">Das Image erkennt die Isolation und lehnt sie ab.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary vsli:raw="The image does not use SEH. No SE handler may reside in this image.">Das Image verwendet SEH nicht. In diesem Image darf kein SE-Handler vorhanden sein.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary vsli:raw="The image is NX compatible.">Das Image ist mit NX kompatibel.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary vsli:raw="Reserved.">Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary vsli:raw="Reserved.">Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary vsli:raw="The image is Terminal Server aware.">Das Image ist Terminalserverfähig.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary vsli:raw="Reserved.">Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary vsli:raw="Reserved.">Reserviert.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary vsli:raw="The driver uses the WDM model.">Der Treiber verwendet das WDM-Modell.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary vsli:raw="Specifies the target machine's CPU architecture.">Gibt die CPU-Architektur des Zielcomputers an.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary vsli:raw="Alpha.">Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary vsli:raw="ALPHA64.">ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary vsli:raw="Matsushita AM33.">Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary vsli:raw="AMD64 (K8).">AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary vsli:raw="ARM little endian.">ARM Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary vsli:raw="ARM64.">ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary vsli:raw="ARM Thumb-2 little endian.">ARM Thumb-2 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary vsli:raw="EFI Byte Code.">EFI-Bytecode.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary vsli:raw="Intel 386.">Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary vsli:raw="Intel 64.">Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary vsli:raw="M32R little-endian.">M32R Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary vsli:raw="MIPS.">MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary vsli:raw="MIPS with FPU.">MIPS mit FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary vsli:raw="MIPS16 with FPU.">MIPS16 mit FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary vsli:raw="IBM PowerPC little endian.">IBM PowerPC Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary vsli:raw="PowerPCFP.">PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary vsli:raw="Hitachi SH3 DSP.">Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary vsli:raw="Hitachi SH4 little endian.">Hitachi SH4 Little-Endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary vsli:raw="Hitachi SH5.">Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary vsli:raw="Thumb.">Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary vsli:raw="Infineon.">Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary vsli:raw="The target CPU is unknown or not specified.">Die Ziel-CPU ist unbekannt oder wurde nicht angegeben.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary vsli:raw="MIPS little-endian WCE v2.">MIPS Little-Endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" vsli:raw="" />
      <param name="metadataRootBuilder" vsli:raw="" />
      <param name="ilStream" vsli:raw="" />
      <param name="mappedFieldData" vsli:raw="" />
      <param name="managedResources" vsli:raw="" />
      <param name="nativeResources" vsli:raw="" />
      <param name="debugDirectoryBuilder" vsli:raw="" />
      <param name="strongNameSignatureSize" vsli:raw="" />
      <param name="entryPoint" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="deterministicIdProvider" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" vsli:raw="" />
      <param name="signatureProvider" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary vsli:raw="Represents a PDB Checksum debug directory entry.">Stellt einen PDB-Prüfsummen-Debugverzeichniseintrag dar.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary vsli:raw="The name of the crypto hash algorithm used to calculate the checksum.">Der Name des Kryptografiehashalgorithmus, der verwendet wird, um die Prüfsumme zu berechnen.</summary>
      <returns vsli:raw="A string representing the name of the crypto hash algorithm used to calculate the checksum.">Eine Zeichenfolge, die den Namen des kryptografiehash Algorithmus darstellt, mit dem die Prüfsumme berechnet wird.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary vsli:raw="The checksum of the PDB content.">Die Prüfsumme des PDB-Inhalts.</summary>
      <returns vsli:raw="An immutable array of bytes representing the checksum of the PDB content.">Ein unveränderliches Bytearray, das die Prüfsumme des PDB-Inhalts darstellt.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" vsli:raw="" />
      <param name="deterministicIdProvider" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" vsli:raw="" />
      <param name="characteristics" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary vsli:raw="Builds PE directories.">Erstellt PE-Verzeichnisse.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary vsli:raw="Initializes an instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEDirectoriesBuilder&quot; /&gt; class.">Initialisiert eine Instanz der <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />-Klasse.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary vsli:raw="The address of the entry point relative to the image base when the PE file is loaded into memory.">Die Adresse des Einstiegspunkts relativ zur Imagebasis, wenn die PE-Datei in den Arbeitsspeicher geladen wird.</summary>
      <returns vsli:raw="For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero.">Bei Programm Images ist dies die Startadresse. Für Gerätetreiber ist dies die Adresse der Initialisierungsfunktion. Ein Einstiegspunkt ist für DLLs optional. Wenn kein Einstiegspunkt vorhanden ist, muss dieses Feld NULL sein.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary vsli:raw="The base relocation table image directory entry.">Der Imageverzeichniseintrag einer Basisumsetzungstabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary vsli:raw="The bound import image directory entry.">Der Imageverzeichniseintrag eines gebundenen Imports.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary vsli:raw="The copyright/architecture image directory entry.">Der Imageverzeichniseintrag von Copyright/Architektur.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary vsli:raw="The COM descriptortable image directory entry.">Der Imageverzeichniseintrag einer COM-Deskriptortabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary vsli:raw="The debug table image directory entry.">Der Imageverzeichniseintrag einer Debugtabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary vsli:raw="The delay import table image directory entry.">Der Imageverzeichniseintrag einer Verzögerungsimporttabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary vsli:raw="The exception table image directory entry.">Der Imageverzeichniseintrag einer Ausnahmetabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary vsli:raw="The export table image directory entry.">Der Imageverzeichniseintrag einer Exporttabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary vsli:raw="The global pointer table image directory entry.">Der Imageverzeichniseintrag einer globalen Zeigertabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary vsli:raw="The import address table (IAT) image directory entry.">Der Imageverzeichniseintrag einer Importadresstabelle (IAT).</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary vsli:raw="The import table image directory entry.">Der Imageverzeichniseintrag einer Importtabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary vsli:raw="The load configuration table image directory entry.">Der Imageverzeichniseintrag einer Ladekonfigurationstabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary vsli:raw="The resource table image directory entry.">Der Imageverzeichniseintrag einer Ressourcentabelle.</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary vsli:raw="The thread local storage (TLS) table image directory entry.">Der Imageverzeichniseintrag einer TLS-Tabelle (lokaler Threadspeicher).</summary>
      <returns vsli:raw="A directory entry instance.">Eine Instanz eines Verzeichniseintrags.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary vsli:raw="Gets the address of the entry point relative to the image base when the PE file is loaded into memory.">Ruft beim Laden der PE-Datei in den Arbeitsspeicher die Adresse des Einstiegspunkts relativ zur Imagebasis ab.</summary>
      <returns vsli:raw="The address of the entry point relative to the image base.">Die Adresse des Einstiegs Punkts, der relativ zur Bildbasis ist.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary vsli:raw="Gets the address of the beginning-of-code section relative to the image base when the image is loaded into memory.">Ruft beim Laden des Images in den Arbeitsspeicher die Adresse des Codeanfangsabschnitts relativ zur Imagebasis ab.</summary>
      <returns vsli:raw="The address of the beginning-of-code section relative to the image base.">Die Adresse des Code anfangs Abschnitts in Bezug auf die Bildbasis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary vsli:raw="Gets the address of the beginning-of-data section relative to the image base when the image is loaded into memory.">Ruft beim Laden des Images in den Arbeitsspeicher die Adresse des Datenanfangsabschnitts relativ zur Imagebasis ab.</summary>
      <returns vsli:raw="The address of the beginning-of-data section relative to the image base.">Die Adresse des Anfangsdaten Abschnitts in Relation zur Bildbasis.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary vsli:raw="Gets the Certificate Table entry, which points to a table of attribute certificates.">Ruft den Eintrag der Zertifikatstabelle ab, der auf eine Tabelle mit Attributzertifikaten zeigt.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary vsli:raw="Gets the image file checksum.">Ruft die Prüfsumme des Imagedatei ab.</summary>
      <returns vsli:raw="The image file checksum.">Die Prüfsumme der Bilddatei.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary vsli:raw="Gets the alignment factor (in bytes) that is used to align the raw data of sections in the image file.">Ruft den Ausrichtungsfaktor (in Byte) ab, der verwendet wird, um die Rohdaten von Abschnitten in der Imagedatei auszurichten.</summary>
      <returns vsli:raw="A power of 2 between 512 and 64K, inclusive. The default is 512.">Eine Potenz von 2 zwischen 512 und 64K (einschließlich). Der Standardwert liegt bei 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary vsli:raw="Gets the preferred address of the first byte of the image when it is loaded into memory.">Ruft beim Laden in den Arbeitsspeicher die bevorzugte Adresse des ersten Imagebytes ab.</summary>
      <returns vsli:raw="The preferred address, which is a multiple of 64K.">Die bevorzugte Adresse, bei der es sich um ein Vielfaches von 64K handelt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary vsli:raw="Gets a value that identifies the format of the image file.">Ruft einen Wert ab, der das Format der Imagedatei angibt.</summary>
      <returns vsli:raw="The format of the image file.">Das Format der Bilddatei.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary vsli:raw="Gets the major version number of the image.">Ruft die Hauptversionsnummer des Images ab.</summary>
      <returns vsli:raw="The major version number of the image.">Die Hauptversionsnummer des Images.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary vsli:raw="Gets the linker major version number.">Ruft die Hauptversionsnummer des Linker ab.</summary>
      <returns vsli:raw="The linker major version number.">Die Hauptversionsnummer des Linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary vsli:raw="Gets the major version number of the required operating system.">Ruft die Hauptversionsnummer des erforderlichen Betriebssystems ab.</summary>
      <returns vsli:raw="The major version number of the required operating system.">Die Hauptversionsnummer des erforderlichen Betriebssystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary vsli:raw="Gets the major version number of the subsystem.">Ruft die Hauptversionsnummer des Subsystems ab.</summary>
      <returns vsli:raw="The major version number of the subsystem.">Die Hauptversionsnummer des Subsystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary vsli:raw="Gets the minor version number of the image.">Ruft die Nebenversionsnummer des Images ab.</summary>
      <returns vsli:raw="The minor version number of the image.">Die Nebenversionsnummer des Images.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary vsli:raw="Gets the linker minor version number.">Ruft die Nebenversionsnummer des Linker ab.</summary>
      <returns vsli:raw="The linker minor version number.">Die Nebenversionsnummer des Linker.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary vsli:raw="Gets the minor version number of the required operating system.">Ruft die Nebenversionsnummer des erforderlichen Betriebssystems ab.</summary>
      <returns vsli:raw="The minor version number of the required operating system.">Die Nebenversionsnummer des erforderlichen Betriebssystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary vsli:raw="Gets the minor version number of the subsystem.">Ruft die Nebenversionsnummer des Subsystems ab.</summary>
      <returns vsli:raw="The minor version number of the subsystem.">Die Nebenversionsnummer des Subsystems.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary vsli:raw="Gets the number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;. Each describes a location and size.">Ruft die Anzahl der Datenverzeichniseinträge im Rest von <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> ab. Jeder beschreibt einen Speicherort und eine Größe.</summary>
      <returns vsli:raw="The number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;.">Die Anzahl der Datenverzeichnis Einträge im Rest von <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary vsli:raw="Gets the alignment (in bytes) of sections when they are loaded into memory.">Ruft beim Laden in den Arbeitsspeicher die Ausrichtung (in Byte) von Abschnitten ab.</summary>
      <returns vsli:raw="A number greater than or equal to &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.FileAlignment&quot; /&gt;. The default is the page size for the architecture.">Eine Zahl, die größer oder gleich ist <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> . Der Standard für die Architektur ist die Seitengröße.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary vsli:raw="Gets the size of the code (text) section, or the sum of all code sections if there are multiple sections.">Ruft die Größe des Codeabschnitts (Textes) oder die Summe aller Codeabschnitte ab, wenn mehrere Abschnitte vorhanden sind.</summary>
      <returns vsli:raw="the size of the code (text) section, or the sum of all code sections if there are multiple sections.">die Größe des Code Abschnitts (Text) oder die Summe aller Code Abschnitte, wenn mehrere Abschnitte vorhanden sind.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary vsli:raw="Gets the combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">Ruft die kombinierte Größe von MS DOS-Stub, PE-Header und Abschnittsheadern aufgerundet auf ein Vielfaches von FileAlignment ab.</summary>
      <returns vsli:raw="The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">Die kombinierte Größe von MS DOS Stub-, PE-Header-und Abschnitts Headern, die auf ein Vielfaches von FileAlignment aufgerundet werden.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary vsli:raw="Gets the size of the local heap space to commit.">Ruft die Größe des Speicherplatzes für den lokalen Heap ab, für den ein Commit ausgeführt werden soll.</summary>
      <returns vsli:raw="the size of the local heap space to commit.">die Größe des zu commitenden lokalen Heap-Speicherplatzes.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary vsli:raw="Gets the size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Ruft die Größe des Speicherplatzes für den lokalen Heap ab, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns vsli:raw="The size of the local heap space to reserve.">Die Größe des Speicherplatzes für den lokalen Heap, der reserviert werden soll.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary vsli:raw="Gets the size (in bytes) of the image, including all headers, as the image is loaded in memory.">Ruft beim Laden des Images in den Arbeitsspeicher die Größe (in Byte) des Images mit allen Headern ab.</summary>
      <returns vsli:raw="The size (in bytes) of the image, which is a multiple of &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment&quot; /&gt;.">Die Größe (in Bytes) des Bilds, bei der es sich um ein Vielfaches von handelt <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary vsli:raw="Gets the size of the initialized data section, or the sum of all such sections if there are multiple data sections.">Ruft die Größe des Abschnitts mit den initialisierten Daten oder die Summe aller derartiger Abschnitte ab, wenn mehrere Datenabschnitte vorhanden sind.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary vsli:raw="Gets the size of the stack to commit.">Ruft die Größe des Stapels ab, für den ein Commit ausgeführt werden soll.</summary>
      <returns vsli:raw="The size of the stack to commit.">Dier Größe des Stapels, für den ein Commit ausgeführt wird.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary vsli:raw="Gets the size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Ruft die Größe des Stapels ab, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns vsli:raw="The size of the stack to reserve.">Die Größe des Stapels, der reserviert werden soll.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary vsli:raw="Gets the size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.">Ruft die Größe des Abschnitts mit den nicht initialisierten Daten (BSS) oder die Summe aller derartiger Abschnitte ab, wenn mehrere BSS-Abschnitte vorhanden sind.</summary>
      <returns vsli:raw="The size of the uninitialized data section (BSS) or the sum of all such sections.">Die Größe des nicht initialisierten Daten Abschnitts (BSS) oder die Summe aller dieser Abschnitte.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary vsli:raw="Gets the name of the subsystem that is required to run this image.">Ruft den Namen des Subsystems ab, das zum Ausführen dieses Images erforderlich ist.</summary>
      <returns vsli:raw="The name of the subsystem that is required to run this image.">der Name des Subsystems, das zum Ausführen dieses Bilds erforderlich ist.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary vsli:raw="Defines the header for a portable executable (PE) file.">Beschreibt den Header für eine portierbare ausführbare (PE)-Datei.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeader" />-Klasse.</summary>
      <param name="machine" vsli:raw="The target machine's CPU architecture.">Die CPU-Architektur des Zielcomputers.</param>
      <param name="sectionAlignment" vsli:raw="The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to &lt;paramref name=&quot;fileAlignment&quot; /&gt;. The default is the page size for the architecture.">Die Ausrichtung (in Bytes) von Abschnitten beim Laden in den Arbeitsspeicher. Dieses muss größer oder gleich <paramref name="fileAlignment" /> sein. Der Standard für die Architektur ist die Seitengröße.</param>
      <param name="fileAlignment" vsli:raw="The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. If the &lt;paramref name=&quot;sectionAlignment&quot; /&gt; is less than the architecture's page size, then &lt;paramref name=&quot;fileAlignment&quot; /&gt; must match &lt;paramref name=&quot;sectionAlignment&quot; /&gt;.">Der Ausrichtungsfaktor (in Byte), der verwendet wird, um die Rohdaten von Abschnitten in der Imagedatei auszurichten. Der Wert muss eine Potenz von 2 sein und zwischen 512 und einschließlich 64.000 liegen. Der Standardwert liegt bei 512. Wenn <paramref name="sectionAlignment" /> kleiner ist als die Seitengröße der Architektur, dann muss <paramref name="fileAlignment" /> mit <paramref name="sectionAlignment" /> übereinstimmen.</param>
      <param name="imageBase" vsli:raw="The preferred address of the first byte of image when loaded into memory; must be a multiple of 64K.">Beim Laden in den Arbeitsspeicher muss die bevorzugte Adresse des ersten Imagebytes ein Vielfaches von 64.000 sein.</param>
      <param name="majorLinkerVersion" vsli:raw="The linker major version number.">Die Hauptversionsnummer des Linker.</param>
      <param name="minorLinkerVersion" vsli:raw="The linker minor version number.">Die Nebenversionsnummer des Linker.</param>
      <param name="majorOperatingSystemVersion" vsli:raw="The major version number of the required operating system.">Die Hauptversionsnummer des erforderlichen Betriebssystems.</param>
      <param name="minorOperatingSystemVersion" vsli:raw="The minor version number of the required operating system.">Die Nebenversionsnummer des erforderlichen Betriebssystems.</param>
      <param name="majorImageVersion" vsli:raw="The major version number of the image.">Die Hauptversionsnummer des Images.</param>
      <param name="minorImageVersion" vsli:raw="The minor version number of the image.">Die Nebenversionsnummer des Images.</param>
      <param name="majorSubsystemVersion" vsli:raw="The major version number of the subsystem.">Die Hauptversionsnummer des Subsystems.</param>
      <param name="minorSubsystemVersion" vsli:raw="The minor version number of the subsystem.">Die Nebenversionsnummer des Subsystems.</param>
      <param name="subsystem" vsli:raw="The subsystem required to run the image.">Das Subsystem, das für die Ausführung des Images erforderlich ist.</param>
      <param name="dllCharacteristics" vsli:raw="An object describing the characteristics of the dynamic link library.">Ein Objekt, das die Merkmale der Dynamic Link Library beschreibt.</param>
      <param name="imageCharacteristics" vsli:raw="An object describing the characteristics of the image.">Ein Objekt, das die Merkmale des Images beschreibt.</param>
      <param name="sizeOfStackReserve" vsli:raw="The size of the stack to reserve. Only &lt;paramref name=&quot;sizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Die Größe des Stapels, der reserviert werden soll. Nur für <paramref name="sizeOfStackCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</param>
      <param name="sizeOfStackCommit" vsli:raw="The size of the stack to commit.">Dier Größe des Stapels, für den ein Commit ausgeführt wird.</param>
      <param name="sizeOfHeapReserve" vsli:raw="The size of the local heap space to reserve. Only &lt;paramref name=&quot;sizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Die Größe des Speicherplatzes für den lokalen Heap, der reserviert werden soll. Nur für <paramref name="sizeOfHeapCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</param>
      <param name="sizeOfHeapCommit" vsli:raw="The size of the local heap space to commit.">Die Größe des Speicherplatzes für den lokalen Heap, für den ein Commit ausgeführt werden soll.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;fileAlignment&quot; /&gt; is not power of 2 between 512 and 64K.&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;sectionAlignment&quot; /&gt; not power of 2.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;sectionAlignment&quot; /&gt; is less than &lt;paramref name=&quot;fileAlignment&quot; /&gt;.">
        <paramref name="fileAlignment" /> ist keine Potenz von 2, die zwischen 512 und 64.000 liegt.
- oder -

<paramref name="sectionAlignment" /> ist keine Potenz von 2.

- oder -

<paramref name="sectionAlignment" /> ist kleiner als <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary vsli:raw="Creates an executable header.">Erstellt einen ausführbaren Header.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the executable header.">Eine <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />-Instanz, die den ausführbaren Header darstellt.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary vsli:raw="Creates a library header.">Erstellt einen Header der Library.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the library header.">Eine <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" />-Instanz, die den Header der Library darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary vsli:raw="Returns the dynamic linker library characteristics.">Gibt die Eigenschaften der Dynamic Link Library zurück.</summary>
      <returns vsli:raw="An object that describes the dynamic linker library characteristics.">Ein-Objekt, das die Eigenschaften der dynamischen Linker-Bibliothek beschreibt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary vsli:raw="The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. If the section alignment is less than the architecture's page size, then file alignment must match the section alignment.">Der Ausrichtungsfaktor (in Byte), der verwendet wird, um die Rohdaten von Abschnitten in der Imagedatei auszurichten. Der Wert muss eine Potenz von 2 sein und zwischen 512 und einschließlich 64.000 liegen. Der Standardwert liegt bei 512. Wenn die Abschnittsausrichtung kleiner als die Seitengröße der Architektur ist, dann muss die Dateiausrichtung mit der Abschnittsausrichtung übereinstimmen.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary vsli:raw="The preferred address of the first byte of image when loaded into memory; must be a multiple of 64K.">Beim Laden in den Arbeitsspeicher muss die bevorzugte Adresse des ersten Imagebytes ein Vielfaches von 64.000 sein.</summary>
      <returns vsli:raw="A number representing the preferred address of the first byte of image when loaded into memory.">Eine Zahl, die die bevorzugte Adresse des ersten Bytes des Bilds darstellt, wenn Sie in den Arbeitsspeicher geladen wird.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary vsli:raw="Returns the image characteristics.">Gibt die Eigenschaften des Images zurück.</summary>
      <returns vsli:raw="An object representing the image characteristics.">Ein-Objekt, das die Bildmerkmale darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary vsli:raw="The target machine's CPU architecture.">Die CPU-Architektur des Zielcomputers.</summary>
      <returns vsli:raw="One of the enumeration values representing the different CPU architectures.">Einer der Enumerationswerte, die die verschiedenen CPU-Architekturen darstellen.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary vsli:raw="The major version number of the image.">Die Hauptversionsnummer des Images.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the image.">Eine Zahl, die die Größe eines darstellt, das die <see cref="T:System.UInt16" /> Hauptversionsnummer des Bilds darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary vsli:raw="The linker major version number.">Die Hauptversionsnummer des Linker.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker major version number.">Eine Zahl, die die Größe eines darstellt, das <see cref="T:System.Byte" /> die Hauptversionsnummer des Linker darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary vsli:raw="The major version number of the required operating system.">Die Hauptversionsnummer des erforderlichen Betriebssystems.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the required operating system.">Eine Zahl, die die Größe eines darstellt, das <see cref="T:System.UInt16" /> die Hauptversionsnummer des erforderlichen Betriebssystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary vsli:raw="The major version number of the subsystem.">Die Hauptversionsnummer des Subsystems.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the subsystem.">Eine Zahl, die die Größe eines darstellt, das <see cref="T:System.UInt16" /> die Hauptversionsnummer des Subsystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary vsli:raw="The minor version number of the image.">Die Nebenversionsnummer des Images.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the image.">Eine Zahl, die die Größe eines darstellt, das <see cref="T:System.UInt16" /> die neben Versionsnummer des Bilds darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary vsli:raw="The linker minor version number.">Die Nebenversionsnummer des Linker.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker minor version number.">Eine Zahl, die die Größe eines darstellt, das <see cref="T:System.Byte" /> die neben Versionsnummer des Linker darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary vsli:raw="The minor version number of the required operating system.">Die Nebenversionsnummer des erforderlichen Betriebssystems.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the required operating system.">Eine Zahl, die die Größe eines darstellt, das <see cref="T:System.UInt16" /> die neben Versionsnummer des erforderlichen Betriebssystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary vsli:raw="The minor version number of the subsystem.">Die Nebenversionsnummer des Subsystems.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the subsystem.">Eine Zahl, die die Größe eines darstellt, das <see cref="T:System.UInt16" /> die neben Versionsnummer des Subsystems darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary vsli:raw="The alignment (in bytes) of sections when they are loaded into memory.">Die Ausrichtung (in Bytes) von Abschnitten beim Laden in den Arbeitsspeicher.</summary>
      <returns vsli:raw="A number representing the alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to the file alignment. The default is the page size for the architecture.">Eine Zahl, die die Ausrichtung (in Bytes) der Abschnitte darstellt, wenn Sie in den Arbeitsspeicher geladen werden. Der Wert muss größer oder gleich der Datei Ausrichtung sein. Der Standard für die Architektur ist die Seitengröße.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary vsli:raw="The size of the local heap space to commit.">Die Größe des Speicherplatzes für den lokalen Heap, für den ein Commit ausgeführt werden soll.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to commit.">Eine Zahl, die die Größe des zu commitenden lokalen Heap-Speicherplatzes darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary vsli:raw="The size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Die Größe des Speicherplatzes für den lokalen Heap, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to reserve.">Eine Zahl, die die Größe des zu reservierenden lokalen Heap-Speicherplatzes darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary vsli:raw="The size of the stack to commit.">Dier Größe des Stapels, für den ein Commit ausgeführt wird.</summary>
      <returns vsli:raw="A number representing the size of the stack to commit.">Eine Zahl, die die Größe des zu commitenden Stapels darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary vsli:raw="The size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Die Größe des Stapels, der reserviert werden soll. Nur für <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" /> wird ein Commit ausgeführt. Der Rest wird auf jeweils einer Seite verfügbar gemacht, bis die Reservierungsgröße erreicht ist.</summary>
      <returns vsli:raw="A number representing the size of the stack to reserve.">Eine Zahl, die die Größe des zu reservierenden Stapels darstellt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary vsli:raw="The subsystem that is required to run this image.">Das Subsystem, das zum Ausführen dieses Images erforderlich ist.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.Subsystem&quot; /&gt; instance.">Eine <see cref="T:System.Reflection.PortableExecutable.Subsystem" />-Instanz.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary vsli:raw="Defines a type that reads PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.">Definiert einen Typ, der PE-Header (Portable Executable) und COFF-Header (Common Object File Format) aus einem Stream liest.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from the current location in the specified stream.">Instanziiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />-Klasse, die den PE-Header aus der aktuellen Position im angegebenen Stream liest.</summary>
      <param name="peStream" vsli:raw="A stream containing the PE image starting at the stream's current position and ending at the end of the stream.">Ein Stream, der das PE-Image enthält, das bei der aktuellen Position des Streams beginnt und am Ende des Streams endet.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">Die Daten, die aus dem Stream gelesen wurden, haben ein ungültiges Format.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Fehler beim Lesen aus dem Datenstrom.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">Der Stream unterstützt keine Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size.">Instanziiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />-Klasse, die die PE-Header aus dem Stream liest, der ein PE-Image einer angegebenen Größe darstellt.</summary>
      <param name="peStream" vsli:raw="A stream containing PE image of the given size starting at its current position.">Ein Stream, der ein PE-Image der angegebenen Größe enthält, und bei seiner aktuellen Position beginnt.</param>
      <param name="size" vsli:raw="The size of the PE image.">Die Größe des PE-Images.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">Die Daten, die aus dem Stream gelesen wurden, haben ein ungültiges Format.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Fehler beim Lesen aus dem Datenstrom.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">Der Stream unterstützt keine Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> ist negativ oder erstreckt sich über das Ende des Datenstroms hinaus.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size and indicates whether the PE image has been loaded into memory.">Instanziiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.PEHeaders" />-Klasse, die die PE-Header aus dem Stream liest, der ein PE-Image einer angegebenen Größe darstellt, und anzeigt, ob das PE-Image in den Arbeitsspeicher geladen wurde.</summary>
      <param name="peStream" vsli:raw="The stream containing PE image of the given size starting at its current position.">Der Stream, der ein PE-Image der angegebenen Größe enthält, und bei seiner aktuellen Position beginnt.</param>
      <param name="size" vsli:raw="The size of the PE image.">Die Größe des PE-Images.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde. Andernfalls <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has invalid format.">Die Daten, die aus dem Stream gelesen wurden, haben ein ungültiges Format.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Fehler beim Lesen aus dem Datenstrom.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">Der Stream unterstützt keine Suchvorgänge.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> ist negativ oder erstreckt sich über das Ende des Datenstroms hinaus.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary vsli:raw="Searches sections of the PE image for the section that contains the specified Relative Virtual Address.">Sucht nach Bereichen des PE-Images für den Bereich, der die angegebene RVA enthält.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The relative virtual address to search for.">Die zu suchende relative virtuelle Adresse (RVA).</param>
      <returns vsli:raw="The index of the section that contains &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt;, or -1 if there the search is unsuccessful.">Der Index des Abschnitts, der <paramref name="relativeVirtualAddress" />, oder –1 enthält, wenn die Suche erfolglos war.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the image to the given directory data.">Ruft den Offset (in Bytes) vom Anfang des Images bis zu den angegebenen Daten des Verzeichnisses ab.</summary>
      <param name="directory" vsli:raw="The PE directory entry.">Der PE-Eintrag eines Verzeichnisses.</param>
      <param name="offset" vsli:raw="When the method returns, contains the offset from the start of the image to the given directory data.">Wenn die Methode zurückgegeben wird, enthält diese den Offset vom Anfang des Images bis zu den angegebenen Daten des Verzeichnisses.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the directory data is found; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" />, wenn die Daten des Verzeichnisses gefunden werden; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary vsli:raw="Gets the COFF header of the image.">Ruft den COFF-Header des Images ab.</summary>
      <returns vsli:raw="The COFF header of the image.">Der COFF-Header des Bilds.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the PE image to the start of the COFF header.">Ruft den Byteoffset vom Anfang des PE-Images bis zum Anfang des COFF-Headers ab.</summary>
      <returns vsli:raw="The byte offset from the start of the PE image to the start of the COFF header.">Der Byte Offset vom Beginn des PE-Bilds bis zum Anfang des COFF-Headers.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary vsli:raw="Gets the COR header.">Ruft den COR-Header ab.</summary>
      <returns vsli:raw="The COR header, or &lt;see langword=&quot;null&quot; /&gt; if the image does not have one.">Der COR-Header oder, <see langword="null" /> Wenn das Bild nicht über ein solches verfügt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the image to the COR header.">Ruft den Byteoffset vom Anfang des Images bis zum COR-Header ab.</summary>
      <returns vsli:raw="The byte offset from the start of the image to the COR header, or -1 if the image does not have a COR header.">Der Byte Offset vom Beginn des Bilds bis zum COR-Header oder-1, wenn das Bild keinen COR-Header besitzt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary vsli:raw="Gets a value that indicates whether the image is Coff only.">Ruft einen Wert ab, der angibt, ob das Image ausschließlich im COFF-Format vorliegt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is Coff only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das Bild nur COFF ist. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary vsli:raw="Gets a value that indicates whether the image represents a Windows console application.">Ruft einen Wert ab, der angibt, ob das Image eine Windows-Konsolenanwendung darstellt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a Windows console applications; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Wenn das Image eine Windows-Konsolenanwendung ist, andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary vsli:raw="Gets a value that indicates whether the image represents a dynamic link library.">Ruft einen Wert ab, der angibt, ob das Image eine Dynamic link Library darstellt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a DLL; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das Bild eine dll ist. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary vsli:raw="Gets a value that indicates whether the image represents an executable.">Ruft einen Wert ab, der angibt, ob das Image eine ausführbare Datei darstellt.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is an executable; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das Bild eine ausführbare Datei ist. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary vsli:raw="Gets the size of the CLI metadata.">Ruft die Größe der CLI-Metadaten ab.</summary>
      <returns vsli:raw="the size of the CLI metadata, or 0 if the image does not contain metadata.">die Größe der CLI-Metadaten oder 0, wenn das Image keine Metadaten enthält.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.">Ruft den Offset (in Bytes) vom Anfang des PE-Images bis zum Anfang der CLI-Metadaten ab.</summary>
      <returns vsli:raw="The offset (in bytes) from the start of the PE image to the start of the CLI metadata, or -1 if the image does not contain metadata.">Der Offset (in Bytes) vom Anfang des PE-Bilds bis zum Anfang der CLI-Metadaten oder-1, wenn das Image keine Metadaten enthält.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary vsli:raw="Gets the image's PE header.">Ruft den PE-Header des Images ab.</summary>
      <returns vsli:raw="The image's PE header, or &lt;see langword=&quot;null&quot; /&gt; if the image is COFF only.">Der PE-Header des Bilds oder, <see langword="null" /> Wenn das Bild nur COFF ist.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset of the header from the start of the image.">Ruft den Byteoffset des Headers vom Anfang des Images ab.</summary>
      <returns vsli:raw="The byte offset of the header from the start of the image.">Der Byte Offset des Headers vom Beginn des Bilds.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary vsli:raw="Gets the PE section headers.">Ruft die PE-Header des Abschnitts ab.</summary>
      <returns vsli:raw="An array containing the PE section headers.">Ein Array, das die PE-Abschnitts Kopfzeilen enthält.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary vsli:raw="Reads the contents of the entire block into an array.">Liest den Inhalt des gesamten Blocks in ein Array ein.</summary>
      <returns vsli:raw="An immutable byte array.">Ein unveränderliches Bytearray.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary vsli:raw="Reads the contents of a part of the block into an array.">Liest den Inhalt eines Teils des Blocks in ein Array ein.</summary>
      <param name="start" vsli:raw="The starting position in the block.">Die Anfangsposition im Block.</param>
      <param name="length" vsli:raw="The number of bytes to read.">Die Anzahl der zu lesenden Bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">Der angegebene Bereich ist nicht im Block enthalten.</exception>
      <returns vsli:raw="An immutable array of bytes.">Ein unveränderliches Bytearray.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning the entire block.">Erstellt ein <see cref="T:System.Reflection.Metadata.BlobReader" />-Element für ein Blob, das sich über den gesamten Block erstreckt.</summary>
      <returns vsli:raw="A reader for a blob spanning the entire block.">Ein Reader für ein Blob, das sich über den gesamten Block erstreckt.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning a part of the block.">Erstellt ein <see cref="T:System.Reflection.Metadata.BlobReader" />-Element für ein Blob, das sich über einen Teil des Blocks erstreckt.</summary>
      <param name="start" vsli:raw="The starting position in the block.">Die Anfangsposition im Block.</param>
      <param name="length" vsli:raw="The number of bytes in the portion of the block.">Die Anzahl von Bytes in dem Teil des Blocks.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">Der angegebene Bereich ist nicht im Block enthalten.</exception>
      <returns vsli:raw="A reader for a blob spanning a portion of the block.">Ein Reader für ein Blob, das sich über einen Teil des Blocks erstreckt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary vsli:raw="Gets the length of the block.">Ruft die Länge des Blocks ab.</summary>
      <returns vsli:raw="The length of the block.">Die Länge des Blocks.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary vsli:raw="Gets a pointer to the first byte of the block.">Ruft einen Zeiger auf das erste Byte des Blocks ab.</summary>
      <returns vsli:raw="A pointer to the first byte of the block.">Ein Zeiger auf das erste Byte des Blocks.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary vsli:raw="Provides a reader for Portable Executable format (PE) files.">Stellt einen Reader für portierbare ausführbare Dateien (PE) bereit.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory.">Erstellt einen PE-Reader über ein PE-Image, das im Arbeitsspeicher gespeichert ist.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">Ein Zeiger auf den Anfang des PE-Image.</param>
      <param name="size" vsli:raw="The size of the PE image.">Die Größe des PE-Images.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory. A flag indicates whether the image has already been loaded into memory.">Erstellt einen PE-Reader über ein PE-Image, das im Arbeitsspeicher gespeichert ist. Ein Kennzeichen gibt an, ob das Image bereits in den Arbeitsspeicher geladen wurde.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">Ein Zeiger auf den Anfang des PE-Image.</param>
      <param name="size" vsli:raw="The size of the PE image.">Die Größe des PE-Images.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde. Andernfalls <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> ist ein negativer Wert.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a byte array.">Erstellt einen PE-Reader über ein PE-Image, das in einem Bytearray gespeichert ist.</summary>
      <param name="peImage" vsli:raw="An immutable array of bytes representing the PE image.">Ein unveränderliches Bytearray, das das PE-Image darstellt.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImage" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream.">Erstellt einen PE-Reader über ein PE-Image, das in einem Datenstrom gespeichert ist.</summary>
      <param name="peStream" vsli:raw="PE image stream.">PE-Imagedatenstrom.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.">Erstellt einen PE-Reader über ein PE-Image, das in einem Datenstrom gespeichert ist. Der Anfang liegt dabei bei der aktuellen Position, das Ende am Ende des Datenstroms.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">Ein PE-Imagedatenstrom.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">Optionen, die angeben, wie Abschnitte des PE-Image aus dem Datenstrom gelesen werden.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;options&quot; /&gt; has an invalid value.">
        <paramref name="options" /> besitzt einen ungültigen Wert.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">Fehler beim Lesen aus dem Datenstrom (nur beim Vorabrufen von Daten).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> wird angegeben, und die PE-Header des Image sind ungültig.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.">Erstellt einen PE-Reader über ein PE-Image der angegebenen Größe. Der Anfang liegt dabei bei der aktuellen Position des Datenstroms.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">Ein PE-Imagedatenstrom.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">Optionen, die angeben, wie Abschnitte des PE-Image aus dem Datenstrom gelesen werden.</param>
      <param name="size" vsli:raw="The PE image size.">Die Größe des PE-Image.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> ist negativ oder erstreckt sich über das Ende des Datenstroms hinaus.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">Fehler beim Lesen aus dem Datenstrom (nur beim Vorabrufen von Daten).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> wird angegeben, und die PE-Header des Image sind ungültig.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">Verwirft den gesamten vom Leser zugewiesenen Speicher.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEMemoryBlock&quot; /&gt; object containing the entire PE image.">Ruft ein <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" />-Objekt ab, das das gesamte PE-Image enthält.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The entire PE image is not available.">Das gesamte PE-Image ist nicht verfügbar.</exception>
      <returns vsli:raw="A memory block that contains the entire PE image.">Ein Arbeitsspeicherblock, der das gesamte PE-Image enthält.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary vsli:raw="Loads a PE section that contains CLI metadata.">Lädt einen PE-Abschnitt, der CLI-Metadaten enthält.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image doesn't contain metadata (&lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEReader.HasMetadata&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;).">Das PE-Image enthält keine Metadaten (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> gibt <see langword="false" /> zurück).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Die PE-Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <returns vsli:raw="A memory block that contains the CLI metadata.">Ein Arbeitsspeicherblock, der die CLI-Metadaten enthält.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary vsli:raw="Loads the PE section that contains the specified relative virtual address into memory and returns a memory block that starts at that address and ends at the end of the containing section.">Lädt den PE-Abschnitt, der die angegebene relative virtuelle Adresse enthält, in den Arbeitsspeicher und gibt einen Arbeitsspeicherblock zurück, der an dieser Adresse beginnt und am Ende des enthaltenden Abschnitts endet.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address of the data to read.">Die relative virtuelle Adresse der zu lesenden Daten.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Die PE-Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="An IO error occurred while reading from the underlying stream.">Beim Lesen aus dem zugrunde liegenden Datenstrom ist ein E/A-Fehler aufgetreten.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Das PE-Image ist nicht verfügbar.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; is negative.">
        <paramref name="relativeVirtualAddress" /> ist ein negativer Wert.</exception>
      <returns vsli:raw="A memory block that starts at &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; and ends at the end of the containing section, or an empty block if &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; doesn't represent a location in any of the PE sections of this PE image.">Ein Arbeitsspeicherblock, der an <paramref name="relativeVirtualAddress" /> beginnt und am Ende des enthaltenden Abschnitts endet, oder ein leerer Block, wenn <paramref name="relativeVirtualAddress" /> keinen Speicherort in einem der PE-Abschnitte dieses PE-Image darstellt.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary vsli:raw="Loads the PE section with the specified name into memory and returns a memory block that spans the section.">Lädt den PE-Abschnitt mit dem angegebenen Namen in den Arbeitsspeicher und gibt einen Arbeitsspeicherblock zurück, der den Abschnitt umfasst.</summary>
      <param name="sectionName" vsli:raw="The name of the section.">Der Name des Abschnitts.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;sectionName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="sectionName" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Das PE-Image ist nicht verfügbar.</exception>
      <returns vsli:raw="A memory block that spans the section, or an empty block if no section of the given &lt;paramref name=&quot;sectionName&quot; /&gt; exists in this PE image.">Ein Arbeitsspeicherblock, der den Abschnitt umfasst, oder ein leerer Block, wenn kein Abschnitt des angegebenen <paramref name="sectionName" /> in diesem PE-Image vorhanden ist.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as CodeView.">Liest die Daten, auf die der angegebene Debugverzeichniseintrag zeigt, und interpretiert diese als CodeView.</summary>
      <param name="entry" vsli:raw="A Debug Directory entry instance.">Eine Debugverzeichniseintragsinstanz.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a CodeView entry.">
        <paramref name="entry" /> ist kein CodeView-Eintrag.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Das Format der Daten ist ungültig.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Das PE-Image ist nicht verfügbar.</exception>
      <returns vsli:raw="A code view debug directory data instance.">Eine CodeView-Debugverzeichnisdateninstanz.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary vsli:raw="Reads all Debug Directory table entries.">Liest alle Debugverzeichnistabelleneinträge.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the entry.">Das Format des Eintrags ist ungültig.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Das PE-Image ist nicht verfügbar.</exception>
      <returns vsli:raw="An array of Debug Directory table entries.">Ein Array aus Debugverzeichnistabelleneinträgen.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as an Embedded Portable PDB blob.">Liest die Daten, auf die der angegebene Debugverzeichniseintrag zeigt, und interpretiert diese als eingebetteten portierbaren PDB-Blob.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">Der Debugverzeichniseintrag, dessen Daten gelesen werden sollen.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb&quot; /&gt; entry.">
        <paramref name="entry" /> ist kein <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />-Eintrag.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Das Format der Daten ist ungültig.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="PE image not available.">PE-Image nicht verfügbar.</exception>
      <returns vsli:raw="The provider of a metadata reader for reading a Portable PDB image.">Der Anbieter eines Metadatenreaders zum Lesen eines portierbaren PDB-Image.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as a PDB Checksum entry.">Liest die Daten, auf die der angegebene Debugverzeichniseintrag zeigt, und interpretiert diese als PDB-Prüfsummeneintrag.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">Der Debugverzeichniseintrag, dessen Daten gelesen werden sollen.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a PDB Checksum entry.">
        <paramref name="entry" /> ist kein PDB-Prüfsummeneintrag.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Das Format der Daten ist ungültig.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">E/A-Fehler beim Lesen aus dem zugrunde liegenden Stream.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">Das PE-Image ist nicht verfügbar.</exception>
      <returns vsli:raw="The PDB Checksum entry.">Der PDB-Prüfsummeneintrag.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary vsli:raw="Opens a Portable PDB associated with this PE image.">Öffnet eine portierbare PDB-Datei, die diesem PE-Image zugeordnet ist.</summary>
      <param name="peImagePath" vsli:raw="The path to the PE image. The path is used to locate the PDB file located in the directory containing the PE file.">Der Pfad zum PE-Image. Der Pfad wird verwendet, um die PDB-Datei in dem Verzeichnis zu suchen, das die PE-Datei enthält.</param>
      <param name="pdbFileStreamProvider" vsli:raw="If specified, called to open a &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; for a given file path. The provider is expected to either return a readable and seekable &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if the target file doesn't exist or should be ignored for some reason. The provider should throw &lt;see cref=&quot;T:System.IO.IOException&quot; /&gt; if it fails to open the file due to an unexpected IO error.">Wird falls angegeben aufgerufen, um eine <see cref="T:System.IO.Stream" />-Klasse für einen bestimmten Dateipfad zu öffnen. Es wird erwartet, dass der Anbieter entweder eine lesbare und durchsuchbare <see cref="T:System.IO.Stream" />-Klasse oder <see langword="null" /> zurückgibt, wenn die Zieldatei nicht vorhanden ist oder aus irgendeinem Grund ignoriert werden soll. Der Anbieter sollte <see cref="T:System.IO.IOException" /> auslösen, wenn die Datei aufgrund eines unerwarteten E/A-Fehlers nicht geöffnet werden kann.</param>
      <param name="pdbReaderProvider" vsli:raw="If successful, a new instance of &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; to be used to read the Portable PDB.">Im Erfolgsfall eine neue Instanz von <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />, die zum Lesen der portierbaren PDB-Datei verwendet werden soll.</param>
      <param name="pdbPath" vsli:raw="If successful and the PDB is found in a file, the path to the file, or &lt;see langword=&quot;null&quot; /&gt; if the PDB is embedded in the PE image itself.">Bei Erfolg und falls die PDB-Datei in einer Datei gefunden wird, der Pfad zur Datei, oder <see langword="null" />, falls die PDB-Datei in das PE-Image selbst eingebettet ist.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImagePath&quot; /&gt; or &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImagePath" /> oder <paramref name="pdbFileStreamProvider" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The stream returned from &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; doesn't support read and seek operations.">Der von <paramref name="pdbFileStreamProvider" /> zurückgegebene Datenstrom unterstützt keine Lese- und Suchvorgänge.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="No matching PDB file was found due to an error: The PE image or the PDB is invalid.">Aufgrund eines Fehlers wurde keine übereinstimmende PDB-Datei gefunden: das PE-Image oder die PDB-Datei ist ungültig.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="No matching PDB file was found due to an error: An IO error occurred while reading the PE image or the PDB.">Aufgrund eines Fehlers wurde keine übereinstimmende PDB-Datei gefunden: beim Lesen des PE-Images oder der PDB ist ein e/a-Fehler aufgetreten.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has a PDB associated with it and the PDB has been successfully opened; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn dem PE-Image eine PDB-Datei zugeordnet ist und die PDB-Datei erfolgreich geöffnet wurde. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary vsli:raw="Gets a value that indicates if the PE image contains CLI metadata.">Ruft einen Wert ab, der angibt, ob das PE-Image CLI-Metadaten enthält.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Die PE-Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the underlying stream.">Fehler beim Lesen aus dem zugrunde liegenden Datenstrom.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image contains CLI metadata; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn das PE-Image CLI-Metadaten enthält. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary vsli:raw="Gets a value that indicates if the reader can access the entire PE image.">Ruft einen Wert ab, der angibt, ob der Reader Zugriff auf das gesamte PE-Image hat.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader can access the entire PE image; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> , wenn der Reader auf das gesamte PE-Image zugreifen kann. andernfalls <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary vsli:raw="Gets a value that indicates if the PE image has been loaded into memory by the OS loader.">Ruft einen Wert ab, der angibt, ob das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, wenn das PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary vsli:raw="Gets the PE headers.">Ruft die PE-Header ab.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The headers contain invalid data.">Die Header enthalten ungültige Daten.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Fehler beim Lesen aus dem Datenstrom.</exception>
      <returns vsli:raw="The PE headers for this PE image.">Die PE-Header für dieses PE-Image.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary vsli:raw="Provides options that specify how sections of a PE image are read from a stream.">Stellt Optionen bereit, die angeben, wie Abschnitte eines PE-Images aus einem Datenstrom gelesen werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed, and sections of the PE image are read lazily.">Standardmäßig wird der Datenstrom verworfen, wenn die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse verworfen wird und Abschnitte des PE-Images verzögert gelesen werden.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary vsli:raw="Indicates that the underlying PE image has been loaded into memory by the OS loader.">Gibt an, dass das zugrunde liegende PE-Image durch das Betriebssystem-Ladeprogramm in den Arbeitsspeicher geladen wurde.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed.">Hält den Datenstrom geöffnet, wenn <see cref="T:System.Reflection.PortableExecutable.PEReader" /> entfernt wird.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary vsli:raw="Reads the entire image into memory right away. &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified.">Liest das gesamte Image direkt in den Arbeitsspeicher. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> schließt den Stream automatisch, wenn der Konstruktor zurückkehrt, es sei denn, <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> wird angegeben.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads the metadata section into memory right away.&lt;/para&gt;&lt;para&gt;Reading from other sections of the file is not allowed (&lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown by the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;).&lt;/para&gt;&lt;para&gt;&lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified. The underlying file may be closed and even deleted after &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is constructed.&lt;/para&gt;">
        <para>Liest den Metadatenabschnitt direkt in den Arbeitsspeicher.</para>
        <para>Aus anderen Abschnitten der Datei darf nicht gelesen werden (andernfalls löst die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse <see cref="T:System.InvalidOperationException" /> aus).</para>
        <para>
          <see cref="T:System.Reflection.PortableExecutable.PEReader" /> schließt den Stream automatisch, wenn der Konstruktor zurückkehrt, es sei denn, <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> wird angegeben. Nachdem die <see cref="T:System.Reflection.PortableExecutable.PEReader" />-Klasse erstellt wurde, kann die zugrunde liegende Datei geschlossen und sogar gelöscht werden.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary vsli:raw="Defines the base class for a PE resource section builder. Derive from &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; to provide serialization logic for native resources.">Definiert die Basisklasse für einen PE-Ressourcenabschnitt-Generator. Ableiten von <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />, um Serialisierungslogik für native Ressourcen bereitzustellen.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; class.">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />-Klasse.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary vsli:raw="Serializes the specified resource.">Serialisiert die angegebene Ressource.</summary>
      <param name="builder" vsli:raw="A blob that contains the data to serialize.">Ein Blob, das die zu serialisierenden Daten enthält.</param>
      <param name="location" vsli:raw="The location to which to serialize &lt;paramref name=&quot;builder&quot; /&gt;.">Der Speicherort, an den <paramref name="builder" /> serialisiert werden soll.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary vsli:raw="Provides information about the section header of a PE/COFF file.">Stellt Informationen zum Abschnittsheader einer PE/COFF-Datei bereit.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary vsli:raw="Gets the name of the section.">Ruft den Namen des Abschnitts ab.</summary>
      <returns vsli:raw="The name of the section.">Der Name des Abschnitts.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary vsli:raw="Gets the number of line-number entries for the section.">Ruft die Anzahl der Zeilennummereinträge für den Abschnitt ab.</summary>
      <returns vsli:raw="The number of line-number entries for the section.">Die Anzahl der Zeilennummern Einträge für den Abschnitt.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary vsli:raw="Gets the number of relocation entries for the section.">Ruft die Anzahl der Verschiebungseinträge für den Abschnitt ab.</summary>
      <returns vsli:raw="The number of relocation entries for the section. Its value is zero for PE images.">Die Anzahl der Verschiebungs Einträge für den Abschnitt. Der Wert für PE-Images ist 0 (null).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary vsli:raw="Gets the file pointer to the beginning of line-number entries for the section.">Ruft den Dateizeiger auf den Anfang der Zeilennummereinträge für den Abschnitt ab.</summary>
      <returns vsli:raw="The file pointer to the beginning of line-number entries for the section, or zero if there are no COFF line numbers.">Der Dateizeiger auf den Anfang der Zeilennummern Einträge für den Abschnitt, oder 0 (null), wenn keine COFF-Zeilennummern vorhanden sind.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary vsli:raw="Gets the file pointer to the first page of the section within the COFF file.">Ruft den Dateizeiger auf die erste Seite des Abschnitts in der COFF-Datei ab.</summary>
      <returns vsli:raw="The file pointer to the first page of the section within the COFF file.">Der Dateizeiger auf die erste Seite des Abschnitts in der COFF-Datei.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary vsli:raw="Gets the file pointer to the beginning of relocation entries for the section.">Ruft den Dateizeiger auf den Anfang der Verschiebungseinträge für den Abschnitt ab.</summary>
      <returns vsli:raw="The file pointer to the beginning of relocation entries for the section. It is set to zero for PE images or if there are no relocations.">Der Dateizeiger auf den Anfang der Verschiebungs Einträge für den Abschnitt. Es ist für PE-Images auf 0 (null) festgelegt, oder wenn keine Umsetzungen vorhanden sind.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary vsli:raw="Gets the flags that describe the characteristics of the section.">Ruft die Flags ab, die die Merkmale des Abschnitts beschreiben.</summary>
      <returns vsli:raw="The flags that describe the characteristics of the section.">Die Flags, die die Merkmale des Abschnitts beschreiben.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary vsli:raw="Gets the size of the section (for object files) or the size of the initialized data on disk (for image files).">Ruft die Größe des Abschnitts (für Objektdateien) oder die Größe der initialisierten Daten auf dem Datenträger (für Bilddateien) ab.</summary>
      <returns vsli:raw="The size of the section (for object files) or the size of the initialized data on disk (for image files).">Die Größe des Abschnitts (für Objektdateien) oder die Größe der initialisierten Daten auf dem Datenträger (für Bilddateien).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary vsli:raw="Gets the virtual addess of the section.">Ruft die virtuelle Adresse des Abschnitts ab.</summary>
      <returns vsli:raw="The virtual address of the section.">Die virtuelle Adresse des Abschnitts.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary vsli:raw="Gets the total size of the section when loaded into memory.">Ruft die Gesamtgröße des Abschnitts ab, wenn dieser in den Arbeitsspeicher geladen wird.</summary>
      <returns vsli:raw="The total size of the section when loaded into memory.">Die Gesamtgröße des Abschnitts beim Laden in den Arbeitsspeicher.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="pointerToRawData" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary vsli:raw="Describes the subsystem requirement for the image.">Beschreibt die Subsystemanforderung für das Image.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary vsli:raw="Extensible Firmware Interface (EFI) application.">EFI-Anwendung (Extensible Firmware Interface).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary vsli:raw="EFI driver with boot services.">EFI-Treiber mit Startdiensten.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary vsli:raw="EFI ROM image.">EFI-ROM-Image.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary vsli:raw="EFI driver with run-time services.">EFI-Treiber mit Laufzeitdiensten.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary vsli:raw="The image doesn't require a subsystem.">Das Image erfordert kein Subsystem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary vsli:raw="The image is a native Win9x driver.">Bei dem Image handelt es sich um einen nativen Win9x-Treiber.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary vsli:raw="The image runs in the OS/2 character subsystem.">Das Image wird im OS/2-Zeichensubsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary vsli:raw="The image runs in the Posix character subsystem.">Das Image wird im POSIX-Zeichensubsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary vsli:raw="Unknown subsystem.">Unbekanntes Subsystem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary vsli:raw="Boot application.">Startanwendung.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary vsli:raw="The image runs in the Windows CE subsystem.">Das Image wird im Windows CE-Subsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary vsli:raw="The image runs in the Windows character subsystem.">Das Image wird im Windows-Zeichensubsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary vsli:raw="The image runs in the Windows GUI subsystem.">Das Image wird im Windows GUI-Subsystem ausgeführt.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary vsli:raw="Xbox system.">Xbox-System.</summary>
    </member>
  </members>
</doc>