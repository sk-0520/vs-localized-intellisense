<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Emit.Lightweight</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.DynamicILInfo">
      <summary>Fournit la prise en charge d'autres façons de générer le code MSIL (Microsoft Intermediate Language) et les métadonnées d'une méthode dynamique, y compris les méthodes pour créer des jetons et pour insérer le code, la gestion des exceptions et les blobs de signature de variables locales.</summary>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant la signature de la méthode dynamique associée.</summary>
      <param name="signature">Tableau qui contient la signature.</param>
      <returns>Jeton qui peut être incorporé dans les métadonnées et le flux MSIL de la méthode dynamique associée.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant une méthode dynamique à appeler par la méthode associée.</summary>
      <param name="method">Méthode dynamique à appeler.</param>
      <returns>Jeton qui peut être incorporé dans le flux MSIL de la méthode dynamique associée, comme cible d'une instruction MSIL.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un champ accessible à partir de la méthode dynamique associée.</summary>
      <param name="field">Champ auquel accéder.</param>
      <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des champs, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un champ accessible à partir de la méthode dynamique associée ; le champ est du type générique spécifié.</summary>
      <param name="field">Champ auquel accéder.</param>
      <param name="contextType">Type générique auquel le champ appartient.</param>
      <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des champs dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actif.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant une méthode à laquelle accéder à partir de la méthode dynamique associée.</summary>
      <param name="method">Méthode à laquelle accéder.</param>
      <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des méthodes, telles que <see cref="F:System.Reflection.Emit.OpCodes.Call" /> ou <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, qui représente une méthode sur un type générique.</summary>
      <param name="method">Méthode.</param>
      <param name="contextType">Type générique auquel la méthode appartient.</param>
      <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui accède à des méthodes, telles que <see cref="F:System.Reflection.Emit.OpCodes.Call" /> ou <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un type à utiliser dans la méthode dynamique associée.</summary>
      <param name="type">Type à utiliser.</param>
      <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui nécessite un type, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)">
      <summary>Obtient un jeton, valide dans la portée du <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel, représentant un littéral de chaîne à utiliser dans la méthode dynamique associée.</summary>
      <param name="literal">Chaîne à utiliser.</param>
      <returns>Jeton qui peut être utilisé comme opérande d'une instruction MSIL qui nécessite une chaîne, dans la portée de l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)">
      <summary>Définit le corps du code de la méthode dynamique associée.</summary>
      <param name="code">Pointeur vers un tableau d'octets qui contient le flux MSIL.</param>
      <param name="codeSize">Nombre d'octets dans le flux MSIL.</param>
      <param name="maxStackSize">Nombre maximal d'éléments sur le tas d'opérandes lorsque la méthode s'exécute.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="code" /> est <see langword="null" /> et  <paramref name="codeSize" /> est supérieur à 0.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)">
      <summary>Définit le corps du code de la méthode dynamique associée.</summary>
      <param name="code">Tableau qui contient le flux MSIL.</param>
      <param name="maxStackSize">Nombre maximal d'éléments sur le tas d'opérandes lorsque la méthode s'exécute.</param>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)">
      <summary>Définit les métadonnées d'exception de la méthode dynamique associée.</summary>
      <param name="exceptions">Pointeur vers un tableau d'octets qui contient les métadonnées d'exception.</param>
      <param name="exceptionsSize">Nombre d'octets de métadonnées d'exception.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="exceptions" /> est <see langword="null" /> et  <paramref name="exceptionSize" /> est supérieur à 0.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="exceptionSize" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])">
      <summary>Définit les métadonnées d'exception de la méthode dynamique associée.</summary>
      <param name="exceptions">Tableau qui contient les métadonnées d'exception.</param>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)">
      <summary>Définit la signature des variables locales qui décrit la mise en forme des variables locales de la méthode dynamique associée.</summary>
      <param name="localSignature">Tableau qui contient la structure des variables locales du <see cref="T:System.Reflection.Emit.DynamicMethod" /> associé.</param>
      <param name="signatureSize">Nombre d'octets dans la signature.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="localSignature" /> est <see langword="null" /> et  <paramref name="signatureSize" /> est supérieur à 0.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureSize" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])">
      <summary>Définit la signature des variables locales qui décrit la mise en forme des variables locales de la méthode dynamique associée.</summary>
      <param name="localSignature">Tableau qui contient la structure des variables locales du <see cref="T:System.Reflection.Emit.DynamicMethod" /> associé.</param>
    </member>
    <member name="P:System.Reflection.Emit.DynamicILInfo.DynamicMethod">
      <summary>Obtient la méthode dynamique dont le corps est généré par l'instance actuelle.</summary>
      <returns>Objet <see cref="T:System.Reflection.Emit.DynamicMethod" /> qui représente la méthode dynamique pour laquelle l'objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> actuel génère le code.</returns>
    </member>
    <member name="T:System.Reflection.Emit.DynamicMethod">
      <summary>Définit et représente une méthode dynamique qui peut être compilée, exécutée et ignorée. Les méthodes ignorées sont disponibles pour le garbage collection.</summary>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
      <summary>Crée une méthode dynamique qui est globale pour un module, en spécifiant le nom de la méthode, les attributs, les conventions d'appel, le type de retour, les types de paramètres, le module et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage Microsoft Intermediate Language (MSIL) de la méthode dynamique.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="attributes">Combinaison de bits de valeurs <see cref="T:System.Reflection.MethodAttributes" /> qui spécifie les attributs de la méthode dynamique. La seule combinaison autorisée est <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Convention d’appel de la méthode dynamique. Doit être <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <param name="m">
        <see cref="T:System.Reflection.Module" /> représentant le module auquel la méthode dynamique doit être associée de manière logique.</param>
      <param name="skipVisibility">
        <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et membres auxquels a accès le langage MSIL de la méthode dynamique ; sinon, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> est un module qui fournit l’hébergement anonyme pour les méthodes dynamiques.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.  
  
-ou- 
 <paramref name="m" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="attributes" /> est une combinaison d’indicateurs autre que <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- ou - 
 <paramref name="callingConvention" /> n’est pas un <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- ou - 
 <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
      <summary>Crée une méthode dynamique, en spécifiant le nom de la méthode, les attributs, la convention d’appel, le type de retour, les types de paramètre, le type auquel la méthode dynamique est associée logiquement, et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="attributes">Combinaison de bits de valeurs <see cref="T:System.Reflection.MethodAttributes" /> qui spécifie les attributs de la méthode dynamique. La seule combinaison autorisée est <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
      <param name="callingConvention">Convention d’appel de la méthode dynamique. Doit être <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <param name="owner">
        <see cref="T:System.Type" /> avec lequel la méthode dynamique est logiquement associée. La méthode dynamique a accès à tous les membres du type.</param>
      <param name="skipVisibility">
        <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et membres auxquels a accès le langage MSIL de la méthode dynamique ; sinon, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> est une interface, un tableau, un type générique ouvert ou un paramètre de type d’un type générique ou d’une méthode.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.  
  
-ou- 
 <paramref name="owner" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="attributes" /> est une combinaison d’indicateurs autre que <see cref="F:System.Reflection.MethodAttributes.Public" /> et <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- ou - 
 <paramref name="callingConvention" /> n’est pas un <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- ou - 
 <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
      <summary>Initialise une méthode dynamique hébergée de manière anonyme, en spécifiant le nom de la méthode, le type de retour et les types de paramètres.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
      <summary>Initialise une méthode dynamique hébergée de façon anonyme, en spécifiant le nom de la méthode, le type de retour, les types de paramètre et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <param name="restrictedSkipVisibility">
        <see langword="true" /> pour ignorer les contrôles de visibilité juste-à-temps pour les types et membres auxquels accède le langage MSIL de la méthode dynamique, avec cette restriction : le niveau d’approbation des assemblys qui contiennent ces types et membres doit être inférieur ou égal à celui de la pile des appels qui émet la méthode dynamique ; sinon, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
      <summary>Crée une méthode dynamique qui est globale pour un module, en spécifiant le nom de la méthode, le type de retour, les types de paramètres et le module.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <param name="m">
        <see cref="T:System.Reflection.Module" /> représentant le module auquel la méthode dynamique doit être associée de manière logique.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> est un module qui fournit l’hébergement anonyme pour les méthodes dynamiques.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.  
  
-ou- 
 <paramref name="m" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
      <summary>Crée une méthode dynamique qui est globale pour un module, en spécifiant le nom de la méthode, le type de retour, les types de paramètre, le module et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels a accès le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <param name="m">
        <see cref="T:System.Reflection.Module" /> représentant le module auquel la méthode dynamique doit être associée de manière logique.</param>
      <param name="skipVisibility">
        <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et les membres auxquels a accès le langage MSIL de la méthode dynamique.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> est un module qui fournit l’hébergement anonyme pour les méthodes dynamiques.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.  
  
-ou- 
 <paramref name="m" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="returnType" /> est un type pour lequel <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
      <summary>Crée une méthode dynamique, en spécifiant le nom de la méthode, le type de retour, les types de paramètres et le type avec lequel la méthode dynamique est logiquement associée.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <param name="owner">
        <see cref="T:System.Type" /> avec lequel la méthode dynamique est logiquement associée. La méthode dynamique a accès à tous les membres du type.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> est une interface, un tableau, un type générique ouvert ou un paramètre de type d’un type générique ou d’une méthode.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.  
  
-ou- 
 <paramref name="owner" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="returnType" /> a la valeur <see langword="null" /> ou est un type pour lequel <see cref="P:System.Type.IsByRef" /> renvoie <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
      <summary>Crée une méthode dynamique, en spécifiant le nom de la méthode, le type de retour, les types de paramètre, le type auquel la méthode dynamique est associée logiquement, et si les contrôles de visibilité juste-à-temps (JIT) doivent être ignorés pour les types et membres auxquels accède le langage MSIL (Microsoft Intermediate Language) de la méthode dynamique.</summary>
      <param name="name">Nom de la méthode dynamique. Il peut s’agir d’une chaîne de longueur nulle, mais pas de <see langword="null" />.</param>
      <param name="returnType">Objet <see cref="T:System.Type" /> qui spécifie le type de retour de la méthode dynamique, ou <see langword="null" /> si la méthode n’a aucun type de retour.</param>
      <param name="parameterTypes">Tableau d’objets <see cref="T:System.Type" /> spécifiant les types des paramètres de la méthode dynamique, ou <see langword="null" /> si la méthode ne possède aucun paramètre.</param>
      <param name="owner">
        <see cref="T:System.Type" /> avec lequel la méthode dynamique est logiquement associée. La méthode dynamique a accès à tous les membres du type.</param>
      <param name="skipVisibility">
        <see langword="true" /> pour ignorer les contrôles de visibilité JIT sur les types et membres auxquels a accès le langage MSIL de la méthode dynamique ; sinon, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentException">Un élément de <paramref name="parameterTypes" /> a la valeur <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> est une interface, un tableau, un type générique ouvert ou un paramètre de type d’un type générique ou d’une méthode.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur <see langword="null" />.  
  
-ou- 
 <paramref name="owner" /> a la valeur <see langword="null" />.</exception>
      <exception cref="T:System.NotSupportedException">
        <paramref name="returnType" /> a la valeur <see langword="null" /> ou est un type pour lequel <see cref="P:System.Type.IsByRef" /> renvoie <see langword="true" />.</exception>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
      <summary>Exécute la méthode dynamique et crée un délégué qui peut être utilisé pour l’exécuter.</summary>
      <param name="delegateType">Type de délégué dont la signature correspond à celle de la méthode dynamique.</param>
      <exception cref="T:System.InvalidOperationException">La méthode dynamique ne possède aucun corps de méthode.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> possède un nombre erroné de paramètres ou des types de paramètre incorrects.</exception>
      <returns>Délégué du type spécifié, qui peut être utilisé pour exécuter la méthode dynamique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
      <summary>Exécute la méthode dynamique et crée un délégué qui peut être utilisé pour l’exécuter, en spécifiant le type de délégué et un objet auquel le délégué est lié.</summary>
      <param name="delegateType">Type de délégué dont la signature correspond à celle de la méthode dynamique, moins le premier paramètre.</param>
      <param name="target">Objet auquel le délégué est lié. Doit être du même type que le premier paramètre de la méthode dynamique.</param>
      <exception cref="T:System.InvalidOperationException">La méthode dynamique ne possède aucun corps de méthode.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="target" /> n’est pas du même type que le premier paramètre de la méthode dynamique et ne peut pas être assigné à ce type.  
  
- ou - 
 <paramref name="delegateType" /> possède un nombre erroné de paramètres ou des types de paramètre incorrects.</exception>
      <returns>Délégué du type spécifié, qui peut être utilisé pour exécuter la méthode dynamique avec l’objet cible spécifié.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>Définit un paramètre de la méthode dynamique.</summary>
      <param name="position">Position du paramètre dans la liste des paramètres. Les paramètres sont indexés en commençant par le numéro 1 pour le premier paramètre.</param>
      <param name="attributes">Combinaison de bits de valeurs <see cref="T:System.Reflection.ParameterAttributes" /> qui spécifie les attributs du paramètre.</param>
      <param name="parameterName">Le nom du paramètre. Le nom peut être une chaîne de longueur égale à zéro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">La méthode n'a pas de paramètre.  
  
- ou - 
 <paramref name="position" /> est inférieur à 0.  
  
-ou- 
 <paramref name="position" /> est supérieur au nombre de paramètres de la méthode.</exception>
      <returns>Retourne toujours <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
      <summary>Retourne l’implémentation de base pour la méthode.</summary>
      <returns>Implémentation de base de la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
      <summary>Retourne tous les attributs personnalisés définis pour cette méthode.</summary>
      <param name="inherit">
        <see langword="true" /> pour explorer la chaîne d’héritage de la méthode et rechercher les attributs personnalisés ; <see langword="false" /> pour vérifier uniquement la méthode actuelle.</param>
      <returns>Tableau d’objets représentant tous les attributs personnalisés de cette méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Retourne les attributs personnalisés du type spécifié qui ont été appliqués à la méthode.</summary>
      <param name="attributeType">
        <see cref="T:System.Type" /> représentant le type d’attribut personnalisé à retourner.</param>
      <param name="inherit">
        <see langword="true" /> pour explorer la chaîne d’héritage de la méthode et rechercher les attributs personnalisés ; <see langword="false" /> pour vérifier uniquement la méthode actuelle.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> a la valeur <see langword="null" />.</exception>
      <returns>Tableau d’objets représentant les attributs de la méthode qui sont de type <paramref name="attributeType" /> ou qui sont dérivés du type <paramref name="attributeType" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
      <summary>Retourne un objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> qui peut être utilisé pour générer un corps de méthode à partir de jetons de métadonnées, de portées et de flux MSIL (Microsoft Intermediate Language).</summary>
      <returns>Objet <see cref="T:System.Reflection.Emit.DynamicILInfo" /> qui peut être utilisé pour générer un corps de méthode à partir de jetons de métadonnées, de portées et de flux MSIL.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
      <summary>Retourne un générateur de langage MSIL (Microsoft Intermediate Language) pour la méthode avec une taille de flux MSIL par défaut de 64 bits.</summary>
      <returns>Objet <see cref="T:System.Reflection.Emit.ILGenerator" /> pour la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
      <summary>Retourne un générateur de langage MSIL (Microsoft Intermediate Language) pour la méthode avec la taille de flux MSIL spécifiée.</summary>
      <param name="streamSize">Taille du flux MSIL, en octets.</param>
      <returns>Objet <see cref="T:System.Reflection.Emit.ILGenerator" /> pour la méthode avec la taille de flux MSIL spécifiée.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
      <summary>Retourne les indicateurs d’implémentation pour la méthode.</summary>
      <returns>Combinaison d’opérations de bits des valeurs <see cref="T:System.Reflection.MethodImplAttributes" /> représentant les indicateurs d’implémentation de la méthode.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.GetParameters">
      <summary>Retourne les paramètres de la méthode dynamique.</summary>
      <returns>Tableau d’objets <see cref="T:System.Reflection.ParameterInfo" /> qui représentent les paramètres de la méthode dynamique.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>Appelle la méthode dynamique à l’aide des paramètres spécifiés, sous les contraintes du binder spécifié, avec les informations de culture spécifiées.</summary>
      <param name="obj">Ce paramètre est ignoré pour les méthodes dynamiques, car elles sont statiques. Spécifiez <see langword="null" />.</param>
      <param name="invokeAttr">Combinaison de bits de valeurs <see cref="T:System.Reflection.BindingFlags" />.</param>
      <param name="binder">Objet <see cref="T:System.Reflection.Binder" /> qui active la liaison, la contrainte de types d’arguments, l’appel des membres et la récupération d’objets <see cref="T:System.Reflection.MemberInfo" /> par la réflexion. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé. Pour plus d'informations, consultez <see cref="T:System.Reflection.Binder" />.</param>
      <param name="parameters">Liste d’arguments. Il s’agit d’un tableau d’arguments possédant les mêmes nombre, ordre et type que les paramètres de la méthode à appeler. En l’absence de paramètres, ce paramètre doit avoir la valeur <see langword="null" />.</param>
      <param name="culture">Instance de <see cref="T:System.Globalization.CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé. Par exemple, ces informations sont nécessaires pour convertir correctement un <see cref="T:System.String" /> représentant 1000 en valeur <see cref="T:System.Double" />, car 1000 est représenté de différentes manières selon la culture.</param>
      <exception cref="T:System.NotSupportedException">La convention d’appel <see cref="F:System.Reflection.CallingConventions.VarArgs" /> n’est pas prise en charge.</exception>
      <exception cref="T:System.Reflection.TargetParameterCountException">Le nombre d’éléments dans <paramref name="parameters" /> ne correspond pas au nombre de paramètres dans la méthode dynamique.</exception>
      <exception cref="T:System.ArgumentException">Le type d’un ou plusieurs éléments de <paramref name="parameters" /> ne correspond pas au type du paramètre correspondant de la méthode dynamique.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">La méthode dynamique est associée à un module, n’est pas hébergée de manière anonyme, et la valeur <see langword="false" /> a été affectée à <paramref name="skipVisibility" /> lors de sa construction. Toutefois, la méthode dynamique accède à des membres qui ne sont pas <see langword="public" /> ou <see langword="internal" /> (<see langword="Friend" /> en Visual Basic).  
  
- ou - 
La méthode dynamique est hébergée de manière anonyme, et la valeur <see langword="false" /> a été affectée à <paramref name="skipVisibility" /> lors de sa construction. Toutefois, elle accède à des membres qui ne sont pas <see langword="public" />.  
  
- ou - 
La méthode dynamique contient du code non vérifiable. Consultez la section « Vérification » dans la section Notes pour <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      <returns>
        <see cref="T:System.Object" /> contenant la valeur de retour de la méthode appelée.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
      <summary>Indique si le type d’attribut personnalisé spécifié est défini.</summary>
      <param name="attributeType">
        <see cref="T:System.Type" /> qui représente le type d’attribut personnalisé à rechercher.</param>
      <param name="inherit">
        <see langword="true" /> pour explorer la chaîne d’héritage de la méthode et rechercher les attributs personnalisés ; <see langword="false" /> pour vérifier uniquement la méthode actuelle.</param>
      <returns>
        <see langword="true" /> si le type d’attribut personnalisé spécifié est défini ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Emit.DynamicMethod.ToString">
      <summary>Retourne la signature de la méthode, représentée sous forme de chaîne.</summary>
      <returns>Chaîne représentant la signature de la méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.Attributes">
      <summary>Obtient les attributs qui ont été spécifiés quand la méthode dynamique a été créée.</summary>
      <returns>Combinaison d’opérations de bits des valeurs <see cref="T:System.Reflection.MethodAttributes" /> représentant les attributs de la méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
      <summary>Obtient la convention d’appel qui a été spécifiée quand la méthode dynamique a été créée.</summary>
      <returns>Une des valeurs de <see cref="T:System.Reflection.CallingConventions" /> qui indique la convention d’appel de la méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
      <summary>Obtient le type qui déclare la méthode, qui est toujours <see langword="null" /> pour les méthodes dynamiques.</summary>
      <returns>Toujours <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.InitLocals">
      <summary>Obtient ou définit une valeur qui indique si les variables locales de la méthode sont initialisées à zéro.</summary>
      <returns>
        <see langword="true" /> si les variables locales dans la méthode sont initialisées à zéro ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
      <summary>Obtient une valeur qui indique si la méthode dynamique actuelle est critique de sécurité (security-critical) ou critique sécurisée (security-safe-critical), et peut donc effectuer des opérations critiques.</summary>
      <exception cref="T:System.InvalidOperationException">La méthode dynamique n’a pas de corps de méthode.</exception>
      <returns>
        <see langword="true" /> si la méthode dynamique actuelle est critique de sécurité ou critique sécurisée ; <see langword="false" /> si elle est transparente.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
      <summary>Obtient une valeur qui indique si la méthode dynamique actuelle est critique sécurisée au niveau de confiance actuel, autrement dit si elle peut exécuter des opérations critiques et être accessible par du code transparent.</summary>
      <exception cref="T:System.InvalidOperationException">La méthode dynamique n’a pas de corps de méthode.</exception>
      <returns>
        <see langword="true" /> si la méthode dynamique est critique sécurisée au niveau de confiance actuel ; <see langword="false" /> si elle est critique de sécurité ou transparente.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
      <summary>Obtient une valeur qui indique si la méthode dynamique actuelle est transparente au niveau de confiance actuel et ne peut donc pas exécuter d’opérations critiques.</summary>
      <exception cref="T:System.InvalidOperationException">La méthode dynamique n’a pas de corps de méthode.</exception>
      <returns>
        <see langword="true" /> si la méthode dynamique est transparente de sécurité au niveau de confiance actuel ; sinon, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
      <summary>Non pris en charge pour les méthodes dynamiques.</summary>
      <exception cref="T:System.InvalidOperationException">Non autorisé pour les méthodes dynamiques.</exception>
      <returns>Non pris en charge pour les méthodes dynamiques.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.Module">
      <summary>Obtient le module auquel la méthode dynamique est logiquement associée.</summary>
      <returns>
        <see cref="T:System.Reflection.Module" /> auquel la méthode dynamique est logiquement associée.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.Name">
      <summary>Obtient le nom de la méthode dynamique.</summary>
      <returns>Nom simple de la méthode.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
      <summary>Obtient la classe qui a été utilisée dans la réflexion pour obtenir la méthode.</summary>
      <returns>Toujours <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
      <summary>Obtient le paramètre de retour de la méthode dynamique.</summary>
      <returns>Toujours <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.ReturnType">
      <summary>Obtient le type de la valeur de retour de la méthode dynamique.</summary>
      <returns>
        <see cref="T:System.Type" /> représentant le type de la valeur de retour de la méthode actuelle ; <see cref="T:System.Void" /> si la méthode n’a aucun type de retour.</returns>
    </member>
    <member name="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
      <summary>Obtient les attributs personnalisés du type de retour pour la méthode dynamique.</summary>
      <returns>
        <see cref="T:System.Reflection.ICustomAttributeProvider" /> représentant les attributs personnalisés du type de retour pour la méthode dynamique.</returns>
    </member>
  </members>
</doc>