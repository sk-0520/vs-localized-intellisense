<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary>Representa um sink de saída com apoio de matriz baseado em heap nos quais <typeparam name="T" /> dados podem ser gravados.</summary>
      <typeparam name="T">O tipo dos itens nesta <see cref="T:System.Buffers.ArrayBufferWriter`1" /> instância.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary>Cria uma instância de um <see cref="T:System.Buffers.ArrayBufferWriter`1" /> na qual os dados podem ser gravados, com a capacidade inicial padrão.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary>Cria uma instância de um <see cref="T:System.Buffers.ArrayBufferWriter`1" /> na qual os dados podem ser gravados, com uma capacidade inicial especificada.</summary>
      <param name="initialCapacity">A capacidade mínima com a qual inicializar o buffer subjacente.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCapacity" /> é menor ou igual a 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary>Notifica o <see cref="T:System.Buffers.IBufferWriter`1" /> que os itens <paramref name="count" /> foram gravados no <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /> de saída</summary>
      <param name="count">O número de itens gravados.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="count" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException">A chamada de método tenta ignorar o fim do buffer subjacente.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary>Limpa os dados gravados no buffer subjacente.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary>Retorna um <see cref="T:System.Memory`1" /> no qual gravar que tem o tamanho mínimo especificado por <paramref name="sizeHint" />.</summary>
      <param name="sizeHint">O comprimento solicitado mínimo do <see cref="T:System.Memory`1" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> é negativo.</exception>
      <returns>Um <see cref="T:System.Memory`1" /> cujo comprimento é de pelo menos <paramref name="sizeHint" />.  Se <paramref name="sizeHint" /> não for fornecido ou for igual a 0, algum buffer diferente de vazio será retornado.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary>Retorna um <see cref="T:System.Span`1" /> no qual gravar que tem o tamanho mínimo especificado.</summary>
      <param name="sizeHint">O comprimento solicitado mínimo do <see cref="T:System.Span`1" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> é negativo.</exception>
      <returns>Um intervalo de pelo menos <paramref name="sizeHint" /> de comprimento. Se <paramref name="sizeHint" /> não for fornecido ou for igual a 0, algum buffer diferente de vazio será retornado.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary>Obtém a quantidade total de espaço dentro do buffer subjacente.</summary>
      <returns>A capacidade total do buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary>Obtém a quantidade de espaço disponível no qual é possível gravar sem forçar o buffer subjacente a crescer.</summary>
      <returns>O espaço disponível para gravação sem forçar o crescimento do buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary>Obtém a quantidade de dados gravados no buffer subjacente.</summary>
      <returns>A quantidade de dados gravados no buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary>Obtém um <see cref="T:System.ReadOnlyMemory`1" /> que contém os dados gravados no buffer subjacente até o momento.</summary>
      <returns>Os dados gravados no buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary>Obtém um <see cref="T:System.ReadOnlySpan`1" /> que contém os dados gravados no buffer subjacente até o momento.</summary>
      <returns>Os dados gravados no buffer subjacente.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary>Lê bytes como primitivos com endians específicos.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
      <returns>O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
      <returns>O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Byte" /> especificado, o que não faz nada para um <see cref="T:System.Byte" />.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor passado, não modificado.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Int16" /> especificado.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Int32" /> especificado.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Int64" /> especificado.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.SByte" /> especificado, o que não faz nada para um <see cref="T:System.SByte" />.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor passado, não modificado.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.UInt16" /> especificado.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.UInt32" /> especificado.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary>Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.UInt64" /> especificado.</summary>
      <param name="value">O valor a ser invertido.</param>
      <returns>O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <returns>
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary>Fornece métodos de extensão para <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary>Copia o <see cref="T:System.Buffers.ReadOnlySequence`1" /> para o <see cref="T:System.Span`1" /> especificado.</summary>
      <param name="source">A fonte de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="destination">O <see cref="T:System.Span`1" /> de destino.</param>
      <typeparam name="T">O tipo dos itens no <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary>Retorna a posição da primeira ocorrência de <paramref name="item" /> em <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source">A fonte de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="value">O item a ser localizado em <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T">O tipo dos itens no <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns>Um objeto cujo método <see cref="M:System.SequencePosition.GetInteger" /> retorna a posição da primeira ocorrência de <paramref name="item" /> ou um objeto cuja propriedade <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> é <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary>Converte <see cref="T:System.Buffers.ReadOnlySequence`1" /> em uma matriz.</summary>
      <param name="sequence">A sequência somente leitura a ser convertida em uma matriz.</param>
      <typeparam name="T">O tipo dos itens no <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns>Uma matriz que contém os dados na sequência atual de somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary>Grava o conteúdo de <paramref name="value" /> em <paramref name="writer" />.</summary>
      <param name="writer">O gravador de buffer no qual gravar <paramref name="value" />.</param>
      <param name="value">A extensão somente leitura a ser gravada em <paramref name="writer" />.</param>
      <typeparam name="T">O tipo dos itens no <see cref="T:System.ReadOnlySpan`1" /> .</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="writer" /> é menor do que <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary>Representa um coletor de saída no qual os dados <typeparamref name="T" /> podem ser gravados.</summary>
      <typeparam name="T">O tipo dos itens no <see cref="T:System.Buffers.IBufferWriter`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary>Notifica <see cref="T:System.Buffers.IBufferWriter`1" /> que os itens de dados de <paramref name="count" /> foram gravados na saída <see cref="T:System.Span`1" /> ou <see cref="T:System.Memory`1" />.</summary>
      <param name="count">O número de itens de dados gravados em <see cref="T:System.Span`1" /> ou em <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary>Retorna um <see cref="T:System.Memory`1" /> para gravar que é o tamanho mínimo solicitado ou superior (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">O comprimento mínimo de <see cref="T:System.Memory`1" /> retornado. Se for 0, um buffer não vazio será retornado.</param>
      <exception cref="T:System.OutOfMemoryException">O tamanho do buffer solicitado não está disponível.</exception>
      <returns>Um <see cref="T:System.Memory`1" /> de tamanho mínimo <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> for 0, retornará um buffer não vazio.</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary>Retorna um <see cref="T:System.Span`1" /> para gravar que é o tamanho mínimo solicitado ou superior (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint">O comprimento mínimo de <see cref="T:System.Span`1" /> retornado. Se for 0, um buffer não vazio será retornado.</param>
      <returns>Um <see cref="T:System.Span`1" /> de tamanho mínimo <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> for 0, retornará um buffer não vazio.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary>Representa um pool de blocos de memória.</summary>
      <typeparam name="T">O tipo dos itens no pool de memória.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary>Constrói uma nova instância de um pool de memória.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary>Libera todos os recursos usados pelo pool de memória.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary>Libera os recursos não gerenciados usados pelo pool de memória e, opcionalmente, libera os recursos gerenciados.</summary>
      <param name="disposing">
        <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary>Retorna um bloco de memória capaz de conter pelo menos <paramref name="minBufferSize" /> elementos de T.</summary>
      <param name="minBufferSize">O número mínimo de elementos de <typeparamref name="T" /> que o pool de memória pode conter. Um valor de -1 retorna um pool de memória definido no tamanho padrão do pool.</param>
      <returns>Um bloco de memória capaz de conter pelo menos <paramref name="minBufferSize" /> elementos de T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary>Obtém o tamanho máximo de buffer com suporte para este pool.</summary>
      <returns>O tamanho máximo de buffer suportado por este pool.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary>Obtém uma instância singleton de um pool de memória com base em matrizes.</summary>
      <returns>Uma instância singleton de um pool de memória.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary>Representa uma sequência que pode ler uma série sequencial de <typeparamref name="T" />.</summary>
      <typeparam name="T">O tipo dos elementos na sequência somente leitura.</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary>Retorna um <see cref="T:System.Buffers.ReadOnlySequence`1" /> vazio.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary>Cria uma instância de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <paramref name="array" />.</summary>
      <param name="array">A matriz com base na qual criar uma sequência somente leitura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>Cria uma instância de um <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de uma seção de uma matriz.</summary>
      <param name="array">A matriz com base na qual criar a sequência somente leitura.</param>
      <param name="start">O índice de base zero do primeiro elemento na matriz a ser incluído na sequência somente leitura.</param>
      <param name="length">O número de elementos a ser incluídos na sequência somente leitura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary>Cria uma instância de um <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de uma lista de memória vinculada representada pelos segmentos inicial e final e os índices correspondentes neles.</summary>
      <param name="startSegment">O nó inicial da lista de memória vinculada.</param>
      <param name="startIndex">A posição para o início da sequência dentro de <paramref name="startSegment" />.</param>
      <param name="endSegment">O nó final da lista de memória vinculada.</param>
      <param name="endIndex">A posição para o final da sequência dentro de <paramref name="endSegment" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="startSegment" /> ou <paramref name="endSegment" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O índice em execução de <paramref name="startSegment" /> é maior que o índice em execução de <paramref name="endSegment" />, mesmo que <paramref name="startSegment" /> seja diferente de <paramref name="endSegment" />.

- ou -

<paramref name="startSegment" /> é igual a <paramref name="endSegment" />, mas <paramref name="endIndex" /> é menor que <paramref name="startIndex" />.

- ou -

<paramref name="startIndex" /> é maior que o comprimento do bloco de memória subjacente de <paramref name="startSegment" />.</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary>Cria uma instância de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">Um bloco de memória somente leitura de elementos do tipo <typeparamref name="T" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary>Retorna um enumerador sobre o <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>Retorna um enumerador sobre o <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary>Retorna o deslocamento de um <paramref name="position" /> dentro dessa sequência desde o início.</summary>
      <param name="position">O <see cref="T:System.SequencePosition" /> do qual obter o deslocamento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">A posição está fora do intervalo.</exception>
      <returns>O deslocamento do início da sequência.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary>Retorna um novo <see cref="T:System.SequencePosition" /> em um <paramref name="offset" /> a partir do início da sequência.</summary>
      <param name="offset">O deslocamento do início da sequência.</param>
      <returns>Um objeto que representa a posição da sequência que começa no <paramref name="offset" /> especificado desde o início da sequência.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary>Retorna um novo <see cref="T:System.SequencePosition" /> começando no deslocamento especificado da posição <paramref name="origin" />.</summary>
      <param name="offset">O deslocamento da posição da sequência <paramref name="origin" /> especificada.</param>
      <param name="origin">Uma posição de sequência que representa o ponto do qual iniciar o deslocamento.</param>
      <returns>Um objeto que representa a posição da sequência que começa na posição <paramref name="offset" /> do objeto de posição <paramref name="origin" /> especificado.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start">O índice no qual começar essa fatia.</param>
      <param name="length">O comprimento da fatia.</param>
      <returns>Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando no índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" /> e terminando em <paramref name="end" /> (exclusivo).</summary>
      <param name="start">O índice no qual começar essa fatia.</param>
      <param name="end">O final (exclusivo) <see cref="T:System.SequencePosition" /> da fatia.</param>
      <returns>Uma fatia que consiste em itens do índice <paramref name="start" />, não incluindo a posição de sequência <paramref name="end" /> na sequência atual somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em um índice especificado e continuando até o final da sequência somente leitura.</summary>
      <param name="start">O índice inicial no qual começar essa fatia.</param>
      <returns>Uma fatia começando no índice <paramref name="start" /> e continuando até o final da sequência somente leitura atual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary>Forma uma fatia a partir do <see cref="T:System.Buffers.ReadOnlySequence`1" /> dado, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start">O índice no qual começar essa fatia.</param>
      <param name="length">O comprimento da fatia.</param>
      <returns>Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando no índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" /> e terminando em <paramref name="end" /> (exclusivo).</summary>
      <param name="start">O índice no qual começar essa fatia.</param>
      <param name="end">O final (exclusivo) da fatia.</param>
      <returns>Uma fatia que consiste em itens do índice <paramref name="start" />, não incluindo a posição de sequência <paramref name="end" /> na sequência atual somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em uma posição de sequência especificada e continuando até o final da sequência somente leitura.</summary>
      <param name="start">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <returns>Uma fatia começando na posição de sequência <paramref name="start" /> e continuando até o final da sequência somente leitura atual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <param name="length">O comprimento da fatia.</param>
      <returns>Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando na posição de sequência <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <param name="length">O comprimento da fatia.</param>
      <returns>Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando na posição de sequência <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary>Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" /> e terminando em <paramref name="end" /> (exclusivo).</summary>
      <param name="start">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <param name="end">O final (exclusivo) <see cref="T:System.SequencePosition" /> da fatia.</param>
      <returns>Uma fatia que consiste em itens da posição de sequência <paramref name="start" />, não incluindo a posição de sequência <paramref name="end" /> na sequência atual somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary>Retorna uma cadeia de caracteres que representa a sequência atual.</summary>
      <returns>Uma cadeia de caracteres que representa a sequência atual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary>Tenta recuperar o próximo segmento após <paramref name="position" /> e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="position">A posição atual da sequência.</param>
      <param name="memory">Uma extensão de memória somente leitura que contém o próximo segmento após <paramref name="position" />.</param>
      <param name="advance">
        <see langword="true" /> se <paramref name="position" /> deve ir para o começo do próximo segmento. Caso contrário, <see langword="false" />.</param>
      <returns>Retornará <see langword="true" />, se o método tiver retornado o próximo segmento, ou <see langword="false" />, se o final da sequência somente leitura tiver sido atingido.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary>Obtém a posição no final de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary>Obtém o <see cref="T:System.ReadOnlyMemory`1" /> a partir do primeiro segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary>Obtém o <see cref="T:System.ReadOnlySpan`1" /> a partir do primeiro segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary>Obtém um valor que indica se a <see cref="T:System.Buffers.ReadOnlySequence`1" /> está vazia.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary>Obtém um valor que indica se <see cref="T:System.Buffers.ReadOnlySequence`1" /> contém um único segmento <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <returns>
        <see langword="true" /> se a sequência somente leitura estiver vazia; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary>Obtém o comprimento do <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>O comprimento da sequência somente leitura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary>Obtém a posição para o início do <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary>Representa um enumerador acima de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary>Inicializa o enumerador.</summary>
      <param name="sequence">A <see cref="T:System.Buffers.ReadOnlySequence`1" /> a ser enumerada.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary>Avança para o próximo <see cref="T:System.ReadOnlyMemory`1" /> no <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo item; <see langword="false" /> se o final da sequência foi alcançado.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary>Obtém o <see cref="T:System.ReadOnlyMemory`1" /> atual.</summary>
      <returns>O <see cref="T:System.ReadOnlyMemory`1" /> atual.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary>Representa uma lista vinculada de nós <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <typeparam name="T">O tipo dos elementos no segmento de sequência somente leitura.</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary>Obtém ou define um valor <see cref="T:System.ReadOnlyMemory`1" /> para o nó atual.</summary>
      <returns>Um <see cref="T:System.ReadOnlyMemory`1" /> valor para o nó atual.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary>Obtém ou define o próximo nó.</summary>
      <returns>O próximo nó.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary>Obtém ou define a soma dos comprimentos de nó antes do nó atual.</summary>
      <returns>A soma de comprimentos de nó antes do nó atual.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary>Fornece métodos para ler dados binários e de texto de um <see cref="T:System.Buffers.ReadOnlySequence`1" /> com foco no desempenho e em alocações de heap mínimas ou zero.</summary>
      <typeparam name="T">O tipo da sequência somente leitura.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary>Cria um <see cref="T:System.Buffers.SequenceReader`1" /> sobre um determinado <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="sequence">A sequência somente leitura sobre a qual criar o <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary>Move o leitor para frente um número especificado de itens.</summary>
      <param name="count">O número de itens a ser avançado.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary>Ignora instâncias consecutivas do <paramref name="value" /> fornecido.</summary>
      <param name="value">O valor que o leitor deve ignorar.</param>
      <returns>O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary>Ignora instâncias consecutivas de qualquer um dos dois valores especificados.</summary>
      <param name="value0">O primeiro valor a ser ignorado.</param>
      <param name="value1">O segundo valor a ser ignorado.</param>
      <returns>O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary>Ignora instâncias consecutivas de qualquer um dos três valores especificados.</summary>
      <param name="value0">O primeiro valor a ser ignorado.</param>
      <param name="value1">O segundo valor a ser ignorado.</param>
      <param name="value2">O terceiro valor a ser ignorado.</param>
      <returns>O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary>Ignora instâncias consecutivas de qualquer um dos quatro valores especificados.</summary>
      <param name="value0">O primeiro valor a ser ignorado.</param>
      <param name="value1">O segundo valor a ser ignorado.</param>
      <param name="value2">O terceiro valor a ser ignorado.</param>
      <param name="value3">O quarto valor a ser ignorado.</param>
      <returns>O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary>Ignora instâncias consecutivas de qualquer um dos <paramref name="values" /> especificados.</summary>
      <param name="values">Os valores a serem ignorados.</param>
      <returns>O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary>Move o leitor para o fim da sequência.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary>Verifica se um valor especificado é o próximo na sequência.</summary>
      <param name="next">O valor com o qual comprar os próximos itens.</param>
      <param name="advancePast">
        <see langword="true" /> para ignorar os valores <paramref name="next" /> se eles forem encontrados; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se os valores forem os próximos na sequência; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Verifica se os valores especificados em um intervalo somente leitura são os próximos na sequência.</summary>
      <param name="next">O intervalo com o qual comparar os próximos itens.</param>
      <param name="advancePast">
        <see langword="true" /> para ignorar os valores <paramref name="next" /> se eles forem encontrados; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se os valores forem os próximos na sequência; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary>Move o leitor de volta o número especificado de itens.</summary>
      <param name="count">O número de itens.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> é negativo ou maior que <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary>Procura um delimitador especificado e, opcionalmente, o ignorará se for encontrado.</summary>
      <param name="delimiter">O delimitador a ser pesquisado.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o <paramref name="delimiter" /> fornecido tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Procura qualquer número de delimitadores especificados e, opcionalmente, ignora o primeiro encontrado.</summary>
      <param name="delimiters">Os delimitadores a serem pesquisados.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar a primeira instância de qualquer um dos <paramref name="delimiters" /> fornecidos; <see langword="false" /> para não ignorar o delimitador.</param>
      <returns>
        <see langword="true" /> se um dos <paramref name="delimiters" /> fornecidos tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary>Copiará dados da posição atual para o intervalo de destino fornecido se houver dados suficientes para preenchê-lo.</summary>
      <param name="destination">Intervalo de destino para o qual copiar.</param>
      <returns>
        <see langword="true" /> se houver dados suficientes para preencher completamente o intervalo <paramref name="destination" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary>Espia o próximo valor sem avançar o leitor.</summary>
      <param name="value">O próximo valor ou o valor padrão se estiver no fim do leitor.</param>
      <returns>
        <see langword="true" /> se o leitor não estiver no seu fim e a operação de espiada for bem-sucedida; <see langword="false" /> se estiver no final do leitor.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary>Inspeciona o próximo valor no deslocamento especificado sem avançar o leitor.</summary>
      <param name="offset">O deslocamento da posição atual.</param>
      <param name="value">O próximo valor ou o valor padrão se estiver no fim do leitor.</param>
      <returns>
        <see langword="true" /> se o leitor não estiver no seu fim e a operação de espiada for bem-sucedida; <see langword="false" /> se estiver no final do leitor.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary>Lê o próximo valor e avança o leitor.</summary>
      <param name="value">O próximo valor ou o valor padrão se estiver no fim do leitor.</param>
      <returns>
        <see langword="true" /> se o leitor não estiver no seu fim e a operação de leitura for bem-sucedida; <see langword="false" /> se estiver no final do leitor.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary>Tenta ler tudo até o <paramref name="delimiter" /> fornecido, ignorando os delimitadores precedidos por <paramref name="delimiterEscape" />.</summary>
      <param name="sequence">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter">O delimitador a ser procurado.</param>
      <param name="delimiterEscape">Um valor que indica que um <paramref name="delimiter" /> imediatamente após deve ser ignorado.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary>Tenta ler tudo até o <paramref name="delimiter" /> fornecido.</summary>
      <param name="sequence">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter">O delimitador a ser procurado.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tenta ler dados até a correspondência do delimitador inteiro especificado como um intervalo somente leitura.</summary>
      <param name="sequence">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter">Um intervalo somente leitura que contém um ou mais delimitadores.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary>Tenta ler tudo até o <paramref name="delimiter" /> fornecido, ignorando os delimitadores precedidos por <paramref name="delimiterEscape" />.</summary>
      <param name="span">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter">O delimitador a ser procurado.</param>
      <param name="delimiterEscape">Um valor que indica que um <paramref name="delimiter" /> imediatamente após deve ser ignorado.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary>Tenta ler tudo até o <paramref name="delimiter" /> fornecido.</summary>
      <param name="span">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter">O delimitador a ser procurado.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tente ler tudo até o <paramref name="delimiter" /> fornecido.</summary>
      <param name="sequence">Os dados lidos, se houver.</param>
      <param name="delimiter">O delimitador a ser procurado.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se encontrado.</param>
      <param name="span">Os dados lidos, se houver.</param>
      <returns>
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tenta ler tudo até o qualquer um dos <paramref name="delimiters" /> especificados.</summary>
      <param name="sequence">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiters">Os delimitadores a serem procurados.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar a primeira instância encontrada de qualquer um dos <paramref name="delimiters" /> fornecidos; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="delimiters" /> forem encontrados; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>Tenta ler tudo até o qualquer um dos <paramref name="delimiters" /> especificados.</summary>
      <param name="span">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiters">Os delimitadores a serem procurados.</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> para ignorar a primeira instância encontrada de qualquer um dos <paramref name="delimiters" /> fornecidos; caso contrário, <see langword="false" />.</param>
      <returns>
        <see langword="true" /> se <paramref name="delimiters" /> forem encontrados; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary>Obtém o número total de valores <typeparamref name="T" /> processados pelo leitor.</summary>
      <returns>O número total de valores processados pelo leitor.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary>Obtém um <see cref="T:System.Span`1" /> que contém o segmento atual no <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>Um Span que contém o segmento atual na sequência.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary>Obtém o índice no <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>O índice no <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary>Obtém um valor que indica se não há mais dados no <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>
        <see langword="true" /> Quando não há mais dados no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary>Obtém a contagem de itens no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> do leitor.</summary>
      <returns>A contagem de itens nos leitores <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary>Obtém a posição atual no <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>A posição atual no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary>Obtém os itens restantes no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> do leitor.</summary>
      <returns>Os itens restantes nas <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary>Obtém o <see cref="T:System.Buffers.ReadOnlySequence`1" /> subjacente do leitor.</summary>
      <returns>A sequência de somente leitura subjacente para o leitor.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary>Obtém a parte não lida do <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns>A parte não lida do <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary>Obtém a parte não lida do <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns>A parte não lida do <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary>Fornece funcionalidade estendida para a classe <see cref="T:System.Buffers.SequenceReader`1" /> que permite a leitura de valores numéricos específicos de endian de dados binários.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Tenta ler um <see cref="T:System.Int16" /> como big endian.</summary>
      <param name="reader">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como big endian.</param>
      <returns>
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Tenta ler um <see cref="T:System.Int32" /> como big endian.</summary>
      <param name="reader">O leitor de sequência de bytes do qual ler o valor.</param>
      <param name="value">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como big endian.</param>
      <returns>
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Tenta ler um <see cref="T:System.Int64" /> como big endian.</summary>
      <param name="reader">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como big endian.</param>
      <returns>
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>Tenta ler um <see cref="T:System.Int16" /> como little endian.</summary>
      <param name="reader">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como little endian.</param>
      <returns>
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>Tenta ler um <see cref="T:System.Int32" /> como little endian.</summary>
      <param name="reader">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como little endian.</param>
      <returns>
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>Tenta ler um <see cref="T:System.Int64" /> como little endian.</summary>
      <param name="reader">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como little endian.</param>
      <returns>
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary>Representa uma cadeia de caracteres de formato padrão sem usar uma cadeia de caracteres real.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary>Define o valor máximo válido da precisão.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary>Indica se um formato não usa uma precisão ou se a precisão não está especificada.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol">Um especificador de formato de tipo específico, como 'G','D' ou 'X'.</param>
      <param name="precision">Uma precisão opcional que varia de 0 a 99, ou o valor especial <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (o padrão).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="symbol" /> não é <see cref="F:System.Buffers.StandardFormat.NoPrecision" />, e seu valor é maior que <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

- ou -

<paramref name="symbol" /> não pode ser convertido para um <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary>Retorna um valor que indica se a instância <see cref="T:System.Buffers.StandardFormat" /> especificada é igual à instância atual.</summary>
      <param name="other">O formato para ser comparado com a instância atual.</param>
      <returns>
        <see langword="true" /> se as duas instâncias forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary>Retorna um valor que indica se o objeto especificado é um objeto <see cref="T:System.Buffers.StandardFormat" /> igual à instância atual.</summary>
      <param name="obj">Um objeto a ser comparado à instância atual.</param>
      <returns>
        <see langword="true" /> se as duas instâncias forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary>Retorna o código hash para a instância.</summary>
      <returns>O código hash para essa instância.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Retorna um valor que indica se duas instâncias <see cref="T:System.Buffers.StandardFormat" /> são iguais.</summary>
      <param name="left">O primeiro formato a comparar.</param>
      <param name="right">O segundo formato a comparar.</param>
      <returns>
        <see langword="true" /> se as duas instâncias forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary>Converte um caractere em uma instância <see cref="T:System.Buffers.StandardFormat" /> usando a precisão <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol">O caractere a converter em um valor <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns>Um formato com a propriedade <see cref="P:System.Buffers.StandardFormat.Symbol" /> igual a <paramref name="symbol" /> e uma propriedade <see cref="P:System.Buffers.StandardFormat.Precision" /> igual a <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>Determina se duas instâncias <see cref="T:System.Buffers.StandardFormat" /> são diferentes.</summary>
      <param name="left">O primeiro formato a comparar.</param>
      <param name="right">O segundo formato a comparar.</param>
      <returns>
        <see langword="true" /> se os dois formatos forem diferentes; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary>Converte <see langword="ReadOnlySpan&lt;System.Char&gt;" /> em uma instância <see cref="T:System.Buffers.StandardFormat" /> usando a precisão <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format">Uma extensão somente leitura que contém o caractere a analisar.</param>
      <returns>Um valor cujo valor de propriedade <see cref="P:System.Buffers.StandardFormat.Symbol" /> é o caractere em <paramref name="format" /> e cujo valor de propriedade <see cref="P:System.Buffers.StandardFormat.Precision" /> é <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary>Converte uma cadeia clássica de caracteres de formato padrão .NET em uma instância <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format">Uma cadeia clássica de formato padrão do .NET.</param>
      <exception cref="T:System.FormatException">
        <paramref name="format" /> não é uma cadeia de caracteres de formato padrão válida.</exception>
      <returns>Um formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary>Retorna a representação de cadeia de caracteres desse formato.</summary>
      <returns>A representação de cadeia de caracteres desse formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary>Tenta converter uma instância <see langword="ReadOnlySpan&lt;Char&gt;" /> em <see cref="T:System.Buffers.StandardFormat" /> e retorna um valor que indica se a operação de análise foi bem-sucedida.</summary>
      <param name="format">Uma extensão somente leitura que contém o caractere a converter.</param>
      <param name="result">Quando o método retorna, contém a instância <see cref="T:System.Buffers.StandardFormat" /> analisada se a operação for bem-sucedida.</param>
      <returns>
        <see langword="true" /> se a operação de análise for bem-sucedida; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary>Obtém um valor que indica se um formato tem uma precisão definida.</summary>
      <returns>
        <see langword="true" /> Se o formato tiver uma precisão diferente de <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary>Obtém um valor que indica se a instância atual é o formato padrão.</summary>
      <returns>
        <see langword="true" /> se a instância atual for um formato padrão; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary>Obtém o componente de precisão do formato.</summary>
      <returns>O componente de precisão, que pode ser <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> , ou pode variar de 0 a 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary>Obtém o componente de caracteres do formato.</summary>
      <returns>O componente de caractere do formato.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Faz a conversão entre dados binários e texto codificado em UTF-8 representado na base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Decodifica a extensão de texto codificado em UTF-8 representado como base 64 em dados binários. Se a entrada não for um múltiplo de 4, ela fará o maior número de decodificações possível até o múltiplo mais próximo de 4.</summary>
      <param name="utf8">A extensão de entrada que contém o texto codificado em UTF-8 na base 64 que precisa ser decodificado.</param>
      <param name="bytes">A extensão de saída que contém o resultado da operação, ou seja, os dados binários decodificados.</param>
      <param name="bytesConsumed">O número de bytes de entrada consumidos durante a operação. Isso pode ser usado para fatiar a entrada para chamadas subsequentes, se necessário.</param>
      <param name="bytesWritten">O número de bytes gravados na extensão de saída. Isso pode ser usado para fatiar a saída para chamadas subsequentes, se necessário.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (padrão) se a extensão de entrada contiver todos os dados a ser decodificados. <see langword="false" /> se a extensão de entrada contiver dados parciais com mais dados para seguir.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de decodificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Decodifica a extensão do texto codificado em UTF-8 na base 64 (in-loco) em dados binários. A saída binária decodificada é menor que os dados de texto contidos na entrada (a operação compacta os dados). Se a entrada não for um múltiplo de 4, o método não decodificará nenhum dado.</summary>
      <param name="buffer">A extensão de entrada que contém os dados de texto da base 64 que precisam ser decodificados.</param>
      <param name="bytesWritten">O número de bytes gravados no buffer.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de decodificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codifica a extensão de dados binários em texto codificado em UTF-8 representado como base 64.</summary>
      <param name="bytes">A extensão de entrada que contém dados binários que precisam ser codificados.</param>
      <param name="utf8">A extensão de saída que contém o resultado da operação, ou seja, o texto codificado em UTF-8 na base 64.</param>
      <param name="bytesConsumed">O número de bytes de entrada consumidos durante a operação. Isso pode ser usado para fatiar a entrada para chamadas subsequentes, se necessário.</param>
      <param name="bytesWritten">O número de bytes gravados na extensão de saída. Isso pode ser usado para fatiar a saída para chamadas subsequentes, se necessário.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (o padrão) se a extensão de entrada contiver todos os dados a ser codificados. <see langword="false" /> se a extensão de entrada contiver dados parciais com mais dados para seguir.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de codificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codifica a extensão de dados binários (in-loco) em texto codificado em UTF-8 representado como base 64. A saída de texto codificada é maior que os dados binários contidos na entrada (a operação descompacta os dados).</summary>
      <param name="buffer">A extensão de entrada que contém dados binários que precisam ser codificados. Visto que o método realiza uma conversão in-loco, ele precisa ser grande o suficiente para armazenar o resultado da operação.</param>
      <param name="dataLength">O número de bytes de dados binários contidos no buffer que precisam ser codificados. Esse valor deve ser menor que o tamanho do buffer.</param>
      <param name="bytesWritten">O número de bytes gravados no buffer.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de codificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Retorna o tamanho máximo (em bytes) do resultado caso seja necessário decodificar um texto codificado como base 64 sem a extensão de bytes com o tamanho especificado.</summary>
      <param name="length">O tamanho da extensão de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> é menor que 0.</exception>
      <returns>O tamanho máximo (em bytes) do resultado.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Retorna o tamanho máximo (em bytes) do resultado caso seja necessário codificar dados binários sem a extensão de bytes com o tamanho especificado.</summary>
      <param name="length">O tamanho da extensão de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> é menor que 0 ou maior que 1610612733 (pois a codificação infla os dados em 4/3).</exception>
      <returns>O tamanho máximo (em bytes) do resultado.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary>Fornece métodos estáticos para formatar tipos de dados comuns como cadeias de caracteres UTF8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Boolean" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Byte" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.DateTime" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.DateTimeOffset" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Decimal" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Double" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Guid" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Int16" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Int32" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Int64" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.SByte" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.Single" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.TimeSpan" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.UInt16" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.UInt32" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>Formata um <see cref="T:System.UInt64" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value">O valor a ser formatado.</param>
      <param name="destination">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format">O formato padrão a ser usado.</param>
      <returns>
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary>Fornece métodos estáticos para analisar cadeias de caracteres Utf8 para tipos de dados comuns.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Boolean" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Byte" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.DateTime" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.DateTimeOffset" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Decimal" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Double" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Guid" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Int16" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Int32" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Int64" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.SByte" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.Single" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.TimeSpan" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.UInt16" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.UInt32" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary>Analisa um <see cref="T:System.UInt64" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns>
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary>Fornece métodos de extensão para os tipos relacionados à memória e ao intervalo, como <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary>Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> na parte da cadeia de caracteres de destino.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <returns>A representação de memória de caracteres somente leitura da cadeia de caracteres ou <see langword="default" /> se <paramref name="text" /> é <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary>Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em uma parte da cadeia de caracteres de destino começando em um índice especificado.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <param name="startIndex">O índice no qual começar essa fatia.</param>
      <returns>A representação de memória de caracteres somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary>Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em uma parte da cadeia de caracteres de destino começando em uma posição de caractere especificada.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <param name="start">O índice no qual começar essa fatia.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> não está no intervalo de <paramref name="text" /> (<paramref name="start" /> é &lt; 0 ou &gt; <c>text.Length</c>).</exception>
      <returns>A representação de memória de caracteres somente leitura da cadeia de caracteres ou <see langword="default" /> se <paramref name="text" /> é <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary>Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em uma parte da cadeia de caracteres de destino começando em uma posição especificada com um tamanho.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <param name="start">O índice no qual começar essa fatia.</param>
      <param name="length">O tamanho desejado da fatia.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="text" />.</exception>
      <returns>A representação de memória de caracteres somente leitura da cadeia de caracteres ou <see langword="default" /> se <paramref name="text" /> é <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary>Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em um intervalo especificado da cadeia de caracteres de destino.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <param name="range">O intervalo que indica o início e o tamanho da cadeia de caracteres segmentada.</param>
      <returns>A representação de memória de caracteres somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary>Cria uma região de memória na matriz de destino.</summary>
      <param name="array">A matriz a ser convertida.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <returns>A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary>Cria uma região de memória na parte da matriz de destino começando em um índice especificado até o final da matriz.</summary>
      <param name="array">A matriz a ser convertida.</param>
      <param name="startIndex">A primeira posição da matriz.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <returns>A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary>Cria uma região de memória na parte da matriz de destino começando em uma posição especificada até o final da matriz.</summary>
      <param name="array">A matriz de destino.</param>
      <param name="start">O índice no qual a memória será iniciada.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O índice <paramref name="start" /> é menor que 0 ou maior que <see langword="array.Length" />.</exception>
      <returns>A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary>Cria uma região de memória na parte da matriz de destino começando em uma posição especificada com um tamanho especificado.</summary>
      <param name="array">A matriz de destino.</param>
      <param name="start">O índice no qual a região de memória será iniciada.</param>
      <param name="length">O número de itens na região de memória.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="array" />.</exception>
      <returns>A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary>Cria uma região de memória na parte da matriz de destino começando no índice de início inclusivo do intervalo e terminando no índice final exclusivo do intervalo.</summary>
      <param name="array">A matriz a ser convertida.</param>
      <param name="range">O intervalo a ser convertido com base na matriz.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <returns>A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary>Cria uma região de memória na parte do segmento de matriz de destino.</summary>
      <param name="segment">O segmento a ser convertido.</param>
      <typeparam name="T">O tipo do segmento.</typeparam>
      <returns>A representação de memória do segmento.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary>Cria uma região de memória na parte do segmento de matriz de destino começando em uma posição especificada até o final do segmento.</summary>
      <param name="segment">O segmento de matriz de destino.</param>
      <param name="start">O índice no qual a memória será iniciada.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> é covariante e o tipo de <paramref name="segment" /> não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> é menor que 0 ou maior que <see langword="segment.Count" />.</exception>
      <returns>A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Cria uma região de memória na parte do segmento de matriz de destino começando em uma posição especificada com um tamanho especificado.</summary>
      <param name="segment">O segmento de matriz de destino.</param>
      <param name="start">O índice no qual a memória será iniciada.</param>
      <param name="length">O número de itens na memória.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="segment" />.</exception>
      <returns>A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary>Cria um intervalo somente leitura em uma parte da cadeia de caracteres de destino com base em uma posição especificada para um número especificado de caracteres.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <returns>A representação de intervalo somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary>Cria um intervalo somente leitura em uma parte da cadeia de caracteres de destino com base em uma posição especificada até o final da cadeia de caracteres.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <param name="start">O índice no qual começar essa fatia.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="text" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> é menor que 0 ou maior que <see langword="text.Length" />.</exception>
      <returns>A representação de intervalo somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary>Cria um intervalo somente leitura em uma cadeia de caracteres.</summary>
      <param name="text">A cadeia de caracteres de destino.</param>
      <param name="start">O índice no qual começar essa fatia.</param>
      <param name="length">O tamanho desejado da fatia.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="text" />.</exception>
      <returns>A representação de intervalo somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary>Cria um intervalo em uma matriz de destino.</summary>
      <param name="array">A matriz a ser convertida.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <returns>A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary>Cria um intervalo na parte da matriz de destino definida por um valor <see cref="T:System.Index" />.</summary>
      <param name="array">A matriz a ser convertida.</param>
      <param name="startIndex">O índice inicial.</param>
      <typeparam name="T">O tipo de matriz.</typeparam>
      <returns>A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary>Cria um intervalo em uma parte da matriz de destino começando em uma posição especificada até o fim da matriz.</summary>
      <param name="array">A matriz a ser convertida.</param>
      <param name="start">O índice inicial do qual a matriz será convertida.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <returns>A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary>Cria um intervalo na parte da matriz de destino começando em uma posição especificada para um tamanho especificado.</summary>
      <param name="array">A matriz de destino.</param>
      <param name="start">O índice no qual o intervalo será iniciado.</param>
      <param name="length">O número de itens no intervalo.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="text" />.</exception>
      <returns>A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary>Cria um intervalo em uma parte de uma matriz de destino definida por um valor <see cref="T:System.Range" />.</summary>
      <param name="array">A matriz a ser convertida.</param>
      <param name="range">O intervalo da matriz a ser convertido.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <returns>A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary>Cria um intervalo em um segmento de matriz de destino.</summary>
      <param name="segment">O segmento de matriz a ser convertido.</param>
      <typeparam name="T">O tipo do segmento da matriz.</typeparam>
      <returns>A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary>Cria um intervalo em uma parte do segmento de matriz de destino começando em um índice especificado e terminando no final do segmento.</summary>
      <param name="segment">O segmento de matriz de destino.</param>
      <param name="startIndex">O índice no qual o intervalo será iniciado.</param>
      <typeparam name="T">O tipo do segmento da matriz.</typeparam>
      <returns>A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary>Cria um intervalo em uma parte de um segmento de matriz de destino com base em uma posição especificada até o final do segmento.</summary>
      <param name="segment">O segmento de matriz de destino.</param>
      <param name="start">O índice no qual o intervalo será iniciado.</param>
      <typeparam name="T">O tipo do segmento da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> é menor que 0 ou maior que <see langword="segment.Count" />.</exception>
      <returns>A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>Cria um intervalo em uma parte de um segmento de matriz de destino com base em uma posição especificada para um tamanho especificado.</summary>
      <param name="segment">O segmento de matriz de destino.</param>
      <param name="start">O índice no qual o intervalo será iniciado.</param>
      <param name="length">O número de itens no intervalo.</param>
      <typeparam name="T">O tipo do segmento da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="segment" />.</exception>
      <returns>A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary>Cria um intervalo em uma parte de um segmento de matriz de destino usando os índices de início e término do intervalo.</summary>
      <param name="segment">O segmento de matriz de destino.</param>
      <param name="range">O intervalo que tem os índices de início e término a serem usados para dividir a matriz.</param>
      <typeparam name="T">O tipo do segmento da matriz.</typeparam>
      <returns>A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary>Pesquisa um <see cref="T:System.ReadOnlySpan`1" /> inteiro classificado por um valor usando a interface genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span">O <see cref="T:System.ReadOnlySpan`1" /> classificado a ser pesquisado.</param>
      <param name="comparable">O <see cref="T:System.IComparable`1" /> a ser usado na comparação.</param>
      <typeparam name="T">O tipo de elemento da extensão.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns>O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary>Pesquisa um <see cref="T:System.Span`1" /> inteiro classificado por um valor usando a interface genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span">O <see cref="T:System.Span`1" /> classificado a ser pesquisado.</param>
      <param name="comparable">O <see cref="T:System.IComparable`1" /> a ser usado na comparação.</param>
      <typeparam name="T">O tipo de elemento da extensão.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns>O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary>Pesquisa um <see cref="T:System.ReadOnlySpan`1" /> inteiro classificado por um valor especificado usando o tipo genérico <typeparamref name="TComparer" /> especificado.</summary>
      <param name="span">O <see cref="T:System.ReadOnlySpan`1" /> classificado a ser pesquisado.</param>
      <param name="value">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
      <param name="comparer">O <typeparamref name="TComparer" /> a ser usado na comparação.</param>
      <typeparam name="T">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparer">O tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> é <see langword="null" />.</exception>
      <returns>O índice baseado em zero da <paramref name="value" /> no <paramref name="span" /> classificado, se <paramref name="value" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="value" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary>Pesquisa um <see cref="T:System.ReadOnlySpan`1" /> inteiro classificado por um valor usando o tipo genérico <typeparamref name="TComparable" /> especificado.</summary>
      <param name="span">O <see cref="T:System.ReadOnlySpan`1" /> classificado a ser pesquisado.</param>
      <param name="comparable">O <typeparamref name="TComparable" /> a ser usado na comparação.</param>
      <typeparam name="T">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparable">O tipo específico de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns>O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary>Pesquisa um <see cref="T:System.Span`1" /> inteiro classificado por um valor especificado usando o tipo genérico <typeparamref name="TComparer" /> especificado.</summary>
      <param name="span">O <see cref="T:System.Span`1" /> classificado a ser pesquisado.</param>
      <param name="value">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
      <param name="comparer">O <typeparamref name="TComparer" /> a ser usado na comparação.</param>
      <typeparam name="T">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparer">O tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> é <see langword="null" />.</exception>
      <returns>O índice baseado em zero da <paramref name="value" /> no <paramref name="span" /> classificado, se <paramref name="value" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="value" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary>Pesquisa um <see cref="T:System.Span`1" /> inteiro classificado por um valor usando o tipo genérico <typeparamref name="TComparable" /> especificado.</summary>
      <param name="span">O <see cref="T:System.Span`1" /> classificado a ser pesquisado.</param>
      <param name="comparable">O <typeparamref name="TComparable" /> a ser usado na comparação.</param>
      <typeparam name="T">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparable">O tipo específico de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns>O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Compara um intervalo de caracteres com outro usando uma comparação de cadeia de caracteres especificada e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="other">O valor a ser comparado com o intervalo de origem.</param>
      <param name="comparisonType">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="other" /> são comparados.</param>
      <returns>Um inteiro com sinal que indica a ordem relativa de <paramref name="span" /> e <paramref name="other" />:   – Se for menor que 0, <paramref name="span" /> precederá <paramref name="other" />.   - Se for 0, <paramref name="span" /> será igual a <paramref name="other" />.   – Se for maior que 0, <paramref name="span" /> seguirá <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Indica se um valor especificado ocorre em um intervalo de caracteres somente leitura.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="value">O valor a ser buscado no intervalo de origem.</param>
      <param name="comparisonType">Um valor de enumeração que determina como os caracteres em <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns>
        <see langword="true" /> se <paramref name="value" /> ocorre dentro do intervalo; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary>Indica se um valor especificado é encontrado em um intervalo somente leitura. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">O valor a ser procurado.</param>
      <typeparam name="T">O tipo da extensão.</typeparam>
      <returns>
        <see langword="true" /> se encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary>Indica se um valor especificado é encontrado em um intervalo. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">O valor a ser procurado.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>
        <see langword="true" /> se encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary>Copia o conteúdo da matriz para uma região de memória.</summary>
      <param name="source">A matriz da qual os itens serão copiados.</param>
      <param name="destination">A memória para a qual os itens serão copiados.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArgumentException">O destino é menor que a matriz de origem.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary>Copia o conteúdo da matriz para o intervalo.</summary>
      <param name="source">A matriz da qual os itens serão copiados.</param>
      <param name="destination">O intervalo no qual copiar itens.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArgumentException">O intervalo de destino é menor que a matriz de origem.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina se o final do <paramref name="span" /> corresponde ao <paramref name="value" /> especificado quando comparado usando a opção <paramref name="comparisonType" /> especificada.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="value">A sequência a ser comparada com o final do intervalo de origem.</param>
      <param name="comparisonType">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corresponde ao final de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se a sequência especificada aparece no final de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="value">A sequência a ser comparada com o final do intervalo de origem.</param>
      <typeparam name="T">O tipo da extensão.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corresponde ao final de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se a sequência especificada aparece no final de um intervalo.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="value">A sequência a ser comparada com o final do intervalo de origem.</param>
      <typeparam name="T">O tipo da extensão.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corresponde ao final de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary>Retorna uma enumeração de <see cref="T:System.Text.Rune" /> do intervalo somente leitura fornecido.</summary>
      <param name="span">O intervalo de origem.</param>
      <returns>Um enumerador de rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary>Retorna uma enumeração de <see cref="T:System.Text.Rune" /> do intervalo fornecido.</summary>
      <param name="span">O intervalo de origem.</param>
      <returns>Um enumerador de rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina se este <paramref name="span" /> e o intervalo <paramref name="other" /> especificado têm os mesmos caracteres quando comparados usando a opção <paramref name="comparisonType" /> especificada.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="other">O valor a ser comparado com o intervalo de origem.</param>
      <param name="comparisonType">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="other" /> são comparados.</param>
      <returns>
        <see langword="true" /> se é igual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Relata o índice baseado em zero da primeira ocorrência do <paramref name="value" /> especificado no <paramref name="span" /> atual.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="value">O valor a ser buscado no intervalo de origem.</param>
      <param name="comparisonType">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns>O índice da ocorrência do valor no intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Pesquisa o valor especificado e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">O valor a ser procurado.</param>
      <typeparam name="T">O tipo do intervalo e do valor.</typeparam>
      <returns>O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa a sequência especificada e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">A sequência a ser pesquisada.</param>
      <typeparam name="T">O tipo do intervalo e do valor.</typeparam>
      <returns>O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary>Pesquisa o valor especificado e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">O valor a ser procurado.</param>
      <typeparam name="T">O tipo do intervalo e do valor.</typeparam>
      <returns>O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa a sequência especificada e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">A sequência a ser pesquisada.</param>
      <typeparam name="T">O tipo do intervalo e do valor..</typeparam>
      <returns>O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <param name="value2">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="values">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <param name="value2">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="values">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary>Indica se o intervalo especificado contém apenas caracteres de espaço em branco.</summary>
      <param name="span">O intervalo de origem.</param>
      <returns>
        <see langword="true" /> se o intervalo contém apenas caracteres de espaço em branco; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Relata o índice baseado em zero da última ocorrência do <paramref name="value" /> especificado no <paramref name="span" /> atual.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="value">O valor a ser buscado no intervalo de origem.</param>
      <param name="comparisonType">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns>O índice da última ocorrência do valor no intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>Pesquisa o valor especificado e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">O valor a ser procurado.</param>
      <typeparam name="T">O tipo do intervalo e do valor.</typeparam>
      <returns>O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa a sequência especificada e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">A sequência a ser pesquisada.</param>
      <typeparam name="T">O tipo do intervalo e do valor.</typeparam>
      <returns>O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary>Pesquisa o valor especificado e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">O valor a ser procurado.</param>
      <typeparam name="T">O tipo do intervalo e do valor.</typeparam>
      <returns>O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa a sequência especificada e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">A sequência a ser pesquisada.</param>
      <typeparam name="T">O tipo do intervalo e do valor.</typeparam>
      <returns>O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <param name="value2">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="values">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value0">Um dos valores a serem pesquisados.</param>
      <param name="value1">Um dos valores a serem pesquisados.</param>
      <param name="value2">Um dos valores a serem pesquisados.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="values">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T">O tipo do intervalo e dos valores.</typeparam>
      <returns>O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se duas sequências somente leitura se sobrepõem na memória.</summary>
      <param name="span">A primeira sequência.</param>
      <param name="other">A segunda sequência.</param>
      <typeparam name="T">O tipo de elementos na sequência somente leitura.</typeparam>
      <returns>
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Determina se duas sequências somente leitura se sobrepõem na memória e gera o deslocamento do elemento.</summary>
      <param name="span">A primeira sequência.</param>
      <param name="other">A segunda sequência.</param>
      <param name="elementOffset">Quando o método é retornado, contém o deslocamento entre <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T">O tipo de elementos no span.</typeparam>
      <returns>
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se um intervalo e um intervalo somente leitura se sobrepõem na memória.</summary>
      <param name="span">O intervalo a ser comparado.</param>
      <param name="other">O intervalo somente leitura a ser comparado.</param>
      <typeparam name="T">O tipo de elementos no span.</typeparam>
      <returns>
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>Determina se um intervalo e um intervalo somente leitura se sobrepõem na memória e gera o deslocamento do elemento.</summary>
      <param name="span">A primeira sequência a ser comparada.</param>
      <param name="other">A segunda sequência a ser comparada.</param>
      <param name="elementOffset">Quando o método é retornado, contém o deslocamento entre <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T">O tipo de elementos no span.</typeparam>
      <returns>
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary>Reverte a sequência dos elementos em todo o intervalo.</summary>
      <param name="span">O intervalo a ser revertido.</param>
      <typeparam name="T">O tipo de elementos no span.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina a ordem relativa de duas sequências somente leitura comparando seus elementos com o uso de IComparable{T}.CompareTo(T).</summary>
      <param name="span">A primeira sequência a ser comparada.</param>
      <param name="other">A segunda sequência a ser comparada.</param>
      <typeparam name="T">O tipo de elementos na sequência.</typeparam>
      <returns>Um inteiro com sinal que indica a ordem relativa de <paramref name="span" /> e <paramref name="other" />:   – Se for menor que 0, <paramref name="span" /> precederá <paramref name="other" />.   - Se for 0, <paramref name="span" /> será igual a <paramref name="other" />.   – Se for maior que 0, <paramref name="span" /> seguirá <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina a ordem relativa de um intervalo e um intervalo somente leitura comparando os elementos com o uso de IComparable{T}.CompareTo(T).</summary>
      <param name="span">O intervalo a ser comparado.</param>
      <param name="other">O intervalo somente leitura a ser comparado.</param>
      <typeparam name="T">O tipo de elementos no span.</typeparam>
      <returns>Um inteiro com sinal que indica a ordem relativa de <paramref name="span" /> e <paramref name="other" />:   – Se for menor que 0, <paramref name="span" /> precederá <paramref name="other" />.   - Se for 0, <paramref name="span" /> será igual a <paramref name="other" />.   – Se for maior que 0, <paramref name="span" /> seguirá <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se duas sequências somente leitura são iguais comparando os elementos com o uso de IEquatable{T}.Equals(T).</summary>
      <param name="span">A primeira sequência a ser comparada.</param>
      <param name="other">A segunda sequência a ser comparada.</param>
      <typeparam name="T">O tipo de elementos na sequência.</typeparam>
      <returns>
        <see langword="true" /> se as duas sequências são iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se um intervalo e um intervalo somente leitura são iguais comparando os elementos com o uso de IEquatable{T}.Equals(T).</summary>
      <param name="span">O intervalo a ser comparado.</param>
      <param name="other">O intervalo somente leitura a ser comparado.</param>
      <typeparam name="T">O tipo de elementos na sequência.</typeparam>
      <returns>
        <see langword="true" /> se as duas sequências são iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary>Classifica os elementos em todo o <see cref="T:System.Span`1" /> usando a implementação <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Span`1" /></summary>
      <param name="span">O intervalo de memória a ser classificado.</param>
      <typeparam name="T">O tipo dos elementos do span.</typeparam>
      <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="span" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary>Classifica os elementos em todo o <see cref="T:System.Span`1" /> usando o <see cref="T:System.Comparison`1" /> especificado.</summary>
      <param name="span">O intervalo de memória a ser classificado.</param>
      <param name="comparison">O método a ser usado ao comparar elementos.</param>
      <typeparam name="T">O tipo dos elementos do span.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary>Classifica os elementos em todo o <see cref="T:System.Span`1" /> usando o <typeparamref name="TComparer" />.</summary>
      <param name="span">O intervalo de memória a ser classificado.</param>
      <param name="comparer">O método a ser usado ao comparar elementos ou <see langword="null" /> para usar a implementação de interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
      <typeparam name="T">O tipo dos elementos do span.</typeparam>
      <typeparam name="TComparer">O tipo do comparador a ser usado para comparar elementos.</typeparam>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="span" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
      <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary>Classifica um par de intervalos (um contendo as chaves e o outro contendo os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Span`1" /> usando a implementação <see cref="T:System.IComparable`1" /> de cada chave.</summary>
      <param name="keys">A extensão que contém as chaves a serem classificadas.</param>
      <param name="items">A extensão que contém os itens que correspondem às chaves em <paramref name="keys" />.</param>
      <typeparam name="TKey">O tipo dos elementos do intervalo de chaves.</typeparam>
      <typeparam name="TValue">O tipo dos elementos do span de itens.</typeparam>
      <exception cref="T:System.ArgumentException">O tamanho de <paramref name="keys" /> não é igual ao tamanho de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="keys" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary>Classifica um par de intervalos (um contendo as chaves e o outro contendo os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Span`1" /> usando a comparação especificada.</summary>
      <param name="keys">A extensão que contém as chaves a serem classificadas.</param>
      <param name="items">A extensão que contém os itens que correspondem às chaves em <paramref name="keys" />.</param>
      <param name="comparison">O <see cref="T:System.Comparison`1" /> a ser usado na comparação de elementos.</param>
      <typeparam name="TKey">O tipo dos elementos do intervalo de chaves.</typeparam>
      <typeparam name="TValue">O tipo dos elementos do span de itens.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">O tamanho de <paramref name="keys" /> não é igual ao tamanho de <paramref name="items" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary>Classifica um par de intervalos (um contendo as chaves e o outro contendo os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Span`1" /> usando o comparador especificado.</summary>
      <param name="keys">A extensão que contém as chaves a serem classificadas.</param>
      <param name="items">A extensão que contém os itens que correspondem às chaves em <paramref name="keys" />.</param>
      <param name="comparer">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada ao comparar elementos ou <see langword="null" /> para usar a implementação da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
      <typeparam name="TKey">O tipo dos elementos do intervalo de chaves.</typeparam>
      <typeparam name="TValue">O tipo dos elementos do span de itens.</typeparam>
      <typeparam name="TComparer">O tipo do comparador a ser usado para comparar elementos.</typeparam>
      <exception cref="T:System.ArgumentException">O tamanho de <paramref name="keys" /> não é igual ao tamanho de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="keys" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>Determina se um intervalo de caracteres somente leitura começa com um valor especificado quando comparado usando um valor <see cref="T:System.StringComparison" /> especificado.</summary>
      <param name="span">O intervalo de origem.</param>
      <param name="value">A sequência a ser comparada com o início do intervalo de origem.</param>
      <param name="comparisonType">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corresponde ao início de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se uma sequência especificada aparece no início de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de caracteres somente leitura a ser pesquisado.</param>
      <param name="value">Uma sequência a ser pesquisada no início de <paramref name="span" />.</param>
      <typeparam name="T">O tipo de elementos no span.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corresponde ao início de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Determina se uma sequência especificada aparece no início de um intervalo.</summary>
      <param name="span">O intervalo a ser pesquisado.</param>
      <param name="value">Uma sequência a ser pesquisada no início de <paramref name="span" />.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>
        <see langword="true" /> se <paramref name="value" /> corresponde ao início de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em minúsculas, usando as regras de uso de maiúsculas da cultura especificada.</summary>
      <param name="source">O intervalo de origem.</param>
      <param name="destination">O intervalo de destino que contém os caracteres transformados.</param>
      <param name="culture">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
      <exception cref="T:System.InvalidOperationException">Os buffers de origem e destino se sobrepõem.</exception>
      <returns>O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em minúsculas, usando as regras de uso de maiúsculas da cultura invariável.</summary>
      <param name="source">O intervalo de origem.</param>
      <param name="destination">O intervalo de destino que contém os caracteres transformados.</param>
      <exception cref="T:System.InvalidOperationException">Os buffers de origem e destino se sobrepõem.</exception>
      <returns>O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em maiúsculas, usando as regras de uso de maiúsculas da cultura especificada.</summary>
      <param name="source">O intervalo de origem.</param>
      <param name="destination">O intervalo de destino que contém os caracteres transformados.</param>
      <param name="culture">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
      <exception cref="T:System.InvalidOperationException">Os buffers de origem e destino se sobrepõem.</exception>
      <returns>O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em maiúsculas, usando as regras de uso de maiúsculas da cultura invariável.</summary>
      <param name="source">O intervalo de origem.</param>
      <param name="destination">O intervalo de destino que contém os caracteres transformados.</param>
      <exception cref="T:System.InvalidOperationException">Os buffers de origem e destino se sobrepõem.</exception>
      <returns>O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda e à direita de uma região de memória de caracteres.</summary>
      <param name="memory">A memória de origem da qual os caracteres são removidos.</param>
      <returns>A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda e à direita de uma região de memória de caracteres somente leitura.</summary>
      <param name="memory">A memória de origem da qual os caracteres são removidos.</param>
      <returns>A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda e à direita de um intervalo de caracteres somente leitura.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Remove todas as ocorrências à esquerda e à direita de um caractere especificado de um intervalo de caracteres somente leitura.</summary>
      <param name="span">O intervalo de origem do qual o caractere é removido.</param>
      <param name="trimChar">O caractere especificado a ser procurado e removido.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Remove todas as ocorrências à esquerda e à direita de um conjunto de caracteres especificado em um intervalo somente leitura de um intervalo de caracteres somente leitura.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <param name="trimChars">O intervalo que contém o conjunto de caracteres a ser removido.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda e à direita de um intervalo de caracteres.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns>O intervalo de caracteres cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda e à direita de um elemento especificado de uma região de memória.</summary>
      <param name="memory">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória.</typeparam>
      <returns>A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória.</typeparam>
      <returns>A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda e à direita de um elemento especificado de uma região de memória ROM.</summary>
      <param name="memory">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns>A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificado em um intervalo somente leitura de uma região de memória ROM.</summary>
      <param name="memory">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns>A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda e à direita de um elemento especificado de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos no span somente leitura.</typeparam>
      <returns>O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos no span somente leitura.</typeparam>
      <returns>O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda e à direita de um elemento especificado de um intervalo.</summary>
      <param name="span">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo.</summary>
      <param name="span">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à direita de uma região de memória de caracteres.</summary>
      <param name="memory">A memória de origem da qual os caracteres são removidos.</param>
      <returns>A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à direita de uma região de memória de caracteres somente leitura.</summary>
      <param name="memory">A memória de origem da qual os caracteres são removidos.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à direita de um intervalo de caracteres somente leitura.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Remove todas as ocorrências à direita de um caractere especificado de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de origem do qual o caractere é removido.</param>
      <param name="trimChar">O caractere especificado a ser procurado e removido.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Remove todas as ocorrências à direita de um conjunto de caracteres especificado em um intervalo somente leitura de um intervalo de caracteres somente leitura.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <param name="trimChars">O intervalo que contém o conjunto de caracteres a ser removido.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à direita de um intervalo de caracteres.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns>O intervalo de caracteres cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary>Remove todas as ocorrências à direita de um elemento especificado de uma região de memória de caracteres.</summary>
      <param name="memory">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória.</typeparam>
      <returns>A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à direita de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória.</typeparam>
      <returns>A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Remove todas as ocorrências à direita de um elemento especificado de uma região de memória ROM.</summary>
      <param name="memory">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns>A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à direita de um conjunto de elementos especificado em um intervalo somente leitura de uma região de memória ROM.</summary>
      <param name="memory">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns>A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary>Remove todas as ocorrências à direita de um elemento especificado de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos no span somente leitura.</typeparam>
      <returns>O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos no span somente leitura.</typeparam>
      <returns>O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary>Remove todas as ocorrências à direita de um elemento especificado de um intervalo.</summary>
      <param name="span">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo.</summary>
      <param name="span">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda de uma região de memória.</summary>
      <param name="memory">A memória de origem da qual os caracteres são removidos.</param>
      <returns>A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda de uma região de memória ROM.</summary>
      <param name="memory">A memória de origem da qual os caracteres são removidos.</param>
      <returns>A região de memória do caractere somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda de um intervalo somente leitura.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>Remove todas as ocorrências à esquerda de um caractere especificado do intervalo.</summary>
      <param name="span">O intervalo de origem do qual o caractere é removido.</param>
      <param name="trimChar">O caractere especificado a ser procurado e removido.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Remove todas as ocorrências à esquerda de um conjunto de caracteres especificado em um intervalo somente leitura do intervalo.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <param name="trimChars">O intervalo que contém o conjunto de caracteres a ser removido.</param>
      <returns>O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary>Remove todos os caracteres de espaço em branco à esquerda de um intervalo.</summary>
      <param name="span">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns>O intervalo de caracteres cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda de um elemento especificado de uma região de memória.</summary>
      <param name="memory">A região de memória de origem da qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória.</typeparam>
      <returns>A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória.</typeparam>
      <returns>A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda de um elemento especificado de uma região de memória.</summary>
      <param name="memory">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns>A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns>A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda de um elemento especificado do intervalo.</summary>
      <param name="span">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos no span somente leitura.</typeparam>
      <returns>O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda de um conjunto de elementos especificado em um intervalo somente leitura do intervalo.</summary>
      <param name="span">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos no span somente leitura.</typeparam>
      <returns>O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary>Remove todas as ocorrências à esquerda de um elemento especificado do intervalo.</summary>
      <param name="span">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>Remove todas as ocorrências à esquerda de um conjunto de elementos especificado em um intervalo somente leitura do intervalo.</summary>
      <param name="span">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T">O tipo dos elementos no span.</typeparam>
      <returns>O intervalo cortado.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary>Oferece métodos para interoperar com <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" />e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary>Converte um <see cref="T:System.ReadOnlySpan`1" /> de um tipo primitivo, <paramref name="T" />, em um <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span">A fatia de origem a ser convertida.</param>
      <typeparam name="T">O tipo de itens no span somente leitura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.OverflowException">A propriedade <see cref="P:System.ReadOnlySpan`1.Length" /> da nova <see cref="T:System.ReadOnlySpan`1" /> excederia o <see cref="F:System.Int32.MaxValue" /></exception>
      <returns>Uma extensão de somente leitura do tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary>Converte um <see cref="T:System.Span`1" /> de um tipo primitivo, <paramref name="T" />, em um <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span">A fatia de origem a ser convertida.</param>
      <typeparam name="T">O tipo de itens no intervalo.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.OverflowException">A propriedade <see cref="P:System.Span`1.Length" /> da nova <see cref="T:System.Span`1" /> excederia o <see cref="F:System.Int32.MaxValue" /></exception>
      <returns>Uma extensão do tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary>Cria uma instância <see cref="T:System.Memory`1" /> de uma <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory">O buffer de memória de somente leitura.</param>
      <typeparam name="T">O tipo de itens no buffer de memória somente leitura.</typeparam>
      <returns>Um bloco de memória que representa a mesma memória que o <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary>Reinterpreta um intervalo somente leitura de bytes como uma referência somente leitura para a estrutura do tipo <paramref name="T" />.</summary>
      <param name="span">O intervalo somente leitura a se reinterpretado.</param>
      <typeparam name="T">O tipo da referência retornada.</typeparam>
      <returns>A referência somente leitura para a estrutura do tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary>Reinterpreta um intervalo de bytes como uma referência à estrutura do tipo <paramref name="T" />.</summary>
      <param name="span">O intervalo para reinterpretar.</param>
      <typeparam name="T">O tipo da referência retornada.</typeparam>
      <returns>A referência à estrutura do tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary>Converte uma extensão de somente leitura de um tipo primitivo em uma extensão de outro tipo primitivo.</summary>
      <param name="span">A fatia de origem a ser convertida.</param>
      <typeparam name="TFrom">O tipo do span de origem.</typeparam>
      <typeparam name="TTo">O tipo do span de destino.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contém referências ou ponteiros.</exception>
      <returns>A extensão de somente leitura convertida.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary>Converte um período de um tipo primitivo em um período de outro tipo primitivo.</summary>
      <param name="span">A fatia de origem a ser convertida.</param>
      <typeparam name="TFrom">O tipo do span de origem.</typeparam>
      <typeparam name="TTo">O tipo do span de destino.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contém referências ou ponteiros.</exception>
      <returns>A extensão convertida.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary>Cria um novo buffer de memória sobre a parte da matriz de destino pré-fixada começando pelo índice <paramref name="start" /> e formado por itens <paramref name="length" />.</summary>
      <param name="array">A matriz de origem pré-fixada.</param>
      <param name="start">O índice de <paramref name="array" /> no qual o bloco de memória será iniciado.</param>
      <param name="length">O número de itens a serem incluídos no bloco de memória.</param>
      <typeparam name="T">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> é covariante e o tipo de <paramref name="array" /> não é exatamente <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O <paramref name="start" /> ou o índice final não está no intervalo de 0 a <see cref="P:System.Array.Length" />.</exception>
      <returns>Um bloco de memória nos elementos especificados de <paramref name="array" />. Se <paramref name="array" /> for <see langword="null" />, ou se <paramref name="start" /> e <paramref name="length" /> forem 0, o método retornará uma instância <see cref="T:System.Memory`1" /> de <see cref="P:System.Memory`1.Length" /> com valor zero.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary>Cria uma nova extensão de somente leitura sobre uma parte de um objeto gerenciado regular.</summary>
      <param name="reference">Uma referência aos dados.</param>
      <param name="length">O número de elementos <paramref name="T" /> que <paramref name="reference" /> contém.</param>
      <typeparam name="T">O tipo dos itens de dados.</typeparam>
      <returns>Uma extensão de somente leitura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary>Cria uma nova extensão sobre uma parte de um objeto gerenciado regular.</summary>
      <param name="reference">Uma referência aos dados.</param>
      <param name="length">O número de elementos <paramref name="T" /> que <paramref name="reference" /> contém.</param>
      <typeparam name="T">O tipo dos itens de dados.</typeparam>
      <returns>Uma extensão.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary>Retorna uma referência ao elemento 0 de <paramref name="array" />. Se a matriz estiver vazia, retornará uma referência ao local em que o elemento 0 teria sido armazenado. Essa referência pode ser usada para fixação, mas nunca deve ser desreferenciada.</summary>
      <param name="array">A matriz a ser analisada.</param>
      <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="array" /> é <see langword="null" />.</exception>
      <returns>Referência ao elemento 0 em <paramref name="array" /></returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary>Retorna uma referência ao elemento da extensão de somente leitura no índice 0.</summary>
      <param name="span">A extensão de somente leitura da qual a referência é recuperada.</param>
      <typeparam name="T">O tipo de itens no intervalo.</typeparam>
      <returns>Uma referência ao elemento no índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary>Retorna uma referência ao elemento da extensão no índice 0.</summary>
      <param name="span">A extensão da qual a referência é recuperada.</param>
      <typeparam name="T">O tipo de itens no intervalo.</typeparam>
      <returns>Uma referência ao elemento no índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary>Lê uma estrutura de tipo <param name="T" /> de uma extensão de somente leitura de bytes.</summary>
      <param name="source">Uma extensão de somente leitura.</param>
      <typeparam name="T">O tipo do item a ser recuperado do span somente leitura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> é menor que <paramref name="T" />.</exception>
      <returns>A estrutura recuperada da extensão de somente leitura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary>Cria uma exibição <see cref="T:System.Collections.Generic.IEnumerable`1" /> de determinado buffer de memória de somente leitura.</summary>
      <param name="memory">Um buffer de memória de somente leitura.</param>
      <typeparam name="T">O tipo dos itens no buffer de memória somente leitura.</typeparam>
      <returns>Uma exibição enumerável de <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary>Tenta obter um segmento de matriz do buffer de memória subjacente. O valor retornado indica o sucesso da operação.</summary>
      <param name="memory">Um buffer de memória de somente leitura.</param>
      <param name="segment">Ao retornar, esse método contém o segmento da matriz recuperado do buffer de memória de somente leitura subjacente. Se o método falhar, ele retornará um segmento de matriz padrão.</param>
      <typeparam name="T">O tipo de itens no buffer de memória somente leitura.</typeparam>
      <returns>
        <see langword="true" /> se a chamada de método for bem-sucedida. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary>Tenta recuperar um <see cref="T:System.Buffers.MemoryManager`1" /> do buffer de memória de somente leitura subjacente.</summary>
      <param name="memory">O buffer de memória de somente leitura para o qual obter o gerenciador de memória.</param>
      <param name="manager">Quando o método retorna, o gerenciador de <paramref name="memory" />.</param>
      <typeparam name="T">O tipo dos itens no buffer de memória somente leitura.</typeparam>
      <typeparam name="TManager">O tipo de a <see cref="T:System.Buffers.MemoryManager`1" /> ser recuperado.</typeparam>
      <returns>
        <see langword="true" /> se o método tiver recuperado o gerenciador de memória. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary>Tenta recuperar um <see cref="T:System.Buffers.MemoryManager`1" />, índice de início e comprimento do buffer de memória de somente leitura subjacente.</summary>
      <param name="memory">O buffer de memória de somente leitura para o qual obter o gerenciador de memória.</param>
      <param name="manager">Quando o método retorna, o gerenciador de <paramref name="memory" />.</param>
      <param name="start">Quando o método retorna, o deslocamento do início do <paramref name="manager" /> que o <paramref name="memory" /> representa.</param>
      <param name="length">Quando o método retorna, o comprimento do <paramref name="manager" /> que o <paramref name="memory" /> representa.</param>
      <typeparam name="T">O tipo dos itens no buffer de memória somente leitura.</typeparam>
      <typeparam name="TManager">O tipo de a <see cref="T:System.Buffers.MemoryManager`1" /> ser recuperado.</typeparam>
      <returns>
        <see langword="true" />, se o método for bem-sucedido. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary>Tenta obter a cadeia de caracteres subjacente de um <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory">Memória somente leitura que contém um bloco de caracteres.</param>
      <param name="text">Quando o método retorna, a cadeia de caracteres contida no buffer de memória.</param>
      <param name="start">A localização inicial em <paramref name="text" />.</param>
      <param name="length">O número de caracteres em <paramref name="text" />.</param>
      <returns>
        <see langword="true" /> se o método recuperar a cadeia de caracteres subjacente com eficiência. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary>Tenta ler uma estrutura do tipo <paramref name="T" /> de um intervalo de bytes somente leitura.</summary>
      <param name="source">Uma extensão de somente leitura de bytes.</param>
      <param name="value">Quando o método retorna, uma instância do <paramref name="T" />.</param>
      <typeparam name="T">O tipo da estrutura a ser recuperada.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <returns>
        <see langword="true" /> se o método tiver êxito na recuperação de uma instância da estrutura. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary>Tenta gravar uma estrutura do tipo <paramref name="T" /> em um intervalo de bytes.</summary>
      <param name="destination">O extensão de bytes para conter a estrutura.</param>
      <param name="value">A estrutura a ser gravada na extensão.</param>
      <typeparam name="T">O tipo da estrutura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <returns>
        <see langword="true" /> se a operação de gravação for bem-sucedida. Caso contrário, <see langword="false" />. O método retornará <see langword="false" /> se o intervalo for muito pequeno para conter <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary>Grava uma estrutura do tipo <paramref name="T" /> em um intervalo de bytes.</summary>
      <param name="destination">O extensão de bytes para conter a estrutura.</param>
      <param name="value">A estrutura a ser gravada na extensão.</param>
      <typeparam name="T">O tipo da estrutura.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> é muito pequena para conter <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary>Fornece uma coleção de métodos para interoperar com o <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary>Obtém um segmento de matriz da sequência somente leitura subjacente.</summary>
      <param name="sequence">A sequência somente leitura da qual o segmento de matriz será recuperado.</param>
      <param name="segment">O segmento de matriz retornado.</param>
      <typeparam name="T">O tipo da sequência somente leitura.</typeparam>
      <returns>
        <see langword="true" /> se é possível recuperar o segmento de matriz; caso contrário, <see langword="false" /> e um segmento de matriz padrão é retornado.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary>Tenta recuperar uma memória ROM da sequência somente leitura especificada.</summary>
      <param name="sequence">A sequência somente leitura da qual a memória será recuperada.</param>
      <param name="memory">A memória ROM retornada do tipo T.</param>
      <typeparam name="T">O tipo da sequência somente leitura.</typeparam>
      <returns>
        <see langword="true" /> se a memória ROM pode ser recuperada; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary>Tenta recuperar um segmento de sequência somente leitura da sequência somente leitura especificada.</summary>
      <param name="sequence">A sequência somente leitura da qual o segmento de sequência somente leitura será recuperado.</param>
      <param name="startSegment">O segmento de sequência somente leitura inicial.</param>
      <param name="startIndex">A posição inicial.</param>
      <param name="endSegment">O segmento de sequência somente leitura final.</param>
      <param name="endIndex">A posição final.</param>
      <typeparam name="T">O tipo da sequência somente leitura.</typeparam>
      <returns>
        <see langword="true" /> se o segmento de sequência somente leitura pode ser recuperado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary>Tenta ler o tipo especificado fora do buffer. É perigoso usar esse método com structs arbitrários – confira os comentários para obter mais informações.</summary>
      <param name="reader">Uma referência ao leitor de sequência.</param>
      <param name="value">O valor retornado se a leitura foi bem-sucedida. <paramref name="value" /> será <see langword="default" /> se houver falha (devido à falta de espaço).</param>
      <typeparam name="T">O tipo do valor.</typeparam>
      <returns>
        <see langword="true" /> se a tentativa de leitura foi bem-sucedida; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary>Representa uma posição em um conjunto não contíguo de memória. As propriedades desse tipo não devem ser interpretadas por nada, exceto pelo tipo que a criou.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary>Inicializa uma nova instância do struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object">Um conjunto não contíguo de memória.</param>
      <param name="integer">A posição em <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary>Retorna um valor que indica se a instância atual é igual a outro objeto.</summary>
      <param name="obj">O objeto a ser comparado com a instância atual.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> for do tipo <see cref="T:System.SequencePosition" /> e igual à instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary>Indica se a instância atual é igual a outra <see cref="T:System.SequencePosition" />.</summary>
      <param name="other">A posição da sequência a ser comparada com a instância atual.</param>
      <returns>
        <see langword="true" /> se as duas instâncias de forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary>Retorna o código hash para a instância.</summary>
      <returns>O código hash para essa instância.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary>Retorna a parte inteira desta <see cref="T:System.SequencePosition" />.</summary>
      <returns>A parte inteira desta posição de sequência.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary>Retorna a parte do objeto desta <see cref="T:System.SequencePosition" />.</summary>
      <returns>A parte do objeto dessa posição de sequência.</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary>Fornece métodos de extensão para tipos de codificação, como <see cref="T:System.Text.Encoding" />, <see cref="T:System.Text.Encoder" /> e <see cref="T:System.Text.Decoder" />.</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte um <see cref="T:System.Buffers.ReadOnlySequence`1" /> para caracteres codificados em UTF-16 e grava o resultado em <paramref name="writer" />.</summary>
      <param name="decoder">A instância do decodificador que pode converter bytes em valores <see langword="char" />.</param>
      <param name="bytes">Uma sequência de bytes a ser decodificada.</param>
      <param name="writer">O buffer no qual os caracteres decodificados serão gravados.</param>
      <param name="flush">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="charsUsed">Quando este método é retornado, contém o número de caracteres gravados em <paramref name="writer" />.</param>
      <param name="completed">Quando este método é retornado, contém <see langword="true" /> caso <paramref name="decoder" /> não tenha nenhum estado interno parcial; caso contrário, <see langword="false" />.
Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="decoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte um <see cref="T:System.ReadOnlySpan`1" /> em caracteres usando <paramref name="decoder" /> e grava o resultado em <paramref name="writer" />.</summary>
      <param name="decoder">A instância do decodificador que pode converter bytes em valores <see langword="char" />.</param>
      <param name="bytes">Uma sequência de bytes a ser decodificada.</param>
      <param name="writer">O buffer no qual os caracteres decodificados serão gravados.</param>
      <param name="flush">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="charsUsed">Quando este método é retornado, contém o número de <see langword="char" />s gravados em <paramref name="writer" />.</param>
      <param name="completed">Quando este método é retornado, contém <see langword="true" /> caso <paramref name="decoder" /> não tenha nenhum estado interno parcial; caso contrário, <see langword="false" />.
Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contém dados que não podem ser codificados e <paramref name="decoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte um <see cref="T:System.Buffers.ReadOnlySequence`1" /> em bytes codificados e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoder">A instância do codificador que pode converter valores <see langword="char" /> em bytes.</param>
      <param name="chars">Uma sequência de caracteres a ser codificada.</param>
      <param name="writer">O buffer no qual os bytes codificados serão gravados.</param>
      <param name="flush">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="bytesUsed">Quando este método é retornado, contém o número de <see langword="byte" />s gravados em <paramref name="writer" />.</param>
      <param name="completed">Quando este método é retornado, contém <see langword="true" /> se toda a entrada até <paramref name="bytesUsed" /> foi convertida; caso contrário, <see langword="false" />. Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>Converte um <see cref="T:System.ReadOnlySpan`1" /> em bytes usando <paramref name="encoder" /> e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoder">A instância do codificador que pode converter valores <see langword="char" /> em bytes.</param>
      <param name="chars">Uma sequência de caracteres a ser codificada.</param>
      <param name="writer">O buffer no qual os bytes codificados serão gravados.</param>
      <param name="flush">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="bytesUsed">Quando este método é retornado, contém o número de <see langword="byte" />s gravados em <paramref name="writer" />.</param>
      <param name="completed">Quando este método é retornado, contém <see langword="true" /> caso <paramref name="encoder" /> não tenha nenhum estado interno parcial; caso contrário, <see langword="false" />.
Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary>Codifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado em uma matriz <see cref="T:System.Byte" /> usando o <see cref="T:System.Text.Encoding" /> especificado.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars">A sequência a ser codificada em bytes.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>Uma matriz <see cref="T:System.Byte" /> que representa o conteúdo codificado de <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary>Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="byte" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars">O <see cref="T:System.Buffers.ReadOnlySequence`1" /> cujo conteúdo deve ser codificado.</param>
      <param name="writer">O buffer no qual os bytes codificados serão gravados.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>O número de bytes gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary>Codifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="byte" />s usando o <see cref="T:System.Text.Encoding" /> especificado e gera o resultado para <paramref name="bytes" />.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars">A sequência a ser codificada em bytes.</param>
      <param name="bytes">O buffer de destino no qual os bytes codificados serão gravados.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="bytes" /> não é grande o suficiente para conter a forma codificada de <paramref name="chars" />.</exception>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>O número de bytes gravados em <paramref name="bytes" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary>Codifica o <see cref="T:System.ReadOnlySpan`1" /> especificado para <see langword="byte" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars">A sequência a ser codificada em bytes.</param>
      <param name="writer">O buffer no qual os bytes codificados serão gravados.</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>O número de bytes gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary>Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="char" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="bytes" /> devem ser decodificados.</param>
      <param name="bytes">A sequência cujos bytes devem ser decodificados.</param>
      <param name="writer">O buffer no qual os caracteres decodificados serão gravados.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>O número de caracteres gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary>Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="char" />s usando o <see cref="T:System.Text.Encoding" /> especificado e gera o resultado para <paramref name="chars" />.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="bytes" /> são codificados.</param>
      <param name="bytes">A sequência a ser decodificada em caracteres.</param>
      <param name="chars">O buffer de destino no qual os caracteres decodificados serão gravados.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="chars" /> não é grande o suficiente para conter a forma codificada de <paramref name="bytes" />.</exception>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>O número de caracteres gravados em <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary>Decodifica o <see cref="T:System.ReadOnlySpan`1" /> especificado para <see langword="char" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="bytes" /> devem ser decodificados.</param>
      <param name="bytes">O intervalo de bytes a ser decodificado.</param>
      <param name="writer">O buffer no qual os caracteres decodificados serão gravados.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>O número de caracteres gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary>Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado em um <see cref="T:System.String" /> usando o <see cref="T:System.Text.Encoding" /> especificado.</summary>
      <param name="encoding">A codificação que representa como os dados em <paramref name="bytes" /> são codificados.</param>
      <param name="bytes">A sequência a ser decodificada em caracteres.</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns>Uma <see cref="T:System.String" /> que representa o conteúdo decodificado de <paramref name="bytes" />.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary>Fornece um enumerador para os valores de <see cref="T:System.Text.Rune" /> representados por um intervalo contendo texto em UTF-16.</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary>Retorna a instância do enumerador atual.</summary>
      <returns>A instância do enumerador atual.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary>Avança o enumerador para o próximo <see cref="T:System.Text.Rune" /> do intervalo.</summary>
      <returns>
        <see langword="true" /> se o enumerador avançou com êxito para o próximo item; <see langword="false" /> se o final do intervalo foi atingido.</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary>Obtém o <see cref="T:System.Text.Rune" /> na posição atual do enumerador.</summary>
      <returns>O <see cref="T:System.Text.Rune" /> na posição atual do enumerador.</returns>
    </member>
  </members>
</doc>