<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary vsli:raw="Content type masked bits that correspond to values of &lt;see cref=&quot;T:System.Reflection.AssemblyContentType&quot; /&gt;.">Os bits mascarados de tipo de conteúdo que correspondem aos valores de <see cref="T:System.Reflection.AssemblyContentType" />.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary vsli:raw="Just-In-Time (JIT) compiler optimization is disabled for the assembly.">A otimização do compilador JIT (Just-In-Time) está desabilitada para o assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary vsli:raw="Just-In-Time (JIT) compiler tracking is enabled for the assembly.">O acompanhamento do compilador JIT (Just-In-Time) está habilitado para o assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary vsli:raw="The assembly reference holds the full (unhashed) public key. Not applicable on assembly definition.">A referência de assembly contém a chave pública completa (sem hash). Não aplicável na definição de assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary vsli:raw="The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.">A implementação do assembly de referência usado no runtime não deve corresponder à versão vista no tempo de compilação.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary vsli:raw="The assembly contains Windows Runtime code.">O assembly contém código do Windows Runtime.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary vsli:raw="Specifies the hash algorithms used for hashing assembly files and for generating the strong name.">Especifica os algoritmos de hash usados para fazer hash de arquivos do assembly e para gerar o nome forte.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary vsli:raw="&lt;para&gt;Retrieves the MD5 message-digest algorithm.&lt;/para&gt;&lt;para&gt;Due to collision problems with MD5, Microsoft recommends SHA256.&lt;/para&gt;&lt;para&gt;MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and, while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.&lt;/para&gt;">Recupera o algoritmo de resumo da mensagem MD5.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary vsli:raw="&lt;para&gt;A mask indicating that there is no hash algorithm.&lt;/para&gt;&lt;para&gt;If you specify &lt;see cref=&quot;F:System.Reflection.AssemblyHashAlgorithm.None&quot; /&gt; for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.&lt;/para&gt;">Uma máscara que indica que não há nenhum algoritmo de hash.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary vsli:raw="&lt;para&gt;Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.&lt;/para&gt;&lt;para&gt;Due to collision problems with SHA1, Microsoft recommends SHA256.&lt;/para&gt;">Recupera uma revisão do Secure Hash Algorithm que corrige uma falha não publicada no SHA.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.">Recupera uma versão do Secure Hash Algorithm com um tamanho de hash de 256 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.">Recupera uma versão do Secure Hash Algorithm com um tamanho de hash de 384 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary vsli:raw="Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.">Recupera uma versão do Secure Hash Algorithm com um tamanho de hash de 512 bits.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary vsli:raw="Specifies the security actions that can be performed using declarative security.">Especifica as ações de segurança que podem ser executadas usando a segurança declarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary vsli:raw="The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.">O código de chamada pode acessar o recurso identificado pelo objeto de permissão atual, mesmo que os chamadores na pilha não tenham recebido permissão para acessar o recurso.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary vsli:raw="Check that all callers in the call chain have been granted the specified permission.">Verifique se todos os chamadores na cadeia de chamadas receberam a permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary vsli:raw="Without further checks refuse Demand for the specified permission.">Sem mais verificações, recuse a demanda pela permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary vsli:raw="The derived class inheriting the class or overriding a method is required to have the specified permission.">A classe derivada que está herdando a classe ou substituindo um método deverá ter recebido a permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary vsli:raw="Check that the immediate caller has been granted the specified permission.">Verifique se o chamador imediato recebeu a permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary vsli:raw="No declarative security action.">Nenhuma ação de segurança declarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary vsli:raw="Without further checks, refuse the demand for all permissions other than those specified.">Sem mais verificações, recuse a demanda por todas as permissões que não sejam as especificadas.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary vsli:raw="Request the minimum permissions required for code to run. This action can only be used within the scope of the assembly.">Solicite as permissões mínimas necessárias para a execução do código. Esta ação só pode ser usada no escopo do assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary vsli:raw="Request additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly.">Solicite as permissões adicionais que são opcionais (não necessárias para a execução). Essa solicitação recusa implicitamente todas as outras permissões não solicitadas especificamente. Esta ação só pode ser usada no escopo do assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary vsli:raw="Request that permissions that might be misused not be granted to the calling code. This action can only be used within the scope of the assembly.">Solicite que as permissões que podem ser usadas indevidamente não sejam concedidas ao código de chamada. Esta ação só pode ser usada no escopo do assembly.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary vsli:raw="The resource is not exported from the assembly.">O recurso não é exportado do assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary vsli:raw="The resource is exported from the assembly.">O recurso é exportado do assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary vsli:raw="Masks just the visibility-related attributes.">Oculta apenas os atributos relacionados à visibilidade.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary vsli:raw="Represents the shape of an array type.">Representa a forma de um tipo de matriz.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ArrayShape&quot; /&gt; structure.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.ArrayShape" />.</summary>
      <param name="rank" vsli:raw="The number of dimensions in the array.">O número de dimensões na matriz.</param>
      <param name="sizes" vsli:raw="The size of each dimension.">O tamanho de cada dimensão.</param>
      <param name="lowerBounds" vsli:raw="The lower-bound of each dimension.">O limite inferior de cada dimensão.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary vsli:raw="Gets the lower-bounds of all dimensions. Length may be smaller than rank, in which case the trailing dimensions have unspecified lower bounds.">Obtém o limite inferior de todas as dimensões. O tamanho pode ser menor que a classificação, quando então as dimensões à direita terão limites inferiores não especificados.</summary>
      <returns vsli:raw="An array of lower-bounds.">Uma matriz de limites inferiores.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary vsli:raw="Gets the number of dimensions in the array.">Obtém o número de dimensões na matriz.</summary>
      <returns vsli:raw="The number of dimensions.">O número de dimensões.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary vsli:raw="Gets the sizes of all dimensions.">Obtém os tamanhos de todas as dimensões.</summary>
      <returns vsli:raw="An array of sizes.">Uma matriz de tamanhos.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary vsli:raw="Gets a value that indicates whether the file contains metadata.">Obtém um valor que indica se o arquivo contém metadados.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the file contains metadata, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> Se o arquivo contiver metadados, <see langword="false" /> caso contrário.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary vsli:raw="Gets the hash value of the file content calculated using &lt;see cref=&quot;P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm&quot; /&gt;.">Obtém o valor de hash do arquivo de conteúdo calculado usando <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; instance representing the hash value of the file content.">Uma <see cref="T:System.Reflection.Metadata.BlobHandle" /> instância que representa o valor de hash do conteúdo do arquivo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary vsli:raw="Gets the file name, including its extension.">Obtém o nome de arquivo, incluindo sua extensão.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; instance representing the file name with its extension.">Uma <see cref="T:System.Reflection.Metadata.StringHandle" /> instância que representa o nome do arquivo com sua extensão.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;.">Representa uma coleção de <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary vsli:raw="A collection of assembly references.">Uma coleção de referências de assembly.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Compares the current content of this writer with another one.">Compara o conteúdo atual deste gravador com outro.</summary>
      <param name="other" vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; instance to compare with this one.">Uma instância de <see cref="T:System.Reflection.Metadata.BlobBuilder" /> a ser comparada com esta.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se for igual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary vsli:raw="Returns a sequence of all blobs that represent the content of the builder.">Retorna uma sequência de todos os blobs que representam o conteúdo do construtor.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
      <returns vsli:raw="A sequence of blobs.">Uma sequência de blobs.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;prefix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="prefix" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;suffix&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="suffix" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary vsli:raw="Reserves a contiguous block of bytes.">Reserva um bloco contíguo de bytes.</summary>
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available; the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Attempts to write a sequence of bytes to the builder. A return value indicates the number of bytes successfully written.">Tentativas de gravar uma sequência de bytes no construtor. Um valor retornado indica o número de bytes gravados com êxito.</summary>
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
      <returns vsli:raw="The number of bytes successfully written from &lt;paramref name=&quot;source&quot; /&gt;.">O número de bytes gravados com êxito do <paramref name="source" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; value to the builder.">Grava um valor <see cref="T:System.Boolean" /> no construtor.</summary>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Byte&quot; /&gt; value to the builder.">Grava um valor <see cref="T:System.Byte" /> no construtor.</summary>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes from a buffer to the builder.">Grava no construtor um número especificado de bytes de um buffer.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">O número de bytes a serem gravados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary vsli:raw="Writes a specified number of occurrences of a byte value to the builder.">Grava um número especificado de ocorrências de um valor de byte no construtor.</summary>
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of occurences of &lt;paramref name=&quot;value&quot; /&gt; to write.">O número de ocorrências de <paramref name="value" /> a serem gravadas.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary vsli:raw="Writes the contents of a byte array to the builder.">Grava o conteúdo de uma matriz de bytes no construtor.</summary>
      <param name="buffer" vsli:raw="The byte array to write.">A matriz de bytes para gravação.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index in a byte array to the builder.">Grava no construtor um número especificado de bytes, começando em um índice especificado em uma matriz de bytes.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">O número de bytes a serem gravados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of &lt;paramref name=&quot;buffer&quot; /&gt;.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Writes the contents of an immutable byte array to the builder.">Grava o conteúdo de uma matriz de bytes imutável no construtor.</summary>
      <param name="buffer" vsli:raw="The array to write.">A matriz a gravar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary vsli:raw="Writes a specified number of bytes starting at a specified index of an immutable array to the builder.">Grava no construtor um número especificado de bytes, começando em um índice especificado de uma matriz imutável.</summary>
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="The number of bytes to write.">O número de bytes a serem gravados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementa a codificação de inteiro não assinado compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> não pode ser representado como um inteiro sem sinal compactado.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementa a codificação de inteiro assinada compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value" vsli:raw="The value to write.">O valor a ser gravado.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> não pode ser representado como um inteiro com sinal compactado.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">Grava um valor constante (confira a seção 22.9, Partição II, do ECMA-335) na posição atual.</summary>
      <param name="value" vsli:raw="The constant value to write.">O valor constante a ser gravado.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> não é de um tipo de constante.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="destination" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is default (&lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt;).">
        <paramref name="destination" /> é o padrão (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Content is not available, the builder has been linked with another one.">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">Grava uma referência em um heap (deslocamento do heap) ou em uma tabela (número da linha).</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">Número do deslocamento ou da linha da tabela do heap.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as a 16-bit integer; &lt;see langword=&quot;false&quot; /&gt; to encode it as a 32-bit integer.">
        <see langword="true" /> para codificar a referência como um inteiro de 16 bits. <see langword="false" /> para codificá-la como um inteiro de 32 bits.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">Grava uma cadeia de caracteres no formato SerString (confira os Atributos personalizados do capítulo 23.3 do ECMA-335-II).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">Grava uma cadeia de caracteres no formato de heap de Cadeia de Caracteres do Usuário (#US) (confira Heaps #US e #Blob do capítulo 24.2.4 do ECMA-335-II).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded character array at the current position.">Grava uma matriz de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary vsli:raw="Writes UTF16 (little-endian) encoded string at the current position.">Grava uma cadeia de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">Grava uma cadeia de caracteres UTF8 codificada na posição atual.</summary>
      <param name="value" vsli:raw="Constant value.">Valor constante.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with a U+FFFD character.">
        <see langword="true" /> para codificar substitutos não emparelhados conforme o especificado. <see langword="false" /> para substituí-los por um caractere U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" vsli:raw="" />
      <param name="stamp" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a reader of the specified memory block.">Cria um leitor do bloco de memória especificado.</summary>
      <param name="buffer" vsli:raw="A pointer to the start of the memory block.">Um ponteiro para o início do bloco de memória.</param>
      <param name="length" vsli:raw="Length in bytes of the memory block.">O comprimento em bytes do bloco de memória.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; is greater than zero.">O <paramref name="buffer" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is negative.">
        <paramref name="length" /> é negativo.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is not little-endian.">A plataforma atual não é little endian.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary vsli:raw="Repositions the reader forward by the number of bytes required to satisfy the given alignment.">Reposiciona o leitor mais para frente considerando o número de bytes necessários para satisfazer o alinhamento especificado.</summary>
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary vsli:raw="Searches for a specified byte in the blob following the current position.">Pesquisa um byte especificado no blob após a posição atual.</summary>
      <param name="value" vsli:raw="The byte value to find.">O valor de byte a ser localizado.</param>
      <returns vsli:raw="The index relative to the current position, or -1 if the byte is not found in the blob following the current position.">O índice em relação à posição atual ou -1 se o byte não for encontrado no blob após a posição atual.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary vsli:raw="Reads a Blob heap handle encoded as a compressed integer.">Lê um identificador de heap de blob codificado como um inteiro compactado.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position.">Lê os bytes, começando na posição atual.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">O número de bytes a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
      <returns vsli:raw="The byte array.">A matriz de bytes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary vsli:raw="Reads bytes starting at the current position and writes them to the specified buffer starting at the specified offset.">Lê os bytes começando na posição atual e os grava no buffer especificado, começando no deslocamento especificado.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">O número de bytes a serem lidos.</param>
      <param name="buffer" vsli:raw="The destination buffer the bytes read will be written to.">O buffer de destino no qual os bytes lidos serão gravados.</param>
      <param name="bufferOffset" vsli:raw="The offset in the destination buffer where the bytes read will be written.">O deslocamento no buffer de destino no qual os bytes lidos serão gravados.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Lê um valor inteiro sem sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">Os dados na posição atual não eram um inteiro compactado válido.</exception>
      <returns vsli:raw="The value of the compressed integer that was read.">O valor do inteiro compactado que foi lido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Lê um valor inteiro com sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid compressed integer.">Os dados na posição atual não eram um inteiro compactado válido.</exception>
      <returns vsli:raw="The value of the compressed integer that was read.">O valor do inteiro compactado que foi lido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary vsli:raw="Reads a constant value (see ECMA-335 Partition II section 22.9) from the current position.">Lê um valor constante (confira a seção 22.9, Partição II, do ECMA-335) da posição atual.</summary>
      <param name="typeCode" vsli:raw="" />
      <exception cref="T:System.BadImageFormatException" vsli:raw="Error while reading from the blob.">Erro ao ler do blob.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;typeCode&quot; /&gt; is not a valid &lt;see cref=&quot;T:System.Reflection.Metadata.ConstantTypeCode&quot; /&gt;.">
        <paramref name="typeCode" /> não é um <see cref="T:System.Reflection.Metadata.ConstantTypeCode" /> válido.</exception>
      <returns vsli:raw="A boxed constant value. To avoid allocating the object use Read* methods directly.">Um valor constante demarcado. Para evitar a alocação dos métodos Read* de uso de objeto diretamente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">Lê um número <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data at the current position was not a valid &lt;see cref=&quot;T:System.Decimal&quot; /&gt; number.">Os dados na posição atual não eram um número <see cref="T:System.Decimal" /> válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary vsli:raw="Reads a type code encoded in a serialized custom attribute value.">Lê um código do tipo codificado em um valor de atributo personalizado serializado.</summary>
      <returns vsli:raw="&lt;see cref=&quot;F:System.Reflection.Metadata.SerializationTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" /> se a codificação for inválida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary vsli:raw="Reads a string encoded as a compressed integer containing its length followed by its contents in UTF8. Null strings are encoded as a single 0xFF byte.">Lê uma cadeia de caracteres codificada como um inteiro compactado que contém seu comprimento seguido por seu conteúdo em UTF8. As cadeias de caracteres nulas são codificadas como um único byte 0xFF.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The encoding is invalid.">A codificação é inválida.</exception>
      <returns vsli:raw="A string value, or &lt;see langword=&quot;null&quot; /&gt;.">Um valor de cadeia de caracteres ou <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary vsli:raw="Reads a type code encoded in a signature.">Lê um código de tipo codificado em uma assinatura.</summary>
      <returns vsli:raw="The type code encoded in the serialized custom attribute value if the encoding is valid, or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt; if the encoding is invalid.">O código de tipo codificado no valor do atributo personalizado serializado se a codificação for válida ou <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> se a codificação for inválida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary vsli:raw="Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).">Lê um identificador de tipo codificado em uma assinatura como TypeDefOrRefOrSpecEncoded (confira a seção II.23.2.8 do ECMA-335).</summary>
      <returns vsli:raw="The handle when the encoding is valid. Otherwise, a handle where the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">O identificador quando a codificação é válida. Caso contrário, um identificador no qual a propriedade <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> é <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary vsli:raw="Reads a UTF16 (little-endian) encoded string starting at the current position.">Lê uma cadeia de caracteres codificada em UTF16 (little endian) começando na posição atual.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">O número de bytes a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
      <returns vsli:raw="The string.">A cadeia de caracteres.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary vsli:raw="Reads a UTF8 encoded string starting at the current position.">Lê uma cadeia de caracteres codificada em UTF8 começando na posição atual.</summary>
      <param name="byteCount" vsli:raw="The number of bytes to read.">O número de bytes a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; bytes not available.">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
      <returns vsli:raw="The string.">A cadeia de caracteres.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary vsli:raw="Repositions the reader to the start of the underlying memory block.">Reposiciona o leitor no início do bloco de memória subjacente.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary vsli:raw="Reads an unsigned compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Lê um valor inteiro sem sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">O valor do inteiro compactado que foi lido.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">
        <see langword="true" /> se o valor foi lido com êxito. <see langword="false" /> se os dados na posição atual não eram um inteiro compactado válido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary vsli:raw="Reads a signed compressed integer value. See Metadata Specification section II.23.2: Blobs and signatures.">Lê um valor inteiro com sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <param name="value" vsli:raw="The value of the compressed integer that was read.">O valor do inteiro compactado que foi lido.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the value was read successfully. &lt;see langword=&quot;false&quot; /&gt; if the data at the current position was not a valid compressed integer.">
        <see langword="true" /> se o valor foi lido com êxito. <see langword="false" /> se os dados na posição atual não eram um inteiro compactado válido.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary vsli:raw="Gets a pointer to the byte at the current position of the reader.">Obtém um ponteiro para o byte na posição atual do leitor.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary vsli:raw="Gets the total length of the underlying memory block.">Obtém o comprimento total do bloco de memória subjacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary vsli:raw="Gets or sets the offset from the start of the blob to the current position.">Obtém ou define o deslocamento do início do blob até a posição atual.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The offset is set outside the bounds of the underlying reader.">O deslocamento é definido fora dos limites do leitor subjacente.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary vsli:raw="Gets the number of bytes remaining from current position to the end of the underlying memory block.">Obtém o número de bytes restantes da posição atual até o final do bloco de memória subjacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary vsli:raw="Gets a pointer to the byte at the start of the underlying memory block.">Obtém um ponteiro para o byte no início do bloco de memória subjacente.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="count" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary vsli:raw="Compares the current content of this writer with another one.">Compara o conteúdo atual deste gravador com outro.</summary>
      <param name="other" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the buffer content.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" vsli:raw="" />
      <param name="start" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;buffer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Range specified by &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;byteCount&quot; /&gt; falls outside of the bounds of the &lt;paramref name=&quot;buffer&quot; /&gt;.">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" vsli:raw="" />
      <param name="byteCount" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="source" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementa a codificação de inteiro não assinado compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed unsigned integer.">
        <paramref name="value" /> não pode ser representado como um inteiro sem sinal compactado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary vsli:raw="Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.">Implementa a codificação de inteiro assinada compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; can't be represented as a compressed signed integer.">
        <paramref name="value" /> não pode ser representado como um inteiro com sinal compactado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary vsli:raw="Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.">Grava um valor constante (confira a seção 22.9, Partição II, do ECMA-335) na posição atual.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is not of a constant type.">
        <paramref name="value" /> não é de um tipo de constante.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary vsli:raw="Writes a reference to a heap (heap offset) or a table (row number).">Grava uma referência em um heap (deslocamento do heap) ou em uma tabela (número da linha).</summary>
      <param name="reference" vsli:raw="Heap offset or table row number.">Número do deslocamento ou da linha da tabela do heap.</param>
      <param name="isSmall" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the reference as 16-bit integer, &lt;see langword=&quot;false&quot; /&gt; to encode as 32-bit integer.">
        <see langword="true" /> para codificar a referência como inteiro de 16 bits, <see langword="false" /> para codificar como inteiro de 32 bits.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary vsli:raw="Writes a string in SerString format (see ECMA-335-II 23.3 Custom attributes).">Grava uma cadeia de caracteres no formato SerString (confira os Atributos personalizados do capítulo 23.3 do ECMA-335-II).</summary>
      <param name="str" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="The builder is not writable; it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary vsli:raw="Writes a string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps).">Grava uma cadeia de caracteres no formato de heap de Cadeia de Caracteres do Usuário (#US) (confira Heaps #US e #Blob do capítulo 24.2.4 do ECMA-335-II).</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.InvalidOperationException" vsli:raw="Builder is not writable, it has been linked with another one.">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">Grava uma cadeia de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary vsli:raw="Writes a UTF16 (little-endian) encoded string at the current position.">Grava uma cadeia de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Writes a UTF8 encoded string at the current position.">Grava uma cadeia de caracteres UTF8 codificada na posição atual.</summary>
      <param name="value" vsli:raw="" />
      <param name="allowUnpairedSurrogates" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary vsli:raw="Gets the parent handle (&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;).">Obtém o identificador pai (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary vsli:raw="Gets a type code that identifies the type of the constant value.">Obtém um código de tipo que identifica o tipo do valor constante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary vsli:raw="Gets the constant value.">Obtém o valor da constante.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary vsli:raw="Specifies values that represent types of metadata constants.">Especifica os valores que representam tipos de constantes de metadados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary vsli:raw="A Boolean type.">Um tipo booleano.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer.">Um inteiro de 1 byte sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary vsli:raw="A character type.">Um tipo de caractere.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">Um tipo de ponto flutuante de 8 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">Um tipo de inteiro de 2 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">Um tipo de inteiro de 4 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">Um tipo de inteiro de 8 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary vsli:raw="An invalid type.">Um tipo inválido.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary vsli:raw="A null reference.">Uma referência nula.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">Um tipo de inteiro de 1 byte com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">Um tipo de ponto flutuante de 4 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Um tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">Um tipo de inteiro de 2 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">Um tipo de inteiro de 4 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">Um tipo de inteiro de 8 bytes sem sinal.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary vsli:raw="Decodes the arguments encoded in the value blob.">Decodifica os argumentos codificados no blob de valor.</summary>
      <param name="provider" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary vsli:raw="Gets the constructor (the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;) of the custom attribute type.">Obtém o construtor (o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) do tipo de atributo personalizado.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary vsli:raw="Gets the handle of the metadata entity the attribute is applied to.">Obtém o identificador da entidade de metadados à qual o atributo é aplicado.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary vsli:raw="Gets the value of the attribute.">Obtém o valor do atributo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary vsli:raw="Represents a named argument decoded from a custom attribute signature.">Representa um argumento nomeado decodificado de uma assinatura de atributo personalizado.</summary>
      <typeparam name="TType" vsli:raw="The type used to represent types of values decoded from the custom attribute signature.">O tipo usado para representar tipos de valores decodificados da assinatura de atributo personalizado.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeNamedArgument`1&quot; /&gt; structure using the specified name, kind, type, and value.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> usando o nome, tipo e valor especificados.</summary>
      <param name="name" vsli:raw="The name of the argument.">O nome do argumento.</param>
      <param name="kind" vsli:raw="The kind of the argument.">A variante do argumento.</param>
      <param name="type" vsli:raw="The type of the argument.">O tipo do argumento.</param>
      <param name="value" vsli:raw="The value of the argument.">O valor do argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary vsli:raw="Gets the kind of argument.">Obtém o tipo de argumento.</summary>
      <returns vsli:raw="The argument kind.">O tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary vsli:raw="Gets the name of the argument.">Obtém o nome do argumento.</summary>
      <returns vsli:raw="The argument name.">O nome do argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">Obtém o tipo do argumento.</summary>
      <returns vsli:raw="The argument type.">O tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">Obtém o valor do argumento.</summary>
      <returns vsli:raw="An object containing the argument value.">Um objeto que contém o valor do argumento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary vsli:raw="Specifies constants that define the kinds of arguments in a custom attribute signature.">Especifica constantes que definem os tipos de argumentos em uma assinatura de atributo personalizado.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary vsli:raw="A field argument.">Um argumento de campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary vsli:raw="A property argument.">Um argumento de propriedade.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary vsli:raw="Represents a typed argument for a custom metadata attribute.">Representa um argumento de tipo para um atributo de metadados personalizados.</summary>
      <typeparam name="TType" vsli:raw="The type of the argument.">O tipo do argumento.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeTypedArgument`1&quot; /&gt; structure using the specified argument type and value.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> usando o tipo e o valor do argumento especificado.</summary>
      <param name="type" vsli:raw="The type of the argument.">O tipo do argumento.</param>
      <param name="value" vsli:raw="The argument value.">O valor do argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary vsli:raw="Gets the type of the argument.">Obtém o tipo do argumento.</summary>
      <returns vsli:raw="The argument type.">O tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary vsli:raw="Gets the value of the argument.">Obtém o valor do argumento.</summary>
      <returns vsli:raw="The argument value.">O valor do argumento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary vsli:raw="Represents a custom attribute of the type specified by &lt;paramref name=&quot;TType&quot; /&gt;.">Representa um atributo personalizado do tipo especificado pelo <paramref name="TType" />.</summary>
      <typeparam name="TType" vsli:raw="The attribute type.">O tipo de atributo.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; structure using the specified fixed arguments and named arguments.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> usando os argumentos fixos e nomeados especificados.</summary>
      <param name="fixedArguments" vsli:raw="The fixed arguments.">Os argumentos fixos.</param>
      <param name="namedArguments" vsli:raw="The named arguments.">Os argumentos nomeados.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary vsli:raw="Gets the fixed arguments for the custom attribute.">Obtém os argumentos fixos para o atributo personalizado.</summary>
      <returns vsli:raw="An immutable array of arguments.">Uma matriz imutável de argumentos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary vsli:raw="Gets the named arguments for the custom attribute value.">Obtém os argumentos nomeados para o valor de atributo personalizado.</summary>
      <returns vsli:raw="An immutable array of arguments.">Uma matriz imutável de argumentos.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the metadata blob to the start of the &lt;see cref=&quot;P:System.Reflection.Metadata.DebugMetadataHeader.Id&quot; /&gt; blob.">Obtém o deslocamento (em bytes) do início do blob de metadados ao início do blob <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary vsli:raw="The source document in the debug metadata.">O documento de origem nos metadados de depuração.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary vsli:raw="Gets the document content hash.">Obtém o hash de conteúdo do documento.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary vsli:raw="Gets the hash algorithm used to calculate the &lt;see cref=&quot;P:System.Reflection.Metadata.Document.Hash&quot; /&gt; (SHA1, SHA256, etc.).">Obtém o algoritmo de hash usado para calcular o <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary vsli:raw="Gets the source code language (C#, VB, F#, etc.).">Obtém a linguagem do código-fonte (C#, VB, F#, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary vsli:raw="Gets the document name blob.">Obtém o blob de nome do documento.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.BlobHandle&quot; /&gt; representing a blob on #Blob heap in Portable PDB structured as Document Name.">Um <see cref="T:System.Reflection.Metadata.BlobHandle" /> que representa um blob no heap de #Blob no PDB portátil estruturado como Nome do Documento.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary vsli:raw="Encodes array shape.">Codifica a forma da matriz.</summary>
      <param name="rank" vsli:raw="The number of dimensions in the array (shall be 1 or more).">O número de dimensões na matriz (deverá ser 1 ou mais).</param>
      <param name="sizes" vsli:raw="Dimension sizes. The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer.">Tamanhos da dimensão. A matriz pode ser menor que <paramref name="rank" />, mas não maior.</param>
      <param name="lowerBounds" vsli:raw="Dimension lower bounds, or default(&lt;see cref=&quot;T:System.Collections.Immutable.ImmutableArray`1&quot; /&gt;) to set all &lt;paramref name=&quot;rank&quot; /&gt; lower bounds to 0.&#xA; The array may be shorter than &lt;paramref name=&quot;rank&quot; /&gt; but not longer.">Limites inferiores da dimensão ou default(<see cref="T:System.Collections.Immutable.ImmutableArray`1" />) para definir todos os limites inferiores a 0 do <paramref name="rank" />.
A matriz pode ser menor que <paramref name="rank" />, mas não maior.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;rank&quot; /&gt; is outside of range [1, 0xffff], smaller than &lt;see langword=&quot;sizes.Length&quot; /&gt;, or smaller than &lt;see langword=&quot;lowerBounds.Length&quot; /&gt;.">
        <paramref name="rank" /> está fora do intervalo [1, 0xffff], é menor que <see langword="sizes.Length" /> ou que <see langword="lowerBounds.Length" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;sizes&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="sizes" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary vsli:raw="Encodes custom attribute signature blob.">Codifica um blob de assinatura de atributo personalizado.</summary>
      <param name="fixedArguments" vsli:raw="Called first, to encode fixed arguments.">Chamado primeiro, para codificar argumentos fixos.</param>
      <param name="namedArguments" vsli:raw="Called second, to encode named arguments.">Chamado em segundo lugar, para codificar argumentos nomeados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;fixedArguments&quot; /&gt; or &lt;paramref name=&quot;namedArguments&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="fixedArguments" /> ou <paramref name="namedArguments" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary vsli:raw="Encodes custom attribute signature blob.&#xA; Returns a pair of encoders that must be used in the order they appear in the parameter list.">Codifica um blob de assinatura de atributo personalizado.
Retorna um par de codificadores que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="fixedArguments" vsli:raw="Use first, to encode fixed arguments.">Use em primeiro lugar, para codificar argumentos fixos.</param>
      <param name="namedArguments" vsli:raw="Use second, to encode named arguments.">Use em segundo lugar, para codificar argumentos nomeados.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary vsli:raw="Encodes field signature blob.">Codifica o blob de assinatura de campo.</summary>
      <returns vsli:raw="Encoder of the field type.">Codificador do tipo de campo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary vsli:raw="Encodes local variable signature.">Codifica uma assinatura da variável local.</summary>
      <param name="variableCount" vsli:raw="Number of local variables.">Número de variáveis locais.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;variableCount&quot; /&gt; is not in range [0, 0x1fffffff].">
        <paramref name="variableCount" /> não está no intervalo [0, 0x1fffffff].</exception>
      <returns vsli:raw="Encoder of a sequence of local variables.">Codificador de uma sequência de variáveis locais.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary vsli:raw="Encodes method signature blob.">Codifica o blob de assinatura de método.</summary>
      <param name="convention" vsli:raw="Calling convention.">Convenção de chamada.</param>
      <param name="genericParameterCount" vsli:raw="Number of generic parameters.">Número de parâmetros genéricos.</param>
      <param name="isInstanceMethod" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance method signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static method signature.">
        <see langword="true" /> para codificar uma assinatura de método de instância, <see langword="false" /> para codificar uma assinatura de método estático.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericParameterCount&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="genericParameterCount" /> não está no intervalo [0, 0xffff].</exception>
      <returns vsli:raw="An encoder of the rest of the signature including return value and parameters.">Um codificador do restante da assinatura, incluindo o valor retornado e os parâmetros.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary vsli:raw="Encodes method specification signature blob.">Codifica um blob de assinatura de especificação de método.</summary>
      <param name="genericArgumentCount" vsli:raw="Number of generic arguments.">Número de argumentos genéricos.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericArgumentCount&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="genericArgumentCount" /> não está no intervalo [0, 0xffff].</exception>
      <returns vsli:raw="Encoder of generic arguments.">Codificador de argumentos genéricos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary vsli:raw="Encodes permission set arguments.">Codifica argumentos do conjunto de permissões.</summary>
      <param name="argumentCount" vsli:raw="Number of arguments in the set.">Número de argumentos no conjunto.</param>
      <returns vsli:raw="Encoder of the arguments of the set.">Codificador dos argumentos do conjunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary vsli:raw="Encodes a permission set blob.">Codifica um blob do conjunto de permissões.</summary>
      <param name="attributeCount" vsli:raw="Number of attributes in the set.">Número de atributos no conjunto.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;attributeCount&quot; /&gt; is not in range [0, 0x1fffffff].">
        <paramref name="attributeCount" /> não está no intervalo [0, 0x1fffffff].</exception>
      <returns vsli:raw="Permission set encoder.">Codificador do conjunto de permissões.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary vsli:raw="Encodes property signature blob.">Codifica o blob de assinatura de propriedade.</summary>
      <param name="isInstanceProperty" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode an instance property signature, &lt;see langword=&quot;false&quot; /&gt; to encode a static property signature.">
        <see langword="true" /> para codificar uma assinatura de propriedade de instância, <see langword="false" /> para codificar uma assinatura de propriedade estática.</param>
      <returns vsli:raw="An encoder of the rest of the signature including return value and parameters, which has the same structure as method signature.">Um codificador do restante da assinatura, incluindo o valor retornado e os parâmetros, que tem a mesma estrutura que a assinatura de método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary vsli:raw="Encodes type specification signature.">Codifica a assinatura de especificação de tipo.</summary>
      <returns vsli:raw="Type encoder of the structured type represented by the type specification (it shall not encode a primitive type).">O codificador de tipo do tipo estruturado representado pela especificação de tipo (ele não deverá codificar um tipo primitivo).</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a CustomAttributeType coded index for the specified handle.">Calcula um índice codificado CustomAttributeType para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasConstant coded index for the specified handle.">Calcula um índice codificado HasConstant para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasCustomAttribute coded index for the specified handle.">Calcula um índice codificado HasCustomAttribute para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasCustomDebugInformation coded index for the specified handle.">Calcula um índice codificado HasCustomDebugInformation para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> ou <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasDeclSecurity coded index for the specified handle.">Calcula um índice codificado HasDeclSecurity para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasFieldMarshal coded index for the specified handle.">Calcula um índice codificado HasFieldMarshal para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> ou <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a HasSemantics coded index for the specified handle.">Calcula um índice codificado HasSemantics para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates an implementation coded index for the specified handle.">Calcula uma implementação codificada para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a MemberForwarded coded index for the specified handle.">Calcula um índice codificado MemberForwarded para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinition&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a MemberRefParent coded index for the specified handle.">Calcula um índice codificado MemberRefParent para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a MethodDefOrRef coded index for the specified handle.">Calcula um índice codificado MethodDefOrRef para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a ResolutionScope coded index for the specified handle.">Calcula um índice codificado ResolutionScope para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a TypeDefOrRef coded index for the specified handle.">Calcula um índice codificado TypeDefOrRef para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a TypeDefOrRefOrSpec coded index for the specified handle.">Calcula um índice codificado TypeDefOrRefOrSpec para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Calculates a TypeOrMethodDef coded index for the specified handle.">Calcula um índice codificado TypeOrMethodDef para o manipulador especificado.</summary>
      <param name="handle" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException" vsli:raw="The handle type is unexpected.">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds catch region.">Adiciona a região catch.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <param name="catchType" vsli:raw="The type of exception to be caught: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">O tipo de exceção a ser detectado: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;catchType&quot; /&gt; is not a valid type handle.">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.

- ou -

<paramref name="catchType" /> não é um identificador de tipo válido.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Adds fault region.">Adiciona a região fault.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Adds catch region.">Adiciona a região catch.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <param name="filterStart" vsli:raw="Label marking the first instruction of the filter block.">Rótulo que marca a primeira instrução do bloco filter.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Adds finally region.">Adiciona a região finally.</summary>
      <param name="tryStart" vsli:raw="Label marking the first instruction of the try block.">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd" vsli:raw="Label marking the instruction immediately following the try block.">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart" vsli:raw="Label marking the first instruction of the handler.">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd" vsli:raw="Label marking the instruction immediately following the handler.">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="A label was not defined by an instruction encoder this builder is associated with.">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="A label has default value.">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary vsli:raw="Encodes a custom modifier.">Codifica um modificador personalizado.</summary>
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="isOptional" vsli:raw="Is optional modifier.">É modificador opcional.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt; or of an unexpected kind.">
        <paramref name="type" /> é <see langword="null" /> ou de um tipo inesperado.</exception>
      <returns vsli:raw="Encoder of subsequent modifiers.">Codificador de modificadores subsequentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" vsli:raw="" />
      <param name="operation" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary vsli:raw="Adds an exception clause.">Adiciona uma cláusula de exceção.</summary>
      <param name="kind" vsli:raw="Clause kind.">Tipo de cláusula.</param>
      <param name="tryOffset" vsli:raw="Try block start offset.">Deslocamento inicial do bloco try.</param>
      <param name="tryLength" vsli:raw="Try block length.">Comprimento do bloco try.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Comprimento do manipulador.</param>
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or nil if &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Catch&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> ou nil se <paramref name="kind" /> não for <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" /></param>
      <param name="filterOffset" vsli:raw="Offset of the filter block, or 0 if the &lt;paramref name=&quot;kind&quot; /&gt; is not &lt;see cref=&quot;F:System.Reflection.Metadata.ExceptionRegionKind.Filter&quot; /&gt;.">Deslocamento do bloco filter ou 0 se o <paramref name="kind" /> não for <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;catchType&quot; /&gt; is invalid.">
        <paramref name="catchType" /> é inválido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;kind&quot; /&gt; has an invalid value.&#xA;          &#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt;, or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="kind" /> tem um valor inválido.
          
- ou -

<paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns vsli:raw="Encoder for the next clause.">Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds a fault clause.">Adiciona uma cláusula fault.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Deslocamento inicial do bloco try.</param>
      <param name="tryLength" vsli:raw="Try block length.">Comprimento do bloco try.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Comprimento do manipulador.</param>
      <param name="catchType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;catchType&quot; /&gt; is invalid.">
        <paramref name="catchType" /> é inválido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns vsli:raw="Encoder for the next clause.">Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Adds a fault clause.">Adiciona uma cláusula fault.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Deslocamento inicial do bloco try.</param>
      <param name="tryLength" vsli:raw="Try block length.">Comprimento do bloco try.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Comprimento do manipulador.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns vsli:raw="Encoder for the next clause.">Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Adds a fault clause.">Adiciona uma cláusula fault.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Deslocamento inicial do bloco try.</param>
      <param name="tryLength" vsli:raw="Try block length.">Comprimento do bloco try.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Comprimento do manipulador.</param>
      <param name="filterOffset" vsli:raw="Offset of the filter block.">Deslocamento do bloco filter.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns vsli:raw="Encoder for the next clause.">Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Adds a finally clause.">Adiciona uma cláusula finally.</summary>
      <param name="tryOffset" vsli:raw="Try block start offset.">Deslocamento inicial do bloco try.</param>
      <param name="tryLength" vsli:raw="Try block length.">Comprimento do bloco try.</param>
      <param name="handlerOffset" vsli:raw="Handler start offset.">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength" vsli:raw="Handler length.">Comprimento do manipulador.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tryOffset&quot; /&gt;, &lt;paramref name=&quot;tryLength&quot; /&gt;, &lt;paramref name=&quot;handlerOffset&quot; /&gt; or &lt;paramref name=&quot;handlerLength&quot; /&gt; is out of range.">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="Method body was not declared to have exception regions.">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns vsli:raw="Encoder for the next clause.">Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the region fits small format.">Retornará <see langword="true" /> se a região se ajustar a um formato pequeno.</summary>
      <param name="startOffset" vsli:raw="Start offset of the region.">Deslocamento inicial da região.</param>
      <param name="length" vsli:raw="Length of the region.">Comprimento da região.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the number of exception regions first small format.">Retornará <see langword="true" /> se o número de regiões de exceção se ajustar a um formato pequeno.</summary>
      <param name="exceptionRegionCount" vsli:raw="Number of exception regions.">O número de regiões de exceção.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary vsli:raw="The underlying builder.">O construtor subjacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the encoder uses small format.">
        <see langword="true" /> se o codificador usar um formato pequeno.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary vsli:raw="Provides an extension method to access the TypeDefinitionId column of the ExportedType table.">Fornece um método de extensão para acessar a coluna TypeDefinitionId da tabela ExportedType.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary vsli:raw="Gets a hint at the likely row number of the target type in the TypeDef table of its module.&#xA; If the namespaces and names do not match, resolution falls back to a full search of the target TypeDef table. Ignored and should be zero if &lt;see cref=&quot;P:System.Reflection.Metadata.ExportedType.IsForwarder&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.">Obtém uma dica do número de linha provável do tipo de destino na tabela TypeDef de módulo dele.
Se os namespaces e os nomes não coincidirem, a resolução fará fallback para uma pesquisa completa da tabela TypeDef de destino. Ignorado e deverá ser zero se <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> for <see langword="true" />.</summary>
      <param name="exportedType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary vsli:raw="Encodes Common Intermediate Language (CIL) instructions.">Codifica instruções.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary vsli:raw="Creates an encoder backed by code and control-flow builders.">Cria um codificador com suporte de construtores de código e de fluxo de controle.</summary>
      <param name="codeBuilder" vsli:raw="Builder to write encoded instructions to.">Construtor no qual gravar instruções codificadas.</param>
      <param name="controlFlowBuilder" vsli:raw="Builder tracking labels, branches and exception handlers.&#xA; Must be specified to be able to use some of the control-flow factory methods of &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.InstructionEncoder&quot; /&gt;, such as &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel&quot; /&gt;, &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)&quot; /&gt; etc.">Rótulos de acompanhamento, branches e de manipuladores de exceção do construtor.
Deve ser especificado para poder usar alguns dos métodos de fábrica de fluxo de controle de <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />, como <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /> etc.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Encodes a branch instruction.">Codifica uma instrução branch.</summary>
      <param name="code" vsli:raw="Branch instruction to encode.">Instrução branch a ser codificada.</param>
      <param name="label" vsli:raw="Label of the target location in instruction stream.">Rótulo do local de destino no fluxo de instrução.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;code&quot; /&gt; is not a branch instruction.&#xA;&#xA;-or-&#xA;                    &#xA;&lt;paramref name=&quot;label&quot; /&gt; was not defined by this encoder.">
        <paramref name="code" /> não é uma instrução de branch.

- ou - 
<paramref name="label" /> não foi definido por este codificador.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;label&quot; /&gt; has default value.">
        <paramref name="label" /> tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;call&lt;/c&gt; instruction and its operand.">Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;calli&lt;/c&gt; instruction and its operand.">Codifica a instrução <c>calli</c> e o operando dela.</summary>
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary vsli:raw="Defines a label that can later be used to mark and refer to a location in the instruction stream.">Define um rótulo que pode ser usado posteriormente para marcar e se referir a um local no fluxo de instrução.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> é <see langword="null" />.</exception>
      <returns vsli:raw="Label handle.">Manipulador de rótulo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary vsli:raw="Encodes argument load instruction.">Codifica a instrução load do argumento.</summary>
      <param name="argumentIndex" vsli:raw="Index of the argument.">Índice do argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;argumentIndex&quot; /&gt; is negative.">
        <paramref name="argumentIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary vsli:raw="Encodes argument address load instruction.">Codifica a instrução load do endereço do argumento.</summary>
      <param name="argumentIndex" vsli:raw="Index of the argument.">Índice do argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;argumentIndex&quot; /&gt; is negative.">
        <paramref name="argumentIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Int32&quot; /&gt; constant load instruction.">Codifica a instrução constant load <see cref="T:System.Int32" />.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Int64&quot; /&gt; constant load instruction.">Codifica a instrução constant load <see cref="T:System.Int64" />.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Single&quot; /&gt; constant load instruction.">Codifica a instrução constant load <see cref="T:System.Single" />.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary vsli:raw="Encodes &lt;see cref=&quot;T:System.Double&quot; /&gt; constant load instruction.">Codifica a instrução constant load <see cref="T:System.Double" />.</summary>
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary vsli:raw="Encodes local variable load instruction.">Codifica a instrução load variable local.</summary>
      <param name="slotIndex" vsli:raw="Index of the local variable slot.">Índice do slot variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;slotIndex&quot; /&gt; is negative.">
        <paramref name="slotIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary vsli:raw="Encodes local variable address load instruction.">Codifica a instrução variable address load local.</summary>
      <param name="slotIndex" vsli:raw="Index of the local variable slot.">Índice do slot variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;slotIndex&quot; /&gt; is negative.">
        <paramref name="slotIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Encodes &lt;c&gt;ldstr&lt;/c&gt; instruction and its operand.">Codifica a instrução <c>ldstr</c> e o operando dela.</summary>
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Associates specified label with the current IL offset.">Associa o rótulo especificado ao deslocamento de IL atual.</summary>
      <param name="label" vsli:raw="Label to mark.">Rótulo a ser marcado.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;label&quot; /&gt; was not defined by this encoder.">
        <paramref name="label" /> não foi definido por este codificador.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;label&quot; /&gt; has default value.">
        <paramref name="label" /> tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Encodes specified op-code.">Codifica o código op especificado.</summary>
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary vsli:raw="Encodes argument store instruction.">Codifica a instrução argument store.</summary>
      <param name="argumentIndex" vsli:raw="Index of the argument.">Índice do argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;argumentIndex&quot; /&gt; is negative.">
        <paramref name="argumentIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary vsli:raw="Encodes local variable store instruction.">Codifica a instrução variable store local.</summary>
      <param name="slotIndex" vsli:raw="Index of the local variable slot.">Índice do slot variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;slotIndex&quot; /&gt; is negative.">
        <paramref name="slotIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary vsli:raw="Encodes a token.">Codifica um token.</summary>
      <param name="token" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Encodes a token.">Codifica um token.</summary>
      <param name="handle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary vsli:raw="Underlying builder where encoded instructions are written to.">Construtor subjacente no qual as instruções codificadas são gravadas.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary vsli:raw="Builder tracking labels, branches and exception handlers.">Rótulos de acompanhamento, branches e de manipuladores de exceção do construtor.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary vsli:raw="Offset of the next encoded instruction.">Deslocamento da próxima instrução codificada.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary vsli:raw="1-based id identifying the label within the context of a &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder&quot; /&gt;.">ID de base 1 que identifica o rótulo dentro do contexto de um <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary vsli:raw="Provides methods for encoding literals.">Fornece métodos para codificação de literais.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="Creates a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.LiteralEncoder&quot; /&gt; class with the specified blob builder.">Cria uma instância da classe <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> com o construtor de blobs especificado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary vsli:raw="Returns the encoder used to encode the literal value.">Retorna o codificador usado para codificar o valor da literal.</summary>
      <returns vsli:raw="The encoder of the literal value.">O codificador do valor da literal.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary vsli:raw="Encodes the type and the value of a literal using the specified delegates.">Codifica o tipo e o valor de uma literal usando os delegados especificados.</summary>
      <param name="type" vsli:raw="A delegate used to encode the type of the literal. Called first by this method.">Um delegado usado para codificar o tipo da literal. Chamado primeiro por esse método.</param>
      <param name="scalar" vsli:raw="A delegate used to encode the value of the literal. Called second by this method.">Um delegado usado para codificar o valor da literal. Chamado em segundo lugar por esse método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; or &lt;paramref name=&quot;scalar&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" /> ou <paramref name="scalar" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and value of a literal in the order they appear in the parameter list.">Retorna um par de codificadores que devem ser usados para codificar o tipo e o valor de uma literal na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="type" vsli:raw="When this method returns, a custom attribute element type encoder used to encode the type of the literal.">Quando esse método é retornado, um codificador de tipo de elemento de atributo personalizado usado para codificar o tipo da literal.</param>
      <param name="scalar" vsli:raw="When this method returns, a scalar encoded used to encode the value of the literal.">Quando esse método é retornado, um escalar codificado usado para codificar o valor da literal.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary vsli:raw="Encodes the type and the items of a vector literal using the specified delegates.">Codifica o tipo e os itens de uma literal de vetor usando os delegados especificados.</summary>
      <param name="arrayType" vsli:raw="A delegate used to encode the type of the vector. Called first by this method.">Um delegado usado para codificar o tipo do vetor. Chamado primeiro por esse método.</param>
      <param name="vector" vsli:raw="A delegate used to encode the items of the vector. Called second by this method.">Um delegado usado para codificar os itens do vetor. Chamado em segundo lugar por esse método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;arrayType&quot; /&gt; or &lt;paramref name=&quot;vector&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="arrayType" /> ou <paramref name="vector" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary vsli:raw="Returns a pair of encoders that must be used to encode the type and the items of a vector literal in the order they appear in the parameter list.">Retorna um par de codificadores que devem ser usados para codificar o tipo e os itens de uma literal de vetor na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="arrayType" vsli:raw="When this method returns, a custom attribute array type encoder used to encode the type of the vector.">Quando esse método é retornado, um codificador de tipo de matriz de atributo personalizado usado para codificar o tipo do vetor.</param>
      <param name="vector" vsli:raw="When this method returns, a vector encoder used to encode the items of the vector.">Quando esse método é retornado, um codificador de vetor usado para codificar os itens do vetor.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary vsli:raw="Gets a vector encoder used to encode the items of a vector.">Obtém um codificador de vetor usado para codificar os itens de um vetor.</summary>
      <returns vsli:raw="A vector encoder used to encode the items of a vector.">Um codificador de vetor usado para codificar os itens de um vetor.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" vsli:raw="" />
      <param name="isPinned" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" vsli:raw="" />
      <param name="baseHeapSizes" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" vsli:raw="" />
      <param name="deltaReaders" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary vsli:raw="Calculates the handle of the entity within the metadata generation it is defined in, given a handle of an entity in an aggregate metadata.">Calcula o identificador da entidade dentro da geração de metadados em que ela está definida, considerando o identificador de uma entidade em metadados de agregação.</summary>
      <param name="handle" vsli:raw="Handle of an entity in an aggregate metadata.">Identificador de uma entidade em metadados de agregação.</param>
      <param name="generation" vsli:raw="The generation the entity is defined in.">A geração em que a entidade está definida.</param>
      <returns vsli:raw="Handle of the entity within the metadata &lt;paramref name=&quot;generation&quot; /&gt;.">Identificador da entidade dentro dos metadados <paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary vsli:raw="The MetadataBuilder class writes metadata for an assembly in a highly performant manner. It is designed for use by compilers and other assembly generation tools.">A classe MetadataBuilder lê e grava metadados para um assembly de uma maneira que proporciona alto desempenho. Ele foi projetado para ser usado por compiladores e outras ferramentas de geração de assembly.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a builder for metadata tables and heaps.">Cria um construtor para heaps e tabelas de metadados.</summary>
      <param name="userStringHeapStartOffset" vsli:raw="The start offset of the User String heap. The cumulative size of User String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">O deslocamento inicial do heap de cadeias de caracteres do usuário. O tamanho cumulativo de heaps de cadeias de caracteres do usuário de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <param name="stringHeapStartOffset" vsli:raw="The start offset of the String heap. The cumulative size of String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">O deslocamento inicial do heap de cadeias de caracteres. O tamanho cumulativo de heaps de cadeias de caracteres de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <param name="blobHeapStartOffset" vsli:raw="The start offset of the Blob heap. The cumulative size of Blob heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">O deslocamento inicial do heap de blobs. O tamanho cumulativo de heaps de blobs de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <param name="guidHeapStartOffset" vsli:raw="The start offset of the Guid heap. The cumulative size of Guid heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.">O deslocamento inicial do heap de GUIDs. O tamanho cumulativo de heaps de GUIDs de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="Offset is too big.">O deslocamento é muito grande.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Offset is negative.">O deslocamento é negativo.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;guidHeapStartOffset&quot; /&gt; is not a multiple of size of GUID.">
        <paramref name="guidHeapStartOffset" /> não é um múltiplo do tamanho de GUID.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKey" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashAlgorithm" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
      <param name="containsMetadata" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" vsli:raw="" />
      <param name="version" vsli:raw="" />
      <param name="culture" vsli:raw="" />
      <param name="publicKeyOrToken" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="hashValue" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary vsli:raw="Adds a default value for a parameter, field or property.">Adiciona um valor padrão para um parâmetro, campo ou propriedade.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">O identificador de entidade pai, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value" vsli:raw="The constant value.">O valor da constante.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added constant.">Um identificador para a constante adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a custom attribute.">Adiciona um atributo personalizado.</summary>
      <param name="parent" vsli:raw="An entity to attach the custom attribute to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;.">Uma entidade à qual anexar o atributo personalizado: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor" vsli:raw="A custom attribute constructor: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">Um construtor de atributo personalizado: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value" vsli:raw="A custom attribute value blob.">Um blob de valor de atributo personalizado.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added custom attribute.">Um identificador para o atributo personalizado adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds custom debug information.">Adiciona informações de depuração personalizadas.</summary>
      <param name="parent" vsli:raw="An entity to attach the debug information to: a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.InterfaceImplementationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignatureHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterConstraintHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.DocumentHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalScopeHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalVariableHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.LocalConstantHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.ImportScopeHandle&quot; /&gt;.">Uma entidade à qual anexar as informações de depuração: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> ou <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind" vsli:raw="The information kind. Determines the structure of the &lt;paramref name=&quot;value&quot; /&gt; blob.">O tipo das informações. Determina a estrutura do blob de <paramref name="value" />.</param>
      <param name="value" vsli:raw="The custom debug information blob.">O blob de informações de depuração personalizadas.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added custom debug information.">Um identificador para as informações de depuração personalizadas adicionadas.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a declarative security attribute to a type, method, or assembly.">Adiciona um atributo de segurança declarativa a um tipo, um método ou um assembly.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or a &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyDefinitionHandle&quot; /&gt;.">O identificador de entidade pai, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action" vsli:raw="A declarative security action.">Uma ação de segurança declarativa.</param>
      <param name="permissionSet" vsli:raw="The permission set blob.">O blob de conjunto de permissões.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added declarative security attribute.">Um identificador para o atributo de segurança declarativa adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Adds document debug information.">Adiciona informações de depuração do documento.</summary>
      <param name="name" vsli:raw="The document name blob.">O blob de nome do documento.</param>
      <param name="hashAlgorithm" vsli:raw="THe GUID of the hash algorithm used to calculate the value of &lt;paramref name=&quot;hash&quot; /&gt;.">O GUID do algoritmo de hash usado para calcular o valor de <paramref name="hash" />.</param>
      <param name="hash" vsli:raw="The hash of the document content.">O hash do conteúdo do documento.</param>
      <param name="language" vsli:raw="The GUID of the language.">O GUID da linguagem de programação.</param>
      <returns vsli:raw="A handle to the added document.">Um identificador para o documento adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" vsli:raw="" />
      <param name="code" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an event definition.">Adiciona uma definição de evento.</summary>
      <param name="attributes" vsli:raw="The event attributes.">Os atributos do evento.</param>
      <param name="name" vsli:raw="The event name.">O nome do evento.</param>
      <param name="type" vsli:raw="The type of the event: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">O tipo do evento: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="type" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added event definition.">Um identificador para a definição de evento adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="eventList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary vsli:raw="Adds an exported type.">Adiciona um tipo exportado.</summary>
      <param name="attributes" vsli:raw="The type attributes.">Os atributos de tipo.</param>
      <param name="namespace" vsli:raw="The type namespace.">O namespace de tipo.</param>
      <param name="name" vsli:raw="The type name.">O nome do tipo.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: an &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;.">O identificador de entidade de implementação, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId" vsli:raw="The type definition ID.">A ID de definição de tipo.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;implementation&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="implementation" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added exported type.">Um identificador para o tipo exportado adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a field definition.">Adiciona uma definição de campo.</summary>
      <param name="attributes" vsli:raw="The field attributes.">Os atributos do campo.</param>
      <param name="name" vsli:raw="The field name.">O nome do campo.</param>
      <param name="signature" vsli:raw="The field signature. Use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature&quot; /&gt; to construct the blob.">A assinatura de campo. Use <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> para construir o blob.</param>
      <returns vsli:raw="A handle to the added field definition.">Um identificador para a definição de campo adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Defines a field layout of a field definition.">Define um layout de campo de uma definição de campo.</summary>
      <param name="field" vsli:raw="The field definition handle.">O identificador de definição de campo.</param>
      <param name="offset" vsli:raw="The byte offset of the field within the declaring type instance.">O deslocamento de bytes do campo dentro da instância do tipo declarativo.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary vsli:raw="Adds a mapping from a field to its initial value stored in the PE image.">Adiciona um mapeamento de um campo para o respectivo valor inicial armazenado na imagem PE.</summary>
      <param name="field" vsli:raw="The field definition handle.">O identificador de definição de campo.</param>
      <param name="offset" vsli:raw="The offset within the block in the PE image that stores initial values of mapped fields (usually in the .text section).">O deslocamento dentro do bloco na imagem PE que armazena os valores iniciais de campos mapeados (geralmente na seção .text).</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;offset&quot; /&gt; is negative.">
        <paramref name="offset" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a generic parameter definition.">Adiciona uma definição de parâmetro genérico.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be either a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;.">O identificador de entidade pai, que pode ser <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes" vsli:raw="The generic parameter attributes.">Os atributos de parâmetro genérico.</param>
      <param name="name" vsli:raw="The parameter name.">O nome do parâmetro.</param>
      <param name="index" vsli:raw="The zero-based parameter index.">O índice de parâmetro baseado em zero.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is greater than &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;.">
        <paramref name="index" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns vsli:raw="A handle to the added generic parameter.">Um identificador para o parâmetro genérico adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds a type constraint to a generic parameter.">Adiciona uma restrição de tipo a um parâmetro genérico.</summary>
      <param name="genericParameter" vsli:raw="The generic parameter to constrain.">O parâmetro genérico a ser restringido.</param>
      <param name="constraint" vsli:raw="The type constraint, which can be one of the following: a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">A restrição de tipo, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;genericParameter&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="genericParameter" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added generic parameter constraint.">Um identificador para a restrição de parâmetro genérico adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local scope debug information.">Adiciona informações de depuração do escopo local.</summary>
      <param name="parentScope" vsli:raw="The parent scope handle.">O identificador de escopo pai.</param>
      <param name="imports" vsli:raw="The import scope handle.">O identificador de escopo de importação.</param>
      <returns vsli:raw="A handle to the added import scope.">Um identificador para o escopo de importação adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Adds an interface implementation to a type.">Adiciona uma implementação de interface a um tipo.</summary>
      <param name="type" vsli:raw="The type implementing the interface.">O tipo que implementa a interface.</param>
      <param name="implementedInterface" vsli:raw="The interface being implemented, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">A interface que está sendo implementada, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;implementedInterface&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="implementedInterface" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added interface implementation.">Um identificador para a implementação de interface adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds local constant debug information.">Adiciona informações de depuração da constante local.</summary>
      <param name="name" vsli:raw="The name of the variable.">O nome da variável.</param>
      <param name="signature" vsli:raw="The LocalConstantSig blob.">O blob LocalConstantSig.</param>
      <returns vsli:raw="A handle to the added local constant.">Um identificador para a constante local adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary vsli:raw="Adds local scope debug information.">Adiciona informações de depuração do escopo local.</summary>
      <param name="method" vsli:raw="The containing method.">O método continente.</param>
      <param name="importScope" vsli:raw="The handle of the associated import scope.">O identificador do escopo de importação associado.</param>
      <param name="variableList" vsli:raw="If the scope declares variables, set this to the handle of the first one. Otherwise, set this to the handle of the first variable declared by the next scope definition. If no scope defines any variables, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)&quot; /&gt;.">Se o escopo declarar variáveis, defina esse identificador como o identificador da primeira delas. Caso contrário, defina-o como o identificador da primeira variável declarada pela próxima definição de escopo. Se nenhum escopo definir nenhuma variável, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
      <param name="constantList" vsli:raw="If the scope declares constants, set this the handle of the first one. Otherwise, set this to the handle of the first constant declared by the next scope definition. If no scope defines any constants, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)&quot; /&gt;.">Se o escopo declarar constantes, defina esse identificador como o identificador da primeira delas. Caso contrário, defina-o como o identificador da primeira constante declarada pela próxima definição de escopo. Se nenhum escopo definir nenhuma constante, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
      <param name="startOffset" vsli:raw="The offset of the first instruction covered by the scope.">O deslocamento da primeira instrução abrangida pelo escopo.</param>
      <param name="length" vsli:raw="The length (in bytes) of the scope.">O tamanho, em bytes, do escopo.</param>
      <returns vsli:raw="A handle to the added local scope.">Um identificador para o escopo local adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds local variable debug information.">Adiciona informações de depuração da variável local.</summary>
      <param name="attributes" vsli:raw="The local variable attributes.">Os atributos da variável local.</param>
      <param name="index" vsli:raw="The zero-base index of the local variable in the local signature.">O índice de base zero da variável local na assinatura local.</param>
      <param name="name" vsli:raw="The name of the variable.">O nome da variável.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;index&quot; /&gt; is greater than &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;.">
        <paramref name="index" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns vsli:raw="A handle to the added local variable.">Um identificador para a variável local adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary vsli:raw="Adds a manifest resource.">Adiciona um recurso de manifesto.</summary>
      <param name="attributes" vsli:raw="The manifest resource attributes.">Os atributos do recurso de manifesto.</param>
      <param name="name" vsli:raw="The name of the manifest resource.">O nome do recurso de manifesto.</param>
      <param name="implementation" vsli:raw="The implementation entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">O identificador de entidade de implementação, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> ou <see langword="null" />.</param>
      <param name="offset" vsli:raw="Specifies the byte offset within the referenced file at which this resource record begins.">Especifica o deslocamento de bytes no arquivo referenciado no qual este registro de recurso começa.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;implementation&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="implementation" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added manifest resource.">Um identificador para o recurso de manifesto adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds marshalling information to a field or a parameter.">Adiciona informações de marshaling a um campo ou parâmetro.</summary>
      <param name="parent" vsli:raw="The parent entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ParameterHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.FieldDefinitionHandle&quot; /&gt;.">O identificador de entidade pai, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> ou <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor" vsli:raw="The descriptor blob.">O blob do descritor.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a MemberRef table row.">Adiciona uma linha de tabela MemberRef.</summary>
      <param name="parent" vsli:raw="The containing entity, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;.">A entidade continente, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name" vsli:raw="The member name.">O nome do membro.</param>
      <param name="signature" vsli:raw="The member signature.">A assinatura do membro.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;parent&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added member reference.">Um identificador para a referência de membro adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds method debug information.">Adiciona informações de depuração do método.</summary>
      <param name="document" vsli:raw="The handle of a single document containing all sequence points of the method, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">O identificador de um único documento que contém todos os pontos de sequência do método ou <see langword="null" /> caso o método não tenha pontos de sequência ou abranja vários documentos.</param>
      <param name="sequencePoints" vsli:raw="The sequence Points blob, or &lt;see langword=&quot;null&quot; /&gt; if the method doesn't have sequence points.">O blob de pontos de sequência ou <see langword="null" /> caso o método não tenha pontos de sequência.</param>
      <returns vsli:raw="A handle to the added method debug information.">Um identificador para as informações de depuração do método adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary vsli:raw="Adds a method definition.">Adiciona uma definição de método.</summary>
      <param name="attributes" vsli:raw="The method attributes.">Os atributos do método.</param>
      <param name="implAttributes" vsli:raw="The method implementation attributes.">Os atributos de implementação de método.</param>
      <param name="name" vsli:raw="The method name.">O nome do método.</param>
      <param name="signature" vsli:raw="The method signature.">A assinatura do método.</param>
      <param name="bodyOffset" vsli:raw="Offset within the block in the PE image that stores method bodies (the IL stream), or -1 if the method doesn't have a body.">Deslocamento dentro do bloco na imagem PE que armazena corpos de método – o fluxo de IL (linguagem intermediária) – ou -1 se o método não tiver um corpo.</param>
      <param name="parameterList" vsli:raw="If the method declares parameters in the Params table, set this to the handle of the first one. Otherwise, set this to the handle of the first parameter declared by the next method definition. If no parameters are declared in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)&quot; /&gt;.">Se o método declarar parâmetros na tabela Params, defina-o como o identificador do primeiro parâmetro. Caso contrário, defina-o como o identificador do primeiro parâmetro declarado pela próxima definição de método. Se nenhum parâmetro for declarado no módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;bodyOffset&quot; /&gt; is less than -1.">
        <paramref name="bodyOffset" /> é menor que -1.</exception>
      <returns vsli:raw="A handle to the added method definition.">Um identificador para a definição de método adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Defines an implementation for a method declaration within a type.">Define uma implementação para uma declaração de método dentro de um tipo.</summary>
      <param name="type" vsli:raw="The type definition.">A definição de tipo.</param>
      <param name="methodBody" vsli:raw="The method body entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">O identificador de entidade do corpo do método, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration" vsli:raw="The method declaration entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">O identificador de entidade da declaração de método, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;methodBody&quot; /&gt; or &lt;paramref name=&quot;methodDeclaration&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="methodBody" /> ou <paramref name="methodDeclaration" /> não têm o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added method implementation.">Um identificador para a implementação de método adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary vsli:raw="Adds import information to a method definition.">Adiciona informações de importação a uma definição de método.</summary>
      <param name="method" vsli:raw="The method definition handle.">O identificador de definição do método.</param>
      <param name="attributes" vsli:raw="The method import attributes.">Os atributos de importação de método.</param>
      <param name="name" vsli:raw="The unmanaged method name.">O nome do método não gerenciado.</param>
      <param name="module" vsli:raw="The module containing the unmanaged method.">O módulo que contém o método não gerenciado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Associates a method (a getter, a setter, an adder, etc.) with a property or an event.">Associa um método (um getter, um setter, um adicionador etc.) a uma propriedade ou um evento.</summary>
      <param name="association" vsli:raw="The association entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.EventDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.PropertyDefinitionHandle&quot; /&gt;.">O identificador de entidade de associação, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics" vsli:raw="The method semantics attributes.">Os atributos de semântica de método.</param>
      <param name="methodDefinition" vsli:raw="The method definition.">A definição de método.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;association&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="association" /> não tem o tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a method specification (an instantiation).">Adiciona uma especificação de método (uma instanciação).</summary>
      <param name="method" vsli:raw="The generic method entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt;.">O identificador de entidade do método genérico, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation" vsli:raw="The instantiation blob encoding the generic arguments of the method.">O blob de instanciação que codifica os argumentos genéricos do método.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;method&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="method" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added method specification.">Um identificador para a especificação de método adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" vsli:raw="" />
      <param name="moduleName" vsli:raw="" />
      <param name="mvid" vsli:raw="" />
      <param name="encId" vsli:raw="" />
      <param name="encBaseId" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary vsli:raw="Defines a nesting relationship to specified type definitions.">Define uma relação de aninhamento para definições de tipo especificadas.</summary>
      <param name="type" vsli:raw="The nested type definition handle.">O identificador de definição de tipo aninhado.</param>
      <param name="enclosingType" vsli:raw="The enclosing type definition handle.">O identificador de definição de tipo delimitador.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary vsli:raw="Adds a parameter definition.">Adiciona uma definição de parâmetro.</summary>
      <param name="attributes" vsli:raw="The parameter attributes.">Os atributos de parâmetro.</param>
      <param name="name" vsli:raw="Optional. The parameter name.">Opcional. O nome do parâmetro.</param>
      <param name="sequenceNumber" vsli:raw="The sequence number of the parameter. A value of 0 refers to the owner method's return type; its parameters are then numbered from 1 onward.">O número de sequência do parâmetro. Um valor de 0 refere-se ao tipo de retorno do método de proprietário; em seguida, seus parâmetros são numerados de 1 em diante.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;sequenceNumber&quot; /&gt; is greater than &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;.">
        <paramref name="sequenceNumber" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns vsli:raw="A handle to the added parameter.">Um identificador para o parâmetro adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Adds a property definition.">Adiciona uma definição de propriedade.</summary>
      <param name="attributes" vsli:raw="The property attributes.">Os atributos da propriedade.</param>
      <param name="name" vsli:raw="The property name.">O nome da propriedade.</param>
      <param name="signature" vsli:raw="The signature of the property.">A assinatura da propriedade.</param>
      <returns vsli:raw="A handle to the added property definition.">Um identificador para a definição de propriedade adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" vsli:raw="" />
      <param name="propertyList" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds state machine method debug information.">Adiciona informações de depuração do método de máquina de estado.</summary>
      <param name="moveNextMethod" vsli:raw="The handle of the &lt;see langword=&quot;MoveNext&quot; /&gt; method of the state machine (the compiler-generated method).">O identificador do método <see langword="MoveNext" /> da máquina de estado (o método gerado pelo compilador).</param>
      <param name="kickoffMethod" vsli:raw="The handle of the kickoff method (the user defined iterator/async method).">O identificador do método de início (o método iterador/assíncrono definido pelo usuário).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Adds a type definition.">Adiciona uma definição de tipo.</summary>
      <param name="attributes" vsli:raw="The type attributes.">Os atributos de tipo.</param>
      <param name="namespace" vsli:raw="The type namespace.">O namespace de tipo.</param>
      <param name="name" vsli:raw="The type name.">O nome do tipo.</param>
      <param name="baseType" vsli:raw="The base type entity handle, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">O identificador de entidade de tipo base, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> ou <see langword="null" />.</param>
      <param name="fieldList" vsli:raw="If the type declares fields, set this to the handle of the first one. Otherwise, set this to the handle of the first field declared by the next type definition. If no type defines any fields in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)&quot; /&gt;.">Se o tipo declarar campos, defina esse identificador como o identificador do primeiro deles. Caso contrário, defina-o como o identificador do primeiro campo declarado pela próxima definição de tipo. Se nenhum tipo definir nenhum campo no módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
      <param name="methodList" vsli:raw="If the type declares methods, the handle of the first one. Otherwise, the handle of the first method declared by the next type definition. If no type defines any methods in the module, &lt;see langword=&quot;System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)&quot; /&gt;.">Se o tipo declarar métodos, defina esse identificador como o identificador do primeiro deles. Caso contrário, defina-o como o identificador do primeiro método declarado pela definição de tipo seguinte. Se nenhum tipo definir nenhum método no módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;baseType&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="baseType" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added type definition.">Um identificador para a definição de tipo adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary vsli:raw="Defines a type layout of a type definition.">Define um layout de tipo de uma definição de tipo.</summary>
      <param name="type" vsli:raw="The type definition.">A definição de tipo.</param>
      <param name="packingSize" vsli:raw="Specifies that fields should be placed within the type instance at byte addresses which are a multiple of &lt;paramref name=&quot;packingSize&quot; /&gt;, or at natural alignment for that field type, whichever is smaller. Its value should be one of the following: 0, 1, 2, 4, 8, 16, 32, 64, or 128. A value of zero indicates that the packing size used should match the default for the current platform.">Especifica que os campos devem ser colocados dentro da instância de tipo em endereços de byte que são um múltiplo de <paramref name="packingSize" /> ou em um alinhamento natural para esse tipo de campo, o que for menor. Seu valor deve ser um dos seguintes: 0, 1, 2, 4, 8, 16, 32, 64 ou 128. Um valor de zero indica que o tamanho de compactação usado deve corresponder ao padrão para a plataforma atual.</param>
      <param name="size" vsli:raw="Indicates a minimum size of the type instance and is intended to allow for padding. The amount of memory allocated is the maximum of the size calculated from the layout and &lt;paramref name=&quot;size&quot; /&gt;. Note that if this directive applies to a value type, then the size will be less than 1 MB.">Indica um tamanho mínimo da instância do tipo e destina-se a permitir o preenchimento. A quantidade de memória alocada é o máximo do tamanho calculado com base no layout e em <paramref name="size" />. Observe que, se essa diretiva se aplicar a um tipo de valor, o tamanho será menor que 1 MB.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Adds a type reference.">Adiciona uma referência de tipo.</summary>
      <param name="resolutionScope" vsli:raw="The entity declaring the target type, which can be one of the following: &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.ModuleReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt;.">A entidade que declara o tipo de destino, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see langword="null" />.</param>
      <param name="namespace" vsli:raw="The type reference namespace.">O namespace de referência de tipo.</param>
      <param name="name" vsli:raw="The type reference name.">O nome de referência de tipo.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;resolutionScope&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="resolutionScope" /> não tem o tipo de identificador esperado.</exception>
      <returns vsli:raw="A handle to the added type reference.">Um identificador para a referência de tipo adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary vsli:raw="Adds the specified blob to the Blob heap, if it's not there already.">Adicionará o blob especificado ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value" vsli:raw="The array containing the blob.">A matriz que contém o blob.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds the specified blob from a byte array to the Blob heap, if it's not there already.">Adicionará o blob especificado de uma matriz de bytes ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value" vsli:raw="The array containing the blob.">A matriz que contém o blob.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Adds the specified blob from an immutable byte array to the Blob heap, if it's not there already.">Adicionará o blob especificado de uma matriz de bytes imutável ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value" vsli:raw="The blob builder instance containing the blob.">A instância do construtor de blobs que contém o blob.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary vsli:raw="Encodes a string using UTF16 encoding to a blob and adds it to the Blob heap, if it's not there already.">Codifica uma cadeia de caracteres usando a codificação UTF16 em um blob e a adiciona ao heap de blobs, caso ainda não exista.</summary>
      <param name="value" vsli:raw="The string to add.">A cadeia de caracteres a ser adicionada.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary vsli:raw="Encodes a string using UTF8 encoding to a blob and adds it to the Blob heap, if it's not there already.">Codifica uma cadeia de caracteres usando a codificação UTF8 em um blob e a adiciona ao heap de blobs, caso ainda não exista.</summary>
      <param name="value" vsli:raw="The value to add.">O valor a ser adicionado.</param>
      <param name="allowUnpairedSurrogates" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode the unpaired surrogates as specified; &lt;see langword=&quot;false&quot; /&gt; to replace them with the U+FFFD character.">
        <see langword="true" /> para codificar substitutos não emparelhados conforme o especificado; <see langword="false" /> para substituí-los por um caractere U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing blob.">Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary vsli:raw="Encodes a constant value to a blob and adds it to the Blob heap, if it's not there already. Uses UTF16 to encode string constants.">Codifica um valor de constante em um blob e o adiciona ao heap de blobs, caso ainda não exista. Usa UTF16 para codificar constantes de cadeia de caracteres.</summary>
      <param name="value" vsli:raw="The constant value to add.">O valor constante a ser adicionado.</param>
      <returns vsli:raw="A handle to the added or existing blob.">Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary vsli:raw="Encodes a debug document name and adds it to the Blob heap, if it's not there already.">Codifica um nome de documento de depuração e o adiciona ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value" vsli:raw="The document name to add.">O nome do documento a adicionar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing document name blob.">Um identificador para o blob de nome de documento adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary vsli:raw="Adds the specified Guid to the Guid heap, if it's not there already.">Adicionará o GUID especificado ao heap de GUIDs, caso ele ainda não esteja lá.</summary>
      <param name="guid" vsli:raw="The Guid to add.">O GUID a adicionar.</param>
      <returns vsli:raw="A handle to the added or existing Guid.">Um identificador para o GUID adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary vsli:raw="Adds the specified string to the string heap, if it's not there already.">Adiciona a cadeia de caracteres especificada ao heap de cadeias de caracteres, caso ela ainda não esteja lá.</summary>
      <param name="value" vsli:raw="The string to add.">A cadeia de caracteres a ser adicionada.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing string.">Um identificador para a cadeia de caracteres adicionada ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary vsli:raw="Adds the specified string to the user string heap, if it's not there already.">Adiciona a cadeia de caracteres especificada ao heap de cadeias de caracteres de usuário, caso ela ainda não esteja lá.</summary>
      <param name="value" vsli:raw="The string to add.">A cadeia de caracteres a ser adicionada.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="The remaining space on the heap is too small to fit the string.">O espaço restante no heap é muito pequeno para se ajustar à cadeia de caracteres.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;value&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns vsli:raw="A handle to the added or existing string. This value may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.">Um identificador para a cadeia de caracteres adicionada ou existente. Esse valor pode ser usado em <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the current number of items in the specified table.">Retorna o número atual de itens na tabela especificada.</summary>
      <param name="table" vsli:raw="The table index.">O índice de tabela.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;table&quot; /&gt; is not a valid table index.">
        <paramref name="table" /> não é um índice de tabela válido.</exception>
      <returns vsli:raw="The number of items in the table.">O número de itens na tabela.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary vsli:raw="Returns the current number of items in each table.">Retorna o número atual de itens em cada tabela.</summary>
      <returns vsli:raw="An array of size &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;, with each item filled with the current row count of the corresponding table.">Uma matriz de tamanho <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, com cada item preenchido com a contagem de linhas atual da tabela correspondente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary vsli:raw="Reserves space on the Guid heap for a GUID.">Reserva espaço no heap de GUIDs para um GUID.</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="The remaining space on the heap is too small to fit the string.">O espaço restante no heap é muito pequeno para se ajustar à cadeia de caracteres.</exception>
      <returns vsli:raw="A handle to the reserved Guid and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the GUID blob as stored on the heap.">Um identificador para o GUID reservado e um <see cref="T:System.Reflection.Metadata.Blob" /> que representa o blob de GUID como armazenado no heap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary vsli:raw="Reserves space on the user string heap for a string of the specified length.">Reserva espaço no heap de cadeias de caracteres do usuário para uma cadeia de caracteres do comprimento especificado.</summary>
      <param name="length" vsli:raw="The number of characters to reserve.">O número de caracteres a serem reservados.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException" vsli:raw="The remaining space on the heap is too small to fit the string.">O espaço restante no heap é muito pequeno para se ajustar à cadeia de caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is negative.">
        <paramref name="length" /> é negativo.</exception>
      <returns vsli:raw="A handle to the reserved user string and a &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; representing the entire User String blob (including its length and terminal character). The handle may be used in &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)&quot; /&gt;.&#xA; Use &lt;see cref=&quot;M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)&quot; /&gt; to fill in the blob content.">Um identificador para a cadeia de caracteres de usuário reservada e um <see cref="T:System.Reflection.Metadata.Blob" /> que representa o blob de cadeia de caracteres do usuário inteiro (incluindo seu comprimento e seu caractere terminal). O identificador pode ser usado em <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
Use <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> para preencher o conteúdo do blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified heap.">Define a capacidade do heap especificado.</summary>
      <param name="heap" vsli:raw="The heap index.">O índice de heap.</param>
      <param name="byteCount" vsli:raw="The number of bytes.">O número de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;heap&quot; /&gt; is not a valid heap index.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;byteCount&quot; /&gt; is negative.">
        <paramref name="heap" /> não é um índice de heap válido.

- ou -

<paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Sets the capacity of the specified table.">Define a capacidade da tabela especificada.</summary>
      <param name="table" vsli:raw="The table index.">O índice de tabela.</param>
      <param name="rowCount" vsli:raw="The number of rows in the table.">O número de linhas da tabela.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;table&quot; /&gt; is not a valid table index.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;rowCount&quot; /&gt; is negative.">
        <paramref name="table" /> não é um índice de tabela válido.

- ou -

<paramref name="rowCount" /> é negativo.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary vsli:raw="Provides extension methods for working with certain raw elements of the ECMA-335 metadata tables and heaps.">Fornece métodos de extensão para trabalhar com determinados elementos brutos das tabelas e heaps de metadados ECMA-335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC log.">Enumera as entradas do log do EnC.</summary>
      <param name="reader" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerates entries of EnC map.">Enumera as entradas do mapa do EnC.</summary>
      <param name="reader" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified heap.">Retorna o deslocamento do início dos metadados para o heap especificado.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;heapIndex&quot; /&gt; is not a valid heap index.">
        <paramref name="heapIndex" /> não é um índice de heap válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns the size of the specified heap.">Retorna o tamanho do heap especificado.</summary>
      <param name="reader" vsli:raw="" />
      <param name="heapIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;heapIndex&quot; /&gt; is not a valid heap index.">
        <paramref name="heapIndex" /> não é um índice de heap válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Returns the handle to the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; that follows the given one in the &lt;see cref=&quot;T:System.Reflection.Metadata.Blob&quot; /&gt; heap or a nil handle if it is the last one.">Retorna o identificador para o <see cref="T:System.Reflection.Metadata.Blob" /> que segue o fornecido no heap de <see cref="T:System.Reflection.Metadata.Blob" /> ou um identificador nil caso ele seja o último.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Returns the a handle to the string that follows the given one in the string heap, or a nil handle if it is the last one.">Retorna o identificador para a cadeia de caracteres que segue o fornecido no heap de cadeia de caracteres ou um identificador nil caso ele seja o último.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.">Retorna o identificador para a UserString que segue o fornecido no heap de UserString ou um identificador nil caso ele seja o último.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the offset from the start of metadata to the specified table.">Retorna o deslocamento do início dos metadados até a tabela especificada.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the number of rows in the specified table.">Retorna o número de linhas na tabela especificada.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary vsli:raw="Returns the size of a row in the specified table.">Retorna o tamanho de uma linha na tabela especificada.</summary>
      <param name="reader" vsli:raw="" />
      <param name="tableIndex" vsli:raw="" />
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;reader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more events.">Tipos enumerados que definem um ou mais eventos.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in EventMap table, i.e. n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of EventMap.">A sequência resultante corresponde exatamente às entradas na tabela EventMap, ou seja, o enésimo <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> retornado é armazenado na enésima linha de EventMap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary vsli:raw="Enumerate types that define one or more properties.">Tipos enumerados que definem uma ou mais propriedades.</summary>
      <param name="reader" vsli:raw="" />
      <returns vsli:raw="The resulting sequence corresponds exactly to entries in the property map table, that is, the n-th returned &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; is stored in n-th row of the property map.">A sequência resultante corresponde exatamente às entradas na tabela do mapa de propriedades, ou seja, o n-ésimo <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> retornado é armazenado na n-ésima linha do mapa de propriedades.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary vsli:raw="Given a type handle and a raw type kind found in a signature blob determines whether the target type is a value type or a reference type.">Fornecidos um identificador de tipo e um tipo bruto, encontrados em um blob de assinatura, determina se o tipo de destino é um tipo de valor ou de referência.</summary>
      <param name="reader" vsli:raw="" />
      <param name="typeHandle" vsli:raw="" />
      <param name="rawTypeKind" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary vsli:raw="Builder of a Metadata Root to be embedded in a Portable Executable image.">Construtor de uma raiz de metadados a ser inserido em uma imagem executável portátil.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary vsli:raw="Creates a builder of a metadata root.">Cria um construtor de uma raiz de metadados.</summary>
      <param name="tablesAndHeaps" vsli:raw="Builder populated with metadata entities stored in tables and values stored in heaps. The entities and values will be enumerated when serializing the metadata root.">Construtor preenchido com entidades de metadados armazenadas em tabelas e valores armazenados em heaps. As entidades e os valores serão enumerados ao serializar a raiz dos metadados.</param>
      <param name="metadataVersion" vsli:raw="The version string written to the metadata header. The default value is &quot;v4.0.30319&quot;.">A cadeia de caracteres de versão gravada no cabeçalho de metadados. O valor padrão é "v4.0.30319".</param>
      <param name="suppressValidation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables during serialization; otherwise, &lt;paramref name=&quot;false&quot; /&gt;.">
        <see langword="true" /> para suprimir a validação básica de tabelas de metadados durante a serialização; caso contrário, <paramref name="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;tablesAndHeaps&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="tablesAndHeaps" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;metadataVersion&quot; /&gt; is too long (the number of bytes when UTF8-encoded must be less than 255).">
        <paramref name="metadataVersion" /> é muito longo (o número de bytes quando codificados em UTF8 deve ser menor que 255).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary vsli:raw="Serializes metadata root content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Serializa o conteúdo raiz dos metadados no <see cref="T:System.Reflection.Metadata.BlobBuilder" /> fornecido.</summary>
      <param name="builder" vsli:raw="Builder to write to.">O construtor no qual gravar.</param>
      <param name="methodBodyStreamRva" vsli:raw="The relative virtual address of the start of the method body stream. Used to calculate the final value of RVA fields of MethodDef table.">O endereço virtual relativo do início do fluxo do corpo do método. Usado para calcular o valor final dos campos de RVA da tabela MethodDef.</param>
      <param name="mappedFieldDataStreamRva" vsli:raw="The relative virtual address of the start of the field init data stream. Used to calculate the final value of RVA fields of FieldRVA table.">O endereço virtual relativo do início do fluxo de dados de inicialização de campos. Usado para calcular o valor final dos campos de RVA da tabela FieldRVA.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;builder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="builder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;methodBodyStreamRva&quot; /&gt; or &lt;paramref name=&quot;mappedFieldDataStreamRva&quot; /&gt; is negative.">
        <paramref name="methodBodyStreamRva" /> ou <paramref name="mappedFieldDataStreamRva" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="A metadata table is not ordered as required by the specification and &lt;see cref=&quot;P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation&quot; /&gt; is &lt;see langword=&quot;false&quot; /&gt;.">Uma tabela de metadados não está ordenada como exigido pela especificação, e <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> é <see langword="false" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary vsli:raw="The metadata version.">A versão dos metadados.</summary>
      <returns vsli:raw="A string that represents the metadata version.">Uma cadeia de caracteres que representa a versão de metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary vsli:raw="Returns sizes of various metadata structures.">Retorna tamanhos de várias estruturas de metadados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary vsli:raw="Determines if basic validation of metadata tables should be suppressed. The validation verifies that entries in the tables were added in order required by the ECMA specification. It does not enforce all specification requirements on metadata tables.">Determina se a validação básica de tabelas de metadados deve ser suprimida. A validação verifica se as entradas nas tabelas foram adicionadas na ordem exigida pela especificação ECMA. Ela não impõe todos os requisitos de especificação em tabelas de metadados.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to suppress basic validation of metadata tables; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para suprimir a validação básica de tabelas de metadados; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary vsli:raw="Provides information on sizes of various metadata structures.">Fornece informações sobre tamanhos de várias estruturas de metadados.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary vsli:raw="Returns aligned size of the specified heap.">Retorna o tamanho alinhado do heap especificado.</summary>
      <param name="index" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary vsli:raw="External table row count.">Contagem de linhas da tabela externa.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary vsli:raw="Exact (unaligned) heap sizes.">Tamanhos de heap exatos (não alinhados).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary vsli:raw="Table row counts.">Contagens de linhas da tabela.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Número máximo de tabelas que podem estar presentes nos metadados do Ecma335.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary vsli:raw="Maximum number of tables that can be present in Ecma335 metadata.">Número máximo de tabelas que podem estar presentes nos metadados do Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary vsli:raw="Creates an entity handle from a token value.">Cria um identificador de entidade usando um valor de token.</summary>
      <param name="token" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;token&quot; /&gt; is not a valid metadata entity token.">
        <paramref name="token" /> não é um token de entidade de metadados válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">Cria um <see cref="T:System.Reflection.Metadata.EntityHandle" /> usando um valor de token.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Deslocamento baseado em zero, ou -1 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="1-based index into the #Guid heap. Unlike other heaps, which are essentially byte arrays, the #Guid heap is an array of 16-byte GUIDs.">Índice baseado em 1 no heap #Guid. Ao contrário de outros heaps, que são basicamente matrizes de bytes, o heap #Guid é uma matriz de GUIDs de 16 bytes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="An offset in the corresponding heap, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Um deslocamento no heap correspondente, ou -1 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.NotSupportedException" vsli:raw="The operation is not supported for the specified &lt;paramref name=&quot;handle&quot; /&gt;.">A operação não tem suporte no <paramref name="handle" /> especificado.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;handle&quot; /&gt; is invalid.">O <paramref name="handle" /> é inválido.</exception>
      <returns vsli:raw="Zero based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; isn't a metadata heap handle.">Deslocamento baseado em zero, ou -1 se <paramref name="handle" /> não for um identificador de heap de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MetadataBuilder&quot; /&gt;.">Deslocamento baseado em zero, ou -1 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Gets the offset of metadata heap data that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Zero-based offset.">Deslocamento baseado em zero.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o número da linha de uma entrada da tabela de metadados que corresponde ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="One based row number, or -1 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.&#xA; See &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)&quot; /&gt;.">Número de linha baseado em um ou -1, se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.
Consulte <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the row number of a metadata table entry that corresponds to the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Obtém o número da linha de uma entrada da tabela de metadados que corresponde ao <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="The &lt;paramref name=&quot;handle&quot; /&gt; is not a valid metadata table handle.">O <paramref name="handle" /> não é um identificador de tabela de metadados válido.</exception>
      <returns vsli:raw="One based row number.">Número de linha baseado em um.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o token de metadados do <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">Token de metadados, ou 0 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt;.">Obtém o token de metadados do <paramref name="handle" /> especificado.</summary>
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="Handle represents a metadata entity that doesn't have a token.&#xA;            A token can only be retrieved for a metadata table handle or a heap handle of type &lt;see cref=&quot;F:System.Reflection.Metadata.HandleKind.UserString&quot; /&gt;.">O identificador representa uma entidade de metadados que não tem um token.
Só é possível recuperar um token para um identificador de tabela de metadados ou um identificador de heap do tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <returns vsli:raw="Metadata token, or 0 if &lt;paramref name=&quot;handle&quot; /&gt; can only be interpreted in a context of a specific &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt;.">Token de metadados, ou 0 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Obtém o token de metadados do <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.NotSupportedException" vsli:raw="The operation is not supported for the specified &lt;paramref name=&quot;handle&quot; /&gt;.">A operação não tem suporte no <paramref name="handle" /> especificado.</exception>
      <returns vsli:raw="Metadata token.">Token de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Gets the metadata token of the specified &lt;paramref name=&quot;handle&quot; /&gt; in the context of &lt;paramref name=&quot;reader&quot; /&gt;.">Obtém o token de metadados do <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" vsli:raw="" />
      <param name="handle" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="Handle represents a metadata entity that doesn't have a token.&#xA;            A token can only be retrieved for a metadata table handle or a heap handle of type &lt;see cref=&quot;F:System.Reflection.Metadata.HandleKind.UserString&quot; /&gt;.">O identificador representa uma entidade de metadados que não tem um token.
Só é possível recuperar um token para um identificador de tabela de metadados ou um identificador de heap do tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <exception cref="T:System.NotSupportedException" vsli:raw="The operation is not supported for the specified &lt;paramref name=&quot;handle&quot; /&gt;.">A operação não tem suporte no <paramref name="handle" /> especificado.</exception>
      <returns vsli:raw="Metadata token.">Token de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary vsli:raw="Creates a handle from a token value.">Cria um identificador usando um valor de token.</summary>
      <param name="token" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;token&quot; /&gt; is not a valid metadata token.&#xA;            It must encode a metadata table entity or an offset in the &lt;see cref=&quot;F:System.Reflection.Metadata.HandleKind.UserString&quot; /&gt; heap.">
        <paramref name="token" /> não é um token de metadados válido.
Ele deve codificar uma entidade de tabela de metadados ou um deslocamento no heap <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; from a token value.">Cria um <see cref="T:System.Reflection.Metadata.EntityHandle" /> usando um valor de token.</summary>
      <param name="tableIndex" vsli:raw="" />
      <param name="rowNumber" vsli:raw="" />
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;tableIndex&quot; /&gt; is not a valid table index.">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.HeapIndex&quot; /&gt; of the heap corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">Obtém o <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> do heap correspondente ao <see cref="T:System.Reflection.Metadata.HandleKind" /> especificado.</summary>
      <param name="type" vsli:raw="Handle type.">Tipo de identificador.</param>
      <param name="index" vsli:raw="Heap index.">Índice do heap.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 heap; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se o tipo de identificador corresponder a um heap do Ecma335; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt; of the table corresponding to the specified &lt;see cref=&quot;T:System.Reflection.Metadata.HandleKind&quot; /&gt;.">Obtém o <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> da tabela correspondente ao <see cref="T:System.Reflection.Metadata.HandleKind" /> especificado.</summary>
      <param name="type" vsli:raw="Handle type.">Tipo de identificador.</param>
      <param name="index" vsli:raw="Table index.">Índice de tabela.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the handle type corresponds to an Ecma335 or Portable PDB table; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se o tipo de identificador corresponder a uma tabela Ecma335 ou Portable PDB; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary vsli:raw="Defines method body attributes.">Define os atributos do corpo do método.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary vsli:raw="Initializes any locals the method defines to zero and dynamically allocates local memory.">Inicializa qualquer local que o método define como zero e aloca dinamicamente a memória local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary vsli:raw="Performs no local memory initialization.">Não executa nenhuma inicialização de memória local.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary vsli:raw="Provides an encoder for a method body stream.">Fornece um codificador para um fluxo do corpo do método.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes and allowing to indicate whether the exception regions should be encoded in small format or not.">Codifica um corpo do método e o adiciona ao fluxo do corpo do método usando o tamanho de código fornecido, o tamanho máximo da pilha, o número de regiões de exceção, o identificador de assinatura das variáveis locais e os atributos do corpo do método e permite indicar se as regiões de exceção devem ser codificadas em formato pequeno ou não.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">O número de bytes que serão reservados para instruções.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">O tamanho máximo da pilha.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">O número de regiões de exceção.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se as regiões de exceção devem ser codificadas em formato pequeno; caso contrário, <see langword="false" />.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Os atributos do corpo do método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;codeSize&quot; /&gt;, &lt;paramref name=&quot;exceptionRegionCount&quot; /&gt;, or &lt;paramref name=&quot;maxStack&quot; /&gt; is out of the allowed range.">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> ou <paramref name="maxStack" /> está fora do intervalo permitido.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided code size, maximum stack size, number of exception regions, local variables' signature handle, method body attributes, allowing to indicate whether the exception regions should be encoded in small format or not, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">Codifica um corpo do método e o adiciona ao fluxo do corpo do método usando o tamanho de código fornecido, o tamanho máximo da pilha, o número de regiões de exceção, o identificador de assinatura das variáveis locais e os atributos do corpo do método, permite indicar se as regiões de exceção devem ser codificadas em formato pequeno ou não e permite indicar se o método deve ser alocado a partir do pool de memória local dinâmico.</summary>
      <param name="codeSize" vsli:raw="The number of bytes to be reserved for instructions.">O número de bytes que serão reservados para instruções.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">O tamanho máximo da pilha.</param>
      <param name="exceptionRegionCount" vsli:raw="The number of exception regions.">O número de regiões de exceção.</param>
      <param name="hasSmallExceptionRegions" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the exception regions should be encoded in small format; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se as regiões de exceção devem ser codificadas em formato pequeno; caso contrário, <see langword="false" />.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Os atributos do corpo do método.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se o método for alocar a partir do pool de memória local dinâmico (a instrução <see langword="localloc" />); caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;codeSize&quot; /&gt;, &lt;paramref name=&quot;exceptionRegionCount&quot; /&gt;, or &lt;paramref name=&quot;maxStack&quot; /&gt; is out of the allowed range.">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> ou <paramref name="maxStack" /> está fora do intervalo permitido.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream.">Codifica um corpo do método e o adiciona ao fluxo do corpo do método.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">O codificador de instruções.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">O tamanho máximo da pilha.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Os atributos do corpo do método.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;instructionEncoder&quot; /&gt; has default value.">
        <paramref name="instructionEncoder" /> tem valor padrão.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maxStack&quot; /&gt; is out of range [0, &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;].">
        <paramref name="maxStack" /> está fora do intervalo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="A label targeted by a branch in the instruction stream has not been marked, or the distance between a branch instruction and the target label doesn't fit the size of the instruction operand.">Um rótulo almejado por um branch no fluxo de instrução não foi marcado ou a distância entre uma instrução de branch e o rótulo de destino não se ajusta ao tamanho do operando de instrução.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary vsli:raw="Encodes a method body and adds it to the method body stream, using the provided instruction encoder, maximum stack size, local variables' signature handle, method body attributes, and allowing to indicate whether the method should allocate from the dynamic local memory pool or not.">Codifica um corpo do método e o adiciona ao fluxo do corpo do método usando o codificador de instruções fornecido, o tamanho máximo da pilha, o identificador de assinatura das variáveis locais, os atributos do corpo do método e permite indicar se o método deve ser alocado ou não a partir do pool de memória local dinâmico.</summary>
      <param name="instructionEncoder" vsli:raw="The instruction encoder.">O codificador de instruções.</param>
      <param name="maxStack" vsli:raw="The maximum stack size.">O tamanho máximo da pilha.</param>
      <param name="localVariablesSignature" vsli:raw="The local variables' signature handle.">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes" vsli:raw="The method body attributes.">Os atributos do corpo do método.</param>
      <param name="hasDynamicStackAllocation" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method allocates from the dynamic local memory pool (the IL contains the &lt;see langword=&quot;localloc&quot; /&gt; instruction); &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se o método for alocado a partir do pool de memória local dinâmico (o IL contém a instrução <see langword="localloc" />); caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;instructionEncoder&quot; /&gt; has default value.">
        <paramref name="instructionEncoder" /> tem valor padrão.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;maxStack&quot; /&gt; is out of range [0, &lt;see cref=&quot;F:System.UInt16.MaxValue&quot;&gt;UInt16.MaxValue&lt;/see&gt;].">
        <paramref name="maxStack" /> está fora do intervalo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="A label targeted by a branch in the instruction stream has not been marked, or the distance between a branch instruction and the target label doesn't fit the size of the instruction operand.">Um rótulo almejado por um branch no fluxo de instrução não foi marcado ou a distância entre uma instrução de branch e o rótulo de destino não se ajusta ao tamanho do operando de instrução.</exception>
      <returns vsli:raw="The offset of the encoded body within the method body stream.">O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary vsli:raw="Describes a method body. This class is meant to used along with the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder&quot; /&gt; class.">Descreve um corpo de método. Essa classe deve ser usada junto com a classe <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary vsli:raw="Gets an encoder object that can be used to encode exception regions to the method body.">Obtém um objeto codificador que pode ser usado para codificar regiões de exceção para o corpo do método.</summary>
      <returns vsli:raw="An exception region encoder instance.">Uma instância de codificador de região de exceção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary vsli:raw="Gets a blob reserved for instructions.">Obtém um blob reservado para instruções.</summary>
      <returns vsli:raw="A blob reserved for instructions.">Um blob reservado para instruções.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary vsli:raw="Gets the offset of the encoded method body in the method body stream.">Obtém o deslocamento do corpo do método codificado no fluxo do corpo do método.</summary>
      <returns vsli:raw="The offset of the encoded method body in the method body stream.">O deslocamento do corpo do método codificado no fluxo do corpo do método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary vsli:raw="Provides an encoder for method signatures.">Fornece um codificador para assinaturas de método.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary vsli:raw="Encodes the provided return type and parameters.">Codifica os parâmetros e o tipo de retorno fornecidos.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">O número de parâmetros.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return type.">O primeiro método que é chamado para codificar o tipo de retorno.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">O segundo método que é chamado para codificar os parâmetros.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;returnType&quot; /&gt; or &lt;paramref name=&quot;parameters&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="returnType" /> ou <paramref name="parameters" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary vsli:raw="Encodes the provided return type and parameters, which must be used in the order they appear in the parameter list.">Codifica os parâmetros e o tipo de retorno fornecidos, que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="parameterCount" vsli:raw="The number of parameters.">O número de parâmetros.</param>
      <param name="returnType" vsli:raw="The method that is called first to encode the return types.">O primeiro método que é chamado para codificar os tipos de retorno.</param>
      <param name="parameters" vsli:raw="The method that is called second to encode the parameters.">O segundo método que é chamado para codificar os parâmetros.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder&quot; /&gt; structure.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />.</summary>
      <param name="builder" vsli:raw="A builder for encoding the named argument.">Um construtor para codificar o argumento nomeado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary vsli:raw="Encodes a named argument (a field or property).">Codifica um argumento nomeado (um campo ou propriedade).</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" /> para codificar um campo, <see langword="false" /> para codificar uma propriedade.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">O primeiro método a ser chamado para codificar o tipo do argumento.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">O segundo método a ser chamado para codificar o nome do campo ou da propriedade.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">O terceiro método a ser chamado para codificar o valor literal do argumento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt;, &lt;paramref name=&quot;name&quot; /&gt; or &lt;paramref name=&quot;literal&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="type" />, <paramref name="name" /> ou <paramref name="literal" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary vsli:raw="Encodes a named argument (a field or property) and returns three encoders that must be used in the order they appear in the parameter list.">Codifica um argumento nomeado (um campo ou propriedade) e retorna três codificadores que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="isField" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to encode a field, &lt;see langword=&quot;false&quot; /&gt; to encode a property.">
        <see langword="true" /> para codificar um campo, <see langword="false" /> para codificar uma propriedade.</param>
      <param name="type" vsli:raw="The method to call first to encode the type of the argument.">O primeiro método a ser chamado para codificar o tipo do argumento.</param>
      <param name="name" vsli:raw="The method to call second to encode the name of the field or property.">O segundo método a ser chamado para codificar o nome do campo ou da propriedade.</param>
      <param name="literal" vsli:raw="The method to call third to encode the literal value of the argument.">O terceiro método a ser chamado para codificar o valor literal do argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" vsli:raw="" />
      <param name="hasVarArgs" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" vsli:raw="" />
      <param name="encodedArguments" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary vsli:raw="Represents the builder of a Portable PDB image.">Representa o construtor de uma imagem PDB portátil.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary vsli:raw="Creates a builder of a Portable PDB image.">Cria um construtor de uma imagem PDB portátil.</summary>
      <param name="tablesAndHeaps" vsli:raw="A builder populated with debug metadata entities stored in tables and values stored in heaps. The entities and values are enumerated when serializing the Portable PDB image.">Um construtor preenchido com entidades de metadados de depuração armazenadas em tabelas e valores armazenados em heaps. As entidades e os valores são enumerados ao serializar a imagem PDB portátil.</param>
      <param name="typeSystemRowCounts" vsli:raw="The row counts of all tables that the associated type system metadata contain. Each slot in the array corresponds to a table (&lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.TableIndex&quot; /&gt;). The length of the array must be equal &lt;see cref=&quot;F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount&quot; /&gt;.">As contagens de linhas de todas as tabelas que os metadados do sistema de tipo associado contêm. Cada slot na matriz corresponde a uma tabela (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). O comprimento da matriz deve ser igual a <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.</param>
      <param name="entryPoint" vsli:raw="An entry point method definition handle.">Um identificador de definição de método de ponto de entrada.</param>
      <param name="idProvider" vsli:raw="A function that calculates the ID of content represented as a sequence of blobs. If not specified, a default function that ignores the content and returns a content ID based on the current time is used (&lt;see cref=&quot;M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider&quot; /&gt;). You must specify a deterministic function to produce a deterministic Portable PDB image.">Uma função que calcula a ID de conteúdo representada como uma sequência de blobs. Se não for especificado, será usada uma função padrão que ignora o conteúdo e retorna uma ID de conteúdo com base na hora atual (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Você deve especificar uma função determinística para produzir uma imagem PDB portátil determinística.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;tablesAndHeaps&quot; /&gt; or &lt;paramref name=&quot;typeSystemRowCounts&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="tablesAndHeaps" /> ou <paramref name="typeSystemRowCounts" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary vsli:raw="Serializes portable PDB content into the given &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Serializa o conteúdo PDB portátil no <see cref="T:System.Reflection.Metadata.BlobBuilder" /> fornecido.</summary>
      <param name="builder" vsli:raw="The builder to write to.">O construtor no qual gravar.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;builder&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="builder" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The ID of the serialized content.">A ID do conteúdo serializado.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary vsli:raw="Encodes a constant literal.">Codifica um literal constante.</summary>
      <param name="value" vsli:raw="A constant of type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;, &lt;see cref=&quot;T:System.Byte&quot; /&gt;, &lt;see cref=&quot;T:System.SByte&quot; /&gt;, &lt;see cref=&quot;T:System.Int16&quot; /&gt;, &lt;see cref=&quot;T:System.UInt16&quot; /&gt;, &lt;see cref=&quot;T:System.Int32&quot; /&gt;, &lt;see cref=&quot;T:System.UInt32&quot; /&gt;, &lt;see cref=&quot;T:System.Int64&quot; /&gt;, &lt;see cref=&quot;T:System.UInt64&quot; /&gt;, &lt;see cref=&quot;T:System.Single&quot; /&gt;, &lt;see cref=&quot;T:System.Double&quot; /&gt;, &lt;see cref=&quot;T:System.Char&quot; /&gt; (encoded as a two-byte Unicode character), &lt;see cref=&quot;T:System.String&quot; /&gt; (encoded as SerString), or &lt;see cref=&quot;T:System.Enum&quot; /&gt; (encoded as the underlying integer value).">Uma constante do tipo <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (codificada como um caractere Unicode de dois bytes), <see cref="T:System.String" /> (codificado como SerString) ou <see cref="T:System.Enum" /> (codificado como o valor inteiro subjacente).</param>
      <exception cref="T:System.ArgumentException" vsli:raw="Unexpected constant type.">Tipo de constante inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary vsli:raw="Encodes a &lt;see langword=&quot;null&quot; /&gt; literal of type &lt;see cref=&quot;T:System.Array&quot; /&gt;.">Codifica um literal <see langword="null" /> do tipo <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary vsli:raw="Encodes a literal of type &lt;see cref=&quot;T:System.Type&quot; /&gt; (which can possibly be &lt;see langword=&quot;null&quot; /&gt;).">Codifica um literal do tipo <see cref="T:System.Type" /> (que pode ser <see langword="null" />).</summary>
      <param name="serializedTypeName" vsli:raw="The name of the type, or &lt;see langword=&quot;null&quot; /&gt;.">O nome do tipo ou <see langword="null" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;serializedTypeName&quot; /&gt; is empty.">
        <paramref name="serializedTypeName" /> está vazio.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary vsli:raw="Decodes signature blobs.">Decodifica blobs de assinatura.</summary>
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary vsli:raw="Creates a new &lt;see cref=&quot;T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2&quot; /&gt;.">Cria um novo <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider" vsli:raw="The provider used to obtain type symbols as the signature is decoded.">O provedor usado para obter símbolos de tipo quando a assinatura é decodificada.</param>
      <param name="metadataReader" vsli:raw="The metadata reader from which the signature was obtained. It may be &lt;see langword=&quot;null&quot; /&gt; if the given provider allows it.">O leitor de metadados do qual a assinatura foi obtida. Pode ser <see langword="null" /> caso o provedor fornecido permita.</param>
      <param name="genericContext" vsli:raw="Additional context needed to resolve generic parameters.">Contexto adicional necessário para resolver parâmetros genéricos.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a field signature blob and advances the reader past the signature.">Decodifica um blob de assinatura de campo e avança o leitor após a assinatura.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a field signature.">O leitor de blob posicionado em uma assinatura de campo.</param>
      <returns vsli:raw="The decoded field type.">O tipo de campo decodificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a local variable signature blob and advances the reader past the signature.">Decodifica um blob de assinatura de variável local e avança o leitor após a assinatura.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at a local variable signature.">O leitor de blob posicionado em uma assinatura de variável local.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The local variable signature is invalid.">A assinatura da variável local é inválida.</exception>
      <returns vsli:raw="The local variable types.">Os tipos de variáveis locais.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method (definition, reference, or standalone) or a property signature blob.">Decodifica um método (definição, referência ou autônomo) ou um blob de assinatura de propriedade.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a method signature.">Um leitor de blob posicionado em uma assinatura de método.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The method signature is invalid.">A assinatura do método é inválida.</exception>
      <returns vsli:raw="The decoded method signature.">A assinatura do método decodificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary vsli:raw="Decodes a method specification signature blob and advances the reader past the signature.">Decodifica um blob de assinatura de especificação de método e avança o leitor após a assinatura.</summary>
      <param name="blobReader" vsli:raw="A blob reader positioned at a valid method specification signature.">Um leitor de blob posicionado em uma assinatura de especificação de método válida.</param>
      <returns vsli:raw="The types used to instantiate a generic method via the method specification.">Os tipos usados para instanciar um método genérico por meio da especificação do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary vsli:raw="Decodes a type embedded in a signature and advances the reader past the type.">Decodifica um tipo inserido na assinatura e avança o leitor após o tipo.</summary>
      <param name="blobReader" vsli:raw="The blob reader positioned at the leading &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureTypeCode&quot; /&gt;.">O leitor de blob posicionado no entrelinhamento <see cref="T:System.Reflection.Metadata.SignatureTypeCode" />.</param>
      <param name="allowTypeSpecifications" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to allow a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt; to follow a (CLASS | VALUETYPE) in the signature; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> para permitir que um <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> siga uma (CLASS | VALUETYPE) na assinatura; caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The reader was not positioned at a valid signature type.">O leitor não estava posicionado em um tipo de assinatura válido.</exception>
      <returns vsli:raw="The decoded type.">O tipo decodificado.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt; where the signature will be written." />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary vsli:raw="Encodes an array type.">Codifica um tipo de matriz.</summary>
      <param name="elementType" vsli:raw="Called first, to encode the type of the element.">Chamado primeiro, para codificar o tipo do elemento.</param>
      <param name="arrayShape" vsli:raw="Called second, to encode the shape of the array.">Chamado em segundo lugar, para codificar a forma da matriz.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;elementType&quot; /&gt; or &lt;paramref name=&quot;arrayShape&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="elementType" /> ou <paramref name="arrayShape" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary vsli:raw="Encodes an array type. Returns a pair of encoders that must be used in the order they appear in the parameter list.">Codifica um tipo de matriz. Retorna um par de codificadores que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="elementType" vsli:raw="Use first, to encode the type of the element.">Use primeiro, para codificar o tipo do elemento.</param>
      <param name="arrayShape" vsli:raw="Use second, to encode the shape of the array.">Use em segundo lugar, para codificar a forma da matriz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary vsli:raw="Starts a signature of a type with custom modifiers.">Inicia a assinatura de um tipo com modificadores personalizados.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary vsli:raw="Starts a function pointer signature.">Inicia uma assinatura de ponteiro de função.</summary>
      <param name="convention" vsli:raw="Calling convention.">Convenção de chamada.</param>
      <param name="attributes" vsli:raw="Function pointer attributes.">Atributos de ponteiro de função.</param>
      <param name="genericParameterCount" vsli:raw="Generic parameter count.">Contagem de parâmetros genéricos.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;attributes&quot; /&gt; is invalid.">
        <paramref name="attributes" /> é inválido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericParameterCount&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="genericParameterCount" /> não está no intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary vsli:raw="Starts a generic instantiation signature.">Inicia uma assinatura de instanciação genérica.</summary>
      <param name="genericType" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount" vsli:raw="Generic argument count.">Contagem de argumentos genéricos.</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" /> para marcar o tipo como tipo de valor, <see langword="false" /> para marcá-lo como um tipo de referência na assinatura.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;genericType&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="genericType" /> não tem o tipo de identificador esperado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;genericArgumentCount&quot; /&gt; is not in range [1, 0xffff].">
        <paramref name="genericArgumentCount" /> não está no intervalo [1, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic method.">Codifica uma referência ao parâmetro de tipo de um método genérico que o contém.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">Índice de parâmetro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;parameterIndex&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="parameterIndex" /> não está no intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary vsli:raw="Encodes a reference to type parameter of a containing generic type.">Codifica uma referência ao parâmetro de tipo de um tipo genérico que o contém.</summary>
      <param name="parameterIndex" vsli:raw="Parameter index.">Índice de parâmetro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;parameterIndex&quot; /&gt; is not in range [0, 0xffff].">
        <paramref name="parameterIndex" /> não está no intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary vsli:raw="Starts pointer signature.">Inicia a assinatura do ponteiro.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Writes primitive type code.">Grava o código de tipo primitivo.</summary>
      <param name="type" vsli:raw="Any primitive type code except for &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference&quot; /&gt; and &lt;see cref=&quot;F:System.Reflection.Metadata.PrimitiveTypeCode.Void&quot; /&gt;.">Qualquer código de tipo primitivo, exceto <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> e <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; is not valid in this context.">
        <paramref name="type" /> não é válido neste contexto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary vsli:raw="Starts SZ array (vector) signature.">Inicia a assinatura da matriz SZ (vetor).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary vsli:raw="Encodes a reference to a type.">Codifica uma referência a um tipo.</summary>
      <param name="type" vsli:raw="&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;.">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to mark the type as value type, &lt;see langword=&quot;false&quot; /&gt; to mark it as a reference type in the signature.">
        <see langword="true" /> para marcar o tipo como tipo de valor, <see langword="false" /> para marcá-lo como um tipo de referência na assinatura.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;type&quot; /&gt; doesn't have the expected handle kind.">
        <paramref name="type" /> não tem o tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary vsli:raw="Encodes a void pointer (&lt;c&gt;void*&lt;/c&gt;).">Codifica um ponteiro nulo (<c>nulo*</c>).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary vsli:raw="Represents a metadata entity (such as a type reference, type definition, type specification, method definition, or custom attribute).">Representa uma entidade de metadados (como uma referência de tipo, definição de tipo, especificação de tipo, definição de método ou atributo personalizado).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified object are equal.">Retorna um valor que indica se a instância atual e o objeto especificado são iguais.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">O objeto a ser comparado com a instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is an &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> for um <see cref="T:System.Reflection.Metadata.EntityHandle" /> e for igual a essa instância atual, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Returns a value that indicates whether the current instance and the specified &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; are equal.">Retorna um valor que indica se a instância atual e o <see cref="T:System.Reflection.Metadata.EntityHandle" /> especificado são iguais.</summary>
      <param name="other" vsli:raw="The value to compare with the current instance.">O valor a ser comparado à instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance and &lt;paramref name=&quot;other&quot; /&gt; are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a instância atual e <paramref name="other" /> forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retorna o código hash para a instância.</summary>
      <returns vsli:raw="The hash code for this instance.">O código hash para essa instância.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary vsli:raw="Gets a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, or a nil token otherwise (&lt;see langword=&quot;default&quot; /&gt;(&lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt;)).">Obtém um identificador TypeSpec, TypeDef ou TypeRef quando a região representa uma captura ou um token nulo, caso contrário [<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)].</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary vsli:raw="Gets the IL offset of the start of the filter block, or -1 if the region is not a filter.">Obtém o deslocamento IL do início do bloco de filtro ou -1, quando a região não é um filtro.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary vsli:raw="Gets the length in bytes of the exception handler.">Obtém o comprimento do manipulador de exceção, em bytes.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary vsli:raw="Gets the starting IL offset of the exception handler.">Obtém o deslocamento IL inicial do manipulador de exceção.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary vsli:raw="Gets the length in bytes of the try block.">Obtém o comprimento do bloco try, em bytes.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary vsli:raw="Gets the starting IL offset of the try block.">Obtém o deslocamento IL inicial do bloco try.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary vsli:raw="Gets a handle to resolve the implementation of the target type.">Obtém um identificador para resolver a implementação do tipo de destino.</summary>
      <returns vsli:raw="&lt;list type=&quot;bullet&quot;&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyFileHandle&quot; /&gt; representing another module in the assembly.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.AssemblyReferenceHandle&quot; /&gt; representing another assembly if &lt;see cref=&quot;P:System.Reflection.Metadata.ExportedType.IsForwarder&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;description&gt;&lt;see cref=&quot;T:System.Reflection.Metadata.ExportedTypeHandle&quot; /&gt; representing the declaring exported type in which this was is nested.&lt;/description&gt;&lt;/item&gt;&lt;/list&gt;">
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> representando outro módulo no assembly.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> representando outro assembly, se <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> for <see langword="true" /> .</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> representando o tipo exportado declarativo no qual ele foi aninhado.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary vsli:raw="Gets the name of the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Obtém o nome do tipo de destino ou <see langword="default" /> se o tipo estiver aninhado ou definido em um namespace raiz.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.StringHandle&quot; /&gt; struct instance.">Uma <see cref="T:System.Reflection.Metadata.StringHandle" /> instância de struct.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary vsli:raw="Gets the full name of the namespace that contains the target type, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Obtém o nome completo do namespace que contém o tipo de destino ou <see langword="default" /> se o tipo estiver aninhado ou definido em um namespace raiz.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the target type is defined, or &lt;see langword=&quot;default&quot; /&gt; if the type is nested or defined in a root namespace.">Obtém o identificador de definição do namespace em que o tipo de destino está definido ou <see langword="default" /> se o tipo estiver aninhado ou definido em um namespace raiz.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">Representa uma coleção de instâncias <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary vsli:raw="Returns the field layout offset, or -1 if it is not available.">Retorna o deslocamento de layout de campo ou -1 se ele não está disponível.</summary>
      <returns vsli:raw="The field definition offset, or -1 if it is not available.">O deslocamento de definição de campo ou -1 se ele não estiver disponível.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary vsli:raw="Gets the attributes specifying variance and constraints.">Obtém os atributos que especificam a variação e as restrições.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary vsli:raw="Gets the zero-based index of the parameter within the declaring generic type or method declaration.">Obtém o índice baseado em zero do parâmetro no tipo genérico declarativo ou na declaração de método.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary vsli:raw="Gets the name of the generic parameter.">Obtém o nome do parâmetro genérico.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinitionHandle&quot; /&gt; that represents the parent of this generic parameter.">Obtém um <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> que representa o pai desse parâmetro genérico.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary vsli:raw="Gets the constrained &lt;see cref=&quot;T:System.Reflection.Metadata.GenericParameterHandle&quot; /&gt;.">Obtém o <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> restrito.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary vsli:raw="Gets a handle (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;) &#xA;            specifying from which type this generic parameter is constrained to derive,&#xA;            or which interface this generic parameter is constrained to implement.">Obtém um identificador (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) que especifica de qual tipo esse parâmetro genérico é restrito a ser derivado ou em qual interface esse parâmetro genérico é restrito a implementar.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; instance.">Uma instância <see cref="T:System.Reflection.Metadata.EntityHandle" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary vsli:raw="Represents a collection of constraints of a generic type parameter.">Representa uma coleção de restrições de um parâmetro de tipo genérico.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary vsli:raw="Gets the element at the specified index in the read-only list.">Obtém o elemento no índice especificado na lista somente leitura.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get.">O índice baseado em zero do elemento a ser obtido.</param>
      <returns vsli:raw="The element at the specified index in the read-only list.">O elemento no índice especificado na lista somente leitura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary vsli:raw="Represents a collection of generic type parameters of a method or type.">Representa uma coleção de parâmetros de tipo genérico de um método ou tipo.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary vsli:raw="Gets the element at the specified index in the read-only list.">Obtém o elemento no índice especificado na lista somente leitura.</summary>
      <param name="index" vsli:raw="The zero-based index of the element to get.">O índice baseado em zero do elemento a ser obtido.</param>
      <returns vsli:raw="The element at the specified index in the read-only list.">O elemento no índice especificado na lista somente leitura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary vsli:raw="Represents any metadata entity (such as a type reference, a type definition, a type specification, a method definition, or a custom attribute) or value (a string, blob, guid, or user string).">Representa qualquer entidade de metadados (como uma referência de tipo, uma definição de tipo, uma especificação de tipo, uma definição de método ou um atributo personalizado) ou um valor (uma cadeia de caracteres, um blob, um GUID ou uma cadeia de caracteres de usuário).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Compares two entity handles.">Compara dois identificadores de entidade.</summary>
      <param name="x" vsli:raw="The first entity handle to compare.">O primeiro identificador de entidade a ser comparado.</param>
      <param name="y" vsli:raw="The second entity handle to compare.">O segundo identificador de entidade a ser comparado.</param>
      <returns vsli:raw="Zero if the two entity handles are equal, and a non-zero value of they are not.">Zero se os dois identificadores de entidade forem iguais e um valor diferente de zero se não forem.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Compares two handles.">Compara dois identificadores.</summary>
      <param name="x" vsli:raw="The first handle to compare.">O primeiro identificador a ser comparado.</param>
      <param name="y" vsli:raw="The second handle to compare.">O segundo identificador a ser comparado.</param>
      <returns vsli:raw="Zero if the two handles are equal, and a non-zero value if they are not.">Zero se os dois identificadores forem iguais e um valor diferente de zero se não forem.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Determines whether the specified objects are equal.">Determina se os objetos especificados são iguais.</summary>
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">O primeiro objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">O segundo objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os objetos especificados forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Determines whether the specified objects are equal.">Determina se os objetos especificados são iguais.</summary>
      <param name="x" vsli:raw="The first object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">O primeiro objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <param name="y" vsli:raw="The second object of type &lt;paramref name=&quot;T&quot; /&gt; to compare.">O segundo objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os objetos especificados forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary vsli:raw="Returns a hash code for the specified object.">Retorna um código hash para o objeto especificado.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned.">O <see cref="T:System.Object" /> para o qual um código hash deve ser retornado.</param>
      <returns vsli:raw="A hash code for the specified object.">Um código hash para o objeto especificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary vsli:raw="Returns a hash code for the specified object.">Retorna um código hash para o objeto especificado.</summary>
      <param name="obj" vsli:raw="The &lt;see cref=&quot;T:System.Object&quot; /&gt; for which a hash code is to be returned.">O <see cref="T:System.Object" /> para o qual um código hash deve ser retornado.</param>
      <returns vsli:raw="A hash code for the specified object.">Um código hash para o objeto especificado.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary vsli:raw="Gets the type symbol for a generalized array of the given element type and shape.">Obtém o símbolo de tipo de uma matriz generalizada do tipo de elemento e da forma especificados.</summary>
      <param name="elementType" vsli:raw="The type of the elements in the array.">O tipo dos elementos na matriz.</param>
      <param name="shape" vsli:raw="The shape (rank, sizes, and lower bounds) of the array.">A forma (classificação, tamanhos e limites inferiores) da matriz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary vsli:raw="Gets the type symbol for a managed pointer to the given element type.">Obtém o símbolo de tipo de um ponteiro gerenciado para o tipo de elemento especificado.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Gets the type symbol for a generic instantiation of the given generic type with the given type arguments.">Obtém o símbolo de tipo de uma criação de instância genérica do tipo genérico especificado com os argumentos de tipo especificados.</summary>
      <param name="genericType" vsli:raw="" />
      <param name="typeArguments" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary vsli:raw="Gets the type symbol for an unmanaged pointer to the given element type.">Obtém o símbolo de tipo de um ponteiro não gerenciado para o tipo de elemento especificado.</summary>
      <param name="elementType" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary vsli:raw="Gets the &lt;typeparamref name=&quot;TType&quot; /&gt; representation for &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Obtém a representação de <typeparamref name="TType" /> para <see cref="T:System.Type" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary vsli:raw="Gets the type symbol for the given serialized type name.">Obtém o símbolo de tipo do nome do tipo serializado.</summary>
      <param name="name" vsli:raw="The serialized type name in so-called &quot;reflection notation&quot; format (as understood by the &lt;see cref=&quot;M:System.Type.GetType(System.String)&quot; /&gt; method.)">O nome do tipo serializado no chamado formato de "notação de reflexão" (conforme reconhecido pelo método <see cref="M:System.Type.GetType(System.String)" />.)</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The name is malformed.">O nome está malformado.</exception>
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">Uma instância de <typeparamref name="TType" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary vsli:raw="Gets the underlying type of the given enum type symbol.">Obtém o tipo subjacente do símbolo de tipo enumerado especificado.</summary>
      <param name="type" vsli:raw="An enum type.">Um tipo enumerado.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The given type symbol does not represent an enum.">O símbolo de tipo fornecido não representa uma enumeração.</exception>
      <returns vsli:raw="A type code that indicates the underlying type of the enumeration.">Um código de tipo que indica o tipo subjacente da enumeração.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary vsli:raw="Verifies if the given type represents &lt;see cref=&quot;T:System.Type&quot; /&gt;.">Verifica se o tipo especificado representa <see cref="T:System.Type" />.</summary>
      <param name="type" vsli:raw="The type to verify.">O tipo a ser verificado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given type is a &lt;see cref=&quot;T:System.Type&quot; /&gt;, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se o tipo fornecido for um <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Calculates the size of the specified branch instruction operand.">Calcula o tamanho do operando de instrução de branch especificado.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">O código op do branch.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">O <paramref name="opCode" /> especificado não é um código op do branch.</exception>
      <returns vsli:raw="1 if &lt;paramref name=&quot;opCode&quot; /&gt; is a short branch, or 4 if it is a long branch.">1 se <paramref name="opCode" /> for um branch curto ou 4 se ele for um branch longo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a long form of the specified branch op-code.">Obtém uma forma longa do código op do branch especificado.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">O código op do branch.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">O <paramref name="opCode" /> especificado não é um código op do branch.</exception>
      <returns vsli:raw="The long form of the branch op-code.">A forma longa do código op do branch.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Gets a short form of the specified branch op-code.">Obtém uma forma abreviada do código op do branch especificado.</summary>
      <param name="opCode" vsli:raw="The branch op-code.">O código op do branch.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The specified &lt;paramref name=&quot;opCode&quot; /&gt; is not a branch op-code.">O <paramref name="opCode" /> especificado não é um código op do branch.</exception>
      <returns vsli:raw="The short form of the branch op-code.">A forma abreviada do código op do branch.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary vsli:raw="Verifies if the specified op-code is a branch to a label.">Verifica se o código op especificado é um branch de um rótulo.</summary>
      <param name="opCode" vsli:raw="" />
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the specified op-code is a branch to a label, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se o código op especificado for um branch de um rótulo; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary vsli:raw="The exception that is thrown when an attempt to write metadata exceeds a limit given by the format specification. For example, when the heap size limit is exceeded.">A exceção que é gerada quando uma tentativa de gravar metadados excede um limite fornecido pela especificação de formato. Por exemplo, quando o limite de tamanho do heap é excedido.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with serialized data.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> com dados serializados.</summary>
      <param name="info" vsli:raw="The object that holds the serialized object data.">O objeto que mantém os dados de objeto serializados.</param>
      <param name="context" vsli:raw="The contextual information about the source or destination.">As informações contextuais sobre a origem ou o destino.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> com uma mensagem de erro especificada.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">A mensagem de erro que explica a razão desta exceção.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.ImageFormatLimitationException&quot; /&gt; class with a specified error message and the exception that is the cause of this exception.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> com uma mensagem de erro especificada e a exceção interna que é a causa desta exceção.</summary>
      <param name="message" vsli:raw="The error message that explains the reason for this exception.">A mensagem de erro que explica a razão desta exceção.</param>
      <param name="innerException" vsli:raw="The exception that is the cause of the current exception, or &lt;see langword=&quot;null&quot; /&gt; if no inner exception is specified.">A exceção que é a causa da exceção atual ou <see langword="null" />, se nenhuma exceção interna for especificada.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Invalid blob format.">Formato de blob inválido.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary vsli:raw="Provides information about the lexical scope within which a group of imports are available. This information is stored in debug metadata.">Fornece informações sobre o escopo léxico no qual um grupo de importações está disponível. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary vsli:raw="Gets the interface that is implemented (&lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt;, or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;).">Obtém a interface implementada (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary vsli:raw="Gets the type symbol for the function pointer type of the given method &lt;paramref name=&quot;signature&quot; /&gt;.">Obtém o símbolo de tipo para o tipo de ponteiro de função do método <paramref name="signature" /> determinado.</summary>
      <param name="signature" vsli:raw="" />
      <returns vsli:raw="The type symbol for the function pointer type.">O símbolo de tipo para o tipo de ponteiro de função.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic method parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Obtém o símbolo de tipo para o parâmetro de método genérico no <paramref name="index" /> baseado em zero determinado.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic method parameter at &lt;paramref name=&quot;index&quot; /&gt;.">O símbolo de tipo para o parâmetro de método genérico em <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary vsli:raw="Gets the type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">Obtém o símbolo de tipo para o parâmetro de tipo genérico no <paramref name="index" /> baseado em zero determinado.</summary>
      <param name="genericContext" vsli:raw="" />
      <param name="index" vsli:raw="" />
      <returns vsli:raw="The type symbol for the generic type parameter at the given zero-based &lt;paramref name=&quot;index&quot; /&gt;.">O símbolo de tipo para o parâmetro de tipo genérico no <paramref name="index" /> baseado em zero determinado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary vsli:raw="Gets the type symbol for a type with a custom modifier applied.">Obtém o símbolo de tipo para um tipo com um modificador personalizado aplicado.</summary>
      <param name="modifier" vsli:raw="The modifier type applied.">O tipo de modificador aplicado.</param>
      <param name="unmodifiedType" vsli:raw="The type symbol of the underlying type without modifiers applied.">O símbolo de tipo do tipo subjacente sem modificadores aplicados.</param>
      <param name="isRequired" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the modifier is required, &lt;see langword=&quot;false&quot; /&gt; if it's optional.">
        <see langword="true" /> se o modificador for necessário, <see langword="false" /> se for opcional.</param>
      <returns vsli:raw="The type symbol.">O símbolo de tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary vsli:raw="Gets the type symbol for a local variable type that is marked as pinned.">Obtém o símbolo de tipo para um tipo de variável local que está marcado como fixado.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="The type symbol for the local variable type.">O símbolo de tipo para o tipo de variável local.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type specification.">Obtém o símbolo de tipo para uma especificação de tipo.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">O leitor de metadados que foi passado para o decodificador de assinatura. Pode ser <see langword="null" />.</param>
      <param name="genericContext" vsli:raw="The context that was passed to the signature decoder.">O contexto que foi passado para o decodificador de assinatura.</param>
      <param name="handle" vsli:raw="The type specification handle.">O identificador de especificação de tipo.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">A espécie do tipo, conforme especificado na assinatura. Para interpretar esse valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol for the type specification.">O símbolo de tipo para a especificação de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary vsli:raw="Gets the type symbol for a primitive type.">Obtém o símbolo de tipo para um tipo primitivo.</summary>
      <param name="typeCode" vsli:raw="" />
      <returns vsli:raw="The type symbol for &lt;paramref name=&quot;typeCode&quot; /&gt;.">O símbolo de tipo para <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type definition.">Obtém o símbolo de tipo para uma definição de tipo.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">O leitor de metadados que foi passado para o decodificador de assinatura. Pode ser <see langword="null" />.</param>
      <param name="handle" vsli:raw="The type definition handle.">O identificador de definição de tipo.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type, as specified in the signature. To interpret this value use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">A espécie do tipo, conforme especificado na assinatura. Para interpretar esse valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol.">O símbolo de tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary vsli:raw="Gets the type symbol for a type reference.">Obtém o símbolo de tipo para uma referência de tipo.</summary>
      <param name="reader" vsli:raw="The metadata reader that was passed to the signature decoder. It may be &lt;see langword=&quot;null&quot; /&gt;.">O leitor de metadados que foi passado para o decodificador de assinatura. Pode ser <see langword="null" />.</param>
      <param name="handle" vsli:raw="The type definition handle.">O identificador de definição de tipo.</param>
      <param name="rawTypeKind" vsli:raw="The kind of the type as specified in the signature. To interpret this value, use &lt;see cref=&quot;M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)&quot; /&gt;.">A espécie do tipo, conforme especificado na assinatura. Para interpretar esse valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns vsli:raw="The type symbol.">O símbolo de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary vsli:raw="Gets the type symbol for a single-dimensional array of the given element type with a lower bounds of zero.">Obtém o símbolo de tipo de uma matriz unidimensional do tipo de elemento especificado com um limite inferior igual a zero.</summary>
      <param name="elementType" vsli:raw="" />
      <returns vsli:raw="A &lt;typeparamref name=&quot;TType&quot; /&gt; instance.">Uma instância de <typeparamref name="TType" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary vsli:raw="Provides information about local constants. This information is stored in debug metadata.">Fornece informações sobre constantes locais. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary vsli:raw="Gets the constant signature.">Obtém a assinatura constante.</summary>
      <returns vsli:raw="The constant signature.">A assinatura constante.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary vsli:raw="Provides information about the scope of local variables and constants. This information is stored in debug metadata.">Fornece informações sobre o escopo de variáveis e constantes locais. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary vsli:raw="Provides information about local variables. This information is stored in debug metadata.">Fornece informações sobre variáveis locais. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary vsli:raw="Gets the manifest resource attributes.">Obtém os atributos do recurso de manifesto.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that specify the manifest resource attributes.">Uma combinação de bits de bit que especifica os atributos de recurso de manifesto.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary vsli:raw="Gets the implementation entity handle.">Obtém o identificador da entidade de implementação.</summary>
      <returns vsli:raw="An EntityHandle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">Uma instância de EntityHandle. Se a <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propriedade for <see langword="true" /> , o identificador retornado terá valores padrão.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary vsli:raw="Gets the resource name.">Obtém o nome do recurso.</summary>
      <returns vsli:raw="The resource name.">O nome do recurso.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary vsli:raw="Gets the byte offset within the referenced file at which this resource record begins.">Obtém o deslocamento de bytes no arquivo referenciado no qual este registro de recurso começa.</summary>
      <returns vsli:raw="The byte offset within the referenced file at which this resource record begins.">O deslocamento de byte dentro do arquivo referenciado no qual este registro de recurso começa.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.ManifestResourceHandle&quot; /&gt; instances.">Representa uma coleção de instâncias <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary vsli:raw="Determines if the member reference is to a method or field.">Determina se a referência de membro é um método ou um campo.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The member reference signature is invalid.">A assinatura de referência de membro é inválida.</exception>
      <returns vsli:raw="One of the enumeration values that indicates the kind of member reference.">Um dos valores de enumeração que indica o tipo de referência de membro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary vsli:raw="Gets the parent entity handle.">Obtém o identificador da entidade pai.</summary>
      <returns vsli:raw="An entity handle instance. If the &lt;see cref=&quot;P:System.Reflection.Metadata.EntityHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;, the returned handle will have default values.">Uma instância de identificador de entidade. Se a <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propriedade for <see langword="true" /> , o identificador retornado terá valores padrão.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Obtém um identificador para o blob de assinatura.</summary>
      <returns vsli:raw="A handle to the signature blob.">Um identificador para o blob de assinatura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary vsli:raw="Represents a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReferenceHandle&quot; /&gt; instances.">Representa uma coleção de instâncias <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary vsli:raw="Specifies constants that indicate whether a &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method or field.">Especifica as constantes que indicam se um <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a um método ou campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a field.">O <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a um campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a method.">O <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a um método.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary vsli:raw="CLI metadata.">Metadados da CLI.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary vsli:raw="Windows metadata generated by managed compilers.">Metadados do Windows gerados por compiladores gerenciados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary vsli:raw="Windows metadata.">Metadados do Windows.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary vsli:raw="Reads metadata as defined by the ECMA 335 CLI specification.">Lê os metadados conforme definido pela especificação de CLI do ECMA 335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> usando os metadados armazenados no local da memória determinado.</summary>
      <param name="metadata" vsli:raw="A pointer to the first byte in a block of metadata.">Um ponteiro para o primeiro byte em um bloco de metadados.</param>
      <param name="length" vsli:raw="The number of bytes in the block.">O número de bytes no bloco.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> usando os metadados armazenados no local da memória determinado.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; class from the metadata stored at the given memory location.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> usando os metadados armazenados no local da memória determinado.</summary>
      <param name="metadata" vsli:raw="" />
      <param name="length" vsli:raw="" />
      <param name="options" vsli:raw="" />
      <param name="utf8Decoder" vsli:raw="" />
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;length&quot; /&gt; is not positive.">
        <paramref name="length" /> não é positivo.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;metadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="metadata" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">A codificação de <paramref name="utf8Decoder" /> não é <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">A plataforma atual é big endian.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad metadata header.">Cabeçalho de metadados inválido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary vsli:raw="Gets the information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">Obtém as informações decodificadas de fluxo #Pdb ou <see langword="null" /> quando o fluxo não está presente.</summary>
      <returns vsli:raw="The information decoded from #Pdb stream, or &lt;see langword=&quot;null&quot; /&gt; if the stream is not present.">As informações decodificadas de #Pdb Stream ou <see langword="null" /> se o fluxo não estiver presente.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary vsli:raw="Gets a value that indicates whether the metadata represents an assembly.">Obtém um valor que indica se os metadados representam um assembly.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the metadata represents an assembly; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se os metadados representarem um assembly; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary vsli:raw="Gets the metadata kind.">Obtém o tipo de metadados.</summary>
      <returns vsli:raw="One of the enumeration values that specifies the metadata kind.">Um dos valores de enumeração que especifica o tipo de metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary vsli:raw="Gets the length of the underlying data.">Obtém o comprimento dos dados subjacentes.</summary>
      <returns vsli:raw="The length of the underlying data.">O comprimento dos dados subjacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary vsli:raw="Gets the pointer to the underlying data.">Obtém o ponteiro para os dados subjacentes.</summary>
      <returns vsli:raw="The pointer to the underlying data.">O ponteiro para os dados subjacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary vsli:raw="Gets the version string read from metadata header.">Obtém a leitura da cadeia de caracteres de versão do cabeçalho de metadados.</summary>
      <returns vsli:raw="The version string read from metadata header.">A cadeia de caracteres de versão lida do cabeçalho de metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; passed to the constructor.">Obtém o <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> passado para o construtor.</summary>
      <returns vsli:raw="A bitwise combination of the enumeration values that describes the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; enum value.">Uma combinação de bits de bit que descreve os valores de enumeração que descrevem o <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> valor de enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary vsli:raw="Gets the comparer used to compare strings stored in metadata.">Obtém o comparador usado para comparar as cadeias de caracteres armazenadas nos metadados.</summary>
      <returns vsli:raw="The comparer used to compare strings stored in metadata.">O comparador usado para comparar cadeias de caracteres armazenadas em metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary vsli:raw="Gets the decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">Obtém o decodificador usado pelo leitor para produzir instâncias de cadeia de caracteres de sequências de bytes codificados em UTF8.</summary>
      <returns vsli:raw="The decoder used by the reader to produce string instances from UTF8-encoded byte sequences.">O decodificador usado pelo leitor para produzir instâncias de cadeia de caracteres de sequências de bytes codificadas em UTF8.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary vsli:raw="Windows Runtime projections are enabled (on by default).">As projeções do Windows Runtime estão habilitadas (ativadas por padrão).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary vsli:raw="The options that are used when a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; is obtained via an overload that does not take a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderOptions&quot; /&gt; argument.">As opções usadas quando um <see cref="T:System.Reflection.Metadata.MetadataReader" /> é obtido por meio de uma sobrecarga que não usa um argumento <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary vsli:raw="All options are disabled.">Todas as opções estão desabilitadas.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary vsli:raw="Provides a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; for metadata stored in an array of bytes, a memory block, or a stream.">Fornece um <see cref="T:System.Reflection.Metadata.MetadataReader" /> para metadados armazenados em uma matriz de bytes, um bloco de memória ou um fluxo.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">Descarta toda a memória alocada pelo leitor.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a metadata provider over an image stored in memory.">Cria um provedor de metadados sobre uma imagem armazenada na memória.</summary>
      <param name="start" vsli:raw="Pointer to the start of the metadata blob.">Ponteiro para o início do blob de metadados.</param>
      <param name="size" vsli:raw="The size of the metadata blob.">O tamanho do blob de metadados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> é negativo.</exception>
      <returns vsli:raw="The new metadata provider.">O novo provedor de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a provider over a byte array.">Cria um provedor ao longo de uma matriz de bytes.</summary>
      <param name="image" vsli:raw="Metadata image.">Imagem de metadados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The new provider.">O novo provedor.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">Cria um provedor para um fluxo do tamanho especificado começando na posição atual.</summary>
      <param name="stream" vsli:raw="A &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; instance.">Uma instância de <see cref="T:System.IO.Stream" />.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">Opções especificando como as seções da imagem são lidas do fluxo.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">Tamanho do blob de metadados no fluxo. Se não for especificado, presume-se que o blob de metadados abrangerá até o final do fluxo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> não é compatível com as operações de leitura e busca.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">O tamanho é negativo ou ultrapassa o final do fluxo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata&quot; /&gt; is specified).">Erro ao ler do fluxo (somente quando <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> é especificado).</exception>
      <returns vsli:raw="The new provider.">O novo provedor.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a portable PDB metadata provider over a blob stored in memory.">Cria um provedor de metadados PDB portátil em um blob armazenado na memória.</summary>
      <param name="start" vsli:raw="Pointer to the start of the portable PDB blob.">Ponteiro para o início do blob PDB portátil.</param>
      <param name="size" vsli:raw="The size of the portable PDB blob.">O tamanho do blob PDB portátil.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="start" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> é negativo.</exception>
      <returns vsli:raw="The new portable PDB metadata provider.">O novo provedor de metadados PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a portable PDB metadata provider over a byte array.">Cria um provedor de metadados PDB portátil em uma matriz de bytes.</summary>
      <param name="image" vsli:raw="A portable PDB image.">Uma imagem PDB portátil.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;image&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="image" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The new portable PDB metadata provider .">O novo provedor de metadados PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a provider for a stream of the specified size beginning at its current position.">Cria um provedor para um fluxo do tamanho especificado começando na posição atual.</summary>
      <param name="stream" vsli:raw="The stream.">O fluxo.</param>
      <param name="options" vsli:raw="Options specifying how sections of the image are read from the stream.">Opções especificando como as seções da imagem são lidas do fluxo.</param>
      <param name="size" vsli:raw="Size of the metadata blob in the stream. If not specified, the metadata blob is assumed to span to the end of the stream.">Tamanho do blob de metadados no fluxo. Se não for especificado, presume-se que o blob de metadados abrangerá até o final do fluxo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="stream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;stream&quot; /&gt; doesn't support read and seek operations.">
        <paramref name="stream" /> não é compatível com as operações de leitura e busca.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="Size is negative or extends past the end of the stream.">O tamanho é negativo ou ultrapassa o final do fluxo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; instance.">Uma instância de <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt;.">Obtém um <see cref="T:System.Reflection.Metadata.MetadataReader" /> de um <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
      <param name="options" vsli:raw="A bitwise combination of the enumeration values that represent the configuration when reading the metadata.">Uma combinação bit a bit dos valores de enumeração que representa a configuração ao ler os metadados.</param>
      <param name="utf8Decoder" vsli:raw="The encoding to use.">A codificação a ser usada.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">A codificação de <paramref name="utf8Decoder" /> não é <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.ObjectDisposedException" vsli:raw="Provider has been disposed.">O provedor foi descartado.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; instance.">Uma instância de <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed and sections of the PE image are read lazily.">Por padrão, o fluxo é descartado quando o <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> é descartado e as seções da imagem PE são lidas lentamente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is disposed.">Mantém o fluxo aberto quando o <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> é descartado.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads PDB metadata into memory right away.&lt;/para&gt;&lt;para&gt;The underlying file may be closed and even deleted after the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; is constructed. &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen&quot; /&gt; is specified.&lt;/para&gt;">
        <para>Lê os metadados PDB na memória imediatamente.</para>
        <para>O arquivo subjacente poderá ser fechado e até mesmo excluído depois que o <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> for construído. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> fecha o fluxo automaticamente quando o construtor retorna, a menos que <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> seja especificado.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary vsli:raw="Provides string comparison helpers to query strings in metadata while avoiding allocation if possible.">Fornece auxiliares de comparação de cadeias de caracteres para consultar cadeias em metadados enquanto evita a alocação, se possível.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" vsli:raw="" />
      <param name="value" vsli:raw="" />
      <param name="ignoreCase" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary vsli:raw="Provides the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; with a custom mechanism for decoding byte sequences in metadata that represent text.">Fornece o <see cref="T:System.Reflection.Metadata.MetadataReader" /> com um mecanismo personalizado para decodificar sequências de bytes em metadados que representam texto.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataStringDecoder&quot; /&gt; class using the given encoding.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> usando a codificação fornecida.</summary>
      <param name="encoding" vsli:raw="The encoding to use.">A codificação a ser usada.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary vsli:raw="Obtains strings for byte sequences in metadata. Override this to cache strings if required. Otherwise, it is implemented by forwarding straight to &lt;see cref=&quot;P:System.Reflection.Metadata.MetadataStringDecoder.Encoding&quot; /&gt; and every call will allocate a new string.">Obtém as cadeias de caracteres das sequências de bytes nos metadados. Substitua essa opção para armazenar cadeias de caracteres em cache, se necessário. Caso contrário, ela será implementada por encaminhamento direto para <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> e todas as chamadas alocarão uma nova cadeia de caracteres.</summary>
      <param name="bytes" vsli:raw="Pointer to bytes to decode.">Ponteiro para os bytes a serem decodificados.</param>
      <param name="byteCount" vsli:raw="Number of bytes to decode.">Número de bytes a serem decodificados.</param>
      <returns vsli:raw="The decoded string.">A cadeia de caracteres decodificada.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary vsli:raw="Gets the default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8 when no decoder is provided to the constructor.">Obtém o decodificador padrão usado pelo <see cref="T:System.Reflection.Metadata.MetadataReader" /> para decodificar o UTF-8 quando não é fornecido nenhum decodificador para o construtor.</summary>
      <returns vsli:raw="The default decoder used by &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; to decode UTF-8.">O decodificador padrão usado pelo <see cref="T:System.Reflection.Metadata.MetadataReader" /> para decodificar UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary vsli:raw="Gets the encoding used by this instance.">Obtém a codificação usada por essa instância.</summary>
      <returns vsli:raw="The encoding used by this instance.">A codificação usada por essa instância.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" vsli:raw="The blob reader to read the method body." />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary vsli:raw="Gets the size of the method body, including the header, IL, and exception regions.">Obtém o tamanho do corpo do método, incluindo as regiões de cabeçalho, IL e exceção.</summary>
      <returns vsli:raw="The size of the method body.">O tamanho do corpo do método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary vsli:raw="Provides debug information associated with a method definition. This information is stored in debug metadata.">Fornece informações de depuração associadas a uma definição de método. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary vsli:raw="Returns a collection of sequence points decoded from &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob&quot; /&gt;.">Retorna uma coleção de pontos de sequência decodificados de <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.</summary>
      <returns vsli:raw="A collection of sequence points.">Uma coleção de pontos de sequência.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary vsli:raw="Returns the kickoff method of the state machine.">Retorna o método inicial da máquina de estado.</summary>
      <returns vsli:raw="The kickoff method of the state machine, if the method is a &lt;c&gt;MoveNext&lt;/c&gt; method of a state machine. Otherwise, it returns a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;.">O método inicial da máquina de estado, se o método for um método <c>MoveNext</c> de uma máquina de estado. Caso contrário, ele retornará um identificador cuja propriedade <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> é <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary vsli:raw="Gets the handle of the single document containing all sequence points of the method.">Obtém o identificador do documento único que contém todos os pontos de sequência do método.</summary>
      <returns vsli:raw="The handle of the single document containing all sequence points of the method, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.DocumentHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points or spans multiple documents.">O identificador do único documento que contém todos os pontos de sequência do método ou um identificador cuja <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> propriedade é <see langword="true" /> se o método não tem pontos de sequência ou abrange vários documentos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary vsli:raw="Returns a local signature handle.">Retorna um identificador de assinatura local.</summary>
      <returns vsli:raw="A local signature handle, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't define any local variables.">Um identificador de assinatura local ou um identificador cuja <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> propriedade é <see langword="true" /> se o método não define nenhuma variável local.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary vsli:raw="Returns a blob encoding sequence points.">Retorna os pontos de sequência de codificação de blob.</summary>
      <returns vsli:raw="A blob encoding sequence points, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.BlobHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the method doesn't have sequence points.">Um ponto de sequência de codificação de BLOB ou um identificador cuja <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> propriedade é <see langword="true" /> se o método não tem pontos de sequência.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDefinition&quot; /&gt; that corresponds to this handle.">Retorna um identificador para um <see cref="T:System.Reflection.Metadata.MethodDefinition" /> correspondente a esse identificador.</summary>
      <returns vsli:raw="A method definition handle that corresponds to this handle.">Um identificador de definição de método que corresponde a esse identificador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary vsli:raw="Returns a handle to a &lt;see cref=&quot;T:System.Reflection.Metadata.MethodDebugInformation&quot; /&gt; that corresponds to this handle.">Retorna um identificador para um <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> correspondente a esse identificador.</summary>
      <returns vsli:raw="A method debug information handle that corresponds to this handle.">Um identificador de informações de depuração de método que corresponde a esse identificador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary vsli:raw="Represents a method (definition, reference, or standalone) or property signature. In the case of properties, the signature matches that of a getter with a distinguishing &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt;.">Representa um método (definição, referência ou autônomo) ou uma assinatura de propriedade. No caso de propriedades, a assinatura corresponde à de um getter com um <see cref="T:System.Reflection.Metadata.SignatureHeader" /> distinto.</summary>
      <typeparam name="TType" vsli:raw="The method type.">O tipo de método.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.MethodSignature`1&quot; /&gt; structure using the specified header, return type, and parameter information.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> usando as informações de cabeçalho, tipo de retorno e parâmetro especificadas.</summary>
      <param name="header" vsli:raw="The information in the leading byte of the signature (kind, calling convention, flags).">As informações no byte à esquerda da assinatura (tipo, convenção de chamada, sinalizadores).</param>
      <param name="returnType" vsli:raw="The return type of the method.">O tipo de retorno do método.</param>
      <param name="requiredParameterCount" vsli:raw="The number of required parameters.">O número de parâmetros necessários.</param>
      <param name="genericParameterCount" vsli:raw="The number of generic type parameters.">O número de parâmetros de tipo genérico.</param>
      <param name="parameterTypes" vsli:raw="The parameter types.">Os tipos de parâmetro.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary vsli:raw="Gets the number of generic type parameters for the method.">Obtém o número de parâmetros de tipo genérico para o método.</summary>
      <returns vsli:raw="The number of generic type parameters, or 0 for non-generic methods.">O número de parâmetros de tipo genérico ou 0 para métodos não genéricos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary vsli:raw="Gets the information in the leading byte of the signature (kind, calling convention, flags).">Obtém as informações no byte à esquerda da assinatura (tipo, convenção de chamada, sinalizadores).</summary>
      <returns vsli:raw="The header signature.">A assinatura do cabeçalho.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary vsli:raw="Gets the method's parameter types.">Obtém os tipos de parâmetro do método.</summary>
      <returns vsli:raw="An immutable collection of parameter types.">Uma coleção imutável de tipos de parâmetro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary vsli:raw="Gets the number of parameters that are required for the method.">Obtém o número de parâmetros necessários para o método.</summary>
      <returns vsli:raw="The number of required parameters.">O número de parâmetros necessários.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary vsli:raw="Gets the return type of the method.">Obtém o tipo retornado do método.</summary>
      <returns vsli:raw="The return type.">O tipo de retorno.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary vsli:raw="Gets a &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to (that is, which generic method it is an instantiation of).">Obtém um identificador <see langword="MethodDef" /> ou <see langword="MemberRef" /> que especifica a qual método genérico essa instância se refere (ou seja, de qual método genérico ela é uma criação de instância).</summary>
      <returns vsli:raw="A &lt;see langword=&quot;MethodDef&quot; /&gt; or &lt;see langword=&quot;MemberRef&quot; /&gt; handle specifying which generic method this instance refers to.">Um <see langword="MethodDef" /><see langword="MemberRef" /> identificador ou que especifica a qual método genérico essa instância se refere.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Obtém um identificador para o blob de assinatura.</summary>
      <returns vsli:raw="A handle to the signature blob.">Um identificador para o blob de assinatura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary vsli:raw="Gets all exported types that reside directly in a namespace.">Obtém todos os tipos exportados que residem diretamente em um namespace.</summary>
      <returns vsli:raw="An immutable array of exported type handles.">Uma matriz imutável de identificadores de tipo exportados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary vsli:raw="Gets the unqualified name of the namespace definition.">Obtém o nome não qualificado da definição do namespace.</summary>
      <returns vsli:raw="The unqualified name of the namespace definition.">O nome não qualificado da definição do namespace.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary vsli:raw="Gets the namespace definitions that are direct children of the current namespace definition.">Obtém as definições do namespace que são filhos diretos da definição do namespace atual.</summary>
      <returns vsli:raw="An immutable array of namespace definitions that are direct children of the current namespace definition.">Uma matriz imutável de definições de namespace que são filhos diretos da definição de namespace atual.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary vsli:raw="Gets the parent namespace.">Obtém o namespace pai.</summary>
      <returns vsli:raw="The parent namespace.">O namespace pai.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary vsli:raw="Gets all type definitions that reside directly in a namespace.">Obtém todas as definições de tipo que residem diretamente em um namespace.</summary>
      <returns vsli:raw="An immutable array of type definition handles.">Uma matriz imutável de identificadores de definição de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary vsli:raw="Provides a handle to a namespace definition.">Fornece um identificador para uma definição de namespace.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary vsli:raw="Contains a collection of parameters of a specified method.">Contém uma coleção de parâmetros de um método especificado.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReader&quot; /&gt; from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Obtém um <see cref="T:System.Reflection.Metadata.MetadataReader" /> de um <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns vsli:raw="A metadata reader.">Um leitor de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Obtém um leitor de metadados com a configuração de leitura de metadados especificada de um <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">Um valor de enumeração que indica a configuração de leitura de metadados.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns vsli:raw="A metadata reader with the specified metadata reading configuration.">Um leitor de metadados com a configuração de leitura de metadados especificada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary vsli:raw="Gets a metadata reader with the specified metadata reading configuration and encoding configuration from a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;.">Obtém um leitor de metadados com a configuração de leitura de metadados especificada e a configuração de codifica de um <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <param name="options" vsli:raw="An enumeration value indicating the metadata reading configuration.">Um valor de enumeração que indica a configuração de leitura de metadados.</param>
      <param name="utf8Decoder" vsli:raw="A metadata string decoder with the encoding configuration.">Um decodificador de cadeia de caracteres de metadados com a configuração de codificação.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The encoding of &lt;paramref name=&quot;utf8Decoder&quot; /&gt; is not &lt;see cref=&quot;T:System.Text.UTF8Encoding&quot; /&gt;.">A codificação de <paramref name="utf8Decoder" /> não é <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException" vsli:raw="The current platform is big-endian.">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns vsli:raw="&amp;gt;A metadata reader with the specified metadata reading configuration and encoding configuration.">&gt;Um leitor de metadados com a configuração de leitura de metadados e a configuração de codificação especificadas.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary vsli:raw="Returns a body block of a method with the specified Relative Virtual Address (RVA).">Retorna um bloco de corpo de um método com o RVA (endereço virtual relativo) especificado;</summary>
      <param name="peReader" vsli:raw="The current &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; instance.">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address (RVA).">O RVA (endereço virtual relativo).</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peReader&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The body is not found in the metadata or is invalid.">O corpo não foi encontrado nos metadados ou é inválido.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The section where the method is stored is not available.">A seção em que o método está armazenado não está disponível.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error occurred while reading from the underlying stream.">Ocorreu um erro de E/S ao ler do fluxo subjacente.</exception>
      <returns vsli:raw="A method block body instance.">Uma instância de corpo do bloco de método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary vsli:raw="Specifies constants that define the type codes used to encode types of primitive values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttribute&quot; /&gt; value blob.">Especifica constantes que definem os códigos de tipo usados para codificar tipos de valores primitivos um blob de valor <see cref="T:System.Reflection.Metadata.CustomAttribute" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">Um tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary vsli:raw="An unsigned 1-byte integer type.">Um tipo de inteiro de 1 byte sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">Um tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary vsli:raw="An 8-byte floating point type.">Um tipo de ponto flutuante de 8 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary vsli:raw="A signed 2-byte integer type.">Um tipo de inteiro de 2 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary vsli:raw="A signed 4-byte integer type.">Um tipo de inteiro de 4 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary vsli:raw="A signed 8-byte integer type.">Um tipo de inteiro de 8 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary vsli:raw="A signed 1-byte integer type.">Um tipo de inteiro de 1 byte com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary vsli:raw="A 4-byte floating point type.">Um tipo de ponto flutuante de 4 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Um tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary vsli:raw="An unsigned 2-byte integer type.">Um tipo de inteiro de 2 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary vsli:raw="An unsigned 4-byte integer type.">Um tipo de inteiro de 4 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary vsli:raw="An unsigned 8-byte integer type.">Um tipo de inteiro de 8 bytes sem sinal.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary vsli:raw="Specifies constants that define primitive types found in metadata signatures.">Especifica constantes que definem tipos primitivos encontrados em assinaturas de metadados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Boolean&quot; /&gt; type.">Um tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; type.">Um tipo <see cref="T:System.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Char&quot; /&gt; type.">Um tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Double&quot; /&gt; type.">Um tipo <see cref="T:System.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int16&quot; /&gt; type.">Um tipo <see cref="T:System.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int32&quot; /&gt; type.">Um tipo <see cref="T:System.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Int64&quot; /&gt; type.">Um tipo <see cref="T:System.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; type.">Um tipo <see cref="T:System.IntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.Object&quot; /&gt; type.">Um tipo <see cref="T:System.Object" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary vsli:raw="An &lt;see cref=&quot;T:System.SByte&quot; /&gt; type.">Um tipo <see cref="T:System.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Single&quot; /&gt; type.">Um tipo <see cref="T:System.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; type.">Um tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary vsli:raw="A typed reference.">Uma referência com tipo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt16&quot; /&gt; type.">Um tipo <see cref="T:System.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt32&quot; /&gt; type.">Um tipo <see cref="T:System.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UInt64&quot; /&gt; type.">Um tipo <see cref="T:System.UInt64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; type.">Um tipo <see cref="T:System.UIntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary vsli:raw="A &lt;see cref=&quot;T:System.Void&quot; /&gt; type.">Um tipo <see cref="T:System.Void" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary vsli:raw="Represents a handle and a corresponding blob on a metadata heap that was reserved for future content update.">Representa um identificador e um blob correspondente em um heap de metadados que foi reservado para atualização de conteúdo futura.</summary>
      <typeparam name="THandle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobWriter&quot; /&gt; to be used to update the content.">Retorna um <see cref="T:System.Reflection.Metadata.BlobWriter" /> a ser usado para atualizar o conteúdo.</summary>
      <returns vsli:raw="A blob writer to be used to update the content.">Um gravador de blob a ser usado para atualizar o conteúdo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary vsli:raw="Gets the reserved blob handle.">Obtém o identificador de blob reservado.</summary>
      <returns vsli:raw="The reserved bloc handle.">O identificador Bloq reservado.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" vsli:raw="The object to compare with the current object." />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary vsli:raw="Specifies type codes used to encode the types of values in a &lt;see cref=&quot;T:System.Reflection.Metadata.CustomAttributeValue`1&quot; /&gt; blob.">Especifica os códigos de tipo usados para codificar os tipos de valores em um blob <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Boolean&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Byte&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Char&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Double&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary vsli:raw="The attribute argument is an Enum instance.">O argumento do atributo é uma instância Enum.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int16&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int32&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Int64&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Invalid&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SByte&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.Single&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.String&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.SZArray&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary vsli:raw="The attribute argument is &quot;boxed&quot; (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.">O argumento do atributo é “demarcado” (passado para um parâmetro, campo ou propriedade do objeto de tipo) e carrega informações de tipo no blob de atributo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary vsli:raw="The attribute argument is a &lt;see cref=&quot;T:System.Type&quot; /&gt; instance.">O argumento do atributo é uma instância <see cref="T:System.Type" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt16&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt32&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary vsli:raw="A value equivalent to &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureTypeCode.UInt64&quot; /&gt;.">Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary vsli:raw="Specifies additional flags that can be applied to method signatures. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Especifica os sinalizadores adicionais que podem ser aplicados a assinaturas de método. Os valores subjacentes dos campos nesse tipo correspondem à representação no byte de assinatura à esquerda representado por uma estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary vsli:raw="Indicates the first explicitly declared parameter that represents the instance pointer.">Indica o primeiro parâmetro explicitamente declarado que representa o ponteiro de instância.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary vsli:raw="A generic method.">Um método genérico.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary vsli:raw="&lt;para&gt;An instance method.&lt;/para&gt;&lt;para&gt;The Ecma 335 CLI Specification refers to this flag as &lt;see langword=&quot;HAS_THIS&quot; /&gt;.&lt;/para&gt;">Um método de instância.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary vsli:raw="No flags.">Sem sinalizadores.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary vsli:raw="Specifies how arguments in a given signature are passed from the caller to the callee. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Especifica como os argumentos em determinada assinatura são passados do chamador para o computador chamado. Os valores subjacentes dos campos nesse tipo correspondem à representação no byte de assinatura à esquerda representado por uma estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary vsli:raw="An unmanaged C/C++ style calling convention where the call stack is cleaned by the caller.">Um estilo C/C++ não gerenciado de convenção de chamada em que a pilha de chamadas é limpa pelo chamador.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary vsli:raw="A managed calling convention with a fixed-length argument list.">Uma convenção de chamada gerenciada com uma lista de argumentos de comprimento fixo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary vsli:raw="An unmanaged calling convention where arguments are passed in registers when possible.">Uma convenção de chamada não gerenciada em que os argumentos são passados em registros quando possível.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary vsli:raw="An unmanaged calling convention where the call stack is cleaned up by the callee.">Uma convenção de chamada não gerenciada em que a pilha de chamadas é limpa pelo computador chamado.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary vsli:raw="An unmanaged C++ style calling convention for calling instance member functions with a fixed argument list.">Um estilo C++ não gerenciado de convenção de chamada para chamar funções de membro de instância com uma lista de argumentos fixos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary vsli:raw="Indicates that the specifics of the unmanaged calling convention are encoded as modopts.">Indica que as especificidades da convenção de chamada não gerenciada são codificadas como modopts.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary vsli:raw="A managed calling convention for passing extra arguments.">Uma convenção de chamada gerenciada para passar argumentos extras.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary vsli:raw="Represents the signature characteristics specified by the leading byte of signature blobs.">Representa as características de assinatura especificadas pelo byte à esquerda de blobs de assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary vsli:raw="Gets the mask value for the calling convention or signature kind. The default &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask&quot; /&gt; value is 15 (0x0F).">Obtém o valor da máscara para a convenção de chamada ou tipo de assinatura. O valor <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> padrão é 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified byte value.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> usando o valor de byte especificado.</summary>
      <param name="rawValue" vsli:raw="The byte.">O byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure using the specified signature kind, calling convention and signature attributes.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> usando o tipo de assinatura especificado, convenção de chamada e atributos de assinatura.</summary>
      <param name="kind" vsli:raw="The signature kind.">O tipo de assinatura.</param>
      <param name="convention" vsli:raw="The calling convention.">A convenção de chamada.</param>
      <param name="attributes" vsli:raw="The signature attributes.">Os atributos de assinatura.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary vsli:raw="Compares the specified object with this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; for equality.">Compara a igualdade entre o objeto especificado e este <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="obj" vsli:raw="The object to compare.">O objeto a ser comparado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the objects are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os objetos forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">Comparar a igualdade de dois valores <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="other" vsli:raw="The value to compare.">O valor a ser comparado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os dois valores forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary vsli:raw="Gets a hash code for the current object.">Obtém um código hash para o objeto atual.</summary>
      <returns vsli:raw="A hash code for the current object.">Um código hash do objeto atual.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Compares two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values for equality.">Comparar a igualdade de dois valores <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="left" vsli:raw="The first value to compare.">O primeiro valor a ser comparado.</param>
      <param name="right" vsli:raw="The second value to compare.">O segundo valor a ser comparado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os dois valores forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; values are unequal.">Determina se dois valores <see cref="T:System.Reflection.Metadata.SignatureHeader" /> são diferentes.</summary>
      <param name="left" vsli:raw="The first value to compare.">O primeiro valor a ser comparado.</param>
      <param name="right" vsli:raw="The second value to compare.">O segundo valor a ser comparado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os dois valores forem diferentes; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary vsli:raw="Returns a string that represents the current object.">Retorna uma cadeia de caracteres que representa o objeto atual.</summary>
      <returns vsli:raw="A string that represents the current object.">Uma cadeia de caracteres que representa o objeto atual.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary vsli:raw="Gets the signature attributes.">Obtém os atributos de assinatura.</summary>
      <returns vsli:raw="The attributes.">Os atributos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary vsli:raw="Gets the calling convention.">Obtém a convenção de chamada.</summary>
      <returns vsli:raw="The calling convention.">A convenção de chamada.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; signature attribute.">Obtém um valor que indica se essa estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tem o atributo de assinatura <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> atributo estiver presente; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; signature attribute.">Obtém um valor que indica se essa estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tem o atributo de assinatura <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Generic&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> atributo estiver presente; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary vsli:raw="Gets a value that indicates whether this &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure has the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; signature attribute.">Obtém um valor que indica se essa estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tem o atributo de assinatura <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureAttributes.Instance&quot; /&gt; attribute is present; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> atributo estiver presente; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary vsli:raw="Gets the signature kind.">Obtém o tipo de assinatura.</summary>
      <returns vsli:raw="The signature kind.">O tipo de assinatura.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary vsli:raw="Gets the raw value of the header byte.">Obtém o valor bruto do byte de cabeçalho.</summary>
      <returns vsli:raw="The raw value of the header byte.">O valor bruto do byte do cabeçalho.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary vsli:raw="Specifies the signature kind. The underlying values of the fields in this type correspond to the representation in the leading signature byte represented by a &lt;see cref=&quot;T:System.Reflection.Metadata.SignatureHeader&quot; /&gt; structure.">Especifica o tipo de assinatura. Os valores subjacentes dos campos nesse tipo correspondem à representação no byte de assinatura à esquerda representado por uma estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary vsli:raw="A field signature.">Uma assinatura de campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary vsli:raw="A local variables signature.">Uma assinatura de variáveis locais.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary vsli:raw="A method reference, method definition, or standalone method signature.">Uma referência de método, definição de método ou assinatura de método autônomo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary vsli:raw="A method specification signature.">Uma assinatura de especificação de método.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary vsli:raw="A property signature.">Uma assinatura de propriedade.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary vsli:raw="Specifies constants that define type codes used in signature encoding.">Especifica constantes que definem os códigos de tipo usados na codificação de assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary vsli:raw="Represents a generalized &lt;see cref=&quot;T:System.Array&quot; /&gt; in signatures.">Representa um <see cref="T:System.Array" /> generalizado em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; in signatures.">Representa um <see cref="T:System.Boolean" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary vsli:raw="Represents managed pointers (byref return values and parameters) in signatures. It is followed in the blob by the signature encoding of the underlying type.">Representa os ponteiros gerenciados (parâmetros e valores retornados de byref) em assinaturas. Ele é seguido no blob pela codificação de assinatura do tipo subjacente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Byte&quot; /&gt; in signatures.">Representa um <see cref="T:System.Byte" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Char&quot; /&gt; in signatures.">Representa um <see cref="T:System.Char" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Double&quot; /&gt; in signatures.">Representa um <see cref="T:System.Double" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary vsli:raw="Represents function pointer types in signatures.">Representa os tipos de ponteiro de função em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary vsli:raw="Represents a generic method parameter used within a signature.">Representa um parâmetro de método genérico usado dentro de uma assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary vsli:raw="Represents the instantiation of a generic type in signatures.">Representa a instanciação de um tipo genérico em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary vsli:raw="Represents a generic type parameter used within a signature.">Representa um parâmetro de tipo genérico usado dentro de uma assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int16&quot; /&gt; in signatures.">Representa um <see cref="T:System.Int16" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int32&quot; /&gt; in signatures.">Representa um <see cref="T:System.Int32" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Int64&quot; /&gt; in signatures.">Representa um <see cref="T:System.Int64" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.IntPtr&quot; /&gt; in signatures.">Representa um <see cref="T:System.IntPtr" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary vsli:raw="Represents an invalid or uninitialized type code. It will not appear in valid signatures.">Representa um código de tipo inválido ou que teve sua inicialização cancelada. Ele não aparecerá em assinaturas válidas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.Object&quot; /&gt; in signatures.">Representa um <see cref="T:System.Object" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller can ignore.">Representa um modificador personalizado aplicado a um tipo em uma assinatura que o chamador pode ignorar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary vsli:raw="Represents a local variable that is pinned by garbage collector.">Representa uma variável local fixada pelo coletor de lixo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary vsli:raw="Represents an unmanaged pointer in signatures. It is followed in the blob by the signature encoding of the underlying type.">Representa um ponteiro não gerenciado em assinaturas. Ele é seguido no blob pela codificação de assinatura do tipo subjacente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary vsli:raw="Represents a custom modifier applied to a type within a signature that the caller must understand.">Representa um modificador personalizado aplicado a um tipo em uma assinatura que o chamador precisa entender.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary vsli:raw="Represents an &lt;see cref=&quot;T:System.SByte&quot; /&gt; in signatures.">Representa um <see cref="T:System.SByte" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary vsli:raw="Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments.">Representa um marcador para indicar o fim de argumentos fixos e o início de argumentos variáveis.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.Single&quot; /&gt; in signatures.">Representa um <see cref="T:System.Single" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.String&quot; /&gt; in signatures.">Representa um <see cref="T:System.String" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary vsli:raw="Represents a single dimensional &lt;see cref=&quot;T:System.Array&quot; /&gt; with a lower bound of 0.">Representa um único <see cref="T:System.Array" /> dimensional com um limite inferior de 0.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary vsli:raw="Represents a typed reference in signatures.">Representa uma referência de tipo em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary vsli:raw="Precedes a type &lt;see cref=&quot;T:System.Reflection.Metadata.EntityHandle&quot; /&gt; in signatures. In raw metadata, this is encoded as either ELEMENT_TYPE_CLASS (0x12) for reference types or ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single code because Windows Runtime projections can project from class to value type or vice-versa, and the raw code is misleading in those cases.">Precede um tipo <see cref="T:System.Reflection.Metadata.EntityHandle" /> em assinaturas. Em metadados brutos, isso é codificado como ELEMENT_TYPE_CLASS (0x12) para tipos de referência ou ELEMENT_TYPE_VALUETYPE (0x11) para tipos de valor. Isso é recolhido para um único código porque as projeções do Windows Runtime podem projetar de classe para o tipo de valor ou vice-versa, e o código bruto é enganoso nesses casos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; in signatures.">Representa um <see cref="T:System.UInt16" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; in signatures.">Representa um <see cref="T:System.UInt32" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; in signatures.">Representa um <see cref="T:System.UInt64" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary vsli:raw="Represents a &lt;see cref=&quot;T:System.UIntPtr&quot; /&gt; in signatures.">Representa um <see cref="T:System.UIntPtr" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary vsli:raw="Represents &lt;see cref=&quot;T:System.Void&quot; /&gt; in signatures.">Representa <see cref="T:System.Void" /> em assinaturas.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary vsli:raw="Indicates the type definition of the signature.">Indica a definição de tipo da assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary vsli:raw="The type definition or reference refers to a class.">A definição de tipo ou a referência se refere a uma classe.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary vsli:raw="It isn't known in the current context if the type reference or definition is a class or value type.">Ele não é conhecido no contexto atual, se a referência de tipo ou a definição for um tipo de classe ou de valor.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary vsli:raw="The type definition or reference refers to a value type.">A definição de tipo ou a referência se refere a um tipo de valor.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary vsli:raw="Determines the kind of signature, which can be &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.Method&quot; /&gt; or &lt;see cref=&quot;F:System.Reflection.Metadata.SignatureKind.LocalVariables&quot; /&gt;.">Determina o tipo de assinatura, que pode ser <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> ou <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The signature is invalid.">A assinatura é inválida.</exception>
      <returns vsli:raw="An enumeration value that indicates the signature kind.">Um valor de enumeração que indica o tipo de assinatura.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary vsli:raw="Gets a handle to the signature blob.">Obtém um identificador para o blob de assinatura.</summary>
      <returns vsli:raw="A handle to the signature blob.">Um identificador para o blob de assinatura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary vsli:raw="Indicates whether a &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method or local variable signature.">Indica se um <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> representa um método autônomo ou a assinatura de variável local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.MemberReference&quot; /&gt; references a local variable signature.">O <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a uma assinatura de variável local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary vsli:raw="The &lt;see cref=&quot;T:System.Reflection.Metadata.StandaloneSignature&quot; /&gt; represents a standalone method signature.">O <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> representa uma assinatura de método autônomo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary vsli:raw="Returns the enclosing type of a specified nested type.">Retorna o tipo delimitador de um tipo aninhado especificado.</summary>
      <returns vsli:raw="The enclosing type of the specified nested type, or a handle a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is not nested.">O tipo delimitador do tipo aninhado especificado ou um identificador cuja propriedade <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> é <see langword="true" /> se o tipo não está aninhado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary vsli:raw="Returns an array of types nested in the specified type.">Retorna uma matriz de tipos aninhados no tipo especificado.</summary>
      <returns vsli:raw="An immutable array of type definition handles that represent types nested in the specified type.">Uma matriz imutável de identificadores de definição de tipo que representam os tipos aninhados no tipo especificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary vsli:raw="Gets the base type of the type definition: either &lt;see cref=&quot;T:System.Reflection.Metadata.TypeSpecificationHandle&quot; /&gt;, &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; or &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt;.">Obtém o tipo base da definição de tipo: <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns vsli:raw="The base type of the type definition.">O tipo base da definição de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary vsli:raw="Gets a value that indicates whether this is a nested type.">Obtém um valor que indica se isto é um tipo aninhado.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it is a nested type, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> Se for um tipo aninhado, <see langword="false" /> caso contrário.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary vsli:raw="Gets the name of the type.">Obtém o nome do tipo.</summary>
      <returns vsli:raw="The name of the type.">O nome do tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the type is defined.">Obtém o nome completo do namespace em que o tipo é definido.</summary>
      <returns vsli:raw="The full name of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">O nome completo do namespace em que o tipo é definido ou um identificador cuja <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propriedade é <see langword="true" /> se o tipo é aninhado ou definido em um namespace raiz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary vsli:raw="Gets the definition handle of the namespace where the type is defined.">Obtém o identificador de definição do namespace em que o tipo é definido.</summary>
      <returns vsli:raw="The definition handle of the namespace where the type is defined, or a handle whose &lt;see cref=&quot;P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt;  if the type is nested or defined in a root namespace.">O identificador de definição do namespace em que o tipo é definido ou um identificador cuja <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> propriedade é <see langword="true" />  se o tipo é aninhado ou definido em um namespace raiz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeDefinitionHandle&quot; /&gt; instances.">Contém uma coleção de instâncias de <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" vsli:raw="" />
      <param name="packingSize" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary vsli:raw="Gets the name of the target type.">Obtém o nome do tipo de destino.</summary>
      <returns vsli:raw="The name of the target type.">O nome do tipo de destino.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary vsli:raw="Gets the full name of the namespace where the target type is defined.">Obtém o nome completo do namespace em que o tipo de destino é definido.</summary>
      <returns vsli:raw="The full name of the namespace where the target type is defined, or a handle whose the &lt;see cref=&quot;P:System.Reflection.Metadata.StringHandle.IsNil&quot; /&gt; property is &lt;see langword=&quot;true&quot; /&gt; if the type is nested or defined in a root namespace.">O nome completo do namespace em que o tipo de destino é definido ou um identificador cuja <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propriedade é <see langword="true" /> se o tipo é aninhado ou definido em um namespace raiz,</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary vsli:raw="Gets the resolution scope in which the target type is defined and is uniquely identified by the specified &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Namespace&quot; /&gt; and &lt;see cref=&quot;P:System.Reflection.Metadata.TypeReference.Name&quot; /&gt;.">Obtém o escopo de resolução no qual o tipo de destino é definido e é identificado exclusivamente pelos <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> e <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> especificados.</summary>
      <returns vsli:raw="The resolution scope in which the target type is uniquely defined.">O escopo de resolução no qual o tipo de destino é definido exclusivamente.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary vsli:raw="Contains a collection of &lt;see cref=&quot;T:System.Reflection.Metadata.TypeReferenceHandle&quot; /&gt; instances.">Contém uma coleção de instâncias de <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through the collection.">Retorna um enumerador que itera pela coleção.</summary>
      <returns vsli:raw="An enumerator that can be used to iterate through the collection.">Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary vsli:raw="Returns an enumerator that iterates through a collection.">Retorna um enumerador que itera em uma coleção.</summary>
      <returns vsli:raw="An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&gt; object that can be used to iterate through the collection.">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary vsli:raw="Gets the number of elements in the collection.">Obtém o número de elementos na coleção.</summary>
      <returns vsli:raw="The number of elements in the collection.">O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next element of the collection.">Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator was successfully advanced to the next element; &lt;see langword=&quot;false&quot; /&gt; if the enumerator has passed the end of the collection.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary vsli:raw="Sets the enumerator to its initial position, which is before the first element in the collection.">Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary vsli:raw="Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.">Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary vsli:raw="Gets the element in the collection at the current position of the enumerator.">Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns vsli:raw="The element in the collection at the current position of the enumerator.">O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" vsli:raw="" />
      <param name="genericContext" vsli:raw="" />
      <typeparam name="TType" vsli:raw="" />
      <typeparam name="TGenericContext" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary vsli:raw="Represents a handle to the user string heap.">Representa um identificador para o heap de cadeia de caracteres do usuário.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary vsli:raw="Indicates whether the current object is equal to another object of the same type.">Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other" vsli:raw="An object to compare with this object.">Um objeto para comparação com esse objeto.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current object is equal to the &lt;paramref name=&quot;other&quot; /&gt; parameter; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" vsli:raw="" />
      <param name="right" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary vsli:raw="&lt;para&gt;Used to add a handler for an event. Corresponds to the &lt;see langword=&quot;AddOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant adders are named the with &lt;see langword=&quot;add_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Usado para adicionar um manipulador para um evento. Corresponde ao sinalizador <see langword="AddOn" /> na especificação da CLI ECMA 335.</para>
        <para>Os adders em conformidade com CLS são nomeados com o prefixo <see langword="add_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary vsli:raw="&lt;para&gt;Reads the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant getters are named with get_ prefix.&lt;/para&gt;">
        <para>Lê o valor da propriedade.</para>
        <para>Os getters em conformidade com CLS são nomeados com o prefixo get_.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary vsli:raw="Other method for a property (not a getter or setter) or an event (not an adder, remover, or raiser).">Outro método para uma propriedade (não um getter ou setter) ou um evento (não um adder, remover ou raiser).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary vsli:raw="&lt;para&gt;Used to indicate that an event has occurred. Corresponds to the &lt;see langword=&quot;Fire&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt; CLS-compliant raisers are named with the &lt;see langword=&quot;raise_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Usado para indicar que ocorreu um evento. Corresponde ao sinalizador <see langword="Fire" /> na especificação da CLI ECMA 335.</para>
        <para> Os raisers em conformidade com CLS são nomeados com o prefixo <see langword="raise_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary vsli:raw="&lt;para&gt;Used to remove a handler for an event. Corresponds to the &lt;see langword=&quot;RemoveOn&quot; /&gt; flag in the Ecma 335 CLI specification.&lt;/para&gt;&lt;para&gt;CLS-compliant removers are named with the &lt;see langword=&quot;remove_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Usado para remover um manipulador de um evento. Corresponde ao sinalizador <see langword="RemoveOn" /> na especificação da CLI ECMA 335.</para>
        <para>Os removers em conformidade com CLS são nomeados com o prefixo <see langword="remove_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary vsli:raw="&lt;para&gt;Used to modify the value of the property.&lt;/para&gt;&lt;para&gt;CLS-compliant setters are named with the &lt;see langword=&quot;set_&quot; /&gt; prefix.&lt;/para&gt;">
        <para>Usado para modificar o valor da propriedade.</para>
        <para>Os setters em conformidade com CLS são nomeados com o prefixo <see langword="set_" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary vsli:raw="Provides information about a Program Debug Database (PDB) file.">Fornece informações sobre um arquivo PDB (banco de dados de depuração do programa).</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary vsli:raw="The iteration of the PDB. The first iteration is 1. The iteration is incremented each time the PDB content is augmented.">A iteração do PDB. A primeira iteração é 1. A iteração é incrementada toda vez que o conteúdo do PDB é aumentado.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary vsli:raw="The Globally Unique Identifier (GUID) of the associated PDB.">O GUID (identificador global exclusivo) do PDB associado.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary vsli:raw="The path to the .pdb file that contains debug information for the PE/COFF file.">O caminho para o arquivo .pdb que contém informações de depuração do arquivo PE/COFF.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary vsli:raw="Represents the header of a COFF file.">Representa o cabeçalho de um arquivo COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary vsli:raw="Gets the flags that indicate the attributes of the file.">Obtém os sinalizadores que indicam os atributos do arquivo.</summary>
      <returns vsli:raw="The flags that indicate the attributes of the file.">Os sinalizadores que indicam os atributos do arquivo.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary vsli:raw="Gets the type of the target machine.">Obtém o tipo do computador de destino.</summary>
      <returns vsli:raw="The type of the target machine.">O tipo do computador de destino.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary vsli:raw="Gets the number of sections. This indicates the size of the section table, which immediately follows the headers.">Obtém o número de seções. Isso indica o tamanho da tabela da seção, que segue imediatamente os cabeçalhos.</summary>
      <returns vsli:raw="The number of sections.">O número de seções.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary vsli:raw="Gets the number of entries in the symbol table. This data can be used to locate the string table, which immediately follows the symbol table. This value should be zero for a PE image.">Obtém o número de entradas na tabela de símbolos. Esses dados podem ser usados para localizar a tabela de cadeia de caracteres, que segue imediatamente a tabela de símbolos. Esse valor deve ser zero para uma imagem PE.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary vsli:raw="Gets the file pointer to the COFF symbol table.">Obtém o ponteiro de arquivo para a tabela de símbolos COFF.</summary>
      <returns vsli:raw="The file pointer to the COFF symbol table, or zero if no COFF symbol table is present. This value should be zero for a PE image.">O ponteiro de arquivo para a tabela de símbolos COFF ou zero se nenhuma tabela de símbolos COFF estiver presente. Esse valor deve ser zero para uma imagem PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary vsli:raw="Gets the size of the optional header, which is required for executable files but not for object files. This value should be zero for an object file.">Obtém o tamanho do cabeçalho opcional, que é necessário para arquivos executáveis, mas não para arquivos-objeto. Esse valor deve ser zero para um arquivo-objeto.</summary>
      <returns vsli:raw="The size of the optional header.">O tamanho do cabeçalho opcional.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary vsli:raw="Gets a value that indicates when the file was created.">Obtém um valor que indica quando o arquivo foi criado.</summary>
      <returns vsli:raw="The low 32 bits of the number of seconds since 00:00 January 1, 1970, which indicates when the file was created.">Os poucos 32 bits do número de segundos desde 00:00 de janeiro de 1970, que indicam quando o arquivo foi criado.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary vsli:raw="Represents the runtime flags for a .NET executable image.">COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryBuilder&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary vsli:raw="Adds a CodeView entry.">Adiciona uma entrada de CodeView.</summary>
      <param name="pdbPath" vsli:raw="The path to the PDB. It should not be empty.">O caminho para o PDB. Não deve estar vazio.</param>
      <param name="pdbContentId" vsli:raw="The unique id of the PDB content.">A ID exclusiva do conteúdo do PDB.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0), or 0 if the PDB is not portable.">A versão do formato PDB portátil (por exemplo, 0x0100 para 1,0) ou 0 se o PDB não for portátil.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="pdbPath" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;pdbPath&quot; /&gt; contains a NUL character.">
        <paramref name="pdbPath" /> contém um caractere NUL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" /> é menor que 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary vsli:raw="Adds an Embedded Portable PDB entry.">Adiciona uma entrada PDB portátil inserida.</summary>
      <param name="debugMetadata" vsli:raw="A Portable PDB metadata builder.">Um construtor de metadados PDB portátil.</param>
      <param name="portablePdbVersion" vsli:raw="The version of Portable PDB format (e.g. 0x0100 for 1.0).">A versão do formato PDB portátil (por exemplo, 0x0100 para 1,0).</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;debugMetadata&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="debugMetadata" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;portablePdbVersion&quot; /&gt; is smaller than 0x0100.">
        <paramref name="portablePdbVersion" /> é menor que 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary vsli:raw="Adds an entry of the specified type.">Adiciona uma entrada do tipo especificado.</summary>
      <param name="type" vsli:raw="The entry type.">O tipo de entrada.</param>
      <param name="version" vsli:raw="The entry version.">A versão de entrada.</param>
      <param name="stamp" vsli:raw="The entry stamp.">O selo de entrada.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary vsli:raw="Adds an entry of the specified type and serializes its data.">Adiciona uma entrada do tipo especificado e serializa seus dados.</summary>
      <param name="type" vsli:raw="The entry type.">O tipo de entrada.</param>
      <param name="version" vsli:raw="The entry version.">A versão de entrada.</param>
      <param name="stamp" vsli:raw="The entry stamp.">O selo de entrada.</param>
      <param name="data" vsli:raw="The data to pass to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">Os dados para passar para <paramref name="dataSerializer" />.</param>
      <param name="dataSerializer" vsli:raw="A serializer for serializing data to a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobBuilder&quot; /&gt;.">Um serializador para serializar dados para um <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
      <typeparam name="TData" vsli:raw="The type of the data passed to &lt;paramref name=&quot;dataSerializer&quot; /&gt;.">O tipo dos dados passados para <paramref name="dataSerializer" /> .</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Adds PDB checksum entry.">Adiciona a entrada de soma de verificação de PDB.</summary>
      <param name="algorithmName" vsli:raw="The hash algorithm name (for example, &quot;SHA256&quot;).">O nome do algoritmo de hash (por exemplo, "SHA256").</param>
      <param name="checksum" vsli:raw="The checksum.">A soma de verificação.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="algorithmName" /> ou <paramref name="checksum" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;algorithmName&quot; /&gt; or &lt;paramref name=&quot;checksum&quot; /&gt; is empty.">
        <paramref name="algorithmName" /> ou <paramref name="checksum" /> está vazio.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary vsli:raw="Adds a reproducible entry.">Adiciona uma entrada reproduzível.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary vsli:raw="Identifies the location, size and format of a block of debug information.">Identifica a localização, o tamanho e o formato de um bloco de informações de depuração.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntry&quot; /&gt; structure.">Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
      <param name="stamp" vsli:raw="" />
      <param name="majorVersion" vsli:raw="" />
      <param name="minorVersion" vsli:raw="" />
      <param name="type" vsli:raw="" />
      <param name="dataSize" vsli:raw="" />
      <param name="dataRelativeVirtualAddress" vsli:raw="" />
      <param name="dataPointer" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary vsli:raw="Gets the file pointer to the debug data.">Obtém o ponteiro de arquivo para os dados de depuração.</summary>
      <returns vsli:raw="The file pointer to the debug data.">O ponteiro de arquivo para os dados de depuração.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary vsli:raw="Gets the address of the debug data when loaded, relative to the image base.">Obtém o endereço dos dados de depuração quando carregados, em relação à base da imagem.</summary>
      <returns vsli:raw="The address of the debug data relative to the image base.">O endereço dos dados de depuração relativos à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary vsli:raw="Gets the size of the debug data (not including the debug directory itself).">Obtém o tamanho dos dados de depuração (não incluindo o próprio diretório de depuração).</summary>
      <returns vsli:raw="the size of the debug data (excluding the debug directory).">o tamanho dos dados de depuração (excluindo o diretório de depuração).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary vsli:raw="Gets a value that indicates if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry that points to a Portable PDB.">Obtém um valor que indica se a entrada é uma entrada <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> que aponta para um PDB portátil.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the entry is a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView&quot; /&gt; entry pointing to a Portable PDB; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a entrada for uma <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> entrada que aponta para um PDB portátil; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary vsli:raw="Gets the major version number of the debug data format.">Obtém o número de versão principal do formato de dados de depuração.</summary>
      <returns vsli:raw="The major version number of the debug data format.">O número de versão principal do formato de dados de depuração.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary vsli:raw="Gets the minor version number of the debug data format.">Obtém o número de versão secundária do formato de dados de depuração.</summary>
      <returns vsli:raw="The minor version number of the debug data format.">O número de versão secundária do formato de dados de depuração.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary vsli:raw="Get the time and date that the debug data was created if the PE/COFF file is not deterministic; otherwise, gets a value based on the hash of the content.">Obtém a hora e a data em que os dados de depuração foram criados caso o arquivo PE/COFF não seja determinístico; caso contrário, obtém um valor com base no hash do conteúdo.</summary>
      <returns vsli:raw="for a non-deterministic PE/COFF file, the time and date that the debug data was created; otherwise, a value based on the hash of the content.">para um arquivo PE/COFF não determinístico, a hora e a data em que os dados de depuração foram criados; caso contrário, um valor com base no hash do conteúdo.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary vsli:raw="Gets the format of the debugging information.">Obtém o formulário das informações de depuração.</summary>
      <returns vsli:raw="The format of the debugging information.">O formato das informações de depuração.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary vsli:raw="An enumeration that describes the format of the debugging information of a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntry&quot; /&gt;.">Uma enumeração que descreve o formato das informações de depuração de um <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary vsli:raw="Associated PDB file description. For more information, see the specification.">Descrição do arquivo PDB associado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary vsli:raw="The COFF debug information (line numbers, symbol table, and string table). This type of debug information is also pointed to by fields in the file headers.">As informações de depuração do COFF (números de linha, tabela de símbolos e tabela de cadeia de caracteres). Esse tipo de informação de depuração também é apontado por campos nos cabeçalhos de arquivo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary vsli:raw="&lt;para&gt;The entry points to a blob containing Embedded Portable PDB. The Embedded Portable PDB blob has the following format:&lt;/para&gt;&lt;para&gt;- blob ::= uncompressed-size data&lt;/para&gt;&lt;para&gt;- Data spans the remainder of the blob and contains a Deflate-compressed Portable PDB.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">
        <para>A entrada aponta para um blob que contém o PDB Portátil Inserido. O blob do PDB Portátil Inserido tem o seguinte formato:</para>
        <para>-blob:: = dados de tamanho descompactado</para>
        <para>- Os dados abrangem o restante do blob e contêm um PDB Portátil com compactação desinflado.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary vsli:raw="The entry stores a crypto hash of the content of the symbol file the PE/COFF file was built with. The hash can be used to validate that a given PDB file was built with the PE/COFF file and not altered in any way. More than one entry can be present if multiple PDBs were produced during the build of the PE/COFF file (for example, private and public symbols). For more information, see the specification.">A entrada armazena um hash de criptografia do conteúdo do arquivo de símbolos com o qual o arquivo PE/COFF foi criado. O hash pode ser usado para validar que um determinado arquivo PDB foi criado com o arquivo PE/COFF e não foi alterado de nenhuma forma. Mais de uma entrada pode estar presente se vários PDBs foram produzidos durante a compilação do arquivo PE/COFF (por exemplo, símbolos públicos e privados).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary vsli:raw="&lt;para&gt;The presence of this entry indicates a deterministic PE/COFF file. See the Remarks section for more information.&lt;/para&gt;&lt;para&gt;The tool that produced the deterministic PE/COFF file guarantees that the entire content of the file is based solely on documented inputs given to the tool (such as source files, resource files, and compiler options) rather than ambient environment variables (such as the current time, the operating system, and the bitness of the process running the tool).&#xA;          The value of field TimeDateStamp in COFF File Header of a deterministic PE/COFF file does not indicate the date and time when the file was produced and should not be interpreted that way. Instead, the value of the field is derived from a hash of the file content. The algorithm to calculate this value is an implementation detail of the tool that produced the file.&#xA;          The debug directory entry of type &lt;see cref=&quot;T:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible&quot; /&gt; must have all fields, except for Type zeroed.&lt;/para&gt;&lt;para&gt;For more information, see the specification.&lt;/para&gt;">A presença dessa entrada indica um arquivo PE/COFF determinístico. Consulte a seção Comentários para obter mais informações.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary vsli:raw="An unknown value that should be ignored by all tools.">Um valor desconhecido que deve ser ignorado por todas as ferramentas.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="size" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary vsli:raw="Describes the characteristics of a dynamic link library.">Descreve as características de uma biblioteca de links dinâmicos.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary vsli:raw="The image must run inside an AppContainer.">A imagem deve ser executada dentro de um AppContainer.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary vsli:raw="The DLL can be relocated.">A DLL pode ser realocada.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary vsli:raw="The image can handle a high entropy 64-bit virtual address space.">A imagem pode lidar com um espaço de endereço virtual de alta entropia de 64 bits.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary vsli:raw="Do not bind this image.">Não associe esta imagem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary vsli:raw="The image understands isolation and doesn't want it.">A imagem entende o isolamento e não o deseja.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary vsli:raw="The image does not use SEH. No SE handler may reside in this image.">A imagem não usa SEH. Nenhum manipulador SE pode residir nesta imagem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary vsli:raw="The image is NX compatible.">A imagem é compatível com NX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary vsli:raw="Reserved.">Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary vsli:raw="Reserved.">Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary vsli:raw="The image is Terminal Server aware.">A imagem é ciente do servidor Host da Sessão da Área de Trabalho Remota.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary vsli:raw="Reserved.">Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary vsli:raw="Reserved.">Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary vsli:raw="The driver uses the WDM model.">O driver usa o modelo WDM.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary vsli:raw="Specifies the target machine's CPU architecture.">Especifica a arquitetura de CPU do computador de destino.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary vsli:raw="Alpha.">Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary vsli:raw="ALPHA64.">ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary vsli:raw="Matsushita AM33.">Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary vsli:raw="AMD64 (K8).">AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary vsli:raw="ARM little endian.">ARM little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary vsli:raw="ARM64.">ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary vsli:raw="ARM Thumb-2 little endian.">ARM Thumb-2 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary vsli:raw="EFI Byte Code.">EFI Byte Code.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary vsli:raw="Intel 386.">Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary vsli:raw="Intel 64.">Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary vsli:raw="M32R little-endian.">M32R little-endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary vsli:raw="MIPS.">MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary vsli:raw="MIPS with FPU.">MIPS com FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary vsli:raw="MIPS16 with FPU.">MIPS16 com FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary vsli:raw="IBM PowerPC little endian.">IBM PowerPC little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary vsli:raw="PowerPCFP.">PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary vsli:raw="Hitachi SH3 DSP.">Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary vsli:raw="Hitachi SH3 little endian.">Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary vsli:raw="Hitachi SH4 little endian.">Hitachi SH4 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary vsli:raw="Hitachi SH5.">Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary vsli:raw="Thumb.">Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary vsli:raw="Infineon.">Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary vsli:raw="The target CPU is unknown or not specified.">A CPU de destino é desconhecida ou não está especificada.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary vsli:raw="MIPS little-endian WCE v2.">MIPS little-endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" vsli:raw="" />
      <param name="metadataRootBuilder" vsli:raw="" />
      <param name="ilStream" vsli:raw="" />
      <param name="mappedFieldData" vsli:raw="" />
      <param name="managedResources" vsli:raw="" />
      <param name="nativeResources" vsli:raw="" />
      <param name="debugDirectoryBuilder" vsli:raw="" />
      <param name="strongNameSignatureSize" vsli:raw="" />
      <param name="entryPoint" vsli:raw="" />
      <param name="flags" vsli:raw="" />
      <param name="deterministicIdProvider" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" vsli:raw="" />
      <param name="signatureProvider" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary vsli:raw="Represents a PDB Checksum debug directory entry.">Representa uma entrada de diretório de depuração de soma de verificação do PDB.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary vsli:raw="The name of the crypto hash algorithm used to calculate the checksum.">O nome do algoritmo de hash de criptografia usado para calcular a soma de verificação.</summary>
      <returns vsli:raw="A string representing the name of the crypto hash algorithm used to calculate the checksum.">Uma cadeia de caracteres que representa o nome do algoritmo de hash de criptografia usado para calcular a soma de verificação.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary vsli:raw="The checksum of the PDB content.">A soma de verificação do conteúdo PDB.</summary>
      <returns vsli:raw="An immutable array of bytes representing the checksum of the PDB content.">Uma matriz imutável de bytes que representa a soma de verificação do conteúdo PDB.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" vsli:raw="" />
      <param name="deterministicIdProvider" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" vsli:raw="" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" vsli:raw="" />
      <param name="location" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" vsli:raw="" />
      <param name="characteristics" vsli:raw="" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary vsli:raw="Builds PE directories.">Cria diretórios de PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary vsli:raw="Initializes an instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEDirectoriesBuilder&quot; /&gt; class.">Inicializa uma instância da classe <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary vsli:raw="The address of the entry point relative to the image base when the PE file is loaded into memory.">O endereço do ponto de entrada relativo à base de imagem quando o arquivo de PE é carregado na memória.</summary>
      <returns vsli:raw="For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero.">Para imagens de programa, esse é o endereço inicial. Para drivers de dispositivo, esse é o endereço da função de inicialização. Um ponto de entrada é opcional para DLLs. Quando nenhum ponto de entrada está presente, esse campo deve ser zero.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary vsli:raw="The base relocation table image directory entry.">A entrada do diretório de imagens da tabela de realocação de base.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary vsli:raw="The bound import image directory entry.">A entrada do diretório de imagens de importação associada.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary vsli:raw="The copyright/architecture image directory entry.">A entrada do diretório de imagens de direitos autorais/arquitetura.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary vsli:raw="The COM descriptortable image directory entry.">A entrada do diretório de imagens da descriptortable de COM.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary vsli:raw="The debug table image directory entry.">A entrada do diretório de imagens da tabela de depuração.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary vsli:raw="The delay import table image directory entry.">A entrada do diretório de imagens da tabela de importação com atraso.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary vsli:raw="The exception table image directory entry.">A entrada do diretório de imagens da tabela de exceção.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary vsli:raw="The export table image directory entry.">A entrada do diretório de imagens da tabela de exportação.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary vsli:raw="The global pointer table image directory entry.">A entrada do diretório de imagens da tabela de ponteiro global.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary vsli:raw="The import address table (IAT) image directory entry.">A entrada do diretório de imagens da IAT (tabela de endereços de importação).</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary vsli:raw="The import table image directory entry.">A entrada do diretório de imagens da tabela de importação.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary vsli:raw="The load configuration table image directory entry.">A entrada do diretório de imagens da tabela de configuração de carga.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary vsli:raw="The resource table image directory entry.">A entrada do diretório de imagens da tabela de recursos.</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary vsli:raw="The thread local storage (TLS) table image directory entry.">A entrada do diretório de imagens da tabela de TLS (armazenamento local de threads).</summary>
      <returns vsli:raw="A directory entry instance.">Uma instância de entrada de diretório.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary vsli:raw="Gets the address of the entry point relative to the image base when the PE file is loaded into memory.">Obtém o endereço do ponto de entrada relativo à base de imagem quando o arquivo de PE é carregado na memória.</summary>
      <returns vsli:raw="The address of the entry point relative to the image base.">O endereço do ponto de entrada em relação à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary vsli:raw="Gets the address of the beginning-of-code section relative to the image base when the image is loaded into memory.">Obtém o endereço da seção do início de código relativo à base de imagem quando a imagem é carregada na memória.</summary>
      <returns vsli:raw="The address of the beginning-of-code section relative to the image base.">O endereço da seção de início de código em relação à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary vsli:raw="Gets the address of the beginning-of-data section relative to the image base when the image is loaded into memory.">Obtém o endereço da seção do início dos dados relativo à base de imagem quando a imagem é carregada na memória.</summary>
      <returns vsli:raw="The address of the beginning-of-data section relative to the image base.">O endereço da seção de início de dados em relação à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary vsli:raw="Gets the Certificate Table entry, which points to a table of attribute certificates.">Obtém a entrada da Tabela de Certificado, que aponta para uma tabela de certificados de atributo.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary vsli:raw="Gets the image file checksum.">Obtém a soma de verificação do arquivo de imagem.</summary>
      <returns vsli:raw="The image file checksum.">A soma de verificação do arquivo de imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary vsli:raw="Gets the alignment factor (in bytes) that is used to align the raw data of sections in the image file.">Obtém o fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem.</summary>
      <returns vsli:raw="A power of 2 between 512 and 64K, inclusive. The default is 512.">Uma potência de 2 entre 512 e 64K, inclusive. O padrão é 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary vsli:raw="Gets the preferred address of the first byte of the image when it is loaded into memory.">Obtém o endereço preferencial do primeiro byte de imagem quando ele é carregado na memória.</summary>
      <returns vsli:raw="The preferred address, which is a multiple of 64K.">O endereço preferencial, que é um múltiplo de 64K.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary vsli:raw="Gets a value that identifies the format of the image file.">Obtém um valor que identifica o formato do arquivo de imagem.</summary>
      <returns vsli:raw="The format of the image file.">O formato do arquivo de imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary vsli:raw="Gets the major version number of the image.">Obtém o número de versão principal da imagem.</summary>
      <returns vsli:raw="The major version number of the image.">O número de versão principal da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary vsli:raw="Gets the linker major version number.">Obtém o número da versão principal do vinculador.</summary>
      <returns vsli:raw="The linker major version number.">O número da versão principal do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary vsli:raw="Gets the major version number of the required operating system.">Obtém o número de versão principal do sistema operacional necessário.</summary>
      <returns vsli:raw="The major version number of the required operating system.">O número de versão principal do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary vsli:raw="Gets the major version number of the subsystem.">Obtém o número de versão principal do subsistema.</summary>
      <returns vsli:raw="The major version number of the subsystem.">O número de versão principal do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary vsli:raw="Gets the minor version number of the image.">Obtém o número de versão secundária da imagem.</summary>
      <returns vsli:raw="The minor version number of the image.">O número de versão secundária da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary vsli:raw="Gets the linker minor version number.">Obtém o número da versão secundária do vinculador.</summary>
      <returns vsli:raw="The linker minor version number.">O número da versão secundária do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary vsli:raw="Gets the minor version number of the required operating system.">Obtém o número de versão secundária do sistema operacional necessário.</summary>
      <returns vsli:raw="The minor version number of the required operating system.">O número de versão secundária do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary vsli:raw="Gets the minor version number of the subsystem.">Obtém o número de versão secundário do subsistema.</summary>
      <returns vsli:raw="The minor version number of the subsystem.">O número de secundária principal do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary vsli:raw="Gets the number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;. Each describes a location and size.">Obtém o número de entradas de diretório de dados no restante do <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Cada uma descreve uma localização e um tamanho.</summary>
      <returns vsli:raw="The number of data-directory entries in the remainder of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt;.">O número de entradas de diretório de dados no restante do <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary vsli:raw="Gets the alignment (in bytes) of sections when they are loaded into memory.">Obtém o alinhamento (em bytes) das seções quando elas são carregadas na memória.</summary>
      <returns vsli:raw="A number greater than or equal to &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.FileAlignment&quot; /&gt;. The default is the page size for the architecture.">Um número maior ou igual a <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> . O padrão é o tamanho da página para a arquitetura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary vsli:raw="Gets the size of the code (text) section, or the sum of all code sections if there are multiple sections.">Obtém o tamanho da seção de código (texto) ou a soma de todas as seções de código quando há várias seções.</summary>
      <returns vsli:raw="the size of the code (text) section, or the sum of all code sections if there are multiple sections.">o tamanho da seção de código (texto) ou a soma de todas as seções de código se houver várias seções.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary vsli:raw="Gets the combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">Obtém o tamanho combinado de um stub do MS DOS, o cabeçalho do PE e os cabeçalhos de seção arredondados para um múltiplo de FileAlignment.</summary>
      <returns vsli:raw="The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.">O tamanho combinado de um stub do MS DOS, cabeçalho do PE e cabeçalhos de seção arredondados para um múltiplo de alinhamento de File.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary vsli:raw="Gets the size of the local heap space to commit.">Obtém o tamanho do espaço de heap local a ser confirmado.</summary>
      <returns vsli:raw="the size of the local heap space to commit.">o tamanho do espaço de heap local a ser confirmado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary vsli:raw="Gets the size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Obtém o tamanho do espaço de heap local a ser reservado. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns vsli:raw="The size of the local heap space to reserve.">O tamanho do espaço de heap local a ser reservado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary vsli:raw="Gets the size (in bytes) of the image, including all headers, as the image is loaded in memory.">Obtém o tamanho (em bytes) da imagem, incluindo todos os cabeçalhos, pois a imagem é carregada na memória.</summary>
      <returns vsli:raw="The size (in bytes) of the image, which is a multiple of &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment&quot; /&gt;.">O tamanho (em bytes) da imagem, que é um múltiplo de <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary vsli:raw="Gets the size of the initialized data section, or the sum of all such sections if there are multiple data sections.">Obtém o tamanho da seção de dados inicializados ou a soma de todas essas seções quando há várias seções.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary vsli:raw="Gets the size of the stack to commit.">Obtém o tamanho da pilha a ser confirmada.</summary>
      <returns vsli:raw="The size of the stack to commit.">O tamanho da pilha a ser confirmada.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary vsli:raw="Gets the size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">Obtém o tamanho da pilha a ser reservada. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns vsli:raw="The size of the stack to reserve.">O tamanho da pilha a ser reservada.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary vsli:raw="Gets the size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.">Obtém o tamanho da seção de dados não inicializados (BSS), ou a soma de todas essas seções quando há várias seções de BSS.</summary>
      <returns vsli:raw="The size of the uninitialized data section (BSS) or the sum of all such sections.">O tamanho da seção de dados não inicializado (BSS) ou a soma de todas essas seções.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary vsli:raw="Gets the name of the subsystem that is required to run this image.">Obtém o nome do subsistema necessário para executar esta imagem.</summary>
      <returns vsli:raw="The name of the subsystem that is required to run this image.">o nome do subsistema necessário para executar esta imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary vsli:raw="Defines the header for a portable executable (PE) file.">Define o cabeçalho de um arquivo PE (executável portátil).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeader&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</summary>
      <param name="machine" vsli:raw="The target machine's CPU architecture.">A arquitetura de CPU do computador de destino.</param>
      <param name="sectionAlignment" vsli:raw="The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to &lt;paramref name=&quot;fileAlignment&quot; /&gt;. The default is the page size for the architecture.">O alinhamento (em bytes) das seções quando elas são carregadas na memória. Deve ser maior ou igual a <paramref name="fileAlignment" />. O padrão é o tamanho da página para a arquitetura.</param>
      <param name="fileAlignment" vsli:raw="The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. If the &lt;paramref name=&quot;sectionAlignment&quot; /&gt; is less than the architecture's page size, then &lt;paramref name=&quot;fileAlignment&quot; /&gt; must match &lt;paramref name=&quot;sectionAlignment&quot; /&gt;.">O fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem. O valor deve ser uma potência de 2 entre 512 e 64K, inclusive. O padrão é 512. Se <paramref name="sectionAlignment" /> for menor que o tamanho da página da arquitetura, <paramref name="fileAlignment" /> deverá corresponder a <paramref name="sectionAlignment" />.</param>
      <param name="imageBase" vsli:raw="The preferred address of the first byte of image when loaded into memory; must be a multiple of 64K.">O endereço preferencial do primeiro byte de imagem quando carregado na memória; deve ser um múltiplo de 64K.</param>
      <param name="majorLinkerVersion" vsli:raw="The linker major version number.">O número da versão principal do vinculador.</param>
      <param name="minorLinkerVersion" vsli:raw="The linker minor version number.">O número da versão secundária do vinculador.</param>
      <param name="majorOperatingSystemVersion" vsli:raw="The major version number of the required operating system.">O número de versão principal do sistema operacional necessário.</param>
      <param name="minorOperatingSystemVersion" vsli:raw="The minor version number of the required operating system.">O número de versão secundária do sistema operacional necessário.</param>
      <param name="majorImageVersion" vsli:raw="The major version number of the image.">O número de versão principal da imagem.</param>
      <param name="minorImageVersion" vsli:raw="The minor version number of the image.">O número de versão secundária da imagem.</param>
      <param name="majorSubsystemVersion" vsli:raw="The major version number of the subsystem.">O número de versão principal do subsistema.</param>
      <param name="minorSubsystemVersion" vsli:raw="The minor version number of the subsystem.">O número de secundária principal do subsistema.</param>
      <param name="subsystem" vsli:raw="The subsystem required to run the image.">O subsistema necessário para executar a imagem.</param>
      <param name="dllCharacteristics" vsli:raw="An object describing the characteristics of the dynamic link library.">Um objeto que descreve as características da biblioteca de links dinâmicos.</param>
      <param name="imageCharacteristics" vsli:raw="An object describing the characteristics of the image.">Um objeto que descreve as características da imagem.</param>
      <param name="sizeOfStackReserve" vsli:raw="The size of the stack to reserve. Only &lt;paramref name=&quot;sizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">O tamanho da pilha a ser reservada. Somente <paramref name="sizeOfStackCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</param>
      <param name="sizeOfStackCommit" vsli:raw="The size of the stack to commit.">O tamanho da pilha a ser confirmada.</param>
      <param name="sizeOfHeapReserve" vsli:raw="The size of the local heap space to reserve. Only &lt;paramref name=&quot;sizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">O tamanho do espaço de heap local a ser reservado. Somente <paramref name="sizeOfHeapCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</param>
      <param name="sizeOfHeapCommit" vsli:raw="The size of the local heap space to commit.">O tamanho do espaço de heap local a ser confirmado.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;fileAlignment&quot; /&gt; is not power of 2 between 512 and 64K.&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;sectionAlignment&quot; /&gt; not power of 2.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;sectionAlignment&quot; /&gt; is less than &lt;paramref name=&quot;fileAlignment&quot; /&gt;.">
        <paramref name="fileAlignment" /> não é uma potência de 2 entre 512 e 64K.
- ou -

<paramref name="sectionAlignment" /> não é uma potência de 2.

- ou -

<paramref name="sectionAlignment" /> é menor que <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary vsli:raw="Creates an executable header.">Cria um cabeçalho executável.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the executable header.">Uma instância de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> que representa o cabeçalho executável.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary vsli:raw="Creates a library header.">Cria um cabeçalho de biblioteca.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaderBuilder&quot; /&gt; instance representing the library header.">Uma instância de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> que representa o cabeçalho de biblioteca.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary vsli:raw="Returns the dynamic linker library characteristics.">Retorna as características da biblioteca do vinculador dinâmico.</summary>
      <returns vsli:raw="An object that describes the dynamic linker library characteristics.">Um objeto que descreve as características da biblioteca do vinculador dinâmico.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary vsli:raw="The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. If the section alignment is less than the architecture's page size, then file alignment must match the section alignment.">O fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem. O valor deve ser uma potência de 2 entre 512 e 64K, inclusive. O padrão é 512. Se o alinhamento da seção for menor que o tamanho da página da arquitetura, o alinhamento do arquivo deverá corresponder ao alinhamento da seção.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary vsli:raw="The preferred address of the first byte of image when loaded into memory; must be a multiple of 64K.">O endereço preferencial do primeiro byte de imagem quando carregado na memória; deve ser um múltiplo de 64K.</summary>
      <returns vsli:raw="A number representing the preferred address of the first byte of image when loaded into memory.">Um número que representa o endereço preferencial do primeiro byte de imagem quando carregado na memória.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary vsli:raw="Returns the image characteristics.">Retorna as características da imagem.</summary>
      <returns vsli:raw="An object representing the image characteristics.">Um objeto que representa as características da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary vsli:raw="The target machine's CPU architecture.">A arquitetura de CPU do computador de destino.</summary>
      <returns vsli:raw="One of the enumeration values representing the different CPU architectures.">Um dos valores de enumeração que representa as diferentes arquiteturas de CPU.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary vsli:raw="The major version number of the image.">O número de versão principal da imagem.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the image.">Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão principal da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary vsli:raw="The linker major version number.">O número da versão principal do vinculador.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker major version number.">Um número o tamanho de um <see cref="T:System.Byte" /> que representa o número de versão principal do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary vsli:raw="The major version number of the required operating system.">O número de versão principal do sistema operacional necessário.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the required operating system.">Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão principal do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary vsli:raw="The major version number of the subsystem.">O número de versão principal do subsistema.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the major version number of the subsystem.">Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão principal do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary vsli:raw="The minor version number of the image.">O número de versão secundária da imagem.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the image.">Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão secundária da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary vsli:raw="The linker minor version number.">O número da versão secundária do vinculador.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.Byte&quot; /&gt; representing the linker minor version number.">Um número o tamanho de um <see cref="T:System.Byte" /> que representa o número de versão secundária do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary vsli:raw="The minor version number of the required operating system.">O número de versão secundária do sistema operacional necessário.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the required operating system.">Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão secundária do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary vsli:raw="The minor version number of the subsystem.">O número de secundária principal do subsistema.</summary>
      <returns vsli:raw="A number the size of a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; representing the minor version number of the subsystem.">Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão secundário do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary vsli:raw="The alignment (in bytes) of sections when they are loaded into memory.">O alinhamento (em bytes) das seções quando elas são carregadas na memória.</summary>
      <returns vsli:raw="A number representing the alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to the file alignment. The default is the page size for the architecture.">Um número que representa o alinhamento (em bytes) de seções quando elas são carregadas na memória. Ele deve ser maior ou igual ao alinhamento do arquivo. O padrão é o tamanho da página para a arquitetura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary vsli:raw="The size of the local heap space to commit.">O tamanho do espaço de heap local a ser confirmado.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to commit.">Um número que representa o tamanho do espaço de heap local a ser confirmado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary vsli:raw="The size of the local heap space to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">O tamanho do espaço de heap local a ser reservado. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns vsli:raw="A number representing the size of the local heap space to reserve.">Um número que representa o tamanho do espaço de heap local a ser reservado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary vsli:raw="The size of the stack to commit.">O tamanho da pilha a ser confirmada.</summary>
      <returns vsli:raw="A number representing the size of the stack to commit.">Um número que representa o tamanho da pilha a ser confirmada.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary vsli:raw="The size of the stack to reserve. Only &lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit&quot; /&gt; is committed; the rest is made available one page at a time until the reserve size is reached.">O tamanho da pilha a ser reservada. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns vsli:raw="A number representing the size of the stack to reserve.">Um número que representa o tamanho da pilha a ser reservado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary vsli:raw="The subsystem that is required to run this image.">O subsistema necessário para executar esta imagem.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Reflection.PortableExecutable.Subsystem&quot; /&gt; instance.">Uma instância de <see cref="T:System.Reflection.PortableExecutable.Subsystem" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary vsli:raw="Defines a type that reads PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.">Define um tipo que lê cabeçalhos PE (Executável Portátil) e COFF de um fluxo.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from the current location in the specified stream.">Cria uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lê os cabeçalhos PE da localização atual no fluxo especificado.</summary>
      <param name="peStream" vsli:raw="A stream containing the PE image starting at the stream's current position and ending at the end of the stream.">Um fluxo que contém a imagem PE começando na posição atual do fluxo e terminando no final dele.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">Os dados lidos do fluxo têm um formato inválido.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Erro ao ler do fluxo.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">O fluxo não dá suporte para operações de busca.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size.">Cria uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lê os cabeçalhos PE de um fluxo que representa a imagem PE de um tamanho especificado.</summary>
      <param name="peStream" vsli:raw="A stream containing PE image of the given size starting at its current position.">Um fluxo que contém a imagem PE do tamanho especificado, começando em sua posição atual.</param>
      <param name="size" vsli:raw="The size of the PE image.">O tamanho da imagem PE.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has an invalid format.">Os dados lidos do fluxo têm um formato inválido.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Erro ao ler do fluxo.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">O fluxo não dá suporte para operações de busca.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> é negativo ou ultrapassa o final do fluxo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary vsli:raw="Instantiates a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEHeaders&quot; /&gt; class that reads the PE headers from a stream that represents a PE image of a specified size and indicates whether the PE image has been loaded into memory.">Cria uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lê os cabeçalhos PE de um fluxo que representa a imagem PE de um tamanho especificado e indica se a imagem PE foi carregada na memória.</summary>
      <param name="peStream" vsli:raw="The stream containing PE image of the given size starting at its current position.">O fluxo que contém a imagem PE do tamanho especificado, começando em sua posição atual.</param>
      <param name="size" vsli:raw="The size of the PE image.">O tamanho da imagem PE.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional; caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The data read from the stream has invalid format.">Os dados lidos do fluxo têm um formato inválido.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Erro ao ler do fluxo.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The stream does not support seek operations.">O fluxo não dá suporte para operações de busca.</exception>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> é negativo ou ultrapassa o final do fluxo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary vsli:raw="Searches sections of the PE image for the section that contains the specified Relative Virtual Address.">Pesquisa seções da imagem PE para a seção que contém o endereço virtual relativo especificado.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The relative virtual address to search for.">O endereço virtual relativo a ser pesquisado.</param>
      <returns vsli:raw="The index of the section that contains &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt;, or -1 if there the search is unsuccessful.">O índice da seção que contém <paramref name="relativeVirtualAddress" /> ou -1 se a pesquisa não for bem-sucedida.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the image to the given directory data.">Obtém o deslocamento (em bytes) do início da imagem ao dados do diretório fornecido.</summary>
      <param name="directory" vsli:raw="The PE directory entry.">A entrada do diretório PE.</param>
      <param name="offset" vsli:raw="When the method returns, contains the offset from the start of the image to the given directory data.">Quando o método retorna, contém o deslocamento do início da imagem para os dados de diretório fornecidos.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the directory data is found; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se os dados do diretório forem encontrados; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary vsli:raw="Gets the COFF header of the image.">Obtém o cabeçalho COFF da imagem.</summary>
      <returns vsli:raw="The COFF header of the image.">O cabeçalho COFF da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the PE image to the start of the COFF header.">Obtém o deslocamento de bytes desde o início da imagem PE até o início do cabeçalho COFF.</summary>
      <returns vsli:raw="The byte offset from the start of the PE image to the start of the COFF header.">O deslocamento de bytes desde o início da imagem PE até o início do cabeçalho COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary vsli:raw="Gets the COR header.">Obtém o cabeçalho COR.</summary>
      <returns vsli:raw="The COR header, or &lt;see langword=&quot;null&quot; /&gt; if the image does not have one.">O cabeçalho COR ou <see langword="null" /> se a imagem não tiver uma.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset from the start of the image to the COR header.">Obtém o deslocamento de bytes desde o início da imagem até o cabeçalho COR.</summary>
      <returns vsli:raw="The byte offset from the start of the image to the COR header, or -1 if the image does not have a COR header.">O deslocamento de bytes do início da imagem até o cabeçalho COR, ou-1 se a imagem não tiver um cabeçalho COR.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary vsli:raw="Gets a value that indicates whether the image is Coff only.">Obtém um valor que indica se a imagem é somente COFF.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is Coff only; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem for somente COFF; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary vsli:raw="Gets a value that indicates whether the image represents a Windows console application.">Obtém um valor que indica se a imagem representa um aplicativo de console do Windows.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a Windows console applications; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem for um aplicativo de console do Windows; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary vsli:raw="Gets a value that indicates whether the image represents a dynamic link library.">Obtém um valor que indica se a imagem representa uma biblioteca de links dinâmicos.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is a DLL; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem for uma DLL; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary vsli:raw="Gets a value that indicates whether the image represents an executable.">Obtém um valor que indica se a imagem representa um executável.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the image is an executable; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem for um executável; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary vsli:raw="Gets the size of the CLI metadata.">Obtém o tamanho dos metadados da CLI.</summary>
      <returns vsli:raw="the size of the CLI metadata, or 0 if the image does not contain metadata.">o tamanho dos metadados da CLI ou 0 se a imagem não contiver metadados.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary vsli:raw="Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.">Obtém o deslocamento (em bytes) do início da imagem PE ao início dos metadados da CLI.</summary>
      <returns vsli:raw="The offset (in bytes) from the start of the PE image to the start of the CLI metadata, or -1 if the image does not contain metadata.">O deslocamento (em bytes) desde o início da imagem PE até o início dos metadados da CLI ou-1 se a imagem não contiver metadados.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary vsli:raw="Gets the image's PE header.">Obtém o cabeçalho PE da imagem.</summary>
      <returns vsli:raw="The image's PE header, or &lt;see langword=&quot;null&quot; /&gt; if the image is COFF only.">O cabeçalho PE da imagem, ou <see langword="null" /> se a imagem for apenas COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary vsli:raw="Gets the byte offset of the header from the start of the image.">Obtém o deslocamento de bytes do cabeçalho desde o início da imagem.</summary>
      <returns vsli:raw="The byte offset of the header from the start of the image.">O deslocamento de byte do cabeçalho desde o início da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary vsli:raw="Gets the PE section headers.">Obtém os cabeçalhos de seção do PE.</summary>
      <returns vsli:raw="An array containing the PE section headers.">Uma matriz que contém os cabeçalhos de seção do PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary vsli:raw="Reads the contents of the entire block into an array.">Lê o conteúdo de todo o bloco em uma matriz.</summary>
      <returns vsli:raw="An immutable byte array.">Uma matriz de bytes imutável.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary vsli:raw="Reads the contents of a part of the block into an array.">Lê o conteúdo de uma parte do bloco em uma matriz.</summary>
      <param name="start" vsli:raw="The starting position in the block.">A posição inicial no bloco.</param>
      <param name="length" vsli:raw="The number of bytes to read.">O número de bytes a serem lidos.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">O intervalo especificado não está contido no bloco.</exception>
      <returns vsli:raw="An immutable array of bytes.">Uma matriz imutável de bytes.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning the entire block.">Cria um <see cref="T:System.Reflection.Metadata.BlobReader" /> para um blob que abrange todo o bloco.</summary>
      <returns vsli:raw="A reader for a blob spanning the entire block.">Um leitor para um blob que abrange todo o bloco.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Reflection.Metadata.BlobReader&quot; /&gt; for a blob spanning a part of the block.">Cria um <see cref="T:System.Reflection.Metadata.BlobReader" /> para um blob que abrange uma parte do bloco.</summary>
      <param name="start" vsli:raw="The starting position in the block.">A posição inicial no bloco.</param>
      <param name="length" vsli:raw="The number of bytes in the portion of the block.">O número de bytes na parte do bloco.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The specified range is not contained within the block.">O intervalo especificado não está contido no bloco.</exception>
      <returns vsli:raw="A reader for a blob spanning a portion of the block.">Um leitor para um blob que abrange uma parte do bloco.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary vsli:raw="Gets the length of the block.">Obtém o comprimento do bloco.</summary>
      <returns vsli:raw="The length of the block.">O comprimento do bloco.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary vsli:raw="Gets a pointer to the first byte of the block.">Obtém um ponteiro para o primeiro byte do bloco.</summary>
      <returns vsli:raw="A pointer to the first byte of the block.">Um ponteiro para o primeiro byte do bloco.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary vsli:raw="Provides a reader for Portable Executable format (PE) files.">Fornece um leitor para arquivos no formato PE (Executável Portátil).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory.">Cria um leitor Executável Portátil em uma imagem PE armazenada na memória.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">Um ponteiro para o início da imagem PE.</param>
      <param name="size" vsli:raw="The size of the PE image.">O tamanho da imagem PE.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in memory. A flag indicates whether the image has already been loaded into memory.">Cria um leitor Executável Portátil em uma imagem PE armazenada na memória. Um sinalizador indica se a imagem já foi carregada na memória.</summary>
      <param name="peImage" vsli:raw="A pointer to the start of the PE image.">Um ponteiro para o início da imagem PE.</param>
      <param name="size" vsli:raw="The size of the PE image.">O tamanho da imagem PE.</param>
      <param name="isLoadedImage" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional; caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see cref=&quot;F:System.IntPtr.Zero&quot; /&gt;.">
        <paramref name="peImage" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative.">
        <paramref name="size" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a byte array.">Cria um leitor Executável Portátil em uma imagem PE armazenada em uma matriz de bytes.</summary>
      <param name="peImage" vsli:raw="An immutable array of bytes representing the PE image.">Uma matriz de bytes imutável que representa a imagem PE.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImage&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImage" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream.">Cria um leitor Executável Portátil em uma imagem PE armazenada em um fluxo.</summary>
      <param name="peStream" vsli:raw="PE image stream.">Fluxo de imagem PE.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.">Cria um leitor de Executável Portátil em uma imagem PE armazenada em um fluxo, começando em sua posição atual e terminando no final do fluxo.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">Um fluxo de imagem PE.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">Opções especificando como as seções da imagem PE são lidas do fluxo.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peStream&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;options&quot; /&gt; has an invalid value.">
        <paramref name="options" /> tem um valor inválido.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">Erro ao ler do fluxo (somente ao fazer a pré-busca de dados).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> é especificado e os cabeçalhos PE da imagem são inválidos.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary vsli:raw="Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.">Cria um leitor de Executável Portátil em uma imagem PE do tamanho fornecido, começando na posição atual do fluxo.</summary>
      <param name="peStream" vsli:raw="A PE image stream.">Um fluxo de imagem PE.</param>
      <param name="options" vsli:raw="Options specifying how sections of the PE image are read from the stream.">Opções especificando como as seções da imagem PE são lidas do fluxo.</param>
      <param name="size" vsli:raw="The PE image size.">O tamanho da imagem PE.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;size&quot; /&gt; is negative or extends past the end of the stream.">
        <paramref name="size" /> é negativo ou ultrapassa o final do fluxo.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream (only when prefetching data).">Erro ao ler do fluxo (somente ao fazer a pré-busca de dados).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="&lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata&quot; /&gt; is specified, and the PE headers of the image are invalid.">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> é especificado e os cabeçalhos PE da imagem são inválidos.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary vsli:raw="Disposes all memory allocated by the reader.">Descarta toda a memória alocada pelo leitor.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEMemoryBlock&quot; /&gt; object containing the entire PE image.">Obtém um objeto <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> que contém toda a imagem PE.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The entire PE image is not available.">Toda a imagem PE não está disponível.</exception>
      <returns vsli:raw="A memory block that contains the entire PE image.">Um bloco de memória que contém a imagem PE inteira.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary vsli:raw="Loads a PE section that contains CLI metadata.">Carrega uma seção de PE que contém metadados da CLI.</summary>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image doesn't contain metadata (&lt;see cref=&quot;P:System.Reflection.PortableExecutable.PEReader.HasMetadata&quot; /&gt; returns &lt;see langword=&quot;false&quot; /&gt;).">A imagem PE não contém metadados (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> retorna <see langword="false" />).</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Os cabeçalhos PE contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns vsli:raw="A memory block that contains the CLI metadata.">Um bloco de memória que contém os metadados da CLI.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary vsli:raw="Loads the PE section that contains the specified relative virtual address into memory and returns a memory block that starts at that address and ends at the end of the containing section.">Carrega a seção PE que contém o endereço virtual relativo especificado na memória e retorna um bloco de memória que começa nesse endereço e termina no final da seção que a contém.</summary>
      <param name="relativeVirtualAddress" vsli:raw="The Relative Virtual Address of the data to read.">O endereço virtual relativo dos dados a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Os cabeçalhos PE contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="An IO error occurred while reading from the underlying stream.">Ocorreu um erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">A imagem PE não está disponível.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; is negative.">
        <paramref name="relativeVirtualAddress" /> é negativo.</exception>
      <returns vsli:raw="A memory block that starts at &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; and ends at the end of the containing section, or an empty block if &lt;paramref name=&quot;relativeVirtualAddress&quot; /&gt; doesn't represent a location in any of the PE sections of this PE image.">Um bloco de memória que começa em <paramref name="relativeVirtualAddress" /> e termina no final da seção que a contém ou um bloco vazio se <paramref name="relativeVirtualAddress" /> não representar uma localização em nenhuma das seções PE desta imagem PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary vsli:raw="Loads the PE section with the specified name into memory and returns a memory block that spans the section.">Carrega a seção PE com o nome especificado na memória e retorna um bloco de memória que abrange a seção.</summary>
      <param name="sectionName" vsli:raw="The name of the section.">O nome da seção.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;sectionName&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="sectionName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">A imagem PE não está disponível.</exception>
      <returns vsli:raw="A memory block that spans the section, or an empty block if no section of the given &lt;paramref name=&quot;sectionName&quot; /&gt; exists in this PE image.">Um bloco de memória que abrange a seção ou um bloco vazio se nenhuma seção do <paramref name="sectionName" /> especificado existir nesta imagem PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as CodeView.">Lê os dados apontados pela entrada do diretório de depuração especificado e os interpreta como CodeView.</summary>
      <param name="entry" vsli:raw="A Debug Directory entry instance.">Uma instância de entrada do diretório de depuração.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a CodeView entry.">
        <paramref name="entry" /> não é uma entrada de CodeView.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Formato inválido dos dados.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">A imagem PE não está disponível.</exception>
      <returns vsli:raw="A code view debug directory data instance.">Uma instância de dados do diretório de depuração de exibição de código.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary vsli:raw="Reads all Debug Directory table entries.">Lê todas as entradas de tabela do diretório de depuração.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the entry.">Formato inválido da entrada.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">A imagem PE não está disponível.</exception>
      <returns vsli:raw="An array of Debug Directory table entries.">Uma matriz de entradas de tabela do diretório de depuração.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as an Embedded Portable PDB blob.">Lê os dados apontados pela entrada do diretório de depuração especificado e os interpreta como um blob de PDB Portátil Inserido.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">A entrada do diretório de depuração cujos dados serão lidos.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a &lt;see cref=&quot;F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb&quot; /&gt; entry.">
        <paramref name="entry" /> não é uma entrada de <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Formato inválido dos dados.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="PE image not available.">Imagem PE não está disponível.</exception>
      <returns vsli:raw="The provider of a metadata reader for reading a Portable PDB image.">O provedor de um leitor de metadados para ler uma imagem PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary vsli:raw="Reads the data pointed to by the specified Debug Directory entry and interprets it as a PDB Checksum entry.">Lê os dados apontados pela entrada do diretório de depuração especificado e os interpreta como uma entrada de soma de verificação de PDB.</summary>
      <param name="entry" vsli:raw="The Debug Directory entry whose data is to be read.">A entrada do diretório de depuração cujos dados serão lidos.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;entry&quot; /&gt; is not a PDB Checksum entry.">
        <paramref name="entry" /> não é uma entrada de soma de verificação de PDB.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="Bad format of the data.">Formato inválido dos dados.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="IO error while reading from the underlying stream.">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The PE image is not available.">A imagem PE não está disponível.</exception>
      <returns vsli:raw="The PDB Checksum entry.">A entrada de soma de verificação de PDB.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary vsli:raw="Opens a Portable PDB associated with this PE image.">Abre um PDB portátil associado a esta imagem PE.</summary>
      <param name="peImagePath" vsli:raw="The path to the PE image. The path is used to locate the PDB file located in the directory containing the PE file.">O caminho para a imagem PE. O caminho é usado para localizar o arquivo PDB localizado no diretório que contém o arquivo PE.</param>
      <param name="pdbFileStreamProvider" vsli:raw="If specified, called to open a &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt; for a given file path. The provider is expected to either return a readable and seekable &lt;see cref=&quot;T:System.IO.Stream&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if the target file doesn't exist or should be ignored for some reason. The provider should throw &lt;see cref=&quot;T:System.IO.IOException&quot; /&gt; if it fails to open the file due to an unexpected IO error.">Se especificado, é chamado para abrir um <see cref="T:System.IO.Stream" /> para o caminho de arquivo determinado. O provedor deverá retornar um <see cref="T:System.IO.Stream" /> legível e pesquisável ou <see langword="null" /> se o arquivo de destino não existir ou precisar ser ignorado por algum motivo. O provedor deverá gerar <see cref="T:System.IO.IOException" /> se não for possível abrir o arquivo devido a um erro de E/S inesperado.</param>
      <param name="pdbReaderProvider" vsli:raw="If successful, a new instance of &lt;see cref=&quot;T:System.Reflection.Metadata.MetadataReaderProvider&quot; /&gt; to be used to read the Portable PDB.">Se for bem-sucedida, uma nova instância do <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> a ser usada para ler o PDB portátil,.</param>
      <param name="pdbPath" vsli:raw="If successful and the PDB is found in a file, the path to the file, or &lt;see langword=&quot;null&quot; /&gt; if the PDB is embedded in the PE image itself.">Se for bem-sucedido e o PDB for encontrado em um arquivo, o caminho para o arquivo ou <see langword="null" /> se o PDB for inserido na própria imagem PE.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;peImagePath&quot; /&gt; or &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="peImagePath" /> ou <paramref name="pdbFileStreamProvider" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The stream returned from &lt;paramref name=&quot;pdbFileStreamProvider&quot; /&gt; doesn't support read and seek operations.">O fluxo retornado de <paramref name="pdbFileStreamProvider" /> não é compatível com as operações de leitura e busca.</exception>
      <exception cref="T:System.BadImageFormatException" vsli:raw="No matching PDB file was found due to an error: The PE image or the PDB is invalid.">Nenhum arquivo PDB correspondente foi encontrado devido a um erro: a imagem PE ou o PDB é inválido.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="No matching PDB file was found due to an error: An IO error occurred while reading the PE image or the PDB.">Nenhum arquivo PDB correspondente foi encontrado devido a um erro: ocorreu um erro de e/s durante a leitura da imagem PE ou do PDB.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has a PDB associated with it and the PDB has been successfully opened; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem PE tiver um PDB associado a ela e o PDB tiver sido aberto com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary vsli:raw="Gets a value that indicates if the PE image contains CLI metadata.">Obtém um valor que indica se a imagem PE contém metadados da CLI.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The PE headers contain invalid data.">Os cabeçalhos PE contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the underlying stream.">Erro ao ler do fluxo subjacente.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image contains CLI metadata; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem PE contiver metadados da CLI; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary vsli:raw="Gets a value that indicates if the reader can access the entire PE image.">Obtém um valor que indica se o leitor pode acessar toda a imagem PE.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader can access the entire PE image; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o leitor puder acessar toda a imagem PE; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary vsli:raw="Gets a value that indicates if the PE image has been loaded into memory by the OS loader.">Obtém um valor que indica se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the PE image has been loaded into memory by the OS loader; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary vsli:raw="Gets the PE headers.">Obtém os cabeçalhos PE.</summary>
      <exception cref="T:System.BadImageFormatException" vsli:raw="The headers contain invalid data.">Os cabeçalhos contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException" vsli:raw="Error reading from the stream.">Erro ao ler do fluxo.</exception>
      <returns vsli:raw="The PE headers for this PE image.">Os cabeçalhos PE para esta imagem PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary vsli:raw="Provides options that specify how sections of a PE image are read from a stream.">Fornece opções que especificam como as seções de uma imagem de PE são lidas de um fluxo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary vsli:raw="By default, the stream is disposed when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed, and sections of the PE image are read lazily.">Por padrão, o fluxo é descartado quando o <see cref="T:System.Reflection.PortableExecutable.PEReader" /> é descartado e as seções da imagem PE são lidas lentamente.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary vsli:raw="Indicates that the underlying PE image has been loaded into memory by the OS loader.">Indica que a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary vsli:raw="Keeps the stream open when the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is disposed.">Mantém o fluxo aberto quando o <see cref="T:System.Reflection.PortableExecutable.PEReader" /> é descartado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary vsli:raw="Reads the entire image into memory right away. &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified.">Lê toda a imagem na memória imediatamente. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> fecha o fluxo automaticamente quando o construtor retorna, a menos que <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> seja especificado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary vsli:raw="&lt;para&gt;Reads the metadata section into memory right away.&lt;/para&gt;&lt;para&gt;Reading from other sections of the file is not allowed (&lt;see cref=&quot;T:System.InvalidOperationException&quot; /&gt; is thrown by the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt;).&lt;/para&gt;&lt;para&gt;&lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; closes the stream automatically by the time the constructor returns unless &lt;see cref=&quot;F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen&quot; /&gt; is specified. The underlying file may be closed and even deleted after &lt;see cref=&quot;T:System.Reflection.PortableExecutable.PEReader&quot; /&gt; is constructed.&lt;/para&gt;">
        <para>Lê a seção de metadados na memória imediatamente.</para>
        <para>A leitura de outras seções do arquivo não é permitida (<see cref="T:System.InvalidOperationException" /> é gerada pelo <see cref="T:System.Reflection.PortableExecutable.PEReader" />).</para>
        <para>
          <see cref="T:System.Reflection.PortableExecutable.PEReader" /> fecha o fluxo automaticamente quando o construtor retorna, a menos que <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> seja especificado. O arquivo subjacente poderá ser fechado e até mesmo excluído depois que o <see cref="T:System.Reflection.PortableExecutable.PEReader" /> for construído.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary vsli:raw="Defines the base class for a PE resource section builder. Derive from &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; to provide serialization logic for native resources.">Define a classe base para um construtor de seções de recursos de PE. Derive de <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> para fornecer lógica de serialização para recursos nativos.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Reflection.PortableExecutable.ResourceSectionBuilder&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary vsli:raw="Serializes the specified resource.">Serializa o recurso especificado.</summary>
      <param name="builder" vsli:raw="A blob that contains the data to serialize.">Um blob que contém os dados a serem serializados.</param>
      <param name="location" vsli:raw="The location to which to serialize &lt;paramref name=&quot;builder&quot; /&gt;.">A localização para a qual serializar <paramref name="builder" />.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary vsli:raw="Provides information about the section header of a PE/COFF file.">Fornece informações sobre o cabeçalho da seção de um arquivo PE/COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary vsli:raw="Gets the name of the section.">Obtém o nome da seção.</summary>
      <returns vsli:raw="The name of the section.">O nome da seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary vsli:raw="Gets the number of line-number entries for the section.">Obtém o número de entradas de número de linha para a seção.</summary>
      <returns vsli:raw="The number of line-number entries for the section.">O número de entradas de número de linha para a seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary vsli:raw="Gets the number of relocation entries for the section.">Obtém o número de entradas de realocação para a seção.</summary>
      <returns vsli:raw="The number of relocation entries for the section. Its value is zero for PE images.">O número de entradas de realocação para a seção. Seu valor é zero para imagens PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary vsli:raw="Gets the file pointer to the beginning of line-number entries for the section.">Obtém o ponteiro do arquivo para o início das entradas de número de linha da seção.</summary>
      <returns vsli:raw="The file pointer to the beginning of line-number entries for the section, or zero if there are no COFF line numbers.">O ponteiro do arquivo para o início das entradas de número de linha para a seção ou zero se não houver números de linha COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary vsli:raw="Gets the file pointer to the first page of the section within the COFF file.">Obtém o ponteiro do arquivo para a primeira página da seção dentro do arquivo COFF.</summary>
      <returns vsli:raw="The file pointer to the first page of the section within the COFF file.">O ponteiro de arquivo para a primeira página da seção dentro do arquivo COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary vsli:raw="Gets the file pointer to the beginning of relocation entries for the section.">Obtém o ponteiro do arquivo para o início das entradas de realocação para a seção.</summary>
      <returns vsli:raw="The file pointer to the beginning of relocation entries for the section. It is set to zero for PE images or if there are no relocations.">O ponteiro do arquivo para o início das entradas de realocação da seção. Ele é definido como zero para imagens PE ou se não houver realocações.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary vsli:raw="Gets the flags that describe the characteristics of the section.">Obtém os sinalizadores que descrevem as características da seção.</summary>
      <returns vsli:raw="The flags that describe the characteristics of the section.">Os sinalizadores que descrevem as características da seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary vsli:raw="Gets the size of the section (for object files) or the size of the initialized data on disk (for image files).">Obtém o tamanho da seção (para arquivos de objeto) ou o tamanho dos dados inicializados em disco (para arquivos de imagem).</summary>
      <returns vsli:raw="The size of the section (for object files) or the size of the initialized data on disk (for image files).">O tamanho da seção (para arquivos de objeto) ou o tamanho dos dados inicializados em disco (para arquivos de imagem).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary vsli:raw="Gets the virtual addess of the section.">Obtém a endereço virtual da seção.</summary>
      <returns vsli:raw="The virtual address of the section.">O endereço virtual da seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary vsli:raw="Gets the total size of the section when loaded into memory.">Obtém o tamanho total da seção quando carregada na memória.</summary>
      <returns vsli:raw="The total size of the section when loaded into memory.">O tamanho total da seção quando carregado na memória.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" vsli:raw="" />
      <param name="pointerToRawData" vsli:raw="" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary vsli:raw="Describes the subsystem requirement for the image.">Descreve o requisito de subsistema para a imagem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary vsli:raw="Extensible Firmware Interface (EFI) application.">Aplicativo de EFI (Interface de Firmware Extensível).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary vsli:raw="EFI driver with boot services.">Driver EFI com serviços de inicialização.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary vsli:raw="EFI ROM image.">Imagem ROM da EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary vsli:raw="EFI driver with run-time services.">Driver EFI com serviços de runtime.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary vsli:raw="The image doesn't require a subsystem.">A imagem não requer um subsistema.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary vsli:raw="The image is a native Win9x driver.">A imagem é um driver Win9x nativo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary vsli:raw="The image runs in the OS/2 character subsystem.">A imagem é executada no subsistema de caracteres OS/2.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary vsli:raw="The image runs in the Posix character subsystem.">A imagem é executada no subsistema de caracteres Posix.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary vsli:raw="Unknown subsystem.">Subsistema desconhecido.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary vsli:raw="Boot application.">Aplicativo de inicialização.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary vsli:raw="The image runs in the Windows CE subsystem.">A imagem é executada no subsistema do Windows CE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary vsli:raw="The image runs in the Windows character subsystem.">A imagem é executada no subsistema de caracteres do Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary vsli:raw="The image runs in the Windows GUI subsystem.">A imagem é executada no subsistema de GUI do Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary vsli:raw="Xbox system.">Sistema Xbox.</summary>
    </member>
  </members>
</doc>