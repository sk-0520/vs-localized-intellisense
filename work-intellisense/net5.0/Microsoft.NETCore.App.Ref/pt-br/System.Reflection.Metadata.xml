<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>Os bits mascarados de tipo de conteúdo que correspondem aos valores de <see cref="T:System.Reflection.AssemblyContentType" />.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>A otimização do compilador JIT (Just-In-Time) está desabilitada para o assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>O acompanhamento do compilador JIT (Just-In-Time) está habilitado para o assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>A referência de assembly contém a chave pública completa (sem hash). Não aplicável na definição de assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>A implementação do assembly de referência usado no runtime não deve corresponder à versão vista no tempo de compilação.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>O assembly contém código do Windows Runtime.</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>Especifica os algoritmos de hash usados para fazer hash de arquivos do assembly e para gerar o nome forte.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>Recupera o algoritmo de resumo da mensagem MD5.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>Uma máscara que indica que não há nenhum algoritmo de hash.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>Recupera uma revisão do Secure Hash Algorithm que corrige uma falha não publicada no SHA.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>Recupera uma versão do Secure Hash Algorithm com um tamanho de hash de 256 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>Recupera uma versão do Secure Hash Algorithm com um tamanho de hash de 384 bits.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>Recupera uma versão do Secure Hash Algorithm com um tamanho de hash de 512 bits.</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>Especifica as ações de segurança que podem ser executadas usando a segurança declarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>O código de chamada pode acessar o recurso identificado pelo objeto de permissão atual, mesmo que os chamadores na pilha não tenham recebido permissão para acessar o recurso.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>Verifique se todos os chamadores na cadeia de chamadas receberam a permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>Sem mais verificações, recuse a demanda pela permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>A classe derivada que está herdando a classe ou substituindo um método deverá ter recebido a permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>Verifique se o chamador imediato recebeu a permissão especificada.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>Nenhuma ação de segurança declarativa.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>Sem mais verificações, recuse a demanda por todas as permissões que não sejam as especificadas.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>Solicite as permissões mínimas necessárias para a execução do código. Esta ação só pode ser usada no escopo do assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>Solicite as permissões adicionais que são opcionais (não necessárias para a execução). Essa solicitação recusa implicitamente todas as outras permissões não solicitadas especificamente. Esta ação só pode ser usada no escopo do assembly.</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>Solicite que as permissões que podem ser usadas indevidamente não sejam concedidas ao código de chamada. Esta ação só pode ser usada no escopo do assembly.</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>O recurso não é exportado do assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>O recurso é exportado do assembly.</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>Oculta apenas os atributos relacionados à visibilidade.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>Representa a forma de um tipo de matriz.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.ArrayShape" />.</summary>
      <param name="rank">O número de dimensões na matriz.</param>
      <param name="sizes">O tamanho de cada dimensão.</param>
      <param name="lowerBounds">O limite inferior de cada dimensão.</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>Obtém o limite inferior de todas as dimensões. O tamanho pode ser menor que a classificação, quando então as dimensões à direita terão limites inferiores não especificados.</summary>
      <returns>Uma matriz de limites inferiores.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>Obtém o número de dimensões na matriz.</summary>
      <returns>O número de dimensões.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>Obtém os tamanhos de todas as dimensões.</summary>
      <returns>Uma matriz de tamanhos.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>Obtém um valor que indica se o arquivo contém metadados.</summary>
      <returns>
        <see langword="true" /> Se o arquivo contiver metadados, <see langword="false" /> caso contrário.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>Obtém o valor de hash do arquivo de conteúdo calculado usando <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.</summary>
      <returns>Uma <see cref="T:System.Reflection.Metadata.BlobHandle" /> instância que representa o valor de hash do conteúdo do arquivo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>Obtém o nome de arquivo, incluindo sua extensão.</summary>
      <returns>Uma <see cref="T:System.Reflection.Metadata.StringHandle" /> instância que representa o nome do arquivo com sua extensão.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>Representa uma coleção de <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>Uma coleção de referências de assembly.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>Compara o conteúdo atual deste gravador com outro.</summary>
      <param name="other">Uma instância de <see cref="T:System.Reflection.Metadata.BlobBuilder" /> a ser comparada com esta.</param>
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
      <returns>
        <see langword="true" /> se for igual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>Retorna uma sequência de todos os blobs que representam o conteúdo do construtor.</summary>
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
      <returns>Uma sequência de blobs.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>Reserva um bloco contíguo de bytes.</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>Tentativas de gravar uma sequência de bytes no construtor. Um valor retornado indica o número de bytes gravados com êxito.</summary>
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
      <returns>O número de bytes gravados com êxito do <paramref name="source" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>Grava um valor <see cref="T:System.Boolean" /> no construtor.</summary>
      <param name="value">O valor a ser gravado.</param>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>Grava um valor <see cref="T:System.Byte" /> no construtor.</summary>
      <param name="value">O valor a ser gravado.</param>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>Grava no construtor um número especificado de bytes de um buffer.</summary>
      <param name="buffer" />
      <param name="byteCount">O número de bytes a serem gravados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>Grava um número especificado de ocorrências de um valor de byte no construtor.</summary>
      <param name="value" />
      <param name="byteCount">O número de ocorrências de <paramref name="value" /> a serem gravadas.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>Grava o conteúdo de uma matriz de bytes no construtor.</summary>
      <param name="buffer">A matriz de bytes para gravação.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Grava no construtor um número especificado de bytes, começando em um índice especificado em uma matriz de bytes.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">O número de bytes a serem gravados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Grava o conteúdo de uma matriz de bytes imutável no construtor.</summary>
      <param name="buffer">A matriz a gravar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>Grava no construtor um número especificado de bytes, começando em um índice especificado de uma matriz imutável.</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">O número de bytes a serem gravados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>Implementa a codificação de inteiro não assinado compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value">O valor a ser gravado.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> não pode ser representado como um inteiro sem sinal compactado.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementa a codificação de inteiro assinada compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value">O valor a ser gravado.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> não pode ser representado como um inteiro com sinal compactado.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>Grava um valor constante (confira a seção 22.9, Partição II, do ECMA-335) na posição atual.</summary>
      <param name="value">O valor constante a ser gravado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> não é de um tipo de constante.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> é o padrão (<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
      <exception cref="T:System.InvalidOperationException">O conteúdo não está disponível. O construtor foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>Grava uma referência em um heap (deslocamento do heap) ou em uma tabela (número da linha).</summary>
      <param name="reference">Número do deslocamento ou da linha da tabela do heap.</param>
      <param name="isSmall">
        <see langword="true" /> para codificar a referência como um inteiro de 16 bits. <see langword="false" /> para codificá-la como um inteiro de 32 bits.</param>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>Grava uma cadeia de caracteres no formato SerString (confira os Atributos personalizados do capítulo 23.3 do ECMA-335-II).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>Grava uma cadeia de caracteres no formato de heap de Cadeia de Caracteres do Usuário (#US) (confira Heaps #US e #Blob do capítulo 24.2.4 do ECMA-335-II).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>Grava uma matriz de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>Grava uma cadeia de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>Grava uma cadeia de caracteres UTF8 codificada na posição atual.</summary>
      <param name="value">Valor constante.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> para codificar substitutos não emparelhados conforme o especificado. <see langword="false" /> para substituí-los por um caractere U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>Cria um leitor do bloco de memória especificado.</summary>
      <param name="buffer">Um ponteiro para o início do bloco de memória.</param>
      <param name="length">O comprimento em bytes do bloco de memória.</param>
      <exception cref="T:System.ArgumentNullException">O <paramref name="buffer" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> é negativo.</exception>
      <exception cref="T:System.PlatformNotSupportedException">A plataforma atual não é little endian.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>Reposiciona o leitor mais para frente considerando o número de bytes necessários para satisfazer o alinhamento especificado.</summary>
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>Pesquisa um byte especificado no blob após a posição atual.</summary>
      <param name="value">O valor de byte a ser localizado.</param>
      <returns>O índice em relação à posição atual ou -1 se o byte não for encontrado no blob após a posição atual.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>Lê um identificador de heap de blob codificado como um inteiro compactado.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>Lê os bytes, começando na posição atual.</summary>
      <param name="byteCount">O número de bytes a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
      <returns>A matriz de bytes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>Lê os bytes começando na posição atual e os grava no buffer especificado, começando no deslocamento especificado.</summary>
      <param name="byteCount">O número de bytes a serem lidos.</param>
      <param name="buffer">O buffer de destino no qual os bytes lidos serão gravados.</param>
      <param name="bufferOffset">O deslocamento no buffer de destino no qual os bytes lidos serão gravados.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>Lê um valor inteiro sem sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <exception cref="T:System.BadImageFormatException">Os dados na posição atual não eram um inteiro compactado válido.</exception>
      <returns>O valor do inteiro compactado que foi lido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>Lê um valor inteiro com sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <exception cref="T:System.BadImageFormatException">Os dados na posição atual não eram um inteiro compactado válido.</exception>
      <returns>O valor do inteiro compactado que foi lido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>Lê um valor constante (confira a seção 22.9, Partição II, do ECMA-335) da posição atual.</summary>
      <param name="typeCode" />
      <exception cref="T:System.BadImageFormatException">Erro ao ler do blob.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> não é um <see cref="T:System.Reflection.Metadata.ConstantTypeCode" /> válido.</exception>
      <returns>Um valor constante demarcado. Para evitar a alocação dos métodos Read* de uso de objeto diretamente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>Lê um número <see cref="T:System.Decimal" />.</summary>
      <exception cref="T:System.BadImageFormatException">Os dados na posição atual não eram um número <see cref="T:System.Decimal" /> válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>Lê um código do tipo codificado em um valor de atributo personalizado serializado.</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" /> se a codificação for inválida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>Lê uma cadeia de caracteres codificada como um inteiro compactado que contém seu comprimento seguido por seu conteúdo em UTF8. As cadeias de caracteres nulas são codificadas como um único byte 0xFF.</summary>
      <exception cref="T:System.BadImageFormatException">A codificação é inválida.</exception>
      <returns>Um valor de cadeia de caracteres ou <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>Lê um código de tipo codificado em uma assinatura.</summary>
      <returns>O código de tipo codificado no valor do atributo personalizado serializado se a codificação for válida ou <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> se a codificação for inválida.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>Lê um identificador de tipo codificado em uma assinatura como TypeDefOrRefOrSpecEncoded (confira a seção II.23.2.8 do ECMA-335).</summary>
      <returns>O identificador quando a codificação é válida. Caso contrário, um identificador no qual a propriedade <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> é <see langword="true" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>Lê uma cadeia de caracteres codificada em UTF16 (little endian) começando na posição atual.</summary>
      <param name="byteCount">O número de bytes a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
      <returns>A cadeia de caracteres.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>Lê uma cadeia de caracteres codificada em UTF8 começando na posição atual.</summary>
      <param name="byteCount">O número de bytes a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> bytes não estão disponíveis.</exception>
      <returns>A cadeia de caracteres.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>Reposiciona o leitor no início do bloco de memória subjacente.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>Lê um valor inteiro sem sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <param name="value">O valor do inteiro compactado que foi lido.</param>
      <returns>
        <see langword="true" /> se o valor foi lido com êxito. <see langword="false" /> se os dados na posição atual não eram um inteiro compactado válido.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>Lê um valor inteiro com sinal compactado. Consulte a seção de especificação de metadados II. 23.2: BLOBs e assinaturas.</summary>
      <param name="value">O valor do inteiro compactado que foi lido.</param>
      <returns>
        <see langword="true" /> se o valor foi lido com êxito. <see langword="false" /> se os dados na posição atual não eram um inteiro compactado válido.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>Obtém um ponteiro para o byte na posição atual do leitor.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>Obtém o comprimento total do bloco de memória subjacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>Obtém ou define o deslocamento do início do blob até a posição atual.</summary>
      <exception cref="T:System.BadImageFormatException">O deslocamento é definido fora dos limites do leitor subjacente.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>Obtém o número de bytes restantes da posição atual até o final do bloco de memória subjacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>Obtém um ponteiro para o byte no início do bloco de memória subjacente.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>Compara o conteúdo atual deste gravador com outro.</summary>
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do conteúdo do buffer.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado por <paramref name="start" /> e <paramref name="byteCount" /> está fora dos limites do <paramref name="buffer" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>Implementa a codificação de inteiro não assinado compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> não pode ser representado como um inteiro sem sinal compactado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>Implementa a codificação de inteiro assinada compactada conforme definido pelo ECMA-335-II capítulo 23,2: BLOBs e assinaturas.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> não pode ser representado como um inteiro com sinal compactado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>Grava um valor constante (confira a seção 22.9, Partição II, do ECMA-335) na posição atual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> não é de um tipo de constante.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>Grava uma referência em um heap (deslocamento do heap) ou em uma tabela (número da linha).</summary>
      <param name="reference">Número do deslocamento ou da linha da tabela do heap.</param>
      <param name="isSmall">
        <see langword="true" /> para codificar a referência como inteiro de 16 bits, <see langword="false" /> para codificar como inteiro de 32 bits.</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>Grava uma cadeia de caracteres no formato SerString (confira os Atributos personalizados do capítulo 23.3 do ECMA-335-II).</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>Grava uma cadeia de caracteres no formato de heap de Cadeia de Caracteres do Usuário (#US) (confira Heaps #US e #Blob do capítulo 24.2.4 do ECMA-335-II).</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">O construtor não é gravável e foi vinculado com outro.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>Grava uma cadeia de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>Grava uma cadeia de caracteres codificada UTF16 (little endian) na posição atual.</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>Grava uma cadeia de caracteres UTF8 codificada na posição atual.</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>Obtém o identificador pai (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>Obtém um código de tipo que identifica o tipo do valor constante.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>Obtém o valor da constante.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>Especifica os valores que representam tipos de constantes de metadados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Um tipo booleano.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>Um inteiro de 1 byte sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>Um tipo de caractere.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>Um tipo de ponto flutuante de 8 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>Um tipo de inteiro de 2 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>Um tipo de inteiro de 4 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>Um tipo de inteiro de 8 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>Um tipo inválido.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>Uma referência nula.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>Um tipo de inteiro de 1 byte com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>Um tipo de ponto flutuante de 4 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>Um tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>Um tipo de inteiro de 2 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>Um tipo de inteiro de 4 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>Um tipo de inteiro de 8 bytes sem sinal.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>Decodifica os argumentos codificados no blob de valor.</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>Obtém o construtor (o <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) do tipo de atributo personalizado.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>Obtém o identificador da entidade de metadados à qual o atributo é aplicado.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>Obtém o valor do atributo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>Representa um argumento nomeado decodificado de uma assinatura de atributo personalizado.</summary>
      <typeparam name="TType">O tipo usado para representar tipos de valores decodificados da assinatura de atributo personalizado.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> usando o nome, tipo e valor especificados.</summary>
      <param name="name">O nome do argumento.</param>
      <param name="kind">A variante do argumento.</param>
      <param name="type">O tipo do argumento.</param>
      <param name="value">O valor do argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>Obtém o tipo de argumento.</summary>
      <returns>O tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>Obtém o nome do argumento.</summary>
      <returns>O nome do argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>Obtém o tipo do argumento.</summary>
      <returns>O tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>Obtém o valor do argumento.</summary>
      <returns>Um objeto que contém o valor do argumento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>Especifica constantes que definem os tipos de argumentos em uma assinatura de atributo personalizado.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>Um argumento de campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>Um argumento de propriedade.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>Representa um argumento de tipo para um atributo de metadados personalizados.</summary>
      <typeparam name="TType">O tipo do argumento.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> usando o tipo e o valor do argumento especificado.</summary>
      <param name="type">O tipo do argumento.</param>
      <param name="value">O valor do argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>Obtém o tipo do argumento.</summary>
      <returns>O tipo de argumento.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>Obtém o valor do argumento.</summary>
      <returns>O valor do argumento.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>Representa um atributo personalizado do tipo especificado pelo <paramref name="TType" />.</summary>
      <typeparam name="TType">O tipo de atributo.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> usando os argumentos fixos e nomeados especificados.</summary>
      <param name="fixedArguments">Os argumentos fixos.</param>
      <param name="namedArguments">Os argumentos nomeados.</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>Obtém os argumentos fixos para o atributo personalizado.</summary>
      <returns>Uma matriz imutável de argumentos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>Obtém os argumentos nomeados para o valor de atributo personalizado.</summary>
      <returns>Uma matriz imutável de argumentos.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>Obtém o deslocamento (em bytes) do início do blob de metadados ao início do blob <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary>O documento de origem nos metadados de depuração.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>Obtém o hash de conteúdo do documento.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>Obtém o algoritmo de hash usado para calcular o <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>Obtém a linguagem do código-fonte (C#, VB, F#, etc.).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>Obtém o blob de nome do documento.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>Um <see cref="T:System.Reflection.Metadata.BlobHandle" /> que representa um blob no heap de #Blob no PDB portátil estruturado como Nome do Documento.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>Codifica a forma da matriz.</summary>
      <param name="rank">O número de dimensões na matriz (deverá ser 1 ou mais).</param>
      <param name="sizes">Tamanhos da dimensão. A matriz pode ser menor que <paramref name="rank" />, mas não maior.</param>
      <param name="lowerBounds">Limites inferiores da dimensão ou default(<see cref="T:System.Collections.Immutable.ImmutableArray`1" />) para definir todos os limites inferiores a 0 do <paramref name="rank" />.
A matriz pode ser menor que <paramref name="rank" />, mas não maior.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="rank" /> está fora do intervalo [1, 0xffff], é menor que <see langword="sizes.Length" /> ou que <see langword="lowerBounds.Length" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sizes" /> é <see langword="null" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary>Codifica um blob de assinatura de atributo personalizado.</summary>
      <param name="fixedArguments">Chamado primeiro, para codificar argumentos fixos.</param>
      <param name="namedArguments">Chamado em segundo lugar, para codificar argumentos nomeados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fixedArguments" /> ou <paramref name="namedArguments" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary>Codifica um blob de assinatura de atributo personalizado.
Retorna um par de codificadores que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="fixedArguments">Use em primeiro lugar, para codificar argumentos fixos.</param>
      <param name="namedArguments">Use em segundo lugar, para codificar argumentos nomeados.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary>Codifica o blob de assinatura de campo.</summary>
      <returns>Codificador do tipo de campo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary>Codifica uma assinatura da variável local.</summary>
      <param name="variableCount">Número de variáveis locais.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="variableCount" /> não está no intervalo [0, 0x1fffffff].</exception>
      <returns>Codificador de uma sequência de variáveis locais.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary>Codifica o blob de assinatura de método.</summary>
      <param name="convention">Convenção de chamada.</param>
      <param name="genericParameterCount">Número de parâmetros genéricos.</param>
      <param name="isInstanceMethod">
        <see langword="true" /> para codificar uma assinatura de método de instância, <see langword="false" /> para codificar uma assinatura de método estático.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> não está no intervalo [0, 0xffff].</exception>
      <returns>Um codificador do restante da assinatura, incluindo o valor retornado e os parâmetros.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary>Codifica um blob de assinatura de especificação de método.</summary>
      <param name="genericArgumentCount">Número de argumentos genéricos.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> não está no intervalo [0, 0xffff].</exception>
      <returns>Codificador de argumentos genéricos.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary>Codifica argumentos do conjunto de permissões.</summary>
      <param name="argumentCount">Número de argumentos no conjunto.</param>
      <returns>Codificador dos argumentos do conjunto.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary>Codifica um blob do conjunto de permissões.</summary>
      <param name="attributeCount">Número de atributos no conjunto.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="attributeCount" /> não está no intervalo [0, 0x1fffffff].</exception>
      <returns>Codificador do conjunto de permissões.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary>Codifica o blob de assinatura de propriedade.</summary>
      <param name="isInstanceProperty">
        <see langword="true" /> para codificar uma assinatura de propriedade de instância, <see langword="false" /> para codificar uma assinatura de propriedade estática.</param>
      <returns>Um codificador do restante da assinatura, incluindo o valor retornado e os parâmetros, que tem a mesma estrutura que a assinatura de método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary>Codifica a assinatura de especificação de tipo.</summary>
      <returns>O codificador de tipo do tipo estruturado representado pela especificação de tipo (ele não deverá codificar um tipo primitivo).</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado CustomAttributeType para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado HasConstant para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado HasCustomAttribute para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado HasCustomDebugInformation para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> ou <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado HasDeclSecurity para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado HasFieldMarshal para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> ou <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado HasSemantics para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula uma implementação codificada para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado MemberForwarded para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado MemberRefParent para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado MethodDefOrRef para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado ResolutionScope para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado TypeDefOrRef para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado TypeDefOrRefOrSpec para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary>Calcula um índice codificado TypeOrMethodDef para o manipulador especificado.</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">O tipo de identificador é inesperado.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Adiciona a região catch.</summary>
      <param name="tryStart">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <param name="catchType">O tipo de exceção a ser detectado: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.

- ou -

<paramref name="catchType" /> não é um identificador de tipo válido.</exception>
      <exception cref="T:System.ArgumentNullException">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Adiciona a região fault.</summary>
      <param name="tryStart">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <exception cref="T:System.ArgumentException">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.</exception>
      <exception cref="T:System.ArgumentNullException">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Adiciona a região catch.</summary>
      <param name="tryStart">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <param name="filterStart">Rótulo que marca a primeira instrução do bloco filter.</param>
      <exception cref="T:System.ArgumentException">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.</exception>
      <exception cref="T:System.ArgumentNullException">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Adiciona a região finally.</summary>
      <param name="tryStart">Rótulo que marca a primeira instrução do bloco try.</param>
      <param name="tryEnd">Rótulo que marca a instrução imediatamente após o bloco try.</param>
      <param name="handlerStart">Rótulo que marca a primeira instrução do manipulador.</param>
      <param name="handlerEnd">Rótulo que marca a instrução imediatamente após o manipulador.</param>
      <exception cref="T:System.ArgumentException">Um rótulo não foi definido por um codificador de instruções ao qual este construtor está associado.</exception>
      <exception cref="T:System.ArgumentNullException">Um rótulo tem valor padrão.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Codifica um modificador personalizado.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="isOptional">É modificador opcional.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> é <see langword="null" /> ou de um tipo inesperado.</exception>
      <returns>Codificador de modificadores subsequentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Adiciona uma cláusula de exceção.</summary>
      <param name="kind">Tipo de cláusula.</param>
      <param name="tryOffset">Deslocamento inicial do bloco try.</param>
      <param name="tryLength">Comprimento do bloco try.</param>
      <param name="handlerOffset">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength">Comprimento do manipulador.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> ou nil se <paramref name="kind" /> não for <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" /></param>
      <param name="filterOffset">Deslocamento do bloco filter ou 0 se o <paramref name="kind" /> não for <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> é inválido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="kind" /> tem um valor inválido.
          
- ou -

<paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns>Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary>Adiciona uma cláusula fault.</summary>
      <param name="tryOffset">Deslocamento inicial do bloco try.</param>
      <param name="tryLength">Comprimento do bloco try.</param>
      <param name="handlerOffset">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength">Comprimento do manipulador.</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> é inválido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns>Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Adiciona uma cláusula fault.</summary>
      <param name="tryOffset">Deslocamento inicial do bloco try.</param>
      <param name="tryLength">Comprimento do bloco try.</param>
      <param name="handlerOffset">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength">Comprimento do manipulador.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns>Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Adiciona uma cláusula fault.</summary>
      <param name="tryOffset">Deslocamento inicial do bloco try.</param>
      <param name="tryLength">Comprimento do bloco try.</param>
      <param name="handlerOffset">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength">Comprimento do manipulador.</param>
      <param name="filterOffset">Deslocamento do bloco filter.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns>Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Adiciona uma cláusula finally.</summary>
      <param name="tryOffset">Deslocamento inicial do bloco try.</param>
      <param name="tryLength">Comprimento do bloco try.</param>
      <param name="handlerOffset">Deslocamento inicial do manipulador.</param>
      <param name="handlerLength">Comprimento do manipulador.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> ou <paramref name="handlerLength" /> está fora do intervalo.</exception>
      <exception cref="T:System.InvalidOperationException">Não foi declarado que o corpo do método tem regiões de exceção.</exception>
      <returns>Codificador para a próxima cláusula.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary>Retornará <see langword="true" /> se a região se ajustar a um formato pequeno.</summary>
      <param name="startOffset">Deslocamento inicial da região.</param>
      <param name="length">Comprimento da região.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary>Retornará <see langword="true" /> se o número de regiões de exceção se ajustar a um formato pequeno.</summary>
      <param name="exceptionRegionCount">O número de regiões de exceção.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary>O construtor subjacente.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary>
        <see langword="true" /> se o codificador usar um formato pequeno.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary>Fornece um método de extensão para acessar a coluna TypeDefinitionId da tabela ExportedType.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary>Obtém uma dica do número de linha provável do tipo de destino na tabela TypeDef de módulo dele.
Se os namespaces e os nomes não coincidirem, a resolução fará fallback para uma pesquisa completa da tabela TypeDef de destino. Ignorado e deverá ser zero se <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> for <see langword="true" />.</summary>
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary>Codifica instruções.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary>Cria um codificador com suporte de construtores de código e de fluxo de controle.</summary>
      <param name="codeBuilder">Construtor no qual gravar instruções codificadas.</param>
      <param name="controlFlowBuilder">Rótulos de acompanhamento, branches e de manipuladores de exceção do construtor.
Deve ser especificado para poder usar alguns dos métodos de fábrica de fluxo de controle de <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />, como <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /> etc.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Codifica uma instrução branch.</summary>
      <param name="code">Instrução branch a ser codificada.</param>
      <param name="label">Rótulo do local de destino no fluxo de instrução.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="code" /> não é uma instrução de branch.

- ou - 
<paramref name="label" /> não foi definido por este codificador.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary>Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Codifica a instrução <c>call</c> e o operando dela.</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Codifica a instrução <c>calli</c> e o operando dela.</summary>
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary>Define um rótulo que pode ser usado posteriormente para marcar e se referir a um local no fluxo de instrução.</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> é <see langword="null" />.</exception>
      <returns>Manipulador de rótulo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary>Codifica a instrução load do argumento.</summary>
      <param name="argumentIndex">Índice do argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary>Codifica a instrução load do endereço do argumento.</summary>
      <param name="argumentIndex">Índice do argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary>Codifica a instrução constant load <see cref="T:System.Int32" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary>Codifica a instrução constant load <see cref="T:System.Int64" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary>Codifica a instrução constant load <see cref="T:System.Single" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary>Codifica a instrução constant load <see cref="T:System.Double" />.</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary>Codifica a instrução load variable local.</summary>
      <param name="slotIndex">Índice do slot variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary>Codifica a instrução variable address load local.</summary>
      <param name="slotIndex">Índice do slot variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary>Codifica a instrução <c>ldstr</c> e o operando dela.</summary>
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Associa o rótulo especificado ao deslocamento de IL atual.</summary>
      <param name="label">Rótulo a ser marcado.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="label" /> não foi definido por este codificador.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> tem valor padrão.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary>Codifica o código op especificado.</summary>
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary>Codifica a instrução argument store.</summary>
      <param name="argumentIndex">Índice do argumento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary>Codifica a instrução variable store local.</summary>
      <param name="slotIndex">Índice do slot variable local.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary>Codifica um token.</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary>Codifica um token.</summary>
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary>Construtor subjacente no qual as instruções codificadas são gravadas.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary>Rótulos de acompanhamento, branches e de manipuladores de exceção do construtor.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary>Deslocamento da próxima instrução codificada.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>ID de base 1 que identifica o rótulo dentro do contexto de um <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>Fornece métodos para codificação de literais.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">Cria uma instância da classe <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> com o construtor de blobs especificado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>Retorna o codificador usado para codificar o valor da literal.</summary>
      <returns>O codificador do valor da literal.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>Codifica o tipo e o valor de uma literal usando os delegados especificados.</summary>
      <param name="type">Um delegado usado para codificar o tipo da literal. Chamado primeiro por esse método.</param>
      <param name="scalar">Um delegado usado para codificar o valor da literal. Chamado em segundo lugar por esse método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="scalar" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>Retorna um par de codificadores que devem ser usados para codificar o tipo e o valor de uma literal na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="type">Quando esse método é retornado, um codificador de tipo de elemento de atributo personalizado usado para codificar o tipo da literal.</param>
      <param name="scalar">Quando esse método é retornado, um escalar codificado usado para codificar o valor da literal.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>Codifica o tipo e os itens de uma literal de vetor usando os delegados especificados.</summary>
      <param name="arrayType">Um delegado usado para codificar o tipo do vetor. Chamado primeiro por esse método.</param>
      <param name="vector">Um delegado usado para codificar os itens do vetor. Chamado em segundo lugar por esse método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayType" /> ou <paramref name="vector" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>Retorna um par de codificadores que devem ser usados para codificar o tipo e os itens de uma literal de vetor na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="arrayType">Quando esse método é retornado, um codificador de tipo de matriz de atributo personalizado usado para codificar o tipo do vetor.</param>
      <param name="vector">Quando esse método é retornado, um codificador de vetor usado para codificar os itens do vetor.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>Obtém um codificador de vetor usado para codificar os itens de um vetor.</summary>
      <returns>Um codificador de vetor usado para codificar os itens de um vetor.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>Calcula o identificador da entidade dentro da geração de metadados em que ela está definida, considerando o identificador de uma entidade em metadados de agregação.</summary>
      <param name="handle">Identificador de uma entidade em metadados de agregação.</param>
      <param name="generation">A geração em que a entidade está definida.</param>
      <returns>Identificador da entidade dentro dos metadados <paramref name="generation" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>A classe MetadataBuilder lê e grava metadados para um assembly de uma maneira que proporciona alto desempenho. Ele foi projetado para ser usado por compiladores e outras ferramentas de geração de assembly.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Cria um construtor para heaps e tabelas de metadados.</summary>
      <param name="userStringHeapStartOffset">O deslocamento inicial do heap de cadeias de caracteres do usuário. O tamanho cumulativo de heaps de cadeias de caracteres do usuário de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <param name="stringHeapStartOffset">O deslocamento inicial do heap de cadeias de caracteres. O tamanho cumulativo de heaps de cadeias de caracteres de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <param name="blobHeapStartOffset">O deslocamento inicial do heap de blobs. O tamanho cumulativo de heaps de blobs de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <param name="guidHeapStartOffset">O deslocamento inicial do heap de GUIDs. O tamanho cumulativo de heaps de GUIDs de todas as gerações anteriores do EnC deve ser 0, a menos que os metadados sejam metadados do EnC delta.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">O deslocamento é muito grande.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O deslocamento é negativo.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="guidHeapStartOffset" /> não é um múltiplo do tamanho de GUID.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>Adiciona um valor padrão para um parâmetro, campo ou propriedade.</summary>
      <param name="parent">O identificador de entidade pai, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="value">O valor da constante.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a constante adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona um atributo personalizado.</summary>
      <param name="parent">Uma entidade à qual anexar o atributo personalizado: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
      <param name="constructor">Um construtor de atributo personalizado: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="value">Um blob de valor de atributo personalizado.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para o atributo personalizado adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona informações de depuração personalizadas.</summary>
      <param name="parent">Uma entidade à qual anexar as informações de depuração: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> ou <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
      <param name="kind">O tipo das informações. Determina a estrutura do blob de <paramref name="value" />.</param>
      <param name="value">O blob de informações de depuração personalizadas.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para as informações de depuração personalizadas adicionadas.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona um atributo de segurança declarativa a um tipo, um método ou um assembly.</summary>
      <param name="parent">O identificador de entidade pai, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
      <param name="action">Uma ação de segurança declarativa.</param>
      <param name="permissionSet">O blob de conjunto de permissões.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para o atributo de segurança declarativa adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>Adiciona informações de depuração do documento.</summary>
      <param name="name">O blob de nome do documento.</param>
      <param name="hashAlgorithm">O GUID do algoritmo de hash usado para calcular o valor de <paramref name="hash" />.</param>
      <param name="hash">O hash do conteúdo do documento.</param>
      <param name="language">O GUID da linguagem de programação.</param>
      <returns>Um identificador para o documento adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Adiciona uma definição de evento.</summary>
      <param name="attributes">Os atributos do evento.</param>
      <param name="name">O nome do evento.</param>
      <param name="type">O tipo do evento: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a definição de evento adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>Adiciona um tipo exportado.</summary>
      <param name="attributes">Os atributos de tipo.</param>
      <param name="namespace">O namespace de tipo.</param>
      <param name="name">O nome do tipo.</param>
      <param name="implementation">O identificador de entidade de implementação, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ou <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
      <param name="typeDefinitionId">A ID de definição de tipo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para o tipo exportado adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona uma definição de campo.</summary>
      <param name="attributes">Os atributos do campo.</param>
      <param name="name">O nome do campo.</param>
      <param name="signature">A assinatura de campo. Use <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> para construir o blob.</param>
      <returns>Um identificador para a definição de campo adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Define um layout de campo de uma definição de campo.</summary>
      <param name="field">O identificador de definição de campo.</param>
      <param name="offset">O deslocamento de bytes do campo dentro da instância do tipo declarativo.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>Adiciona um mapeamento de um campo para o respectivo valor inicial armazenado na imagem PE.</summary>
      <param name="field">O identificador de definição de campo.</param>
      <param name="offset">O deslocamento dentro do bloco na imagem PE que armazena os valores iniciais de campos mapeados (geralmente na seção .text).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Adiciona uma definição de parâmetro genérico.</summary>
      <param name="parent">O identificador de entidade pai, que pode ser <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
      <param name="attributes">Os atributos de parâmetro genérico.</param>
      <param name="name">O nome do parâmetro.</param>
      <param name="index">O índice de parâmetro baseado em zero.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Um identificador para o parâmetro genérico adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Adiciona uma restrição de tipo a um parâmetro genérico.</summary>
      <param name="genericParameter">O parâmetro genérico a ser restringido.</param>
      <param name="constraint">A restrição de tipo, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericParameter" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a restrição de parâmetro genérico adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona informações de depuração do escopo local.</summary>
      <param name="parentScope">O identificador de escopo pai.</param>
      <param name="imports">O identificador de escopo de importação.</param>
      <returns>Um identificador para o escopo de importação adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Adiciona uma implementação de interface a um tipo.</summary>
      <param name="type">O tipo que implementa a interface.</param>
      <param name="implementedInterface">A interface que está sendo implementada, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementedInterface" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a implementação de interface adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona informações de depuração da constante local.</summary>
      <param name="name">O nome da variável.</param>
      <param name="signature">O blob LocalConstantSig.</param>
      <returns>Um identificador para a constante local adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>Adiciona informações de depuração do escopo local.</summary>
      <param name="method">O método continente.</param>
      <param name="importScope">O identificador do escopo de importação associado.</param>
      <param name="variableList">Se o escopo declarar variáveis, defina esse identificador como o identificador da primeira delas. Caso contrário, defina-o como o identificador da primeira variável declarada pela próxima definição de escopo. Se nenhum escopo definir nenhuma variável, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
      <param name="constantList">Se o escopo declarar constantes, defina esse identificador como o identificador da primeira delas. Caso contrário, defina-o como o identificador da primeira constante declarada pela próxima definição de escopo. Se nenhum escopo definir nenhuma constante, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
      <param name="startOffset">O deslocamento da primeira instrução abrangida pelo escopo.</param>
      <param name="length">O tamanho, em bytes, do escopo.</param>
      <returns>Um identificador para o escopo local adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>Adiciona informações de depuração da variável local.</summary>
      <param name="attributes">Os atributos da variável local.</param>
      <param name="index">O índice de base zero da variável local na assinatura local.</param>
      <param name="name">O nome da variável.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Um identificador para a variável local adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>Adiciona um recurso de manifesto.</summary>
      <param name="attributes">Os atributos do recurso de manifesto.</param>
      <param name="name">O nome do recurso de manifesto.</param>
      <param name="implementation">O identificador de entidade de implementação, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> ou <see langword="null" />.</param>
      <param name="offset">Especifica o deslocamento de bytes no arquivo referenciado no qual este registro de recurso começa.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para o recurso de manifesto adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona informações de marshaling a um campo ou parâmetro.</summary>
      <param name="parent">O identificador de entidade pai, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> ou <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
      <param name="descriptor">O blob do descritor.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona uma linha de tabela MemberRef.</summary>
      <param name="parent">A entidade continente, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
      <param name="name">O nome do membro.</param>
      <param name="signature">A assinatura do membro.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a referência de membro adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona informações de depuração do método.</summary>
      <param name="document">O identificador de um único documento que contém todos os pontos de sequência do método ou <see langword="null" /> caso o método não tenha pontos de sequência ou abranja vários documentos.</param>
      <param name="sequencePoints">O blob de pontos de sequência ou <see langword="null" /> caso o método não tenha pontos de sequência.</param>
      <returns>Um identificador para as informações de depuração do método adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>Adiciona uma definição de método.</summary>
      <param name="attributes">Os atributos do método.</param>
      <param name="implAttributes">Os atributos de implementação de método.</param>
      <param name="name">O nome do método.</param>
      <param name="signature">A assinatura do método.</param>
      <param name="bodyOffset">Deslocamento dentro do bloco na imagem PE que armazena corpos de método – o fluxo de IL (linguagem intermediária) – ou -1 se o método não tiver um corpo.</param>
      <param name="parameterList">Se o método declarar parâmetros na tabela Params, defina-o como o identificador do primeiro parâmetro. Caso contrário, defina-o como o identificador do primeiro parâmetro declarado pela próxima definição de método. Se nenhum parâmetro for declarado no módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bodyOffset" /> é menor que -1.</exception>
      <returns>Um identificador para a definição de método adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Define uma implementação para uma declaração de método dentro de um tipo.</summary>
      <param name="type">A definição de tipo.</param>
      <param name="methodBody">O identificador de entidade do corpo do método, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="methodDeclaration">O identificador de entidade da declaração de método, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodBody" /> ou <paramref name="methodDeclaration" /> não têm o tipo de identificador esperado.</exception>
      <returns>Um identificador para a implementação de método adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Adiciona informações de importação a uma definição de método.</summary>
      <param name="method">O identificador de definição do método.</param>
      <param name="attributes">Os atributos de importação de método.</param>
      <param name="name">O nome do método não gerenciado.</param>
      <param name="module">O módulo que contém o método não gerenciado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Associa um método (um getter, um setter, um adicionador etc.) a uma propriedade ou um evento.</summary>
      <param name="association">O identificador de entidade de associação, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
      <param name="semantics">Os atributos de semântica de método.</param>
      <param name="methodDefinition">A definição de método.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="association" /> não tem o tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona uma especificação de método (uma instanciação).</summary>
      <param name="method">O identificador de entidade do método genérico, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
      <param name="instantiation">O blob de instanciação que codifica os argumentos genéricos do método.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a especificação de método adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Define uma relação de aninhamento para definições de tipo especificadas.</summary>
      <param name="type">O identificador de definição de tipo aninhado.</param>
      <param name="enclosingType">O identificador de definição de tipo delimitador.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>Adiciona uma definição de parâmetro.</summary>
      <param name="attributes">Os atributos de parâmetro.</param>
      <param name="name">Opcional. O nome do parâmetro.</param>
      <param name="sequenceNumber">O número de sequência do parâmetro. Um valor de 0 refere-se ao tipo de retorno do método de proprietário; em seguida, seus parâmetros são numerados de 1 em diante.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sequenceNumber" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      <returns>Um identificador para o parâmetro adicionado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>Adiciona uma definição de propriedade.</summary>
      <param name="attributes">Os atributos da propriedade.</param>
      <param name="name">O nome da propriedade.</param>
      <param name="signature">A assinatura da propriedade.</param>
      <returns>Um identificador para a definição de propriedade adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Adiciona informações de depuração do método de máquina de estado.</summary>
      <param name="moveNextMethod">O identificador do método <see langword="MoveNext" /> da máquina de estado (o método gerado pelo compilador).</param>
      <param name="kickoffMethod">O identificador do método de início (o método iterador/assíncrono definido pelo usuário).</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Adiciona uma definição de tipo.</summary>
      <param name="attributes">Os atributos de tipo.</param>
      <param name="namespace">O namespace de tipo.</param>
      <param name="name">O nome do tipo.</param>
      <param name="baseType">O identificador de entidade de tipo base, que pode ser um dos seguintes: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> ou <see langword="null" />.</param>
      <param name="fieldList">Se o tipo declarar campos, defina esse identificador como o identificador do primeiro deles. Caso contrário, defina-o como o identificador do primeiro campo declarado pela próxima definição de tipo. Se nenhum tipo definir nenhum campo no módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
      <param name="methodList">Se o tipo declarar métodos, defina esse identificador como o identificador do primeiro deles. Caso contrário, defina-o como o identificador do primeiro método declarado pela definição de tipo seguinte. Se nenhum tipo definir nenhum método no módulo, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="baseType" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a definição de tipo adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>Define um layout de tipo de uma definição de tipo.</summary>
      <param name="type">A definição de tipo.</param>
      <param name="packingSize">Especifica que os campos devem ser colocados dentro da instância de tipo em endereços de byte que são um múltiplo de <paramref name="packingSize" /> ou em um alinhamento natural para esse tipo de campo, o que for menor. Seu valor deve ser um dos seguintes: 0, 1, 2, 4, 8, 16, 32, 64 ou 128. Um valor de zero indica que o tamanho de compactação usado deve corresponder ao padrão para a plataforma atual.</param>
      <param name="size">Indica um tamanho mínimo da instância do tipo e destina-se a permitir o preenchimento. A quantidade de memória alocada é o máximo do tamanho calculado com base no layout e em <paramref name="size" />. Observe que, se essa diretiva se aplicar a um tipo de valor, o tamanho será menor que 1 MB.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>Adiciona uma referência de tipo.</summary>
      <param name="resolutionScope">A entidade que declara o tipo de destino, que pode ser uma das seguintes: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see langword="null" />.</param>
      <param name="namespace">O namespace de referência de tipo.</param>
      <param name="name">O nome de referência de tipo.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="resolutionScope" /> não tem o tipo de identificador esperado.</exception>
      <returns>Um identificador para a referência de tipo adicionada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>Adicionará o blob especificado ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value">A matriz que contém o blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Adicionará o blob especificado de uma matriz de bytes ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value">A matriz que contém o blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>Adicionará o blob especificado de uma matriz de bytes imutável ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value">A instância do construtor de blobs que contém o blob.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>Codifica uma cadeia de caracteres usando a codificação UTF16 em um blob e a adiciona ao heap de blobs, caso ainda não exista.</summary>
      <param name="value">A cadeia de caracteres a ser adicionada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>Codifica uma cadeia de caracteres usando a codificação UTF8 em um blob e a adiciona ao heap de blobs, caso ainda não exista.</summary>
      <param name="value">O valor a ser adicionado.</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> para codificar substitutos não emparelhados conforme o especificado; <see langword="false" /> para substituí-los por um caractere U+FFFD.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>Codifica um valor de constante em um blob e o adiciona ao heap de blobs, caso ainda não exista. Usa UTF16 para codificar constantes de cadeia de caracteres.</summary>
      <param name="value">O valor constante a ser adicionado.</param>
      <returns>Um identificador para o blob adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>Codifica um nome de documento de depuração e o adiciona ao heap de blobs, caso ele ainda não esteja lá.</summary>
      <param name="value">O nome do documento a adicionar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para o blob de nome de documento adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>Adicionará o GUID especificado ao heap de GUIDs, caso ele ainda não esteja lá.</summary>
      <param name="guid">O GUID a adicionar.</param>
      <returns>Um identificador para o GUID adicionado ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>Adiciona a cadeia de caracteres especificada ao heap de cadeias de caracteres, caso ela ainda não esteja lá.</summary>
      <param name="value">A cadeia de caracteres a ser adicionada.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para a cadeia de caracteres adicionada ou existente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>Adiciona a cadeia de caracteres especificada ao heap de cadeias de caracteres de usuário, caso ela ainda não esteja lá.</summary>
      <param name="value">A cadeia de caracteres a ser adicionada.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">O espaço restante no heap é muito pequeno para se ajustar à cadeia de caracteres.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> é <see langword="null" />.</exception>
      <returns>Um identificador para a cadeia de caracteres adicionada ou existente. Esse valor pode ser usado em <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retorna o número atual de itens na tabela especificada.</summary>
      <param name="table">O índice de tabela.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> não é um índice de tabela válido.</exception>
      <returns>O número de itens na tabela.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>Retorna o número atual de itens em cada tabela.</summary>
      <returns>Uma matriz de tamanho <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, com cada item preenchido com a contagem de linhas atual da tabela correspondente.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>Reserva espaço no heap de GUIDs para um GUID.</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">O espaço restante no heap é muito pequeno para se ajustar à cadeia de caracteres.</exception>
      <returns>Um identificador para o GUID reservado e um <see cref="T:System.Reflection.Metadata.Blob" /> que representa o blob de GUID como armazenado no heap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>Reserva espaço no heap de cadeias de caracteres do usuário para uma cadeia de caracteres do comprimento especificado.</summary>
      <param name="length">O número de caracteres a serem reservados.</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">O espaço restante no heap é muito pequeno para se ajustar à cadeia de caracteres.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> é negativo.</exception>
      <returns>Um identificador para a cadeia de caracteres de usuário reservada e um <see cref="T:System.Reflection.Metadata.Blob" /> que representa o blob de cadeia de caracteres do usuário inteiro (incluindo seu comprimento e seu caractere terminal). O identificador pode ser usado em <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
Use <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> para preencher o conteúdo do blob.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>Define a capacidade do heap especificado.</summary>
      <param name="heap">O índice de heap.</param>
      <param name="byteCount">O número de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heap" /> não é um índice de heap válido.

- ou -

<paramref name="byteCount" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Define a capacidade da tabela especificada.</summary>
      <param name="table">O índice de tabela.</param>
      <param name="rowCount">O número de linhas da tabela.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> não é um índice de tabela válido.

- ou -

<paramref name="rowCount" /> é negativo.</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>Fornece métodos de extensão para trabalhar com determinados elementos brutos das tabelas e heaps de metadados ECMA-335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera as entradas do log do EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>Enumera as entradas do mapa do EnC.</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Retorna o deslocamento do início dos metadados para o heap especificado.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> não é um índice de heap válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Retorna o tamanho do heap especificado.</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> não é um índice de heap válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>Retorna o identificador para o <see cref="T:System.Reflection.Metadata.Blob" /> que segue o fornecido no heap de <see cref="T:System.Reflection.Metadata.Blob" /> ou um identificador nil caso ele seja o último.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>Retorna o identificador para a cadeia de caracteres que segue o fornecido no heap de cadeia de caracteres ou um identificador nil caso ele seja o último.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>Retorna o identificador para a UserString que segue o fornecido no heap de UserString ou um identificador nil caso ele seja o último.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retorna o deslocamento do início dos metadados até a tabela especificada.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retorna o número de linhas na tabela especificada.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>Retorna o tamanho de uma linha na tabela especificada.</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>Tipos enumerados que definem um ou mais eventos.</summary>
      <param name="reader" />
      <returns>A sequência resultante corresponde exatamente às entradas na tabela EventMap, ou seja, o enésimo <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> retornado é armazenado na enésima linha de EventMap.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>Tipos enumerados que definem uma ou mais propriedades.</summary>
      <param name="reader" />
      <returns>A sequência resultante corresponde exatamente às entradas na tabela do mapa de propriedades, ou seja, o n-ésimo <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> retornado é armazenado na n-ésima linha do mapa de propriedades.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>Fornecidos um identificador de tipo e um tipo bruto, encontrados em um blob de assinatura, determina se o tipo de destino é um tipo de valor ou de referência.</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>Construtor de uma raiz de metadados a ser inserido em uma imagem executável portátil.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>Cria um construtor de uma raiz de metadados.</summary>
      <param name="tablesAndHeaps">Construtor preenchido com entidades de metadados armazenadas em tabelas e valores armazenados em heaps. As entidades e os valores serão enumerados ao serializar a raiz dos metadados.</param>
      <param name="metadataVersion">A cadeia de caracteres de versão gravada no cabeçalho de metadados. O valor padrão é "v4.0.30319".</param>
      <param name="suppressValidation">
        <see langword="true" /> para suprimir a validação básica de tabelas de metadados durante a serialização; caso contrário, <paramref name="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataVersion" /> é muito longo (o número de bytes quando codificados em UTF8 deve ser menor que 255).</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>Serializa o conteúdo raiz dos metadados no <see cref="T:System.Reflection.Metadata.BlobBuilder" /> fornecido.</summary>
      <param name="builder">O construtor no qual gravar.</param>
      <param name="methodBodyStreamRva">O endereço virtual relativo do início do fluxo do corpo do método. Usado para calcular o valor final dos campos de RVA da tabela MethodDef.</param>
      <param name="mappedFieldDataStreamRva">O endereço virtual relativo do início do fluxo de dados de inicialização de campos. Usado para calcular o valor final dos campos de RVA da tabela FieldRVA.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="methodBodyStreamRva" /> ou <paramref name="mappedFieldDataStreamRva" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException">Uma tabela de metadados não está ordenada como exigido pela especificação, e <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> é <see langword="false" />.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>A versão dos metadados.</summary>
      <returns>Uma cadeia de caracteres que representa a versão de metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>Retorna tamanhos de várias estruturas de metadados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>Determina se a validação básica de tabelas de metadados deve ser suprimida. A validação verifica se as entradas nas tabelas foram adicionadas na ordem exigida pela especificação ECMA. Ela não impõe todos os requisitos de especificação em tabelas de metadados.</summary>
      <returns>
        <see langword="true" /> para suprimir a validação básica de tabelas de metadados; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>Fornece informações sobre tamanhos de várias estruturas de metadados.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>Retorna o tamanho alinhado do heap especificado.</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>Contagem de linhas da tabela externa.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>Tamanhos de heap exatos (não alinhados).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>Contagens de linhas da tabela.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Número máximo de tabelas que podem estar presentes nos metadados do Ecma335.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Número máximo de tabelas que podem estar presentes nos metadados do Ecma335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>Cria um identificador de entidade usando um valor de token.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> não é um token de entidade de metadados válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Cria um <see cref="T:System.Reflection.Metadata.EntityHandle" /> usando um valor de token.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Deslocamento baseado em zero, ou -1 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Índice baseado em 1 no heap #Guid. Ao contrário de outros heaps, que são basicamente matrizes de bytes, o heap #Guid é uma matriz de GUIDs de 16 bytes.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Um deslocamento no heap correspondente, ou -1 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">A operação não tem suporte no <paramref name="handle" /> especificado.</exception>
      <exception cref="T:System.ArgumentException">O <paramref name="handle" /> é inválido.</exception>
      <returns>Deslocamento baseado em zero, ou -1 se <paramref name="handle" /> não for um identificador de heap de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Deslocamento baseado em zero, ou -1 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> ou <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>Obtém o deslocamento dos dados de heap de metadados que correspondem ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Deslocamento baseado em zero.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>Obtém o número da linha de uma entrada da tabela de metadados que corresponde ao <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Número de linha baseado em um ou -1, se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.
Consulte <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Obtém o número da linha de uma entrada da tabela de metadados que corresponde ao <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">O <paramref name="handle" /> não é um identificador de tabela de metadados válido.</exception>
      <returns>Número de linha baseado em um.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>Obtém o token de metadados do <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <returns>Token de metadados, ou 0 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>Obtém o token de metadados do <paramref name="handle" /> especificado.</summary>
      <param name="handle" />
      <exception cref="T:System.ArgumentException">O identificador representa uma entidade de metadados que não tem um token.
Só é possível recuperar um token para um identificador de tabela de metadados ou um identificador de heap do tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <returns>Token de metadados, ou 0 se <paramref name="handle" /> puder ser interpretado apenas no contexto de um <see cref="T:System.Reflection.Metadata.MetadataReader" /> específico.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>Obtém o token de metadados do <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">A operação não tem suporte no <paramref name="handle" /> especificado.</exception>
      <returns>Token de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>Obtém o token de metadados do <paramref name="handle" /> especificado no contexto de <paramref name="reader" />.</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">O identificador representa uma entidade de metadados que não tem um token.
Só é possível recuperar um token para um identificador de tabela de metadados ou um identificador de heap do tipo <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
      <exception cref="T:System.NotSupportedException">A operação não tem suporte no <paramref name="handle" /> especificado.</exception>
      <returns>Token de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>Cria um identificador usando um valor de token.</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> não é um token de metadados válido.
Ele deve codificar uma entidade de tabela de metadados ou um deslocamento no heap <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>Cria um <see cref="T:System.Reflection.Metadata.EntityHandle" /> usando um valor de token.</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> não é um índice de tabela válido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>Obtém o <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> do heap correspondente ao <see cref="T:System.Reflection.Metadata.HandleKind" /> especificado.</summary>
      <param name="type">Tipo de identificador.</param>
      <param name="index">Índice do heap.</param>
      <returns>
        <see langword="true" /> se o tipo de identificador corresponder a um heap do Ecma335; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>Obtém o <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> da tabela correspondente ao <see cref="T:System.Reflection.Metadata.HandleKind" /> especificado.</summary>
      <param name="type">Tipo de identificador.</param>
      <param name="index">Índice de tabela.</param>
      <returns>
        <see langword="true" /> se o tipo de identificador corresponder a uma tabela Ecma335 ou Portable PDB; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>Define os atributos do corpo do método.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>Inicializa qualquer local que o método define como zero e aloca dinamicamente a memória local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>Não executa nenhuma inicialização de memória local.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>Fornece um codificador para um fluxo do corpo do método.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codifica um corpo do método e o adiciona ao fluxo do corpo do método usando o tamanho de código fornecido, o tamanho máximo da pilha, o número de regiões de exceção, o identificador de assinatura das variáveis locais e os atributos do corpo do método e permite indicar se as regiões de exceção devem ser codificadas em formato pequeno ou não.</summary>
      <param name="codeSize">O número de bytes que serão reservados para instruções.</param>
      <param name="maxStack">O tamanho máximo da pilha.</param>
      <param name="exceptionRegionCount">O número de regiões de exceção.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> se as regiões de exceção devem ser codificadas em formato pequeno; caso contrário, <see langword="false" />.</param>
      <param name="localVariablesSignature">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes">Os atributos do corpo do método.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> ou <paramref name="maxStack" /> está fora do intervalo permitido.</exception>
      <returns>O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codifica um corpo do método e o adiciona ao fluxo do corpo do método usando o tamanho de código fornecido, o tamanho máximo da pilha, o número de regiões de exceção, o identificador de assinatura das variáveis locais e os atributos do corpo do método, permite indicar se as regiões de exceção devem ser codificadas em formato pequeno ou não e permite indicar se o método deve ser alocado a partir do pool de memória local dinâmico.</summary>
      <param name="codeSize">O número de bytes que serão reservados para instruções.</param>
      <param name="maxStack">O tamanho máximo da pilha.</param>
      <param name="exceptionRegionCount">O número de regiões de exceção.</param>
      <param name="hasSmallExceptionRegions">
        <see langword="true" /> se as regiões de exceção devem ser codificadas em formato pequeno; caso contrário, <see langword="false" />.</param>
      <param name="localVariablesSignature">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes">Os atributos do corpo do método.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> se o método for alocar a partir do pool de memória local dinâmico (a instrução <see langword="localloc" />); caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />, <paramref name="exceptionRegionCount" /> ou <paramref name="maxStack" /> está fora do intervalo permitido.</exception>
      <returns>O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>Codifica um corpo do método e o adiciona ao fluxo do corpo do método.</summary>
      <param name="instructionEncoder">O codificador de instruções.</param>
      <param name="maxStack">O tamanho máximo da pilha.</param>
      <param name="localVariablesSignature">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes">Os atributos do corpo do método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> tem valor padrão.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> está fora do intervalo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException">Um rótulo almejado por um branch no fluxo de instrução não foi marcado ou a distância entre uma instrução de branch e o rótulo de destino não se ajusta ao tamanho do operando de instrução.</exception>
      <returns>O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>Codifica um corpo do método e o adiciona ao fluxo do corpo do método usando o codificador de instruções fornecido, o tamanho máximo da pilha, o identificador de assinatura das variáveis locais, os atributos do corpo do método e permite indicar se o método deve ser alocado ou não a partir do pool de memória local dinâmico.</summary>
      <param name="instructionEncoder">O codificador de instruções.</param>
      <param name="maxStack">O tamanho máximo da pilha.</param>
      <param name="localVariablesSignature">O identificador de assinatura de variáveis locais.</param>
      <param name="attributes">Os atributos do corpo do método.</param>
      <param name="hasDynamicStackAllocation">
        <see langword="true" /> se o método for alocado a partir do pool de memória local dinâmico (o IL contém a instrução <see langword="localloc" />); caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> tem valor padrão.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> está fora do intervalo [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
      <exception cref="T:System.InvalidOperationException">Um rótulo almejado por um branch no fluxo de instrução não foi marcado ou a distância entre uma instrução de branch e o rótulo de destino não se ajusta ao tamanho do operando de instrução.</exception>
      <returns>O deslocamento do corpo codificado dentro do fluxo do corpo do método.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>Descreve um corpo de método. Essa classe deve ser usada junto com a classe <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" />.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>Obtém um objeto codificador que pode ser usado para codificar regiões de exceção para o corpo do método.</summary>
      <returns>Uma instância de codificador de região de exceção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>Obtém um blob reservado para instruções.</summary>
      <returns>Um blob reservado para instruções.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>Obtém o deslocamento do corpo do método codificado no fluxo do corpo do método.</summary>
      <returns>O deslocamento do corpo do método codificado no fluxo do corpo do método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>Fornece um codificador para assinaturas de método.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>Codifica os parâmetros e o tipo de retorno fornecidos.</summary>
      <param name="parameterCount">O número de parâmetros.</param>
      <param name="returnType">O primeiro método que é chamado para codificar o tipo de retorno.</param>
      <param name="parameters">O segundo método que é chamado para codificar os parâmetros.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> ou <paramref name="parameters" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>Codifica os parâmetros e o tipo de retorno fornecidos, que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="parameterCount">O número de parâmetros.</param>
      <param name="returnType">O primeiro método que é chamado para codificar os tipos de retorno.</param>
      <param name="parameters">O segundo método que é chamado para codificar os parâmetros.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />.</summary>
      <param name="builder">Um construtor para codificar o argumento nomeado.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>Codifica um argumento nomeado (um campo ou propriedade).</summary>
      <param name="isField">
        <see langword="true" /> para codificar um campo, <see langword="false" /> para codificar uma propriedade.</param>
      <param name="type">O primeiro método a ser chamado para codificar o tipo do argumento.</param>
      <param name="name">O segundo método a ser chamado para codificar o nome do campo ou da propriedade.</param>
      <param name="literal">O terceiro método a ser chamado para codificar o valor literal do argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" />, <paramref name="name" /> ou <paramref name="literal" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>Codifica um argumento nomeado (um campo ou propriedade) e retorna três codificadores que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="isField">
        <see langword="true" /> para codificar um campo, <see langword="false" /> para codificar uma propriedade.</param>
      <param name="type">O primeiro método a ser chamado para codificar o tipo do argumento.</param>
      <param name="name">O segundo método a ser chamado para codificar o nome do campo ou da propriedade.</param>
      <param name="literal">O terceiro método a ser chamado para codificar o valor literal do argumento.</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>Representa o construtor de uma imagem PDB portátil.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>Cria um construtor de uma imagem PDB portátil.</summary>
      <param name="tablesAndHeaps">Um construtor preenchido com entidades de metadados de depuração armazenadas em tabelas e valores armazenados em heaps. As entidades e os valores são enumerados ao serializar a imagem PDB portátil.</param>
      <param name="typeSystemRowCounts">As contagens de linhas de todas as tabelas que os metadados do sistema de tipo associado contêm. Cada slot na matriz corresponde a uma tabela (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />). O comprimento da matriz deve ser igual a <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.</param>
      <param name="entryPoint">Um identificador de definição de método de ponto de entrada.</param>
      <param name="idProvider">Uma função que calcula a ID de conteúdo representada como uma sequência de blobs. Se não for especificado, será usada uma função padrão que ignora o conteúdo e retorna uma ID de conteúdo com base na hora atual (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />). Você deve especificar uma função determinística para produzir uma imagem PDB portátil determinística.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> ou <paramref name="typeSystemRowCounts" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>Serializa o conteúdo PDB portátil no <see cref="T:System.Reflection.Metadata.BlobBuilder" /> fornecido.</summary>
      <param name="builder">O construtor no qual gravar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> é <see langword="null" />.</exception>
      <returns>A ID do conteúdo serializado.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>Codifica um literal constante.</summary>
      <param name="value">Uma constante do tipo <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:System.Char" /> (codificada como um caractere Unicode de dois bytes), <see cref="T:System.String" /> (codificado como SerString) ou <see cref="T:System.Enum" /> (codificado como o valor inteiro subjacente).</param>
      <exception cref="T:System.ArgumentException">Tipo de constante inesperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>Codifica um literal <see langword="null" /> do tipo <see cref="T:System.Array" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>Codifica um literal do tipo <see cref="T:System.Type" /> (que pode ser <see langword="null" />).</summary>
      <param name="serializedTypeName">O nome do tipo ou <see langword="null" />.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="serializedTypeName" /> está vazio.</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>Decodifica blobs de assinatura.</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>Cria um novo <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />.</summary>
      <param name="provider">O provedor usado para obter símbolos de tipo quando a assinatura é decodificada.</param>
      <param name="metadataReader">O leitor de metadados do qual a assinatura foi obtida. Pode ser <see langword="null" /> caso o provedor fornecido permita.</param>
      <param name="genericContext">Contexto adicional necessário para resolver parâmetros genéricos.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica um blob de assinatura de campo e avança o leitor após a assinatura.</summary>
      <param name="blobReader">O leitor de blob posicionado em uma assinatura de campo.</param>
      <returns>O tipo de campo decodificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica um blob de assinatura de variável local e avança o leitor após a assinatura.</summary>
      <param name="blobReader">O leitor de blob posicionado em uma assinatura de variável local.</param>
      <exception cref="T:System.BadImageFormatException">A assinatura da variável local é inválida.</exception>
      <returns>Os tipos de variáveis locais.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica um método (definição, referência ou autônomo) ou um blob de assinatura de propriedade.</summary>
      <param name="blobReader">Um leitor de blob posicionado em uma assinatura de método.</param>
      <exception cref="T:System.BadImageFormatException">A assinatura do método é inválida.</exception>
      <returns>A assinatura do método decodificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>Decodifica um blob de assinatura de especificação de método e avança o leitor após a assinatura.</summary>
      <param name="blobReader">Um leitor de blob posicionado em uma assinatura de especificação de método válida.</param>
      <returns>Os tipos usados para instanciar um método genérico por meio da especificação do método.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>Decodifica um tipo inserido na assinatura e avança o leitor após o tipo.</summary>
      <param name="blobReader">O leitor de blob posicionado no entrelinhamento <see cref="T:System.Reflection.Metadata.SignatureTypeCode" />.</param>
      <param name="allowTypeSpecifications">
        <see langword="true" /> para permitir que um <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> siga uma (CLASS | VALUETYPE) na assinatura; caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">O leitor não estava posicionado em um tipo de assinatura válido.</exception>
      <returns>O tipo decodificado.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>Codifica um tipo de matriz.</summary>
      <param name="elementType">Chamado primeiro, para codificar o tipo do elemento.</param>
      <param name="arrayShape">Chamado em segundo lugar, para codificar a forma da matriz.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="elementType" /> ou <paramref name="arrayShape" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>Codifica um tipo de matriz. Retorna um par de codificadores que devem ser usados na ordem em que aparecem na lista de parâmetros.</summary>
      <param name="elementType">Use primeiro, para codificar o tipo do elemento.</param>
      <param name="arrayShape">Use em segundo lugar, para codificar a forma da matriz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>Inicia a assinatura de um tipo com modificadores personalizados.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>Inicia uma assinatura de ponteiro de função.</summary>
      <param name="convention">Convenção de chamada.</param>
      <param name="attributes">Atributos de ponteiro de função.</param>
      <param name="genericParameterCount">Contagem de parâmetros genéricos.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributes" /> é inválido.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> não está no intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>Inicia uma assinatura de instanciação genérica.</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="genericArgumentCount">Contagem de argumentos genéricos.</param>
      <param name="isValueType">
        <see langword="true" /> para marcar o tipo como tipo de valor, <see langword="false" /> para marcá-lo como um tipo de referência na assinatura.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericType" /> não tem o tipo de identificador esperado.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> não está no intervalo [1, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>Codifica uma referência ao parâmetro de tipo de um método genérico que o contém.</summary>
      <param name="parameterIndex">Índice de parâmetro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> não está no intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>Codifica uma referência ao parâmetro de tipo de um tipo genérico que o contém.</summary>
      <param name="parameterIndex">Índice de parâmetro.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> não está no intervalo [0, 0xffff].</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>Inicia a assinatura do ponteiro.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Grava o código de tipo primitivo.</summary>
      <param name="type">Qualquer código de tipo primitivo, exceto <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> e <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="type" /> não é válido neste contexto.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>Inicia a assinatura da matriz SZ (vetor).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>Codifica uma referência a um tipo.</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
      <param name="isValueType">
        <see langword="true" /> para marcar o tipo como tipo de valor, <see langword="false" /> para marcá-lo como um tipo de referência na assinatura.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> não tem o tipo de identificador esperado.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>Codifica um ponteiro nulo (<c>nulo*</c>).</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>Representa uma entidade de metadados (como uma referência de tipo, definição de tipo, especificação de tipo, definição de método ou atributo personalizado).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>Retorna um valor que indica se a instância atual e o objeto especificado são iguais.</summary>
      <param name="obj">O objeto a ser comparado com a instância atual.</param>
      <returns>
        <see langword="true" /> se <paramref name="obj" /> for um <see cref="T:System.Reflection.Metadata.EntityHandle" /> e for igual a essa instância atual, caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>Retorna um valor que indica se a instância atual e o <see cref="T:System.Reflection.Metadata.EntityHandle" /> especificado são iguais.</summary>
      <param name="other">O valor a ser comparado à instância atual.</param>
      <returns>
        <see langword="true" /> se a instância atual e <paramref name="other" /> forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>Retorna o código hash para a instância.</summary>
      <returns>O código hash para essa instância.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>Obtém um identificador TypeSpec, TypeDef ou TypeRef quando a região representa uma captura ou um token nulo, caso contrário [<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />)].</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>Obtém o deslocamento IL do início do bloco de filtro ou -1, quando a região não é um filtro.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>Obtém o comprimento do manipulador de exceção, em bytes.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>Obtém o deslocamento IL inicial do manipulador de exceção.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>Obtém o comprimento do bloco try, em bytes.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>Obtém o deslocamento IL inicial do bloco try.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>Obtém um identificador para resolver a implementação do tipo de destino.</summary>
      <returns>
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> representando outro módulo no assembly.</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> representando outro assembly, se <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> for <see langword="true" /> .</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> representando o tipo exportado declarativo no qual ele foi aninhado.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>Obtém o nome do tipo de destino ou <see langword="default" /> se o tipo estiver aninhado ou definido em um namespace raiz.</summary>
      <returns>Uma <see cref="T:System.Reflection.Metadata.StringHandle" /> instância de struct.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>Obtém o nome completo do namespace que contém o tipo de destino ou <see langword="default" /> se o tipo estiver aninhado ou definido em um namespace raiz.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>Obtém o identificador de definição do namespace em que o tipo de destino está definido ou <see langword="default" /> se o tipo estiver aninhado ou definido em um namespace raiz.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>Representa uma coleção de instâncias <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>Retorna o deslocamento de layout de campo ou -1 se ele não está disponível.</summary>
      <returns>O deslocamento de definição de campo ou -1 se ele não estiver disponível.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>Obtém os atributos que especificam a variação e as restrições.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>Obtém o índice baseado em zero do parâmetro no tipo genérico declarativo ou na declaração de método.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>Obtém o nome do parâmetro genérico.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>Obtém um <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> ou <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> que representa o pai desse parâmetro genérico.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>Obtém o <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> restrito.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>Obtém um identificador (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) que especifica de qual tipo esse parâmetro genérico é restrito a ser derivado ou em qual interface esse parâmetro genérico é restrito a implementar.</summary>
      <returns>Uma instância <see cref="T:System.Reflection.Metadata.EntityHandle" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>Representa uma coleção de restrições de um parâmetro de tipo genérico.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary>Obtém o elemento no índice especificado na lista somente leitura.</summary>
      <param name="index">O índice baseado em zero do elemento a ser obtido.</param>
      <returns>O elemento no índice especificado na lista somente leitura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>Representa uma coleção de parâmetros de tipo genérico de um método ou tipo.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary>Obtém o elemento no índice especificado na lista somente leitura.</summary>
      <param name="index">O índice baseado em zero do elemento a ser obtido.</param>
      <returns>O elemento no índice especificado na lista somente leitura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>Representa qualquer entidade de metadados (como uma referência de tipo, uma definição de tipo, uma especificação de tipo, uma definição de método ou um atributo personalizado) ou um valor (uma cadeia de caracteres, um blob, um GUID ou uma cadeia de caracteres de usuário).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Compara dois identificadores de entidade.</summary>
      <param name="x">O primeiro identificador de entidade a ser comparado.</param>
      <param name="y">O segundo identificador de entidade a ser comparado.</param>
      <returns>Zero se os dois identificadores de entidade forem iguais e um valor diferente de zero se não forem.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Compara dois identificadores.</summary>
      <param name="x">O primeiro identificador a ser comparado.</param>
      <param name="y">O segundo identificador a ser comparado.</param>
      <returns>Zero se os dois identificadores forem iguais e um valor diferente de zero se não forem.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>Determina se os objetos especificados são iguais.</summary>
      <param name="x">O primeiro objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <param name="y">O segundo objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <returns>
        <see langword="true" /> se os objetos especificados forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>Determina se os objetos especificados são iguais.</summary>
      <param name="x">O primeiro objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <param name="y">O segundo objeto do tipo <paramref name="T" /> a ser comparado.</param>
      <returns>
        <see langword="true" /> se os objetos especificados forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary>Retorna um código hash para o objeto especificado.</summary>
      <param name="obj">O <see cref="T:System.Object" /> para o qual um código hash deve ser retornado.</param>
      <returns>Um código hash para o objeto especificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary>Retorna um código hash para o objeto especificado.</summary>
      <param name="obj">O <see cref="T:System.Object" /> para o qual um código hash deve ser retornado.</param>
      <returns>Um código hash para o objeto especificado.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>Obtém o símbolo de tipo de uma matriz generalizada do tipo de elemento e da forma especificados.</summary>
      <param name="elementType">O tipo dos elementos na matriz.</param>
      <param name="shape">A forma (classificação, tamanhos e limites inferiores) da matriz.</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>Obtém o símbolo de tipo de um ponteiro gerenciado para o tipo de elemento especificado.</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Obtém o símbolo de tipo de uma criação de instância genérica do tipo genérico especificado com os argumentos de tipo especificados.</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>Obtém o símbolo de tipo de um ponteiro não gerenciado para o tipo de elemento especificado.</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>Obtém a representação de <typeparamref name="TType" /> para <see cref="T:System.Type" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>Obtém o símbolo de tipo do nome do tipo serializado.</summary>
      <param name="name">O nome do tipo serializado no chamado formato de "notação de reflexão" (conforme reconhecido pelo método <see cref="M:System.Type.GetType(System.String)" />.)</param>
      <exception cref="T:System.BadImageFormatException">O nome está malformado.</exception>
      <returns>Uma instância de <typeparamref name="TType" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>Obtém o tipo subjacente do símbolo de tipo enumerado especificado.</summary>
      <param name="type">Um tipo enumerado.</param>
      <exception cref="T:System.BadImageFormatException">O símbolo de tipo fornecido não representa uma enumeração.</exception>
      <returns>Um código de tipo que indica o tipo subjacente da enumeração.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>Verifica se o tipo especificado representa <see cref="T:System.Type" />.</summary>
      <param name="type">O tipo a ser verificado.</param>
      <returns>
        <see langword="true" /> se o tipo fornecido for um <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>Calcula o tamanho do operando de instrução de branch especificado.</summary>
      <param name="opCode">O código op do branch.</param>
      <exception cref="T:System.ArgumentException">O <paramref name="opCode" /> especificado não é um código op do branch.</exception>
      <returns>1 se <paramref name="opCode" /> for um branch curto ou 4 se ele for um branch longo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Obtém uma forma longa do código op do branch especificado.</summary>
      <param name="opCode">O código op do branch.</param>
      <exception cref="T:System.ArgumentException">O <paramref name="opCode" /> especificado não é um código op do branch.</exception>
      <returns>A forma longa do código op do branch.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Obtém uma forma abreviada do código op do branch especificado.</summary>
      <param name="opCode">O código op do branch.</param>
      <exception cref="T:System.ArgumentException">O <paramref name="opCode" /> especificado não é um código op do branch.</exception>
      <returns>A forma abreviada do código op do branch.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>Verifica se o código op especificado é um branch de um rótulo.</summary>
      <param name="opCode" />
      <returns>
        <see langword="true" /> se o código op especificado for um branch de um rótulo; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>A exceção que é gerada quando uma tentativa de gravar metadados excede um limite fornecido pela especificação de formato. Por exemplo, quando o limite de tamanho do heap é excedido.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> com dados serializados.</summary>
      <param name="info">O objeto que mantém os dados de objeto serializados.</param>
      <param name="context">As informações contextuais sobre a origem ou o destino.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> com uma mensagem de erro especificada.</summary>
      <param name="message">A mensagem de erro que explica a razão desta exceção.</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> com uma mensagem de erro especificada e a exceção interna que é a causa desta exceção.</summary>
      <param name="message">A mensagem de erro que explica a razão desta exceção.</param>
      <param name="innerException">A exceção que é a causa da exceção atual ou <see langword="null" />, se nenhuma exceção interna for especificada.</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <exception cref="T:System.BadImageFormatException">Formato de blob inválido.</exception>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>Fornece informações sobre o escopo léxico no qual um grupo de importações está disponível. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>Obtém a interface implementada (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />).</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>Obtém o símbolo de tipo para o tipo de ponteiro de função do método <paramref name="signature" /> determinado.</summary>
      <param name="signature" />
      <returns>O símbolo de tipo para o tipo de ponteiro de função.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>Obtém o símbolo de tipo para o parâmetro de método genérico no <paramref name="index" /> baseado em zero determinado.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>O símbolo de tipo para o parâmetro de método genérico em <paramref name="index" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>Obtém o símbolo de tipo para o parâmetro de tipo genérico no <paramref name="index" /> baseado em zero determinado.</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>O símbolo de tipo para o parâmetro de tipo genérico no <paramref name="index" /> baseado em zero determinado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>Obtém o símbolo de tipo para um tipo com um modificador personalizado aplicado.</summary>
      <param name="modifier">O tipo de modificador aplicado.</param>
      <param name="unmodifiedType">O símbolo de tipo do tipo subjacente sem modificadores aplicados.</param>
      <param name="isRequired">
        <see langword="true" /> se o modificador for necessário, <see langword="false" /> se for opcional.</param>
      <returns>O símbolo de tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>Obtém o símbolo de tipo para um tipo de variável local que está marcado como fixado.</summary>
      <param name="elementType" />
      <returns>O símbolo de tipo para o tipo de variável local.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>Obtém o símbolo de tipo para uma especificação de tipo.</summary>
      <param name="reader">O leitor de metadados que foi passado para o decodificador de assinatura. Pode ser <see langword="null" />.</param>
      <param name="genericContext">O contexto que foi passado para o decodificador de assinatura.</param>
      <param name="handle">O identificador de especificação de tipo.</param>
      <param name="rawTypeKind">A espécie do tipo, conforme especificado na assinatura. Para interpretar esse valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>O símbolo de tipo para a especificação de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>Obtém o símbolo de tipo para um tipo primitivo.</summary>
      <param name="typeCode" />
      <returns>O símbolo de tipo para <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>Obtém o símbolo de tipo para uma definição de tipo.</summary>
      <param name="reader">O leitor de metadados que foi passado para o decodificador de assinatura. Pode ser <see langword="null" />.</param>
      <param name="handle">O identificador de definição de tipo.</param>
      <param name="rawTypeKind">A espécie do tipo, conforme especificado na assinatura. Para interpretar esse valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>O símbolo de tipo.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>Obtém o símbolo de tipo para uma referência de tipo.</summary>
      <param name="reader">O leitor de metadados que foi passado para o decodificador de assinatura. Pode ser <see langword="null" />.</param>
      <param name="handle">O identificador de definição de tipo.</param>
      <param name="rawTypeKind">A espécie do tipo, conforme especificado na assinatura. Para interpretar esse valor, use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />.</param>
      <returns>O símbolo de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>Obtém o símbolo de tipo de uma matriz unidimensional do tipo de elemento especificado com um limite inferior igual a zero.</summary>
      <param name="elementType" />
      <returns>Uma instância de <typeparamref name="TType" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>Fornece informações sobre constantes locais. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>Obtém a assinatura constante.</summary>
      <returns>A assinatura constante.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>Fornece informações sobre o escopo de variáveis e constantes locais. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>Fornece informações sobre variáveis locais. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>Obtém os atributos do recurso de manifesto.</summary>
      <returns>Uma combinação de bits de bit que especifica os atributos de recurso de manifesto.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>Obtém o identificador da entidade de implementação.</summary>
      <returns>Uma instância de EntityHandle. Se a <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propriedade for <see langword="true" /> , o identificador retornado terá valores padrão.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>Obtém o nome do recurso.</summary>
      <returns>O nome do recurso.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>Obtém o deslocamento de bytes no arquivo referenciado no qual este registro de recurso começa.</summary>
      <returns>O deslocamento de byte dentro do arquivo referenciado no qual este registro de recurso começa.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>Representa uma coleção de instâncias <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>Determina se a referência de membro é um método ou um campo.</summary>
      <exception cref="T:System.BadImageFormatException">A assinatura de referência de membro é inválida.</exception>
      <returns>Um dos valores de enumeração que indica o tipo de referência de membro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>Obtém o identificador da entidade pai.</summary>
      <returns>Uma instância de identificador de entidade. Se a <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> propriedade for <see langword="true" /> , o identificador retornado terá valores padrão.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>Obtém um identificador para o blob de assinatura.</summary>
      <returns>Um identificador para o blob de assinatura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>Representa uma coleção de instâncias <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>Especifica as constantes que indicam se um <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a um método ou campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>O <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a um campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>O <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a um método.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>Metadados da CLI.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>Metadados do Windows gerados por compiladores gerenciados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Metadados do Windows.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>Lê os metadados conforme definido pela especificação de CLI do ECMA 335.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> usando os metadados armazenados no local da memória determinado.</summary>
      <param name="metadata">Um ponteiro para o primeiro byte em um bloco de metadados.</param>
      <param name="length">O número de bytes no bloco.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> usando os metadados armazenados no local da memória determinado.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataReader" /> usando os metadados armazenados no local da memória determinado.</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> não é positivo.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">A codificação de <paramref name="utf8Decoder" /> não é <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">A plataforma atual é big endian.</exception>
      <exception cref="T:System.BadImageFormatException">Cabeçalho de metadados inválido.</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>Obtém as informações decodificadas de fluxo #Pdb ou <see langword="null" /> quando o fluxo não está presente.</summary>
      <returns>As informações decodificadas de #Pdb Stream ou <see langword="null" /> se o fluxo não estiver presente.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>Obtém um valor que indica se os metadados representam um assembly.</summary>
      <returns>
        <see langword="true" /> Se os metadados representarem um assembly; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>Obtém o tipo de metadados.</summary>
      <returns>Um dos valores de enumeração que especifica o tipo de metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>Obtém o comprimento dos dados subjacentes.</summary>
      <returns>O comprimento dos dados subjacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>Obtém o ponteiro para os dados subjacentes.</summary>
      <returns>O ponteiro para os dados subjacentes.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>Obtém a leitura da cadeia de caracteres de versão do cabeçalho de metadados.</summary>
      <returns>A cadeia de caracteres de versão lida do cabeçalho de metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>Obtém o <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> passado para o construtor.</summary>
      <returns>Uma combinação de bits de bit que descreve os valores de enumeração que descrevem o <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> valor de enumeração.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>Obtém o comparador usado para comparar as cadeias de caracteres armazenadas nos metadados.</summary>
      <returns>O comparador usado para comparar cadeias de caracteres armazenadas em metadados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>Obtém o decodificador usado pelo leitor para produzir instâncias de cadeia de caracteres de sequências de bytes codificados em UTF8.</summary>
      <returns>O decodificador usado pelo leitor para produzir instâncias de cadeia de caracteres de sequências de bytes codificadas em UTF8.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>As projeções do Windows Runtime estão habilitadas (ativadas por padrão).</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>As opções usadas quando um <see cref="T:System.Reflection.Metadata.MetadataReader" /> é obtido por meio de uma sobrecarga que não usa um argumento <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>Todas as opções estão desabilitadas.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>Fornece um <see cref="T:System.Reflection.Metadata.MetadataReader" /> para metadados armazenados em uma matriz de bytes, um bloco de memória ou um fluxo.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>Descarta toda a memória alocada pelo leitor.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>Cria um provedor de metadados sobre uma imagem armazenada na memória.</summary>
      <param name="start">Ponteiro para o início do blob de metadados.</param>
      <param name="size">O tamanho do blob de metadados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> é negativo.</exception>
      <returns>O novo provedor de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Cria um provedor ao longo de uma matriz de bytes.</summary>
      <param name="image">Imagem de metadados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> é <see langword="null" />.</exception>
      <returns>O novo provedor.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Cria um provedor para um fluxo do tamanho especificado começando na posição atual.</summary>
      <param name="stream">Uma instância de <see cref="T:System.IO.Stream" />.</param>
      <param name="options">Opções especificando como as seções da imagem são lidas do fluxo.</param>
      <param name="size">Tamanho do blob de metadados no fluxo. Se não for especificado, presume-se que o blob de metadados abrangerá até o final do fluxo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> não é compatível com as operações de leitura e busca.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O tamanho é negativo ou ultrapassa o final do fluxo.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo (somente quando <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> é especificado).</exception>
      <returns>O novo provedor.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>Cria um provedor de metadados PDB portátil em um blob armazenado na memória.</summary>
      <param name="start">Ponteiro para o início do blob PDB portátil.</param>
      <param name="size">O tamanho do blob PDB portátil.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> é negativo.</exception>
      <returns>O novo provedor de metadados PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Cria um provedor de metadados PDB portátil em uma matriz de bytes.</summary>
      <param name="image">Uma imagem PDB portátil.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> é <see langword="null" />.</exception>
      <returns>O novo provedor de metadados PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>Cria um provedor para um fluxo do tamanho especificado começando na posição atual.</summary>
      <param name="stream">O fluxo.</param>
      <param name="options">Opções especificando como as seções da imagem são lidas do fluxo.</param>
      <param name="size">Tamanho do blob de metadados no fluxo. Se não for especificado, presume-se que o blob de metadados abrangerá até o final do fluxo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> não é compatível com as operações de leitura e busca.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">O tamanho é negativo ou ultrapassa o final do fluxo.</exception>
      <returns>Uma instância de <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Obtém um <see cref="T:System.Reflection.Metadata.MetadataReader" /> de um <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.</summary>
      <param name="options">Uma combinação bit a bit dos valores de enumeração que representa a configuração ao ler os metadados.</param>
      <param name="utf8Decoder">A codificação a ser usada.</param>
      <exception cref="T:System.ArgumentException">A codificação de <paramref name="utf8Decoder" /> não é <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.ObjectDisposedException">O provedor foi descartado.</exception>
      <returns>Uma instância de <see cref="T:System.Reflection.Metadata.MetadataReader" />.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>Por padrão, o fluxo é descartado quando o <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> é descartado e as seções da imagem PE são lidas lentamente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>Mantém o fluxo aberto quando o <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> é descartado.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>
        <para>Lê os metadados PDB na memória imediatamente.</para>
        <para>O arquivo subjacente poderá ser fechado e até mesmo excluído depois que o <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> for construído. <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> fecha o fluxo automaticamente quando o construtor retorna, a menos que <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> seja especificado.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>Fornece auxiliares de comparação de cadeias de caracteres para consultar cadeias em metadados enquanto evita a alocação, se possível.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>Fornece o <see cref="T:System.Reflection.Metadata.MetadataReader" /> com um mecanismo personalizado para decodificar sequências de bytes em metadados que representam texto.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> usando a codificação fornecida.</summary>
      <param name="encoding">A codificação a ser usada.</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>Obtém as cadeias de caracteres das sequências de bytes nos metadados. Substitua essa opção para armazenar cadeias de caracteres em cache, se necessário. Caso contrário, ela será implementada por encaminhamento direto para <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> e todas as chamadas alocarão uma nova cadeia de caracteres.</summary>
      <param name="bytes">Ponteiro para os bytes a serem decodificados.</param>
      <param name="byteCount">Número de bytes a serem decodificados.</param>
      <returns>A cadeia de caracteres decodificada.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>Obtém o decodificador padrão usado pelo <see cref="T:System.Reflection.Metadata.MetadataReader" /> para decodificar o UTF-8 quando não é fornecido nenhum decodificador para o construtor.</summary>
      <returns>O decodificador padrão usado pelo <see cref="T:System.Reflection.Metadata.MetadataReader" /> para decodificar UTF-8.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>Obtém a codificação usada por essa instância.</summary>
      <returns>A codificação usada por essa instância.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>Obtém o tamanho do corpo do método, incluindo as regiões de cabeçalho, IL e exceção.</summary>
      <returns>O tamanho do corpo do método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>Fornece informações de depuração associadas a uma definição de método. Essas informações são armazenadas em metadados de depuração.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>Retorna uma coleção de pontos de sequência decodificados de <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.</summary>
      <returns>Uma coleção de pontos de sequência.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>Retorna o método inicial da máquina de estado.</summary>
      <returns>O método inicial da máquina de estado, se o método for um método <c>MoveNext</c> de uma máquina de estado. Caso contrário, ele retornará um identificador cuja propriedade <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> é <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>Obtém o identificador do documento único que contém todos os pontos de sequência do método.</summary>
      <returns>O identificador do único documento que contém todos os pontos de sequência do método ou um identificador cuja <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /> propriedade é <see langword="true" /> se o método não tem pontos de sequência ou abrange vários documentos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>Retorna um identificador de assinatura local.</summary>
      <returns>Um identificador de assinatura local ou um identificador cuja <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /> propriedade é <see langword="true" /> se o método não define nenhuma variável local.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>Retorna os pontos de sequência de codificação de blob.</summary>
      <returns>Um ponto de sequência de codificação de BLOB ou um identificador cuja <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /> propriedade é <see langword="true" /> se o método não tem pontos de sequência.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>Retorna um identificador para um <see cref="T:System.Reflection.Metadata.MethodDefinition" /> correspondente a esse identificador.</summary>
      <returns>Um identificador de definição de método que corresponde a esse identificador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>Retorna um identificador para um <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> correspondente a esse identificador.</summary>
      <returns>Um identificador de informações de depuração de método que corresponde a esse identificador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>Representa um método (definição, referência ou autônomo) ou uma assinatura de propriedade. No caso de propriedades, a assinatura corresponde à de um getter com um <see cref="T:System.Reflection.Metadata.SignatureHeader" /> distinto.</summary>
      <typeparam name="TType">O tipo de método.</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> usando as informações de cabeçalho, tipo de retorno e parâmetro especificadas.</summary>
      <param name="header">As informações no byte à esquerda da assinatura (tipo, convenção de chamada, sinalizadores).</param>
      <param name="returnType">O tipo de retorno do método.</param>
      <param name="requiredParameterCount">O número de parâmetros necessários.</param>
      <param name="genericParameterCount">O número de parâmetros de tipo genérico.</param>
      <param name="parameterTypes">Os tipos de parâmetro.</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>Obtém o número de parâmetros de tipo genérico para o método.</summary>
      <returns>O número de parâmetros de tipo genérico ou 0 para métodos não genéricos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>Obtém as informações no byte à esquerda da assinatura (tipo, convenção de chamada, sinalizadores).</summary>
      <returns>A assinatura do cabeçalho.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>Obtém os tipos de parâmetro do método.</summary>
      <returns>Uma coleção imutável de tipos de parâmetro.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>Obtém o número de parâmetros necessários para o método.</summary>
      <returns>O número de parâmetros necessários.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>Obtém o tipo retornado do método.</summary>
      <returns>O tipo de retorno.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>Obtém um identificador <see langword="MethodDef" /> ou <see langword="MemberRef" /> que especifica a qual método genérico essa instância se refere (ou seja, de qual método genérico ela é uma criação de instância).</summary>
      <returns>Um <see langword="MethodDef" /><see langword="MemberRef" /> identificador ou que especifica a qual método genérico essa instância se refere.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>Obtém um identificador para o blob de assinatura.</summary>
      <returns>Um identificador para o blob de assinatura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>Obtém todos os tipos exportados que residem diretamente em um namespace.</summary>
      <returns>Uma matriz imutável de identificadores de tipo exportados.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>Obtém o nome não qualificado da definição do namespace.</summary>
      <returns>O nome não qualificado da definição do namespace.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>Obtém as definições do namespace que são filhos diretos da definição do namespace atual.</summary>
      <returns>Uma matriz imutável de definições de namespace que são filhos diretos da definição de namespace atual.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>Obtém o namespace pai.</summary>
      <returns>O namespace pai.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>Obtém todas as definições de tipo que residem diretamente em um namespace.</summary>
      <returns>Uma matriz imutável de identificadores de definição de tipo.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>Fornece um identificador para uma definição de namespace.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>Contém uma coleção de parâmetros de um método especificado.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>Obtém um <see cref="T:System.Reflection.Metadata.MetadataReader" /> de um <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns>Um leitor de metadados.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>Obtém um leitor de metadados com a configuração de leitura de metadados especificada de um <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <param name="options">Um valor de enumeração que indica a configuração de leitura de metadados.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns>Um leitor de metadados com a configuração de leitura de metadados especificada.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>Obtém um leitor de metadados com a configuração de leitura de metadados especificada e a configuração de codifica de um <see cref="T:System.Reflection.PortableExecutable.PEReader" />.</summary>
      <param name="peReader">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <param name="options">Um valor de enumeração que indica a configuração de leitura de metadados.</param>
      <param name="utf8Decoder">Um decodificador de cadeia de caracteres de metadados com a configuração de codificação.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">A codificação de <paramref name="utf8Decoder" /> não é <see cref="T:System.Text.UTF8Encoding" />.</exception>
      <exception cref="T:System.PlatformNotSupportedException">A plataforma atual é big endian.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns>&gt;Um leitor de metadados com a configuração de leitura de metadados e a configuração de codificação especificadas.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>Retorna um bloco de corpo de um método com o RVA (endereço virtual relativo) especificado;</summary>
      <param name="peReader">A instância <see cref="T:System.Reflection.PortableExecutable.PEReader" /> atual.</param>
      <param name="relativeVirtualAddress">O RVA (endereço virtual relativo).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> é <see langword="null" />.</exception>
      <exception cref="T:System.BadImageFormatException">O corpo não foi encontrado nos metadados ou é inválido.</exception>
      <exception cref="T:System.InvalidOperationException">A seção em que o método está armazenado não está disponível.</exception>
      <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao ler do fluxo subjacente.</exception>
      <returns>Uma instância de corpo do bloco de método.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>Especifica constantes que definem os códigos de tipo usados para codificar tipos de valores primitivos um blob de valor <see cref="T:System.Reflection.Metadata.CustomAttribute" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>Um tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>Um tipo de inteiro de 1 byte sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>Um tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>Um tipo de ponto flutuante de 8 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>Um tipo de inteiro de 2 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>Um tipo de inteiro de 4 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>Um tipo de inteiro de 8 bytes com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>Um tipo de inteiro de 1 byte com sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>Um tipo de ponto flutuante de 4 bytes.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>Um tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>Um tipo de inteiro de 2 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>Um tipo de inteiro de 4 bytes sem sinal.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>Um tipo de inteiro de 8 bytes sem sinal.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>Especifica constantes que definem tipos primitivos encontrados em assinaturas de metadados.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>Um tipo <see cref="T:System.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>Um tipo <see cref="T:System.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>Um tipo <see cref="T:System.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>Um tipo <see cref="T:System.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>Um tipo <see cref="T:System.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>Um tipo <see cref="T:System.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>Um tipo <see cref="T:System.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>Um tipo <see cref="T:System.IntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>Um tipo <see cref="T:System.Object" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>Um tipo <see cref="T:System.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>Um tipo <see cref="T:System.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>Um tipo <see cref="T:System.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>Uma referência com tipo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>Um tipo <see cref="T:System.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>Um tipo <see cref="T:System.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>Um tipo <see cref="T:System.UInt64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>Um tipo <see cref="T:System.UIntPtr" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>Um tipo <see cref="T:System.Void" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>Representa um identificador e um blob correspondente em um heap de metadados que foi reservado para atualização de conteúdo futura.</summary>
      <typeparam name="THandle" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>Retorna um <see cref="T:System.Reflection.Metadata.BlobWriter" /> a ser usado para atualizar o conteúdo.</summary>
      <returns>Um gravador de blob a ser usado para atualizar o conteúdo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>Obtém o identificador de blob reservado.</summary>
      <returns>O identificador Bloq reservado.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>Especifica os códigos de tipo usados para codificar os tipos de valores em um blob <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>O argumento do atributo é uma instância Enum.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>O argumento do atributo é “demarcado” (passado para um parâmetro, campo ou propriedade do objeto de tipo) e carrega informações de tipo no blob de atributo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>O argumento do atributo é uma instância <see cref="T:System.Type" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>Um valor equivalente a <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" />.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>Especifica os sinalizadores adicionais que podem ser aplicados a assinaturas de método. Os valores subjacentes dos campos nesse tipo correspondem à representação no byte de assinatura à esquerda representado por uma estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>Indica o primeiro parâmetro explicitamente declarado que representa o ponteiro de instância.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>Um método genérico.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>Um método de instância.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>Sem sinalizadores.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>Especifica como os argumentos em determinada assinatura são passados do chamador para o computador chamado. Os valores subjacentes dos campos nesse tipo correspondem à representação no byte de assinatura à esquerda representado por uma estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>Um estilo C/C++ não gerenciado de convenção de chamada em que a pilha de chamadas é limpa pelo chamador.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>Uma convenção de chamada gerenciada com uma lista de argumentos de comprimento fixo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>Uma convenção de chamada não gerenciada em que os argumentos são passados em registros quando possível.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>Uma convenção de chamada não gerenciada em que a pilha de chamadas é limpa pelo computador chamado.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>Um estilo C++ não gerenciado de convenção de chamada para chamar funções de membro de instância com uma lista de argumentos fixos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary>Indica que as especificidades da convenção de chamada não gerenciada são codificadas como modopts.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>Uma convenção de chamada gerenciada para passar argumentos extras.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>Representa as características de assinatura especificadas pelo byte à esquerda de blobs de assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>Obtém o valor da máscara para a convenção de chamada ou tipo de assinatura. O valor <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> padrão é 15 (0x0F).</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> usando o valor de byte especificado.</summary>
      <param name="rawValue">O byte.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> usando o tipo de assinatura especificado, convenção de chamada e atributos de assinatura.</summary>
      <param name="kind">O tipo de assinatura.</param>
      <param name="convention">A convenção de chamada.</param>
      <param name="attributes">Os atributos de assinatura.</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>Compara a igualdade entre o objeto especificado e este <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="obj">O objeto a ser comparado.</param>
      <returns>
        <see langword="true" /> se os objetos forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>Comparar a igualdade de dois valores <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="other">O valor a ser comparado.</param>
      <returns>
        <see langword="true" /> se os dois valores forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>Obtém um código hash para o objeto atual.</summary>
      <returns>Um código hash do objeto atual.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Comparar a igualdade de dois valores <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
      <param name="left">O primeiro valor a ser comparado.</param>
      <param name="right">O segundo valor a ser comparado.</param>
      <returns>
        <see langword="true" /> se os dois valores forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>Determina se dois valores <see cref="T:System.Reflection.Metadata.SignatureHeader" /> são diferentes.</summary>
      <param name="left">O primeiro valor a ser comparado.</param>
      <param name="right">O segundo valor a ser comparado.</param>
      <returns>
        <see langword="true" /> se os dois valores forem diferentes; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>Retorna uma cadeia de caracteres que representa o objeto atual.</summary>
      <returns>Uma cadeia de caracteres que representa o objeto atual.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>Obtém os atributos de assinatura.</summary>
      <returns>Os atributos.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>Obtém a convenção de chamada.</summary>
      <returns>A convenção de chamada.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>Obtém um valor que indica se essa estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tem o atributo de assinatura <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />.</summary>
      <returns>
        <see langword="true" /> Se o <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> atributo estiver presente; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>Obtém um valor que indica se essa estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tem o atributo de assinatura <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />.</summary>
      <returns>
        <see langword="true" /> Se o <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> atributo estiver presente; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>Obtém um valor que indica se essa estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" /> tem o atributo de assinatura <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />.</summary>
      <returns>
        <see langword="true" /> Se o <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> atributo estiver presente; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>Obtém o tipo de assinatura.</summary>
      <returns>O tipo de assinatura.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>Obtém o valor bruto do byte de cabeçalho.</summary>
      <returns>O valor bruto do byte do cabeçalho.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>Especifica o tipo de assinatura. Os valores subjacentes dos campos nesse tipo correspondem à representação no byte de assinatura à esquerda representado por uma estrutura <see cref="T:System.Reflection.Metadata.SignatureHeader" />.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>Uma assinatura de campo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>Uma assinatura de variáveis locais.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>Uma referência de método, definição de método ou assinatura de método autônomo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>Uma assinatura de especificação de método.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>Uma assinatura de propriedade.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>Especifica constantes que definem os códigos de tipo usados na codificação de assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>Representa um <see cref="T:System.Array" /> generalizado em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>Representa um <see cref="T:System.Boolean" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>Representa os ponteiros gerenciados (parâmetros e valores retornados de byref) em assinaturas. Ele é seguido no blob pela codificação de assinatura do tipo subjacente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>Representa um <see cref="T:System.Byte" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>Representa um <see cref="T:System.Char" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>Representa um <see cref="T:System.Double" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>Representa os tipos de ponteiro de função em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>Representa um parâmetro de método genérico usado dentro de uma assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>Representa a instanciação de um tipo genérico em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>Representa um parâmetro de tipo genérico usado dentro de uma assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>Representa um <see cref="T:System.Int16" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>Representa um <see cref="T:System.Int32" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>Representa um <see cref="T:System.Int64" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>Representa um <see cref="T:System.IntPtr" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>Representa um código de tipo inválido ou que teve sua inicialização cancelada. Ele não aparecerá em assinaturas válidas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>Representa um <see cref="T:System.Object" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>Representa um modificador personalizado aplicado a um tipo em uma assinatura que o chamador pode ignorar.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>Representa uma variável local fixada pelo coletor de lixo.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>Representa um ponteiro não gerenciado em assinaturas. Ele é seguido no blob pela codificação de assinatura do tipo subjacente.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>Representa um modificador personalizado aplicado a um tipo em uma assinatura que o chamador precisa entender.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>Representa um <see cref="T:System.SByte" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>Representa um marcador para indicar o fim de argumentos fixos e o início de argumentos variáveis.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>Representa um <see cref="T:System.Single" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>Representa um <see cref="T:System.String" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>Representa um único <see cref="T:System.Array" /> dimensional com um limite inferior de 0.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>Representa uma referência de tipo em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>Precede um tipo <see cref="T:System.Reflection.Metadata.EntityHandle" /> em assinaturas. Em metadados brutos, isso é codificado como ELEMENT_TYPE_CLASS (0x12) para tipos de referência ou ELEMENT_TYPE_VALUETYPE (0x11) para tipos de valor. Isso é recolhido para um único código porque as projeções do Windows Runtime podem projetar de classe para o tipo de valor ou vice-versa, e o código bruto é enganoso nesses casos.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>Representa um <see cref="T:System.UInt16" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>Representa um <see cref="T:System.UInt32" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>Representa um <see cref="T:System.UInt64" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>Representa um <see cref="T:System.UIntPtr" /> em assinaturas.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>Representa <see cref="T:System.Void" /> em assinaturas.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>Indica a definição de tipo da assinatura.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>A definição de tipo ou a referência se refere a uma classe.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>Ele não é conhecido no contexto atual, se a referência de tipo ou a definição for um tipo de classe ou de valor.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>A definição de tipo ou a referência se refere a um tipo de valor.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>Determina o tipo de assinatura, que pode ser <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> ou <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />.</summary>
      <exception cref="T:System.BadImageFormatException">A assinatura é inválida.</exception>
      <returns>Um valor de enumeração que indica o tipo de assinatura.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>Obtém um identificador para o blob de assinatura.</summary>
      <returns>Um identificador para o blob de assinatura.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>Indica se um <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> representa um método autônomo ou a assinatura de variável local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>O <see cref="T:System.Reflection.Metadata.MemberReference" /> faz referência a uma assinatura de variável local.</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>O <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> representa uma assinatura de método autônomo.</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>Retorna o tipo delimitador de um tipo aninhado especificado.</summary>
      <returns>O tipo delimitador do tipo aninhado especificado ou um identificador cuja propriedade <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> é <see langword="true" /> se o tipo não está aninhado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>Retorna uma matriz de tipos aninhados no tipo especificado.</summary>
      <returns>Uma matriz imutável de identificadores de definição de tipo que representam os tipos aninhados no tipo especificado.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>Obtém o tipo base da definição de tipo: <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> ou <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
      <returns>O tipo base da definição de tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>Obtém um valor que indica se isto é um tipo aninhado.</summary>
      <returns>
        <see langword="true" /> Se for um tipo aninhado, <see langword="false" /> caso contrário.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>Obtém o nome do tipo.</summary>
      <returns>O nome do tipo.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>Obtém o nome completo do namespace em que o tipo é definido.</summary>
      <returns>O nome completo do namespace em que o tipo é definido ou um identificador cuja <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propriedade é <see langword="true" /> se o tipo é aninhado ou definido em um namespace raiz.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>Obtém o identificador de definição do namespace em que o tipo é definido.</summary>
      <returns>O identificador de definição do namespace em que o tipo é definido ou um identificador cuja <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /> propriedade é <see langword="true" />  se o tipo é aninhado ou definido em um namespace raiz.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>Contém uma coleção de instâncias de <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>Obtém o nome do tipo de destino.</summary>
      <returns>O nome do tipo de destino.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>Obtém o nome completo do namespace em que o tipo de destino é definido.</summary>
      <returns>O nome completo do namespace em que o tipo de destino é definido ou um identificador cuja <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> propriedade é <see langword="true" /> se o tipo é aninhado ou definido em um namespace raiz,</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>Obtém o escopo de resolução no qual o tipo de destino é definido e é identificado exclusivamente pelos <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> e <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> especificados.</summary>
      <returns>O escopo de resolução no qual o tipo de destino é definido exclusivamente.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>Contém uma coleção de instâncias de <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary>Retorna um enumerador que itera pela coleção.</summary>
      <returns>Um enumerador que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>Retorna um enumerador que itera em uma coleção.</summary>
      <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary>Obtém o número de elementos na coleção.</summary>
      <returns>O número de elementos da coleção.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary>Avança o enumerador para o próximo elemento da coleção.</summary>
      <returns>
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo elemento; <see langword="false" /> se o enumerador passou o final da coleção.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Define o enumerador com sua posição inicial, que é antes do primeiro elemento da coleção.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>Realiza tarefas definidas pelo aplicativo associadas à liberação ou à redefinição de recursos não gerenciados.</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtém o elemento na coleção na posição atual do enumerador.</summary>
      <returns>O elemento na coleção na posição atual do enumerador.</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>Representa um identificador para o heap de cadeia de caracteres do usuário.</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
      <param name="other">Um objeto para comparação com esse objeto.</param>
      <returns>
        <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>
        <para>Usado para adicionar um manipulador para um evento. Corresponde ao sinalizador <see langword="AddOn" /> na especificação da CLI ECMA 335.</para>
        <para>Os adders em conformidade com CLS são nomeados com o prefixo <see langword="add_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>
        <para>Lê o valor da propriedade.</para>
        <para>Os getters em conformidade com CLS são nomeados com o prefixo get_.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>Outro método para uma propriedade (não um getter ou setter) ou um evento (não um adder, remover ou raiser).</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>
        <para>Usado para indicar que ocorreu um evento. Corresponde ao sinalizador <see langword="Fire" /> na especificação da CLI ECMA 335.</para>
        <para> Os raisers em conformidade com CLS são nomeados com o prefixo <see langword="raise_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>
        <para>Usado para remover um manipulador de um evento. Corresponde ao sinalizador <see langword="RemoveOn" /> na especificação da CLI ECMA 335.</para>
        <para>Os removers em conformidade com CLS são nomeados com o prefixo <see langword="remove_" />.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>
        <para>Usado para modificar o valor da propriedade.</para>
        <para>Os setters em conformidade com CLS são nomeados com o prefixo <see langword="set_" />.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>Fornece informações sobre um arquivo PDB (banco de dados de depuração do programa).</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>A iteração do PDB. A primeira iteração é 1. A iteração é incrementada toda vez que o conteúdo do PDB é aumentado.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>O GUID (identificador global exclusivo) do PDB associado.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>O caminho para o arquivo .pdb que contém informações de depuração do arquivo PE/COFF.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>Representa o cabeçalho de um arquivo COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>Obtém os sinalizadores que indicam os atributos do arquivo.</summary>
      <returns>Os sinalizadores que indicam os atributos do arquivo.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>Obtém o tipo do computador de destino.</summary>
      <returns>O tipo do computador de destino.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>Obtém o número de seções. Isso indica o tamanho da tabela da seção, que segue imediatamente os cabeçalhos.</summary>
      <returns>O número de seções.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>Obtém o número de entradas na tabela de símbolos. Esses dados podem ser usados para localizar a tabela de cadeia de caracteres, que segue imediatamente a tabela de símbolos. Esse valor deve ser zero para uma imagem PE.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>Obtém o ponteiro de arquivo para a tabela de símbolos COFF.</summary>
      <returns>O ponteiro de arquivo para a tabela de símbolos COFF ou zero se nenhuma tabela de símbolos COFF estiver presente. Esse valor deve ser zero para uma imagem PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>Obtém o tamanho do cabeçalho opcional, que é necessário para arquivos executáveis, mas não para arquivos-objeto. Esse valor deve ser zero para um arquivo-objeto.</summary>
      <returns>O tamanho do cabeçalho opcional.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>Obtém um valor que indica quando o arquivo foi criado.</summary>
      <returns>Os poucos 32 bits do número de segundos desde 00:00 de janeiro de 1970, que indicam quando o arquivo foi criado.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary>COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>Adiciona uma entrada de CodeView.</summary>
      <param name="pdbPath">O caminho para o PDB. Não deve estar vazio.</param>
      <param name="pdbContentId">A ID exclusiva do conteúdo do PDB.</param>
      <param name="portablePdbVersion">A versão do formato PDB portátil (por exemplo, 0x0100 para 1,0) ou 0 se o PDB não for portátil.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> contém um caractere NUL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> é menor que 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>Adiciona uma entrada PDB portátil inserida.</summary>
      <param name="debugMetadata">Um construtor de metadados PDB portátil.</param>
      <param name="portablePdbVersion">A versão do formato PDB portátil (por exemplo, 0x0100 para 1,0).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> é menor que 0x0100.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>Adiciona uma entrada do tipo especificado.</summary>
      <param name="type">O tipo de entrada.</param>
      <param name="version">A versão de entrada.</param>
      <param name="stamp">O selo de entrada.</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>Adiciona uma entrada do tipo especificado e serializa seus dados.</summary>
      <param name="type">O tipo de entrada.</param>
      <param name="version">A versão de entrada.</param>
      <param name="stamp">O selo de entrada.</param>
      <param name="data">Os dados para passar para <paramref name="dataSerializer" />.</param>
      <param name="dataSerializer">Um serializador para serializar dados para um <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
      <typeparam name="TData">O tipo dos dados passados para <paramref name="dataSerializer" /> .</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Adiciona a entrada de soma de verificação de PDB.</summary>
      <param name="algorithmName">O nome do algoritmo de hash (por exemplo, "SHA256").</param>
      <param name="checksum">A soma de verificação.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> ou <paramref name="checksum" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> ou <paramref name="checksum" /> está vazio.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>Adiciona uma entrada reproduzível.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>Identifica a localização, o tamanho e o formato de um bloco de informações de depuração.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>Obtém o ponteiro de arquivo para os dados de depuração.</summary>
      <returns>O ponteiro de arquivo para os dados de depuração.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>Obtém o endereço dos dados de depuração quando carregados, em relação à base da imagem.</summary>
      <returns>O endereço dos dados de depuração relativos à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>Obtém o tamanho dos dados de depuração (não incluindo o próprio diretório de depuração).</summary>
      <returns>o tamanho dos dados de depuração (excluindo o diretório de depuração).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>Obtém um valor que indica se a entrada é uma entrada <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> que aponta para um PDB portátil.</summary>
      <returns>
        <see langword="true" /> se a entrada for uma <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> entrada que aponta para um PDB portátil; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>Obtém o número de versão principal do formato de dados de depuração.</summary>
      <returns>O número de versão principal do formato de dados de depuração.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>Obtém o número de versão secundária do formato de dados de depuração.</summary>
      <returns>O número de versão secundária do formato de dados de depuração.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>Obtém a hora e a data em que os dados de depuração foram criados caso o arquivo PE/COFF não seja determinístico; caso contrário, obtém um valor com base no hash do conteúdo.</summary>
      <returns>para um arquivo PE/COFF não determinístico, a hora e a data em que os dados de depuração foram criados; caso contrário, um valor com base no hash do conteúdo.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>Obtém o formulário das informações de depuração.</summary>
      <returns>O formato das informações de depuração.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary>Uma enumeração que descreve o formato das informações de depuração de um <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" />.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>Descrição do arquivo PDB associado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>As informações de depuração do COFF (números de linha, tabela de símbolos e tabela de cadeia de caracteres). Esse tipo de informação de depuração também é apontado por campos nos cabeçalhos de arquivo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>
        <para>A entrada aponta para um blob que contém o PDB Portátil Inserido. O blob do PDB Portátil Inserido tem o seguinte formato:</para>
        <para>-blob:: = dados de tamanho descompactado</para>
        <para>- Os dados abrangem o restante do blob e contêm um PDB Portátil com compactação desinflado.</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>A entrada armazena um hash de criptografia do conteúdo do arquivo de símbolos com o qual o arquivo PE/COFF foi criado. O hash pode ser usado para validar que um determinado arquivo PDB foi criado com o arquivo PE/COFF e não foi alterado de nenhuma forma. Mais de uma entrada pode estar presente se vários PDBs foram produzidos durante a compilação do arquivo PE/COFF (por exemplo, símbolos públicos e privados).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>A presença dessa entrada indica um arquivo PE/COFF determinístico. Consulte a seção Comentários para obter mais informações.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>Um valor desconhecido que deve ser ignorado por todas as ferramentas.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>Descreve as características de uma biblioteca de links dinâmicos.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>A imagem deve ser executada dentro de um AppContainer.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>A DLL pode ser realocada.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>A imagem pode lidar com um espaço de endereço virtual de alta entropia de 64 bits.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>Não associe esta imagem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>A imagem entende o isolamento e não o deseja.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>A imagem não usa SEH. Nenhum manipulador SE pode residir nesta imagem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>A imagem é compatível com NX.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>A imagem é ciente do servidor Host da Sessão da Área de Trabalho Remota.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>Reservado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>O driver usa o modelo WDM.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>Especifica a arquitetura de CPU do computador de destino.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI Byte Code.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R little-endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>MIPS com FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>MIPS16 com FPU.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 little endian.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>A CPU de destino é desconhecida ou não está especificada.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS little-endian WCE v2.</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>Representa uma entrada de diretório de depuração de soma de verificação do PDB.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>O nome do algoritmo de hash de criptografia usado para calcular a soma de verificação.</summary>
      <returns>Uma cadeia de caracteres que representa o nome do algoritmo de hash de criptografia usado para calcular a soma de verificação.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>A soma de verificação do conteúdo PDB.</summary>
      <returns>Uma matriz imutável de bytes que representa a soma de verificação do conteúdo PDB.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>Cria diretórios de PE.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>Inicializa uma instância da classe <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" />.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>O endereço do ponto de entrada relativo à base de imagem quando o arquivo de PE é carregado na memória.</summary>
      <returns>Para imagens de programa, esse é o endereço inicial. Para drivers de dispositivo, esse é o endereço da função de inicialização. Um ponto de entrada é opcional para DLLs. Quando nenhum ponto de entrada está presente, esse campo deve ser zero.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>A entrada do diretório de imagens da tabela de realocação de base.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>A entrada do diretório de imagens de importação associada.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>A entrada do diretório de imagens de direitos autorais/arquitetura.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>A entrada do diretório de imagens da descriptortable de COM.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>A entrada do diretório de imagens da tabela de depuração.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>A entrada do diretório de imagens da tabela de importação com atraso.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>A entrada do diretório de imagens da tabela de exceção.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>A entrada do diretório de imagens da tabela de exportação.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>A entrada do diretório de imagens da tabela de ponteiro global.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>A entrada do diretório de imagens da IAT (tabela de endereços de importação).</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>A entrada do diretório de imagens da tabela de importação.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>A entrada do diretório de imagens da tabela de configuração de carga.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>A entrada do diretório de imagens da tabela de recursos.</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>A entrada do diretório de imagens da tabela de TLS (armazenamento local de threads).</summary>
      <returns>Uma instância de entrada de diretório.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>Obtém o endereço do ponto de entrada relativo à base de imagem quando o arquivo de PE é carregado na memória.</summary>
      <returns>O endereço do ponto de entrada em relação à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>Obtém o endereço da seção do início de código relativo à base de imagem quando a imagem é carregada na memória.</summary>
      <returns>O endereço da seção de início de código em relação à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>Obtém o endereço da seção do início dos dados relativo à base de imagem quando a imagem é carregada na memória.</summary>
      <returns>O endereço da seção de início de dados em relação à base da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>Obtém a entrada da Tabela de Certificado, que aponta para uma tabela de certificados de atributo.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>Obtém a soma de verificação do arquivo de imagem.</summary>
      <returns>A soma de verificação do arquivo de imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>Obtém o fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem.</summary>
      <returns>Uma potência de 2 entre 512 e 64K, inclusive. O padrão é 512.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>Obtém o endereço preferencial do primeiro byte de imagem quando ele é carregado na memória.</summary>
      <returns>O endereço preferencial, que é um múltiplo de 64K.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>Obtém um valor que identifica o formato do arquivo de imagem.</summary>
      <returns>O formato do arquivo de imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>Obtém o número de versão principal da imagem.</summary>
      <returns>O número de versão principal da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>Obtém o número da versão principal do vinculador.</summary>
      <returns>O número da versão principal do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>Obtém o número de versão principal do sistema operacional necessário.</summary>
      <returns>O número de versão principal do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>Obtém o número de versão principal do subsistema.</summary>
      <returns>O número de versão principal do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>Obtém o número de versão secundária da imagem.</summary>
      <returns>O número de versão secundária da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>Obtém o número da versão secundária do vinculador.</summary>
      <returns>O número da versão secundária do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>Obtém o número de versão secundária do sistema operacional necessário.</summary>
      <returns>O número de versão secundária do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>Obtém o número de versão secundário do subsistema.</summary>
      <returns>O número de secundária principal do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>Obtém o número de entradas de diretório de dados no restante do <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Cada uma descreve uma localização e um tamanho.</summary>
      <returns>O número de entradas de diretório de dados no restante do <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>Obtém o alinhamento (em bytes) das seções quando elas são carregadas na memória.</summary>
      <returns>Um número maior ou igual a <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> . O padrão é o tamanho da página para a arquitetura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>Obtém o tamanho da seção de código (texto) ou a soma de todas as seções de código quando há várias seções.</summary>
      <returns>o tamanho da seção de código (texto) ou a soma de todas as seções de código se houver várias seções.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>Obtém o tamanho combinado de um stub do MS DOS, o cabeçalho do PE e os cabeçalhos de seção arredondados para um múltiplo de FileAlignment.</summary>
      <returns>O tamanho combinado de um stub do MS DOS, cabeçalho do PE e cabeçalhos de seção arredondados para um múltiplo de alinhamento de File.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>Obtém o tamanho do espaço de heap local a ser confirmado.</summary>
      <returns>o tamanho do espaço de heap local a ser confirmado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>Obtém o tamanho do espaço de heap local a ser reservado. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns>O tamanho do espaço de heap local a ser reservado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>Obtém o tamanho (em bytes) da imagem, incluindo todos os cabeçalhos, pois a imagem é carregada na memória.</summary>
      <returns>O tamanho (em bytes) da imagem, que é um múltiplo de <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>Obtém o tamanho da seção de dados inicializados ou a soma de todas essas seções quando há várias seções.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>Obtém o tamanho da pilha a ser confirmada.</summary>
      <returns>O tamanho da pilha a ser confirmada.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>Obtém o tamanho da pilha a ser reservada. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns>O tamanho da pilha a ser reservada.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>Obtém o tamanho da seção de dados não inicializados (BSS), ou a soma de todas essas seções quando há várias seções de BSS.</summary>
      <returns>O tamanho da seção de dados não inicializado (BSS) ou a soma de todas essas seções.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>Obtém o nome do subsistema necessário para executar esta imagem.</summary>
      <returns>o nome do subsistema necessário para executar esta imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>Define o cabeçalho de um arquivo PE (executável portátil).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeader" />.</summary>
      <param name="machine">A arquitetura de CPU do computador de destino.</param>
      <param name="sectionAlignment">O alinhamento (em bytes) das seções quando elas são carregadas na memória. Deve ser maior ou igual a <paramref name="fileAlignment" />. O padrão é o tamanho da página para a arquitetura.</param>
      <param name="fileAlignment">O fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem. O valor deve ser uma potência de 2 entre 512 e 64K, inclusive. O padrão é 512. Se <paramref name="sectionAlignment" /> for menor que o tamanho da página da arquitetura, <paramref name="fileAlignment" /> deverá corresponder a <paramref name="sectionAlignment" />.</param>
      <param name="imageBase">O endereço preferencial do primeiro byte de imagem quando carregado na memória; deve ser um múltiplo de 64K.</param>
      <param name="majorLinkerVersion">O número da versão principal do vinculador.</param>
      <param name="minorLinkerVersion">O número da versão secundária do vinculador.</param>
      <param name="majorOperatingSystemVersion">O número de versão principal do sistema operacional necessário.</param>
      <param name="minorOperatingSystemVersion">O número de versão secundária do sistema operacional necessário.</param>
      <param name="majorImageVersion">O número de versão principal da imagem.</param>
      <param name="minorImageVersion">O número de versão secundária da imagem.</param>
      <param name="majorSubsystemVersion">O número de versão principal do subsistema.</param>
      <param name="minorSubsystemVersion">O número de secundária principal do subsistema.</param>
      <param name="subsystem">O subsistema necessário para executar a imagem.</param>
      <param name="dllCharacteristics">Um objeto que descreve as características da biblioteca de links dinâmicos.</param>
      <param name="imageCharacteristics">Um objeto que descreve as características da imagem.</param>
      <param name="sizeOfStackReserve">O tamanho da pilha a ser reservada. Somente <paramref name="sizeOfStackCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</param>
      <param name="sizeOfStackCommit">O tamanho da pilha a ser confirmada.</param>
      <param name="sizeOfHeapReserve">O tamanho do espaço de heap local a ser reservado. Somente <paramref name="sizeOfHeapCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</param>
      <param name="sizeOfHeapCommit">O tamanho do espaço de heap local a ser confirmado.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> não é uma potência de 2 entre 512 e 64K.
- ou -

<paramref name="sectionAlignment" /> não é uma potência de 2.

- ou -

<paramref name="sectionAlignment" /> é menor que <paramref name="fileAlignment" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>Cria um cabeçalho executável.</summary>
      <returns>Uma instância de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> que representa o cabeçalho executável.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>Cria um cabeçalho de biblioteca.</summary>
      <returns>Uma instância de <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> que representa o cabeçalho de biblioteca.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>Retorna as características da biblioteca do vinculador dinâmico.</summary>
      <returns>Um objeto que descreve as características da biblioteca do vinculador dinâmico.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>O fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem. O valor deve ser uma potência de 2 entre 512 e 64K, inclusive. O padrão é 512. Se o alinhamento da seção for menor que o tamanho da página da arquitetura, o alinhamento do arquivo deverá corresponder ao alinhamento da seção.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>O endereço preferencial do primeiro byte de imagem quando carregado na memória; deve ser um múltiplo de 64K.</summary>
      <returns>Um número que representa o endereço preferencial do primeiro byte de imagem quando carregado na memória.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>Retorna as características da imagem.</summary>
      <returns>Um objeto que representa as características da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>A arquitetura de CPU do computador de destino.</summary>
      <returns>Um dos valores de enumeração que representa as diferentes arquiteturas de CPU.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>O número de versão principal da imagem.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão principal da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>O número da versão principal do vinculador.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.Byte" /> que representa o número de versão principal do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>O número de versão principal do sistema operacional necessário.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão principal do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>O número de versão principal do subsistema.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão principal do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>O número de versão secundária da imagem.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão secundária da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>O número da versão secundária do vinculador.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.Byte" /> que representa o número de versão secundária do vinculador.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>O número de versão secundária do sistema operacional necessário.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão secundária do sistema operacional necessário.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>O número de secundária principal do subsistema.</summary>
      <returns>Um número o tamanho de um <see cref="T:System.UInt16" /> que representa o número de versão secundário do subsistema.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>O alinhamento (em bytes) das seções quando elas são carregadas na memória.</summary>
      <returns>Um número que representa o alinhamento (em bytes) de seções quando elas são carregadas na memória. Ele deve ser maior ou igual ao alinhamento do arquivo. O padrão é o tamanho da página para a arquitetura.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>O tamanho do espaço de heap local a ser confirmado.</summary>
      <returns>Um número que representa o tamanho do espaço de heap local a ser confirmado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>O tamanho do espaço de heap local a ser reservado. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns>Um número que representa o tamanho do espaço de heap local a ser reservado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>O tamanho da pilha a ser confirmada.</summary>
      <returns>Um número que representa o tamanho da pilha a ser confirmada.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>O tamanho da pilha a ser reservada. Somente <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" /> é confirmado; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.</summary>
      <returns>Um número que representa o tamanho da pilha a ser reservado.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>O subsistema necessário para executar esta imagem.</summary>
      <returns>Uma instância de <see cref="T:System.Reflection.PortableExecutable.Subsystem" />.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>Define um tipo que lê cabeçalhos PE (Executável Portátil) e COFF de um fluxo.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>Cria uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lê os cabeçalhos PE da localização atual no fluxo especificado.</summary>
      <param name="peStream">Um fluxo que contém a imagem PE começando na posição atual do fluxo e terminando no final dele.</param>
      <exception cref="T:System.BadImageFormatException">Os dados lidos do fluxo têm um formato inválido.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo.</exception>
      <exception cref="T:System.ArgumentException">O fluxo não dá suporte para operações de busca.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>Cria uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lê os cabeçalhos PE de um fluxo que representa a imagem PE de um tamanho especificado.</summary>
      <param name="peStream">Um fluxo que contém a imagem PE do tamanho especificado, começando em sua posição atual.</param>
      <param name="size">O tamanho da imagem PE.</param>
      <exception cref="T:System.BadImageFormatException">Os dados lidos do fluxo têm um formato inválido.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo.</exception>
      <exception cref="T:System.ArgumentException">O fluxo não dá suporte para operações de busca.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> é negativo ou ultrapassa o final do fluxo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>Cria uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> que lê os cabeçalhos PE de um fluxo que representa a imagem PE de um tamanho especificado e indica se a imagem PE foi carregada na memória.</summary>
      <param name="peStream">O fluxo que contém a imagem PE do tamanho especificado, começando em sua posição atual.</param>
      <param name="size">O tamanho da imagem PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional; caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.BadImageFormatException">Os dados lidos do fluxo têm um formato inválido.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo.</exception>
      <exception cref="T:System.ArgumentException">O fluxo não dá suporte para operações de busca.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> é negativo ou ultrapassa o final do fluxo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>Pesquisa seções da imagem PE para a seção que contém o endereço virtual relativo especificado.</summary>
      <param name="relativeVirtualAddress">O endereço virtual relativo a ser pesquisado.</param>
      <returns>O índice da seção que contém <paramref name="relativeVirtualAddress" /> ou -1 se a pesquisa não for bem-sucedida.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>Obtém o deslocamento (em bytes) do início da imagem ao dados do diretório fornecido.</summary>
      <param name="directory">A entrada do diretório PE.</param>
      <param name="offset">Quando o método retorna, contém o deslocamento do início da imagem para os dados de diretório fornecidos.</param>
      <returns>
        <see langword="true" /> se os dados do diretório forem encontrados; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>Obtém o cabeçalho COFF da imagem.</summary>
      <returns>O cabeçalho COFF da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>Obtém o deslocamento de bytes desde o início da imagem PE até o início do cabeçalho COFF.</summary>
      <returns>O deslocamento de bytes desde o início da imagem PE até o início do cabeçalho COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>Obtém o cabeçalho COR.</summary>
      <returns>O cabeçalho COR ou <see langword="null" /> se a imagem não tiver uma.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>Obtém o deslocamento de bytes desde o início da imagem até o cabeçalho COR.</summary>
      <returns>O deslocamento de bytes do início da imagem até o cabeçalho COR, ou-1 se a imagem não tiver um cabeçalho COR.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>Obtém um valor que indica se a imagem é somente COFF.</summary>
      <returns>
        <see langword="true" /> se a imagem for somente COFF; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>Obtém um valor que indica se a imagem representa um aplicativo de console do Windows.</summary>
      <returns>
        <see langword="true" /> se a imagem for um aplicativo de console do Windows; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>Obtém um valor que indica se a imagem representa uma biblioteca de links dinâmicos.</summary>
      <returns>
        <see langword="true" /> se a imagem for uma DLL; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>Obtém um valor que indica se a imagem representa um executável.</summary>
      <returns>
        <see langword="true" /> se a imagem for um executável; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>Obtém o tamanho dos metadados da CLI.</summary>
      <returns>o tamanho dos metadados da CLI ou 0 se a imagem não contiver metadados.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>Obtém o deslocamento (em bytes) do início da imagem PE ao início dos metadados da CLI.</summary>
      <returns>O deslocamento (em bytes) desde o início da imagem PE até o início dos metadados da CLI ou-1 se a imagem não contiver metadados.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>Obtém o cabeçalho PE da imagem.</summary>
      <returns>O cabeçalho PE da imagem, ou <see langword="null" /> se a imagem for apenas COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>Obtém o deslocamento de bytes do cabeçalho desde o início da imagem.</summary>
      <returns>O deslocamento de byte do cabeçalho desde o início da imagem.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>Obtém os cabeçalhos de seção do PE.</summary>
      <returns>Uma matriz que contém os cabeçalhos de seção do PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>Lê o conteúdo de todo o bloco em uma matriz.</summary>
      <returns>Uma matriz de bytes imutável.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>Lê o conteúdo de uma parte do bloco em uma matriz.</summary>
      <param name="start">A posição inicial no bloco.</param>
      <param name="length">O número de bytes a serem lidos.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado não está contido no bloco.</exception>
      <returns>Uma matriz imutável de bytes.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>Cria um <see cref="T:System.Reflection.Metadata.BlobReader" /> para um blob que abrange todo o bloco.</summary>
      <returns>Um leitor para um blob que abrange todo o bloco.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>Cria um <see cref="T:System.Reflection.Metadata.BlobReader" /> para um blob que abrange uma parte do bloco.</summary>
      <param name="start">A posição inicial no bloco.</param>
      <param name="length">O número de bytes na parte do bloco.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">O intervalo especificado não está contido no bloco.</exception>
      <returns>Um leitor para um blob que abrange uma parte do bloco.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>Obtém o comprimento do bloco.</summary>
      <returns>O comprimento do bloco.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>Obtém um ponteiro para o primeiro byte do bloco.</summary>
      <returns>Um ponteiro para o primeiro byte do bloco.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>Fornece um leitor para arquivos no formato PE (Executável Portátil).</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>Cria um leitor Executável Portátil em uma imagem PE armazenada na memória.</summary>
      <param name="peImage">Um ponteiro para o início da imagem PE.</param>
      <param name="size">O tamanho da imagem PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>Cria um leitor Executável Portátil em uma imagem PE armazenada na memória. Um sinalizador indica se a imagem já foi carregada na memória.</summary>
      <param name="peImage">Um ponteiro para o início da imagem PE.</param>
      <param name="size">O tamanho da imagem PE.</param>
      <param name="isLoadedImage">
        <see langword="true" /> se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional; caso contrário, <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> é <see cref="F:System.IntPtr.Zero" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> é negativo.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>Cria um leitor Executável Portátil em uma imagem PE armazenada em uma matriz de bytes.</summary>
      <param name="peImage">Uma matriz de bytes imutável que representa a imagem PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>Cria um leitor Executável Portátil em uma imagem PE armazenada em um fluxo.</summary>
      <param name="peStream">Fluxo de imagem PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>Cria um leitor de Executável Portátil em uma imagem PE armazenada em um fluxo, começando em sua posição atual e terminando no final do fluxo.</summary>
      <param name="peStream">Um fluxo de imagem PE.</param>
      <param name="options">Opções especificando como as seções da imagem PE são lidas do fluxo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" /> tem um valor inválido.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo (somente ao fazer a pré-busca de dados).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> é especificado e os cabeçalhos PE da imagem são inválidos.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>Cria um leitor de Executável Portátil em uma imagem PE do tamanho fornecido, começando na posição atual do fluxo.</summary>
      <param name="peStream">Um fluxo de imagem PE.</param>
      <param name="options">Opções especificando como as seções da imagem PE são lidas do fluxo.</param>
      <param name="size">O tamanho da imagem PE.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> é negativo ou ultrapassa o final do fluxo.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo (somente ao fazer a pré-busca de dados).</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> é especificado e os cabeçalhos PE da imagem são inválidos.</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>Descarta toda a memória alocada pelo leitor.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>Obtém um objeto <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> que contém toda a imagem PE.</summary>
      <exception cref="T:System.InvalidOperationException">Toda a imagem PE não está disponível.</exception>
      <returns>Um bloco de memória que contém a imagem PE inteira.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>Carrega uma seção de PE que contém metadados da CLI.</summary>
      <exception cref="T:System.InvalidOperationException">A imagem PE não contém metadados (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> retorna <see langword="false" />).</exception>
      <exception cref="T:System.BadImageFormatException">Os cabeçalhos PE contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <returns>Um bloco de memória que contém os metadados da CLI.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>Carrega a seção PE que contém o endereço virtual relativo especificado na memória e retorna um bloco de memória que começa nesse endereço e termina no final da seção que a contém.</summary>
      <param name="relativeVirtualAddress">O endereço virtual relativo dos dados a serem lidos.</param>
      <exception cref="T:System.BadImageFormatException">Os cabeçalhos PE contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException">A imagem PE não está disponível.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> é negativo.</exception>
      <returns>Um bloco de memória que começa em <paramref name="relativeVirtualAddress" /> e termina no final da seção que a contém ou um bloco vazio se <paramref name="relativeVirtualAddress" /> não representar uma localização em nenhuma das seções PE desta imagem PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>Carrega a seção PE com o nome especificado na memória e retorna um bloco de memória que abrange a seção.</summary>
      <param name="sectionName">O nome da seção.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">A imagem PE não está disponível.</exception>
      <returns>Um bloco de memória que abrange a seção ou um bloco vazio se nenhuma seção do <paramref name="sectionName" /> especificado existir nesta imagem PE.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lê os dados apontados pela entrada do diretório de depuração especificado e os interpreta como CodeView.</summary>
      <param name="entry">Uma instância de entrada do diretório de depuração.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> não é uma entrada de CodeView.</exception>
      <exception cref="T:System.BadImageFormatException">Formato inválido dos dados.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException">A imagem PE não está disponível.</exception>
      <returns>Uma instância de dados do diretório de depuração de exibição de código.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>Lê todas as entradas de tabela do diretório de depuração.</summary>
      <exception cref="T:System.BadImageFormatException">Formato inválido da entrada.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException">A imagem PE não está disponível.</exception>
      <returns>Uma matriz de entradas de tabela do diretório de depuração.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lê os dados apontados pela entrada do diretório de depuração especificado e os interpreta como um blob de PDB Portátil Inserido.</summary>
      <param name="entry">A entrada do diretório de depuração cujos dados serão lidos.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> não é uma entrada de <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" />.</exception>
      <exception cref="T:System.BadImageFormatException">Formato inválido dos dados.</exception>
      <exception cref="T:System.InvalidOperationException">Imagem PE não está disponível.</exception>
      <returns>O provedor de um leitor de metadados para ler uma imagem PDB portátil.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>Lê os dados apontados pela entrada do diretório de depuração especificado e os interpreta como uma entrada de soma de verificação de PDB.</summary>
      <param name="entry">A entrada do diretório de depuração cujos dados serão lidos.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> não é uma entrada de soma de verificação de PDB.</exception>
      <exception cref="T:System.BadImageFormatException">Formato inválido dos dados.</exception>
      <exception cref="T:System.IO.IOException">Erro de E/S ao ler do fluxo subjacente.</exception>
      <exception cref="T:System.InvalidOperationException">A imagem PE não está disponível.</exception>
      <returns>A entrada de soma de verificação de PDB.</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>Abre um PDB portátil associado a esta imagem PE.</summary>
      <param name="peImagePath">O caminho para a imagem PE. O caminho é usado para localizar o arquivo PDB localizado no diretório que contém o arquivo PE.</param>
      <param name="pdbFileStreamProvider">Se especificado, é chamado para abrir um <see cref="T:System.IO.Stream" /> para o caminho de arquivo determinado. O provedor deverá retornar um <see cref="T:System.IO.Stream" /> legível e pesquisável ou <see langword="null" /> se o arquivo de destino não existir ou precisar ser ignorado por algum motivo. O provedor deverá gerar <see cref="T:System.IO.IOException" /> se não for possível abrir o arquivo devido a um erro de E/S inesperado.</param>
      <param name="pdbReaderProvider">Se for bem-sucedida, uma nova instância do <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> a ser usada para ler o PDB portátil,.</param>
      <param name="pdbPath">Se for bem-sucedido e o PDB for encontrado em um arquivo, o caminho para o arquivo ou <see langword="null" /> se o PDB for inserido na própria imagem PE.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> ou <paramref name="pdbFileStreamProvider" /> é <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">O fluxo retornado de <paramref name="pdbFileStreamProvider" /> não é compatível com as operações de leitura e busca.</exception>
      <exception cref="T:System.BadImageFormatException">Nenhum arquivo PDB correspondente foi encontrado devido a um erro: a imagem PE ou o PDB é inválido.</exception>
      <exception cref="T:System.IO.IOException">Nenhum arquivo PDB correspondente foi encontrado devido a um erro: ocorreu um erro de e/s durante a leitura da imagem PE ou do PDB.</exception>
      <returns>
        <see langword="true" /> se a imagem PE tiver um PDB associado a ela e o PDB tiver sido aberto com êxito; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>Obtém um valor que indica se a imagem PE contém metadados da CLI.</summary>
      <exception cref="T:System.BadImageFormatException">Os cabeçalhos PE contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo subjacente.</exception>
      <returns>
        <see langword="true" /> se a imagem PE contiver metadados da CLI; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>Obtém um valor que indica se o leitor pode acessar toda a imagem PE.</summary>
      <returns>
        <see langword="true" /> Se o leitor puder acessar toda a imagem PE; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>Obtém um valor que indica se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional.</summary>
      <returns>
        <see langword="true" /> se a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>Obtém os cabeçalhos PE.</summary>
      <exception cref="T:System.BadImageFormatException">Os cabeçalhos contêm dados inválidos.</exception>
      <exception cref="T:System.IO.IOException">Erro ao ler do fluxo.</exception>
      <returns>Os cabeçalhos PE para esta imagem PE.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>Fornece opções que especificam como as seções de uma imagem de PE são lidas de um fluxo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>Por padrão, o fluxo é descartado quando o <see cref="T:System.Reflection.PortableExecutable.PEReader" /> é descartado e as seções da imagem PE são lidas lentamente.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>Indica que a imagem de PE subjacente foi carregada na memória pelo carregador do sistema operacional.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>Mantém o fluxo aberto quando o <see cref="T:System.Reflection.PortableExecutable.PEReader" /> é descartado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>Lê toda a imagem na memória imediatamente. <see cref="T:System.Reflection.PortableExecutable.PEReader" /> fecha o fluxo automaticamente quando o construtor retorna, a menos que <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> seja especificado.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>
        <para>Lê a seção de metadados na memória imediatamente.</para>
        <para>A leitura de outras seções do arquivo não é permitida (<see cref="T:System.InvalidOperationException" /> é gerada pelo <see cref="T:System.Reflection.PortableExecutable.PEReader" />).</para>
        <para>
          <see cref="T:System.Reflection.PortableExecutable.PEReader" /> fecha o fluxo automaticamente quando o construtor retorna, a menos que <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> seja especificado. O arquivo subjacente poderá ser fechado e até mesmo excluído depois que o <see cref="T:System.Reflection.PortableExecutable.PEReader" /> for construído.</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>Define a classe base para um construtor de seções de recursos de PE. Derive de <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> para fornecer lógica de serialização para recursos nativos.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />.</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>Serializa o recurso especificado.</summary>
      <param name="builder">Um blob que contém os dados a serem serializados.</param>
      <param name="location">A localização para a qual serializar <paramref name="builder" />.</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>Fornece informações sobre o cabeçalho da seção de um arquivo PE/COFF.</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>Obtém o nome da seção.</summary>
      <returns>O nome da seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>Obtém o número de entradas de número de linha para a seção.</summary>
      <returns>O número de entradas de número de linha para a seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>Obtém o número de entradas de realocação para a seção.</summary>
      <returns>O número de entradas de realocação para a seção. Seu valor é zero para imagens PE.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>Obtém o ponteiro do arquivo para o início das entradas de número de linha da seção.</summary>
      <returns>O ponteiro do arquivo para o início das entradas de número de linha para a seção ou zero se não houver números de linha COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>Obtém o ponteiro do arquivo para a primeira página da seção dentro do arquivo COFF.</summary>
      <returns>O ponteiro de arquivo para a primeira página da seção dentro do arquivo COFF.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>Obtém o ponteiro do arquivo para o início das entradas de realocação para a seção.</summary>
      <returns>O ponteiro do arquivo para o início das entradas de realocação da seção. Ele é definido como zero para imagens PE ou se não houver realocações.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>Obtém os sinalizadores que descrevem as características da seção.</summary>
      <returns>Os sinalizadores que descrevem as características da seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>Obtém o tamanho da seção (para arquivos de objeto) ou o tamanho dos dados inicializados em disco (para arquivos de imagem).</summary>
      <returns>O tamanho da seção (para arquivos de objeto) ou o tamanho dos dados inicializados em disco (para arquivos de imagem).</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>Obtém a endereço virtual da seção.</summary>
      <returns>O endereço virtual da seção.</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>Obtém o tamanho total da seção quando carregada na memória.</summary>
      <returns>O tamanho total da seção quando carregado na memória.</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>Descreve o requisito de subsistema para a imagem.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>Aplicativo de EFI (Interface de Firmware Extensível).</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>Driver EFI com serviços de inicialização.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>Imagem ROM da EFI.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>Driver EFI com serviços de runtime.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>A imagem não requer um subsistema.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>A imagem é um driver Win9x nativo.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>A imagem é executada no subsistema de caracteres OS/2.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>A imagem é executada no subsistema de caracteres Posix.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>Subsistema desconhecido.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>Aplicativo de inicialização.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>A imagem é executada no subsistema do Windows CE.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>A imagem é executada no subsistema de caracteres do Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>A imagem é executada no subsistema de GUI do Windows.</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Sistema Xbox.</summary>
    </member>
  </members>
</doc>