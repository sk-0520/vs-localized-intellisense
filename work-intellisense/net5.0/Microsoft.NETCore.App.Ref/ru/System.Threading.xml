<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>Исключение вызывается, когда некоторый поток получает объект <see cref="T:System.Threading.Mutex" />, брошенный другим потоком путем выхода без высвобождения.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" /> со значениями по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" />, используя конкретиый индекс брошенного мьютекса, (если применимо), а также объект <see cref="T:System.Threading.Mutex" />, представляющий мьютекс.</summary>
      <param name="location">Индекс брошенного мьютекса в массиве дескрипторов ожидания, если выдается исключение для метода <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, или –1, если исключение выдается для методов <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> или <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" /> с сериализованными данными.</summary>
      <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, содержащий сериализованные данные объекта по возникающему исключению.</param>
      <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.AbandonedMutexException" /> с указанным сообщением об ошибке и внутренним исключением.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="inner">Исключение, которое является причиной текущего исключения. Если значение параметра <paramref name="inner" /> не равно <see langword="null" />, текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" />, используя указанное сообщения об ошибке, внутреннее исключение, индекс брошенного мьютекса (если применимо), а также объект <see cref="T:System.Threading.Mutex" />, представляющего мьютекс.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="inner">Исключение, которое является причиной текущего исключения. Если значение параметра <paramref name="inner" /> не равно <see langword="null" />, текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
      <param name="location">Индекс брошенного мьютекса в массиве дескрипторов ожидания, если выдается исключение для метода <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, или –1, если исключение выдается для методов <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> или <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" /> указанным сообщением об ошибке, индексом брошенного мьютекса (если применимо), а также брошенным мьютексом.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="location">Индекс брошенного мьютекса в массиве дескрипторов ожидания, если выдается исключение для метода <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, или –1, если исключение выдается для методов <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> или <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>Получает брошенный мьютекс, вызвавший исключение (если он известен).</summary>
      <returns>Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс, или <see langword="null" />, если брошенный мьютекс не может быть идентифицирован.</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>Получает индекс брошенного мьютекса, вызвавшего исключение (если он известен).</summary>
      <returns>Индекс в массиве дескрипторов ожидания, переданных в <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> метод, <see cref="T:System.Threading.Mutex" /> объекта, представляющего брошенный мьютекс, или значение-1, если не удалось определить индекс брошенного мьютекса.</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary>Обеспечивает функциональность для восстановления миграции или перемещения контекста выполнения между потоками.</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <exception cref="T:System.InvalidOperationException">Структура <see cref="T:System.Threading.AsyncFlowControl" /> не используется в потоке, в котором она была создана.  
  
-или- 
Структура <see cref="T:System.Threading.AsyncFlowControl" /> уже использовалась для вызова <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> или <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary>Определяет, эквивалентен ли указанный объект текущей структуре <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <param name="obj">Объект для сравнения с текущей структурой.</param>
      <returns>Значение <see langword="true" />, если <paramref name="obj" /> является структурой <see cref="T:System.Threading.AsyncFlowControl" /> и эквивалентен текущей структуре <see cref="T:System.Threading.AsyncFlowControl" /> в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary>Определяет, равна ли указанная структура <see cref="T:System.Threading.AsyncFlowControl" /> текущей структуре <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <param name="obj">Структура <see cref="T:System.Threading.AsyncFlowControl" /> для сравнения с текущей структурой.</param>
      <returns>Значение <see langword="true" />, если объект <paramref name="obj" /> равен текущей структуре <see cref="T:System.Threading.AsyncFlowControl" />; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary>Получает хэш-код текущей структуры <see cref="T:System.Threading.AsyncFlowControl" />.</summary>
      <returns>Хэш-код для текущей структуры <see cref="T:System.Threading.AsyncFlowControl" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Сравнивает две структуры <see cref="T:System.Threading.AsyncFlowControl" />, чтобы определить, совпадают ли они.</summary>
      <param name="a">Структура <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Структура <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>Значение <see langword="true" />, если обе структуры эквивалентны, в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>Сравнивает две структуры <see cref="T:System.Threading.AsyncFlowControl" /> на неравенство.</summary>
      <param name="a">Структура <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <param name="b">Структура <see cref="T:System.Threading.AsyncFlowControl" />.</param>
      <returns>Значение <see langword="true" />, если структуры не равны; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary>Восстанавливает перемещение контекста выполнения между потоками.</summary>
      <exception cref="T:System.InvalidOperationException">Структура <see cref="T:System.Threading.AsyncFlowControl" /> не используется в потоке, в котором она была создана.  
  
-или- 
Структура <see cref="T:System.Threading.AsyncFlowControl" /> уже использовалась для вызова <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> или <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary>Представляет внешние данные, локальные для данного асинхронного потока управления, такие как асинхронный метод.</summary>
      <typeparam name="T">Тип внешних данных.</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary>Создает экземпляр экземпляра <see cref="T:System.Threading.AsyncLocal`1" />, который не получает уведомления об изменениях.</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary>Создает экземпляр локального экземпляра <see cref="T:System.Threading.AsyncLocal`1" />, который получает уведомления об изменениях.</summary>
      <param name="valueChangedHandler">Делегат, который вызывается при каждом изменении текущего значения в любом потоке.</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary>Получает или задает значение внешних данных.</summary>
      <returns>Значение внешних данных. Если значение не задано, возвращается значение <c>по умолчанию (T)</c>.</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary>Класс, предоставляющий сведения об изменениях данных экземплярам <see cref="T:System.Threading.AsyncLocal`1" />, которые зарегистрированы для получения уведомлений об изменениях.</summary>
      <typeparam name="T">Тип данных.</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary>Получает текущее значение данных.</summary>
      <returns>Текущее значение данных.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary>Получает предыдущее значение данных.</summary>
      <returns>Предыдущее значение данных.</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary>Возвращает значение, указывающее, изменяется ли значение из-за изменения контекста выполнения.</summary>
      <returns>
        <see langword="true" /> , если значение изменилось из-за изменения контекста выполнения; в противном случае — <see langword="false" /> .</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>Представляет событие синхронизации потоков, которое при срабатывании автоматически сбрасывается, освобождая один поток в состоянии ожидания. Этот класс не наследуется.</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AutoResetEvent" /> логическим значением, показывающим наличие сигнального состояния.</summary>
      <param name="initialState">Значение <see langword="true" /> для задания начального состояния сигнальным; <see langword="false" /> для задания несигнального начального состояния.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>Позволяет нескольким задачам параллельно работать с алгоритмом, используя несколько фаз.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Количество участвующих потоков.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="participantCount" /> имеет значение меньше 0 или больше 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Количество участвующих потоков.</param>
      <param name="postPhaseAction">Действие <see cref="T:System.Action`1" />, выполняемое после каждой фазы. Чтобы указать на отсутствие действия, можно передать значение NULL (Nothing в Visual Basic).</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="participantCount" /> имеет значение меньше 0 или больше 32 767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>Уведомляет <see cref="T:System.Threading.Barrier" /> о добавлении дополнительного участника.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.InvalidOperationException">Добавление участника приведет к превышению 32 767 счетчиком участников барьера.  
  
 -или-  
  
 Метод был вызван из действия после этапа.</exception>
      <returns>Номер фазы барьера, в которой сначала участвуют новые участники.</returns>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>Уведомляет барьер <see cref="T:System.Threading.Barrier" /> о добавлении дополнительных участников.</summary>
      <param name="participantCount">Число дополнительных участников, которых необходимо добавить в барьер.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра<paramref name="participantCount" /> меньше 0.  
  
-или- 
Добавление участников <paramref name="participantCount" /> приведет к превышению 32 767 счетчиком участников барьера.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа.</exception>
      <returns>Номер фазы барьера, в которой сначала участвуют новые участники.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые ресурсы, используемые журналом <see cref="T:System.Threading.Barrier" />, и при необходимости освобождает также управляемые ресурсы.</summary>
      <param name="disposing">Значение true, чтобы освобождать и управляемые и неуправляемые ресурсы. Значение false, чтобы освобождать только неуправляемые ресурсы.</param>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>Уведомляет <see cref="T:System.Threading.Barrier" /> о удалении одного участника.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.InvalidOperationException">Барьер уже содержит 0 участников.  
  
 -или-  
  
 Метод был вызван из действия после этапа.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>Уведомляет барьер <see cref="T:System.Threading.Barrier" /> об удалении нескольких участников.</summary>
      <param name="participantCount">Число дополнительных участников, которых необходимо удалить из барьера.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Общее число участников меньше указанного <paramref name="participantCount" /></exception>
      <exception cref="T:System.InvalidOperationException">Барьер уже содержит 0 участников.  
  
 -или-  
  
 Метод был вызван из действия после этапа.  
  
 -или-  
  
 текущее количество участников меньше указанного participantCount</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>Сообщает, что участник достиг барьера  и ожидает достижения барьера другими участниками.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Если создается исключение из действия следующего этапа барьера после того, как все участвующие потоки вызвали SignalAndWait, исключение будет вставлено в BarrierPostPhaseException и создано для всех участвующих потоков.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>Сообщает, что участник достиг барьера  и ожидает достижения барьера всеми другими участниками, используя 32-разрядное знаковое целое число для измерения времени ожидания.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Если создается исключение из действия следующего этапа барьера после того, как все участвующие потоки вызвали SignalAndWait, исключение будет вставлено в BarrierPostPhaseException и создано для всех участвующих потоков.</exception>
      <returns>Значение <see langword="true" />, если все участники достигли барьера за указанное время; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>Сообщает, что участник достиг барьера и ожидает достижения барьера всеми другими участниками, используя 32-разрядное знаковое целое число для измерения времени ожидания. Кроме того, метод контролирует токен отмены.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
      <returns>Значение true, если все участники достигли барьера за указанное время; в противном случае — значение false</returns>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>Сообщает, что участник достиг барьера  и ожидает достижения барьера всеми другими участниками. Кроме того, метод контролирует токен отмены.</summary>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>Сообщает, что участник достиг барьера и ожидает достижения барьера всеми другими участниками, используя объект <see cref="T:System.TimeSpan" /> для измерения интервала времени.</summary>
      <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения –1 миллисекунды, которое представляет неограниченное время ожидания, или превышает 32 767.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
      <returns>Значение <see langword="true" />, если все остальные участники достигли барьера; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Сообщает, что участник достиг барьера и ожидает достижения барьера всеми другими участниками, используя объект <see cref="T:System.TimeSpan" /> для измерения интервала времени. Кроме того, метод контролирует токен отмены.</summary>
      <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
      <returns>Значение <see langword="true" />, если все остальные участники достигли барьера; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>Получает номер текущей фазы барьера.</summary>
      <returns>Возвращает номер текущего этапа барьера.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>Получает общее количество участников в барьере.</summary>
      <returns>Возвращает общее количество участников в барьере.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>Получает количество участников в барьере, которые еще не создали сигнал в текущей фазе.</summary>
      <returns>Возвращает количество участников в барьере, которые еще не сообщили на текущем этапе.</returns>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>Исключение, которое возникает при сбое действия барьера <see cref="T:System.Threading.Barrier" />, выполняемого в конце фазы.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> с предоставленным системой описанием ошибки.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> с указанным внутренним исключением.</summary>
      <param name="innerException">Исключение, которое является причиной текущего исключения.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> с сериализованными данными.</summary>
      <param name="info">Объект, содержащий сериализованные данные объекта.</param>
      <param name="context">Контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> с указанным описанием ошибки.</summary>
      <param name="message">Сообщение с описанием исключения. Для гарантированной локализации этой строки для текущей системной культуры необходимы сведения о том, кто вызывает этот конструктор.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
      <param name="message">Сообщение с описанием исключения. Для гарантированной локализации этой строки для текущей системной культуры необходимы сведения о том, кто вызывает этот конструктор.</param>
      <param name="innerException">Исключение, которое является причиной текущего исключения. Если значение параметра <paramref name="innerException" /> не равно <see langword="null" />, текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary>Представляет метод, вызываемый в новом контексте.</summary>
      <param name="state">Объект, содержащий информацию, используемую всякий раз методом обратного вызова при каждом выполнении.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>Представляет примитив синхронизации, которому отправляется сигнал при достижении счетчиком нуля.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.CountdownEvent" /> указанным количеством.</summary>
      <param name="initialCount">Количество сигналов, первоначально необходимое для задания объекта <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>Увеличивает текущий подсчет <see cref="T:System.Threading.CountdownEvent" /> на один.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан.  
  
- или - 
 Значение параметра <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> больше или равно значению свойства <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>Увеличивает текущее количество в объекте <see cref="T:System.Threading.CountdownEvent" /> на указанное значение.</summary>
      <param name="signalCount">Значение, на которое нужно увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> меньше или равно 0.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан.  
  
- или - 
 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> не меньше <see cref="F:System.Int32.MaxValue" /> после увеличения счета параметром <paramref name="signalCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые ресурсы, используемые журналом <see cref="T:System.Threading.CountdownEvent" />, и при необходимости освобождает также управляемые ресурсы.</summary>
      <param name="disposing">Значение true, чтобы освободить управляемые и неуправляемые ресурсы; значение false, чтобы освободить только неуправляемые ресурсы.</param>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>Сбрасывает свойство <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на значение свойства <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>Присваивает свойству <see cref="P:System.Threading.CountdownEvent.InitialCount" /> заданное значение.</summary>
      <param name="count">Количество сигналов, необходимое для установки объекта <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>Регистрирует сигнал с событием <see cref="T:System.Threading.CountdownEvent" />, уменьшая значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан.</exception>
      <returns>Значение <see langword="true" />, если после сигнала число стало равно нулю и было создано событие; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>Регистрирует несколько сигналов с объектом <see cref="T:System.Threading.CountdownEvent" />, уменьшая значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на указанное число.</summary>
      <param name="signalCount">Количество сигналов, которое необходимо зарегистрировать.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="signalCount" /> меньше 1.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан. - или- Или значение <paramref name="signalCount" /> больше <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
      <returns>Значение <see langword="true" />, если после сигнала число стало равно нулю и было создано событие; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>Попытка увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на единицу.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> равно <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если увеличение выполнено успешно; в противном случае значение false. Если значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> уже равно нулю, метод возвращает значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>Пытается увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на указанное значение.</summary>
      <param name="signalCount">Значение, на которое нужно увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> меньше или равно 0.</exception>
      <exception cref="T:System.InvalidOperationException">Значение параметра <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> больше или равно значению свойства <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если увеличение выполнено успешно; в противном случае значение false. Если значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> уже равно нулю, возвращается значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>Блокирует текущий поток до установки <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>Блокирует текущий поток до тех пор, пока не установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя 32-разрядное знаковое целое число для измерения времени ожидания.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.CountdownEvent" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя 32-разрядное знаковое целое число для измерения времени ожидания. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален. — или — <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.CountdownEvent" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток, пока не будет установлено <see cref="T:System.Threading.CountdownEvent" />, в то же время контролируя <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален. — или — <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя значение <see cref="T:System.TimeSpan" /> для измерения времени ожидания.</summary>
      <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения -1 миллисекунда, которое представляет неограниченное время ожидания, либо время ожидания превышает <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.CountdownEvent" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток, пока не будет установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя значение <see cref="T:System.TimeSpan" /> для измерения времени ожидания. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален. — или — <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения -1 миллисекунда, которое представляет неограниченное время ожидания, либо время ожидания превышает <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.CountdownEvent" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>Получает количество сигналов, оставшееся до установки события.</summary>
      <returns>Количество сигналов, оставшееся до установки события.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>Получает количество сигналов, изначально нужное для установки события.</summary>
      <returns>Количество сигналов, изначально нужное для установки события.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>Указывает, достиг ли текущий счетчик объекта <see cref="T:System.Threading.CountdownEvent" /> нуля.</summary>
      <returns>
        <see langword="true" />, если текущее значение счетчика равно нулю; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>Получает дескриптор <see cref="T:System.Threading.WaitHandle" />, используемый для ожидания установки события.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <returns>Дескриптор <see cref="T:System.Threading.WaitHandle" />, используемый для ожидания установки события.</returns>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>Указывает, сбрасывается ли <see cref="T:System.Threading.EventWaitHandle" /> автоматически или вручную после получения сигнала.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>При получении сигнала <see cref="T:System.Threading.EventWaitHandle" /> сбрасывается автоматически после освобождения одиночного потока. При отсутствии ожидающих потоков <see cref="T:System.Threading.EventWaitHandle" /> остается сигнальным до тех пор, пока поток не блокируется и не сбрасывается после освобождения потока.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>При получении сигнала, <see cref="T:System.Threading.EventWaitHandle" /> высвобождает все ожидающие потоки и остается сигнальным до тех пор, пока не сбрасывается вручную.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>Представляет событие синхронизации потока.</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяя, получает ли сигнал, ожидающий дескриптор, и производится ли сброс автоматически или вручную.</summary>
      <param name="initialState">Значение <see langword="true" /> для задания начального состояния сигнальным; <see langword="false" /> для задания несигнального начального состояния.</param>
      <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяющего получает ли сигнал дескриптор ожидания, если он был создан в результате данного вызова, сбрасывается ли он автоматически или вручную, а также имя системного события синхронизации.</summary>
      <param name="initialState">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</param>
      <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</param>
      <param name="name">Имя события синхронизации на уровне системы.</param>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.EventWaitHandle" /> и указывает следующие сведения: передавать ли сигнал в дескриптор ожидания при первичном запуске в результате этого вызова; выполнять ли сброс автоматически или вручную; имя системного события синхронизации; логическая переменная для сохранения информации о том, было ли создано именованное системное событие.</summary>
      <param name="initialState">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</param>
      <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</param>
      <param name="name">Имя события синхронизации на уровне системы.</param>
      <param name="createdNew">Когда данный метод возвращает значение, он содержит <see langword="true" />, если было создано локальное событие (то есть, если <paramref name="name" /> имеет значение <see langword="null" /> или пустую строку) или было создано системное событие с заданным именем; либо значение <see langword="false" />, если указанное именованное событие уже существовало. Этот параметр передается неинициализированным.</param>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>Открывает указанное именованное событие синхронизации, если оно уже существует.</summary>
      <param name="name">Имя системного события синхронизации, которое нужно открыть.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное системное событие не существует.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие существует, но у пользователя нет необходимых для его использования прав доступа.</exception>
      <returns>Объект, представляющий именованное системное событие.</returns>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>Задает несигнальное состояние события, вызывая блокирование потоков.</summary>
      <exception cref="T:System.ObjectDisposedException">Метод <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался для этого <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>Устанавливает сигнальное состояние события, что позволяет продолжить выполнение одному или нескольким ожидающим потокам.</summary>
      <exception cref="T:System.ObjectDisposedException">Метод <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался для этого <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      <param name="name">Имя системного события синхронизации, которое нужно открыть.</param>
      <param name="result">При возврате этого метода содержит объект <see cref="T:System.Threading.EventWaitHandle" />, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</exception>
      <returns>Значение <see langword="true" />, если именованное событие синхронизации открылось успешно. В противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary>Управляет контекстом выполнения текущего потока. Этот класс не наследуется.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary>Перехватывает контекст выполнения из текущего потока.</summary>
      <returns>Объект <see cref="T:System.Threading.ExecutionContext" />, представляющий контекст выполнения хоста для текущего потока.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary>Создает копию текущего контекста выполнения.</summary>
      <exception cref="T:System.InvalidOperationException">Данный контекст не может копироваться во время использования. Могут быть скопированы только заново зарегистрированные контексты.</exception>
      <returns>Объект <see cref="T:System.Threading.ExecutionContext" />, представляющий контекст для текущего контекста выполнения.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Задает указанный объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> с информацией логического контекста необходимой для повторного создания экземпляра текущего контекста выполнения.</summary>
      <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который будет заполняться сведениями о сериализации.</param>
      <param name="context">Структура <see cref="T:System.Runtime.Serialization.StreamingContext" />, представляющая контекст назначения сериализации.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="info" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary>Указывает, подавляется ли в данное время поток контекста выполнения.</summary>
      <returns>
        <see langword="true" />, если поток подавляется; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.Restore(System.Threading.ExecutionContext)">
      <summary>Восстанавливает сохраненный контекст выполнения в текущем потоке.</summary>
      <param name="executionContext">Задаваемый контекст ExecutionContext.</param>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary>Восстанавливает перемещение контекста выполнения между асинхронными потоками.</summary>
      <exception cref="T:System.InvalidOperationException">Поток контекста не может быть восстановлен, поскольку он не подавляется.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary>Выполняет метод в указанном контексте выполнения в текущем потоке.</summary>
      <param name="executionContext">Записываемая задача <see cref="T:System.Threading.ExecutionContext" />.</param>
      <param name="callback">Делегат <see cref="T:System.Threading.ContextCallback" />, представляющий выполняемый метод в предоставленном контексте выполнения.</param>
      <param name="state">Данный объект передается в метод обратного вызова.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="executionContext" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="executionContext" /> не был получен во время операции отслеживания.  
  
-или- 
 <paramref name="executionContext" /> уже использовался в качестве аргумента в вызове <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary>Подавляет перемещение контекста выполнения между асинхронными потоками.</summary>
      <exception cref="T:System.InvalidOperationException">Поток контекста уже подавлен.</exception>
      <returns>Структура <see cref="T:System.Threading.AsyncFlowControl" /> для восстановления потока.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary>Инкапсулирует и распространяет контекст выполнения хоста по потокам.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.HostExecutionContext" />, используя определенное состояние.</summary>
      <param name="state">Объект, представляющий состояние контекста выполнения хоста.</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary>Создает копию текущего контекста выполнения хоста.</summary>
      <returns>Объект <see cref="T:System.Threading.HostExecutionContext" />, представляющий контекст хоста для текущего потока.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.HostExecutionContext" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary>При переопределении в производном классе освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Threading.WaitHandle" />, и при необходимости освобождает управляемые ресурсы.</summary>
      <param name="disposing">Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary>Получает или задает состояние контекста выполнения хоста.</summary>
      <returns>Объект, представляющий состояние контекста выполнения хоста.</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary>Обеспечивает функциональность, позволяющие узлу общеязыковой среды выполнения участвовать в потоке или миграции контекста выполнения.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.HostExecutionContextManager" />.</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary>Перехватывает контекст выполнения хоста из текущего потока.</summary>
      <returns>Объект <see cref="T:System.Threading.HostExecutionContext" />, представляющий контекст выполнения хоста для текущего потока.</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary>Восстанавливает контекст выполнения хоста в предыдущее состояние.</summary>
      <param name="previousState">Предыдущее (возвращаемое) состояние контекста.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="previousState" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="previousState" /> не был создан для текущего потока.  
  
-или- 
 <paramref name="previousState" /> не является последним состоянием <see cref="T:System.Threading.HostExecutionContext" />.</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary>Задает текущий контекст выполнения хоста в указываемое значение.</summary>
      <param name="hostExecutionContext">Задаваемый объект <see cref="T:System.Threading.HostExecutionContext" />.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="hostExecutionContext" /> не был получен во время операции отслеживания.  
  
-или- 
 <paramref name="hostExecutionContext" /> использовался в качестве аргумента в предыдущем вызове метода <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" />.</exception>
      <returns>Объект для восстановления <see cref="T:System.Threading.HostExecutionContext" /> в предыдущее состояние.</returns>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>Предоставляет атомарные операции для переменных, общедоступных нескольким потокам.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>Добавляет два 32-разрядных целых числа и заменяет первое число на сумму в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое добавляемое значение. Сумма двух значений сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, добавляемое к целому в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Новое значение сохраняется в <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>Добавляет два 64-разрядных целых числа и заменяет первое число на сумму в виде атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое добавляемое значение. Сумма двух значений сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, добавляемое к целому в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Новое значение сохраняется в <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.UInt32@,System.UInt32)">
      <summary>Складывает два 32-разрядных целых числа без знака и заменяет первое число полученной суммой в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое добавляемое значение. Сумма двух значений сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, добавляемое к целому в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Новое значение сохраняется в <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.UInt64@,System.UInt64)">
      <summary>Складывает два 64-разрядных целых числа без знака и заменяет первое число полученной суммой в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое добавляемое значение. Сумма двух значений сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, добавляемое к целому в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Новое значение сохраняется в <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.Int32@,System.Int32)">
      <summary>Выполняет побитовую операцию "И" над двумя 32-разрядными целыми числами со знаком и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.Int64@,System.Int64)">
      <summary>Выполняет побитовую операцию "И" над двумя 64-разрядными целыми числами со знаком и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.UInt32@,System.UInt32)">
      <summary>Выполняет побитовую операцию "И" над двумя 32-разрядными целыми числами без знака и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.UInt64@,System.UInt64)">
      <summary>Выполняет побитовую операцию "И" над двумя 64-разрядными целыми числами без знака и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>Сравнивает два числа с плавающей запятой двойной точности на равенство и заменяет первое значение, если они равны.</summary>
      <param name="location1">Целевой объект, который нужно сравнить с объектом <paramref name="comparand" /> и, возможно, заменить.</param>
      <param name="value">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</param>
      <param name="comparand">Значение, которое сравнивается со значением в позиции <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>Сравнивает два 32-разрядных целых числа со знаком на равенство и заменяет первое, если они равны.</summary>
      <param name="location1">Целевой объект, который нужно сравнить с объектом <paramref name="comparand" /> и, возможно, заменить.</param>
      <param name="value">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</param>
      <param name="comparand">Значение, которое сравнивается со значением в позиции <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>Сравнивает два 64-разрядных целых числа со знаком на равенство и заменяет первое, если они равны.</summary>
      <param name="location1">Целевой объект, который нужно сравнить с объектом <paramref name="comparand" /> и, возможно, заменить.</param>
      <param name="value">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</param>
      <param name="comparand">Значение, которое сравнивается со значением в позиции <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>Сравнивает два зависящих от платформы обработчика или указателя на равенство и заменяет первое из значений, если они равны.</summary>
      <param name="location1">Целевое значение <see cref="T:System.IntPtr" />, которое будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменено <paramref name="value" />.</param>
      <param name="value">Значение <see cref="T:System.IntPtr" />, которое заменит целевое значение, если результатом сравнения будет равенство.</param>
      <param name="comparand">Значение <see cref="T:System.IntPtr" />, которое сравнивается со значением <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>Сравнивает два объекта на равенство ссылок и заменяет первый объект, если они равны.</summary>
      <param name="location1">Целевой объект, который будет сравниваться по ссылке со значением параметра <paramref name="comparand" /> и, возможно, будет заменен.</param>
      <param name="value">Объект, который заменит целевой объект, если результатом сравнения по ссылке будет равенство.</param>
      <param name="comparand">Объект, который сравнивается по ссылке с объектом в <paramref name="location1" />.</param>
      <exception cref="T:System.ArgumentNullException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>Сравнивает два числа с плавающей запятой с обычной точностью на равенство и, если они равны, заменяет первое значение.</summary>
      <param name="location1">Целевой объект, который нужно сравнить с объектом <paramref name="comparand" /> и, возможно, заменить.</param>
      <param name="value">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</param>
      <param name="comparand">Значение, которое сравнивается со значением в позиции <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.UInt32@,System.UInt32,System.UInt32)">
      <summary>Сравнивает два 32-разрядных целых числа без знака и в случае равенства заменяет первое значение.</summary>
      <param name="location1">Целевой объект, который нужно сравнить с объектом <paramref name="comparand" /> и, возможно, заменить.</param>
      <param name="value">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</param>
      <param name="comparand">Значение, которое сравнивается со значением в позиции <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.UInt64@,System.UInt64,System.UInt64)">
      <summary>Сравнивает два 64-разрядных целых числа без знака и в случае равенства заменяет первое значение.</summary>
      <param name="location1">Целевой объект, который нужно сравнить с объектом <paramref name="comparand" /> и, возможно, заменить.</param>
      <param name="value">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</param>
      <param name="comparand">Значение, которое сравнивается со значением в позиции <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>Сравнивает два экземпляра указанного ссылочного типа <paramref name="T" /> на равенство ссылок. Если они равны, заменяет первый экземпляр.</summary>
      <param name="location1">Целевой объект, значение которого сравнивается по ссылке с объектом <paramref name="comparand" /> и, возможно, будет заменено. Это ссылочный параметр (<see langword="ref" /> в C#, <see langword="ByRef" /> в Visual Basic).</param>
      <param name="value">Значение, которым будет заменено целевое значение, если результатом сравнения по ссылке будет равенство.</param>
      <param name="comparand">Значение, которое сравнивается по ссылке со значением в позиции <paramref name="location1" />.</param>
      <typeparam name="T">Тип, используемый для <paramref name="location1" />, <paramref name="value" />, и <paramref name="comparand" />. Этот тип должен быть ссылочным типом.</typeparam>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является пустым указателем.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <param name="location">Переменная, у которой уменьшается значение.</param>
      <exception cref="T:System.ArgumentNullException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Уменьшаемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>Уменьшает значение заданной переменной и сохраняет результат — как атомарная операция.</summary>
      <param name="location">Переменная, у которой уменьшается значение.</param>
      <exception cref="T:System.ArgumentNullException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Уменьшаемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.UInt32@)">
      <summary>Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <param name="location">Переменная, у которой уменьшается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Уменьшаемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.UInt64@)">
      <summary>Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <param name="location">Переменная, у которой уменьшается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Уменьшаемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>Задает число с плавающей запятой с двойной точностью указанным значением — как атомарная операция, и возвращает исходное значение.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>Присваивает 32-битовому целому числу со знаком заданное значение и возвращает исходное значение в одной атомарной операции.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.ArgumentNullException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>Присваивает 64-разрядному целому числу со знаком заданное значение и возвращает исходное значение в виде атомарной операции.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>Задает указатель или обработчик, зависящий от платформы — как атомарная операция, и возвращает ссылку на исходное значение.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>Задает объект указанным значением — как атомарная операция, и возвращает ссылку на исходный объект.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.ArgumentNullException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>Задает число с плавающей запятой с обычной точностью указанным значением — как атомарная операция, и возвращает исходное значение.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.UInt32@,System.UInt32)">
      <summary>Присваивает 32-разрядному целому числу без знака заданное значение и возвращает его исходное значение в одной атомарной операции.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.UInt64@,System.UInt64)">
      <summary>Присваивает 64-разрядному целому числу без знака заданное значение и возвращает его исходное значение в одной атомарной операции.</summary>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary>Задает определенное значение для переменной указанного типа <paramref name="T" /> и возвращает исходное значение (атомарная операция).</summary>
      <param name="location1">Переменная, которая задается указанным значением. Это ссылочный параметр (<see langword="ref" /> в C#, <see langword="ByRef" /> в Visual Basic).</param>
      <param name="value">Значение, которое задается для параметра <paramref name="location1" />.</param>
      <typeparam name="T">Тип, который должен использоваться для <paramref name="location1" /> и <paramref name="value" />. Этот тип должен быть ссылочным типом.</typeparam>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary>Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <param name="location">Переменная, у которой увеличивается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Увеличиваемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary>Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <param name="location">Переменная, у которой увеличивается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Увеличиваемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.UInt32@)">
      <summary>Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <param name="location">Переменная, у которой увеличивается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Увеличиваемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.UInt64@)">
      <summary>Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <param name="location">Переменная, у которой увеличивается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location" /> является указателем <see langword="null" />.</exception>
      <returns>Увеличиваемое значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary>Синхронизирует доступ к памяти следующим образом: процессор, выполняющий текущий поток, не способен упорядочить инструкции так, чтобы обращения к памяти до вызова метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> выполнялись после обращений к памяти, следующих за вызовом метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary>Предоставляет барьер памяти всего процесса, который не позволяет перемещать операции чтения и записи из любого ЦП.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.Int32@,System.Int32)">
      <summary>Выполняет побитовую операцию "ИЛИ" над двумя 32-разрядными целыми числами со знаком и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.Int64@,System.Int64)">
      <summary>Выполняет побитовую операцию "ИЛИ" над двумя 64-разрядными целыми числами со знаком и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.UInt32@,System.UInt32)">
      <summary>Выполняет побитовую операцию "ИЛИ" над двумя 32-разрядными целыми числами без знака и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.UInt64@,System.UInt64)">
      <summary>Выполняет побитовую операцию "ИЛИ" над двумя 64-разрядными целыми числами без знака и заменяет первое целое число полученным результатом в одной атомарной операции.</summary>
      <param name="location1">Переменная, содержащая первое значение для объединения. Результат сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, которое необходимо объединить с целым числом в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="location1" /> является указателем <see langword="null" />.</exception>
      <returns>Исходное значение в позиции <paramref name="location1" />.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary>Возвращает 64-битное значение, загруженное в виде атомарной операции.</summary>
      <param name="location">Загружаемое 64-разрядное значение.</param>
      <returns>Загруженное значение.</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.UInt64@)">
      <summary>Возвращает загруженное 64-разрядное значение без знака в одной атомарной операции.</summary>
      <param name="location">Загружаемое 64-разрядное значение.</param>
      <returns>Загруженное значение.</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>Обеспечивает процедуры инициализации адаптирующегося типа.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>Инициализирует целевой ссылочный тип его конструктором типа без параметров, если он еще не инициализирован.</summary>
      <param name="target">Ссылка, которую необходимо инициализировать, если она еще не инициализирована. Если это параметр <see langword="null" />, тип считается неинициализированным; в противном случае тип считается инициализированным.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MemberAccessException">Разрешения на доступ к конструктору типа <paramref name="T" /> отсутствовали.</exception>
      <exception cref="T:System.MissingMemberException">У типа <paramref name="T" /> нет конструктора без параметров.</exception>
      <returns>Инициализированный объект.</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>Инициализирует целевой ссылочный тип или тип значения его конструктором без параметров, если он еще не инициализирован.</summary>
      <param name="target">Ссылка или значение типа <c>T</c>, которое необходимо инициализировать, если оно еще не инициализировано.</param>
      <param name="initialized">Ссылка на логическое значение, определяющее, инициализирована ли цель.</param>
      <param name="syncLock">Ссылка на объект, используемый как взаимоисключающая блокировка для инициализации параметра <paramref name="target" />. Если <paramref name="syncLock" /> равно <see langword="null" />, то нового объект будет создан экземпляр.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MemberAccessException">Разрешения на доступ к конструктору типа <paramref name="T" /> отсутствовали.</exception>
      <exception cref="T:System.MissingMemberException">У типа <paramref name="T" /> нет конструктора без параметров.</exception>
      <returns>Инициализированный объект.</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>Инициализирует целевой ссылочный тип или тип значения с использованием указанной функцией, если он еще не инициализирован.</summary>
      <param name="target">Ссылка или значение типа <c>T</c>, которое необходимо инициализировать, если оно еще не инициализировано.</param>
      <param name="initialized">Ссылка на логическое значение, определяющее, инициализирована ли цель.</param>
      <param name="syncLock">Ссылка на объект, используемый как взаимоисключающая блокировка для инициализации параметра <paramref name="target" />. Если <paramref name="syncLock" /> равно <see langword="null" />, то нового объект будет создан экземпляр.</param>
      <param name="valueFactory">Функция, которая вызывается для инициализации ссылки или значения.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MemberAccessException">Разрешения на доступ к конструктору типа <paramref name="T" /> отсутствовали.</exception>
      <exception cref="T:System.MissingMemberException">У типа <paramref name="T" /> нет конструктора без параметров.</exception>
      <returns>Инициализированный объект.</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>Инициализирует целевой ссылочный тип с использованием указанной функцией, если он еще не инициализирован.</summary>
      <param name="target">Ссылка, которую необходимо инициализировать, если она еще не инициализирована.</param>
      <param name="valueFactory">Функция, которая вызывается для инициализации ссылки.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MissingMemberException">У типа <paramref name="T" /> нет конструктора без параметров.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> вернул значение NULL (Nothing в Visual Basic).</exception>
      <returns>Инициализированный объект.</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary>Инициализирует целевой ссылочный тип указанной функцией, если он еще не инициализирован.</summary>
      <param name="target">Ссылка, которую необходимо инициализировать, если она еще не инициализирована. Если это параметр <see langword="null" />, тип считается неинициализированным; в противном случае тип считается инициализированным.</param>
      <param name="syncLock">Ссылка на объект, используемый как взаимоисключающая блокировка для инициализации параметра <paramref name="target" />. Если <paramref name="syncLock" /> равно <see langword="null" />, то нового объект будет создан экземпляр.</param>
      <param name="valueFactory">Метод, который необходимо вызвать для инициализации <paramref name="target" />.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <returns>Инициализированный объект.</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary>Определяет блокировку, которая реализует семантику "один записывающий / много читающих". Это тип значения.</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary>Обозначает равенство указанного объекта и текущего экземпляра объекта <see cref="T:System.Threading.LockCookie" />.</summary>
      <param name="obj">Объект, сравниваемый с текущим экземпляром.</param>
      <returns>Значение <see langword="true" />, если значение параметра <paramref name="obj" /> равно значению текущего экземпляра; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary>Определяет равенство текущего экземпляра и указанного объекта <see cref="T:System.Threading.LockCookie" />.</summary>
      <param name="obj">
        <see cref="T:System.Threading.LockCookie" /> для сравнения с текущим экземпляром.</param>
      <returns>Значение <see langword="true" />, если значение параметра <paramref name="obj" /> равно значению текущего экземпляра; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary>Возвращает хэш-код данного экземпляра.</summary>
      <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Определяет равенство двух структур <see cref="T:System.Threading.LockCookie" />.</summary>
      <param name="a">Объект <see cref="T:System.Threading.LockCookie" />, используемый для сравнения с <paramref name="b" />.</param>
      <param name="b">Объект <see cref="T:System.Threading.LockCookie" />, используемый для сравнения с <paramref name="a" />.</param>
      <returns>
        <see langword="true" />, если значения параметров <paramref name="a" /> и <paramref name="b" /> равны; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>Указывает, действительно ли не равны две структуры <see cref="T:System.Threading.LockCookie" />.</summary>
      <param name="a">Объект <see cref="T:System.Threading.LockCookie" />, используемый для сравнения с <paramref name="b" />.</param>
      <param name="b">Объект <see cref="T:System.Threading.LockCookie" />, используемый для сравнения с <paramref name="a" />.</param>
      <returns>
        <see langword="true" />, если значения <paramref name="a" /> и <paramref name="b" /> не равны; в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary>Исключение, которое создается, когда рекурсивная запись блокировки не совместима с рекурсивной политикой блокировки.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.LockRecursionException" /> с предоставленным системой описанием ошибки.</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.LockRecursionException" /> с сериализованными данными.</summary>
      <param name="info">Объект, содержащий сериализованные данные объекта.</param>
      <param name="context">Контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.LockRecursionException" /> с указанным описанием ошибки.</summary>
      <param name="message">Сообщение с описанием исключения. Вызывающий объект этого конструктора должен убедиться, что эта строка локализована для текущего языка и региональных параметров системы.</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.LockRecursionException" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
      <param name="message">Сообщение с описанием исключения. Вызывающий объект этого конструктора должен убедиться, что эта строка локализована для текущего языка и региональных параметров системы.</param>
      <param name="innerException">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="innerException" /> не равно <see langword="null" />, текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>Указывает, можно ли несколько раз войти в блокировку из одного и того же потока.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>Если поток пытается войти в блокировку рекурсивно, выдается ошибка. Некоторые классы могут допускать определенные виды рекурсий при активированном параметре.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>Допускается рекурсивный вход потока в блокировку. Некоторые классы могут игнорировать эту возможность.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary>Представляет событие синхронизации потока, которое при получении сигнала необходимо сбросить вручную. Этот класс не наследуется.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEvent" /> логическим значением, показывающим наличие сигнального состояния.</summary>
      <param name="initialState">Значение <see langword="true" /> для задания начального состояния сигнальным; <see langword="false" /> для задания несигнального начального состояния.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>Представляет событие синхронизации потока, которое при получении сигнала необходимо сбросить вручную. Этот класс является упрощенной альтернативой <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEventSlim" /> начальным состоянием nonsignaled.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEventSlim" /> логическим значением, показывающим наличие сигнального состояния.</summary>
      <param name="initialState">значение true для задания начального сигнального состояния; значение false для задания начального несигнального состояния.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEventSlim" /> с логическим значением, указывающим, нужно ли для начального состояния задать сигнальное значение, а также указанным числом прокруток.</summary>
      <param name="initialState">Значение true для задания начального сигнального состояния; значение false для задания начального несигнального состояния.</param>
      <param name="spinCount">Число ожиданий прокруток до возврата к операции ожидания на основе ядра.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> меньше 0 или больше максимального разрешенного значения.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые ресурсы, используемые журналом <see cref="T:System.Threading.ManualResetEventSlim" />, и при необходимости освобождает также управляемые ресурсы.</summary>
      <param name="disposing">Значение true, чтобы освобождать и управляемые и неуправляемые ресурсы. Значение false, чтобы освобождать только неуправляемые ресурсы.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>Задает несигнальное состояние события, вызывая блокирование потоков.</summary>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>Устанавливает несигнальное состояние события, позволяя продолжить выполнение одному или нескольким потокам, ожидающим событие.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>Блокирует текущий поток до установки текущего объекта <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>Блокирует текущий поток до тех пор, пока не установлен текущий объект <see cref="T:System.Threading.ManualResetEventSlim" />, используя 32-разрядное знаковое целое число для измерения интервала времени.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен текущий объект <see cref="T:System.Threading.ManualResetEventSlim" />, используя 32-разрядное знаковое целое число для измерения интервала времени. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект был удален или <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до получения сигнала текущим объектом <see cref="T:System.Threading.ManualResetEventSlim" />. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект был удален или <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>Блокирует текущий поток, пока не будет установлено текущее событие <see cref="T:System.Threading.ManualResetEventSlim" />, используя объект <see cref="T:System.TimeSpan" /> для измерения интервала времени.</summary>
      <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания. 
-или- 
Количество миллисекунд в <paramref name="timeout" /> больше, чем значение <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен текущий объект <see cref="T:System.Threading.ManualResetEventSlim" />, используя значение <see cref="T:System.TimeSpan" /> для измерения интервала времени. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания. 
-или- 
Количество миллисекунд в <paramref name="timeout" /> больше, чем значение <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект был удален или <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <returns>Значение <see langword="true" />, если был задан <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>Получает значение, указывающее, установлено ли событие.</summary>
      <returns>Значение true, если событие установлено; в противном случае — значение false.</returns>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>Получает число спин-блокировок до возврата к операции ожидания на основе ядра.</summary>
      <returns>Возвращает число спин-блокировок до возврата к операции ожидания на основе ядра.</returns>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>Получает базовый объект <see cref="T:System.Threading.WaitHandle" /> для данного объекта <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns>Базовый <see cref="T:System.Threading.WaitHandle" /> объект события для этого объекта <see cref="T:System.Threading.ManualResetEventSlim" /> .</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>Предоставляет механизм для синхронизации доступа к объектам.</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>Получает эксклюзивную блокировку указанного объекта.</summary>
      <param name="obj">Объект, для которого получается блокировка монитора.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>Получает монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Объект, в котором следует ожидать.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.  
  
Примечание. Если исключение не возникает, выходное значение этого метода всегда равно <see langword="true" />.</param>
      <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>Освобождает эксклюзивную блокировку указанного объекта.</summary>
      <param name="obj">Объект, блокировка которого освобождается.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Данный поток не владеет блокировкой для указанного объекта.</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>Определяет, содержит ли текущий поток блокировку указанного объекта.</summary>
      <param name="obj">Объект для тестирования.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <returns>Значение <see langword="true" />, если текущий поток владеет блокировкой в <paramref name="obj" />; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>Уведомляет поток в очереди готовности об изменении состояния объекта с блокировкой.</summary>
      <param name="obj">Объект, ожидаемый потоком.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>Уведомляет все ожидающие потоки об изменении состояния объекта.</summary>
      <param name="obj">Объект, посылающий импульс.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>Пытается получить эксклюзивную блокировку указанного объекта.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <returns>Значение <see langword="true" />, если текущий поток получает блокировку; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>Пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
      <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>Пытается получить эксклюзивную блокировку указанного объекта на заданное количество миллисекунд.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="millisecondsTimeout">Количество миллисекунд, в течение которых ожидать блокировку.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> является отрицательным числом и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      <returns>Значение <see langword="true" />, если текущий поток получает блокировку; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>В течение заданного количества миллисекунд пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="millisecondsTimeout">Количество миллисекунд, в течение которых ожидать блокировку.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
      <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> является отрицательным числом и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>Пытается получить эксклюзивную блокировку указанного объекта в течение заданного количества времени.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, в течение которого ожидается блокировка. Значение –1 миллисекунды обозначает бесконечное ожидание.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если текущий поток получает блокировку; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>В течение заданного периода времени пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="timeout">Период времени, в течение которого ожидается блокировка. Значение –1 миллисекунды обозначает бесконечное ожидание.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
      <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова.</summary>
      <param name="obj">Объект, в котором следует ожидать.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
      <returns>Значение <see langword="true" />, если вызов осуществил возврат из-за того, что вызывающий поток заново получил блокировку заданного объекта. Этот метод не осуществляет возврат, если блокировка вновь не получена.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности.</summary>
      <param name="obj">Объект, в котором следует ожидать.</param>
      <param name="millisecondsTimeout">Количество миллисекунд для ожидания постановки в очередь готовности.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности. Этот метод также указывает на выход из области синхронизации для контекста (если она находится в синхронизированном контексте) до ожидания и ее повторное получение впоследствии.</summary>
      <param name="obj">Объект, в котором следует ожидать.</param>
      <param name="millisecondsTimeout">Количество миллисекунд для ожидания постановки в очередь готовности.</param>
      <param name="exitContext">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — значение <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> — не вызывается из синхронизированного блока кода.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности.</summary>
      <param name="obj">Объект, в котором следует ожидать.</param>
      <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, до истечения которого поток поступает в очередь ожидания.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности. Дополнительно выходит из синхронизированного домена для синхронизации контекста до ожидания и получает домен впоследствии.</summary>
      <param name="obj">Объект, в котором следует ожидать.</param>
      <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, до истечения которого поток поступает в очередь ожидания.</param>
      <param name="exitContext">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — значение <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> — не вызывается из синхронизированного блока кода.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Для потока, который вызывает Wait, состояние ожидания позже прерывается. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary>Возвращает значение, указывающее, сколько раз возникало состязание при попытке установить блокировку монитора.</summary>
      <returns>Количество конфликтов при попытке снятия блокировки монитора.</returns>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>Примитив синхронизации, который также может использоваться в межпроцессной синхронизации.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> стандартными свойствами.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса.</summary>
      <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения мьютексом; в противном случае — <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, а также иметь строку, являющуюся именем мьютекса.</summary>
      <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
      <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом.</summary>
      <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
      <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
      <param name="createdNew">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует. Этот параметр передается неинициализированным.</param>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
      <param name="name">Имя системного мьютекса для открытия.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      <returns>Объект, представляющий именованный системный мьютекс.</returns>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>Освобождает объект <see cref="T:System.Threading.Mutex" /> один раз.</summary>
      <exception cref="T:System.ApplicationException">Вызывающий поток не является владельцем мьютекса.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      <param name="name">Имя системного мьютекса для открытия.</param>
      <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова. Этот параметр обрабатывается как неинициализированный.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      <returns>Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary>Определяет блокировку, которая поддерживает один пишущий поток и несколько читающих.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary>Получает блокировку чтения, используя значение <see cref="T:System.Int32" /> для задания времени ожидания.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах.</param>
      <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="millisecondsTimeout" />, истекло до удовлетворения запроса на блокировку.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary>Получает блокировку чтения, используя значение <see cref="T:System.TimeSpan" /> для задания времени ожидания.</summary>
      <param name="timeout">Период <see langword="TimeSpan" />, задающий время ожидания.</param>
      <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary>Получает блокировку записи, используя значение <see cref="T:System.Int32" /> для задания времени ожидания.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах.</param>
      <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary>Получает блокировку записи, используя значение <see cref="T:System.TimeSpan" /> для задания времени ожидания.</summary>
      <param name="timeout">Период <see langword="TimeSpan" />, задающий время ожидания.</param>
      <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary>Показывает, была ли предоставлена блокировка записи какому-либо потоку со времени получения последовательного номера.</summary>
      <param name="seqNum">Порядковый номер.</param>
      <returns>Значение <see langword="true" />, если блокировка записи была предоставлена какому-либо потоку с момента получения порядкового номера; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary>Возвращает состояние блокировки потока к тому, которое было до вызова метода <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
      <param name="lockCookie">Объект <see cref="T:System.Threading.LockCookie" />, возвращаемый <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
      <exception cref="T:System.ApplicationException">Поток не владеет блокировкой записи.</exception>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="lockCookie" /> является пустым указателем.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary>Освобождает блокировку, независимо от количества ее получений потоком.</summary>
      <returns>Объект <see cref="T:System.Threading.LockCookie" />, представляющий освобожденную блокировку.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary>Уменьшает на единицу счетчик блокировок.</summary>
      <exception cref="T:System.ApplicationException">Поток не владеет блокировкой чтения или записи.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary>Уменьшает на единицу счетчик блокировок данной блокировки записи.</summary>
      <exception cref="T:System.ApplicationException">Поток не владеет блокировкой записи.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary>Возвращает состояние блокировки потока к тому, которое было до вызова метода <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
      <param name="lockCookie">Объект <see cref="T:System.Threading.LockCookie" />, возвращаемый <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес <paramref name="lockCookie" /> является пустым указателем.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary>Повышает уровень блокировки чтения до блокировки записи, используя значение <see cref="T:System.Int32" /> для задания времени ожидания.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах.</param>
      <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="millisecondsTimeout" />, истекло до удовлетворения запроса на блокировку.</exception>
      <returns>Значение <see cref="T:System.Threading.LockCookie" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary>Повышает уровень блокировки чтения до блокировки записи, используя значение <see langword="TimeSpan" /> для задания времени ожидания.</summary>
      <param name="timeout">Период <see langword="TimeSpan" />, задающий время ожидания.</param>
      <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</exception>
      <returns>Значение <see cref="T:System.Threading.LockCookie" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary>Возвращает значение, указывающее, владеет ли текущий поток блокировкой чтения.</summary>
      <returns>Значение <see langword="true" />, если текущий поток владеет блокировкой чтения; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary>Возвращает значение, указывающее, владеет ли текущий поток блокировкой записи.</summary>
      <returns>Значение <see langword="true" />, если текущий поток владеет блокировкой записи; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary>Возвращает текущий последовательный номер.</summary>
      <returns>Текущий последовательный номер.</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Представляет блокировку, используемую для управления доступом к ресурсу, которая позволяет нескольким потокам производить считывание или получать монопольный доступ на запись.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> значениями свойств по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> с указанием политики рекурсии блокировок.</summary>
      <param name="recursionPolicy">Одно из значений перечисления, определяющее политику рекурсии блокировки.</param>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> больше нуля.  
  
-или- 
 Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> больше нуля.  
  
-или- 
 Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> больше нуля.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Пытается выполнить вход в блокировку в режиме чтения.</summary>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку чтения, когда уже удерживает эту блокировку чтения.  
  
-или- 
Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку записи, когда уже удерживает эту блокировку записи.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Данное ограничение настолько велико, что приложения никогда не должны столкнуться с этим исключением.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Пытается выполнить вход в блокировку в обновляемом режиме.</summary>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.  
  
-или- 
Текущий поток вошел в режим чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Пытается выполнить вход в блокировку в режиме записи.</summary>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.  
  
-или- 
Текущий поток вступил в режим чтения и еще не имеет блокировки записи, поэтому попытка войти в режим блокировки в режиме записи создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Уменьшает счетчик глубины рекурсии для режима чтения и выходит из режима чтения, если счетчик принял значение 0 (нуль).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме чтения.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Уменьшает счетчик глубины рекурсии для обновляемого режима и выходит из обновляемого режима, если счетчик принял значение 0 (нуль).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в обновляемом режиме.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Уменьшает счетчик глубины рекурсии для режима записи и выходит из режима записи, если счетчик принял значение 0 (нуль).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме записи.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания целым числом.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</summary>
      <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.  
  
-или- 
Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      <returns>Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
      <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.  
  
-или- 
Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      <returns>Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим записи, иначе — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
      <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.  
  
-или- 
Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим записи, иначе — <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Получает общее количество уникальных потоков, вошедших в блокировку в режиме чтения.</summary>
      <returns>Количество уникальных потоков, вошедших в блокировку в режиме чтения.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме чтения.</summary>
      <returns>Значение <see langword="true" />, если текущий поток вошел в режим чтения; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>Возвращает значение, указывающее, вошел ли текущий поток в блокировку в обновляемом режиме.</summary>
      <returns>Значение <see langword="true" />, если текущий поток вошел в обновляемый режим, противном случае – <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме записи.</summary>
      <returns>Значение <see langword="true" />, если текущий поток вошел в режим записи; в противном случае <see langword="false" />.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>Возвращает значение, указывающее политику рекурсии для текущего объекта <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <returns>Одно из значений перечисления, определяющее политику рекурсии блокировки.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>Получает количество раз, которые текущий поток входил в блокировку в режиме чтения, как показатель рекурсии.</summary>
      <returns>0 (ноль), если текущий поток не вошел в режим чтения, 1, если поток вошел в режим чтения, но не вошел в него рекурсивно, или n , если поток вошел в блокировку рекурсивно n -1 раз.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>Получает количество раз, которые текущий поток входил в блокировку в обновляемом режиме, как показатель рекурсии.</summary>
      <returns>0, если текущий поток не вошел в обновляемый режим, 1, если поток вошел в обновляемый режим, но не вошел в него рекурсивно, или n , если поток вошел в обновляемый режим рекурсивно n – 1 раз.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>Получает количество раз, которые текущий поток входил в блокировку в режиме записи, как показатель рекурсии.</summary>
      <returns>0, если текущий поток не вошел в режим записи, 1, если поток вошел в режим записи, но не вошел в него рекурсивно, или n , если поток вошел в режим записи рекурсивно n -1 раз.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>Получает общее количество потоков, ожидающих вхождения в блокировку в режиме чтения.</summary>
      <returns>Общее количество потоков, ожидающих вхождения в режим чтения.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>Получает общее количество потоков, ожидающих входа в блокировку в обновляемом режиме.</summary>
      <returns>Общее количество потоков, ожидающих входа в обновляемый режим.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>Получает общее количество потоков, ожидающих входа в блокировку в режиме записи.</summary>
      <returns>Общее количество потоков, ожидающих входа в режим записи.</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary>Ограничивает число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
      <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
-или- 
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости имя объекта системного семафора.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
      <param name="name">Имя семафора. Если он имеет значение <see langword="null" /> или пустой, создается семафор, локальный для процесса. Если имя имеет префикс "Global", создается семафор на уровне компьютера (или возвращается существующий). Если имя имеет префикс "Local", создается семафор на уровне сеанса (или возвращается существующий). Если имя не имеет префикса, создается семафор на уровне сеанса (как и в случае с префиксом "Local"). В префиксе и имени учитывается регистр.</param>
      <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
-или- 
 Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
-или- 
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости задающий имя объекта системного семафора и переменную, получающую значение, которое указывает, был ли создан новый системный семафор.</summary>
      <param name="initialCount">Начальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
      <param name="maximumCount">Максимальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
      <param name="name">Имя семафора. Если он имеет значение <see langword="null" /> или пустой, создается семафор, локальный для процесса. Если имя имеет префикс "Global", создается семафор на уровне компьютера (или возвращается существующий). Если имя имеет префикс "Local", создается семафор на уровне сеанса (или возвращается существующий). Если имя не имеет префикса, создается семафор на уровне сеанса (как и в случае с префиксом "Local"). В префиксе и имени учитывается регистр.</param>
      <param name="createdNew">При возврате этот метод содержит значение <see langword="true" />, если был создан локальный семафор (то есть если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан заданный именованный системный семафор; значение <see langword="false" />, если указанный именованный семафор уже существовал. Этот параметр передается неинициализированным.</param>
      <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
-или- 
 Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
-или- 
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary>Открывает указанный именованный семафор, если он уже существует.</summary>
      <param name="name">Имя семафора. Если имя имеет префикс "Global", оно относится к семафору на уровне компьютера. Если имя имеет префикс "Local", оно относится к семафору на уровне сеанса. В префиксе и имени учитывается регистр.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не существует.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      <returns>Объект, представляющий именованный системный семафор.</returns>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary>Выходит из семафора и возвращает последнее значение счетчика.</summary>
      <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
-или- 
Текущий семафор представляет именованный системный семафор, но он не был открыт с правами доступа <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary>Выходит из семафора указанное число раз и возвращает последнее значение счетчика.</summary>
      <param name="releaseCount">Количество требуемых выходов из семафора.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="releaseCount" /> меньше 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
-или- 
Текущий семафор представляет именованный системный семафор, но он не был открыт с правами <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary>Открывает указанный именованный семафор, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      <param name="name">Имя семафора. Если имя имеет префикс "Global", оно относится к семафору на уровне компьютера. Если имя имеет префикс "Local", оно относится к семафору на уровне сеанса. В префиксе и имени учитывается регистр.</param>
      <param name="result">При возврате этот метод содержит объект <see cref="T:System.Threading.Semaphore" />, представляющий именованный семафор, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      <returns>Значение <see langword="true" />, если именованный семафор был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary>Это исключение создается при вызове метода <see cref="Overload:System.Threading.Semaphore.Release" /> семафора, счетчик которого уже имеет максимальное значение.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreFullException" /> со значениями по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreFullException" /> с сериализованными данными.</summary>
      <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, содержащий сериализованные данные объекта по возникающему исключению.</param>
      <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreFullException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreFullException" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
      <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
      <param name="innerException">Исключение, которое является причиной текущего исключения. Если значение параметра <paramref name="innerException" /> не равно <see langword="null" />, текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>Представляет упрощенную альтернативу семафору <see cref="T:System.Threading.Semaphore" />, ограничивающему количество потоков, которые могут параллельно обращаться к ресурсу или пулу ресурсов.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreSlim" />, указывая первоначальное число запросов, которые могут выполняться одновременно.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра<paramref name="initialCount" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreSlim" />, указывая изначальное и максимальное число запросов, которые могут выполняться одновременно.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <param name="maxCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> меньше 0 или <paramref name="initialCount" /> больше, чем <paramref name="maxCount" />, или <paramref name="maxCount" /> меньше или равен 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые ресурсы, используемые журналом <see cref="T:System.Threading.SemaphoreSlim" />, и при необходимости освобождает также управляемые ресурсы.</summary>
      <param name="disposing">Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>Освобождает объект <see cref="T:System.Threading.SemaphoreSlim" /> один раз.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> уже достиг максимального размера.</exception>
      <returns>Предыдущее количество в семафоре <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>Освобождает объект <see cref="T:System.Threading.SemaphoreSlim" /> указанное число раз.</summary>
      <param name="releaseCount">Количество требуемых выходов из семафора.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="releaseCount" /> меньше 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> уже достиг максимального размера.</exception>
      <returns>Предыдущее количество в семафоре <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>Блокирует текущий поток, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32-разрядное целое число со знаком, которое определяет время ожидания.</summary>
      <param name="millisecondsTimeout">Количество миллисекунд ожидания, <see cref="F:System.Threading.Timeout.Infinite" />(–1) для неограниченного времени ожидания, или нуль, чтобы проверить состояние дескриптора ожидания и выполнить немедленный возврат.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от значения –1, которое представляет неограниченное время ожидания, либо время ожидания превышает <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.SemaphoreSlim" /> удален.</exception>
      <returns>Значение <see langword="true" />, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32-разрядное целое число со знаком, которое определяет время ожидания, и контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Количество миллисекунд ожидания, <see cref="F:System.Threading.Timeout.Infinite" />(–1) для неограниченного времени ожидания, или нуль, чтобы проверить состояние дескриптора ожидания и выполнить немедленный возврат.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.

-или-

Значение <paramref name="millisecondsTimeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.SemaphoreSlim" /> был удален, или объект <see cref="T:System.Threading.CancellationTokenSource" />, создавший<paramref name="cancellationToken" />, был удален.</exception>
      <returns>Значение <see langword="true" />, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, и контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.  
  
-или- 
Класс <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, уже удален.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя значение <see cref="T:System.TimeSpan" /> для определения времени ожидания.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />, представляющий количество миллисекунд для ожидания, <see cref="T:System.TimeSpan" />, представляющий –1 миллисекунду для неопределенного ожидания, или <see cref="T:System.TimeSpan" />, представляющий 0 миллисекунд, чтобы протестировать дескриптор ожидания и выполнить немедленный возврат.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.

-или-

Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Экземпляр semaphoreSlim был уничтожен.</exception>
      <returns>Значение <see langword="true" />, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя значение <see cref="T:System.TimeSpan" />, которое определяет время ожидания, и контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />, представляющий количество миллисекунд для ожидания, <see cref="T:System.TimeSpan" />, представляющий –1 миллисекунду для неопределенного ожидания, или <see cref="T:System.TimeSpan" />, представляющий 0 миллисекунд, чтобы протестировать дескриптор ожидания и выполнить немедленный возврат.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.

- или -.

Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Экземпляр semaphoreSlim был уничтожен.
          
-или-

Класс <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, уже удален.</exception>
      <returns>Значение <see langword="true" />, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.SemaphoreSlim" /> удален.</exception>
      <returns>Задача, которая завершается, когда семафор будет введен.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32-разрядное целое число со знаком для измерения интервала времени.</summary>
      <param name="millisecondsTimeout">Количество миллисекунд ожидания, <see cref="F:System.Threading.Timeout.Infinite" /> (–1) для неограниченного времени ожидания, или нуль, чтобы проверить состояние дескриптора ожидания и выполнить немедленный возврат.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.
          
-или- 
Значение <paramref name="millisecondsTimeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Задача, которая будет завершаться с результатом <see langword="true" />, если текущий поток успешно вошел в <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом <see langword="false" /> в противном случае.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32-разрядное целое число со знаком для измерения интервала времени, контролируя <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="millisecondsTimeout">Количество миллисекунд ожидания, <see cref="F:System.Threading.Timeout.Infinite" /> (–1) для неограниченного времени ожидания, или нуль, чтобы проверить состояние дескриптора ожидания и выполнить немедленный возврат.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> является числом, отличным от -1, которое представляет неограниченное время ожидания.
          
-или-

Значение <paramref name="millisecondsTimeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <returns>Задача, которая будет завершаться с результатом <see langword="true" />, если текущий поток успешно вошел в <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом <see langword="false" /> в противном случае.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, контролируя <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <returns>Задача, которая завершается, когда семафор будет введен.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя <see cref="T:System.TimeSpan" /> для измерения интервала времени.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />, представляющий количество миллисекунд для ожидания, <see cref="T:System.TimeSpan" />, представляющий –1 миллисекунду для неопределенного ожидания, или <see cref="T:System.TimeSpan" />, представляющий 0 миллисекунд, чтобы протестировать дескриптор ожидания и выполнить немедленный возврат.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.

-или- 
Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Задача, которая будет завершаться с результатом <see langword="true" />, если текущий поток успешно вошел в <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом <see langword="false" /> в противном случае.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя <see cref="T:System.TimeSpan" /> для измерения интервала времени и контролируя <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />, представляющий количество миллисекунд для ожидания, <see cref="T:System.TimeSpan" />, представляющий –1 миллисекунду для неопределенного ожидания, или <see cref="T:System.TimeSpan" />, представляющий 0 миллисекунд, чтобы протестировать дескриптор ожидания и выполнить немедленный возврат.</param>
      <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.
          
-или-

Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.SemaphoreSlim" /> удален.</exception>
      <returns>Задача, которая будет завершаться с результатом <see langword="true" />, если текущий поток успешно вошел в <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом <see langword="false" /> в противном случае.</returns>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>Возвращает дескриптор <see cref="T:System.Threading.WaitHandle" />, который можно использовать для ожидания семафора.</summary>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.SemaphoreSlim" /> удален.</exception>
      <returns>Дескриптор <see cref="T:System.Threading.WaitHandle" />, который можно использовать для ожидания семафора.</returns>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>Возвращает количество оставшихся потоков, которым разрешено входить в объект <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Количество оставшихся потоков, которым разрешено входить в семафор.</returns>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary>Задает метод, вызываемый при отправке сообщения в контекст синхронизации.</summary>
      <param name="state">Передаваемый делегату объект.</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>Предоставляет примитив взаимно исключающей блокировки, в котором поток, пытающийся получить блокировку, ожидает в состоянии цикла, проверяя доступность блокировки.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Threading.SpinLock" /> параметром для отслеживания идентификаторов потоков для повышения качества отладки.</summary>
      <param name="enableThreadOwnerTracking">Следует ли перенаправлять и использовать идентификаторы потоков для отладки.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>Получает блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>Снимает блокировку.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Включено отслеживание владения потоков и текущий поток не является владельцем этой блокировки.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>Снимает блокировку.</summary>
      <param name="useMemoryBarrier">Логическое значение, указывающее, следует ли выпустить барьер памяти, чтобы немедленно опубликовать операцию выхода для других потоков.</param>
      <exception cref="T:System.Threading.SynchronizationLockException">Включено отслеживание владения потоков и текущий поток не является владельцем этой блокировки.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>Пытается получить блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>Пытается получить блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>Пытается получить блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения -1 миллисекунды, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>Получает значение, определяющее, имеет ли какой-либо поток блокировку в настоящий момент.</summary>
      <returns>Значение true, если в настоящее время блокировка удерживается каким-либо потоком; в противном случае — значение false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>Получает значение, определяющее, имеет ли текущий поток блокировку.</summary>
      <exception cref="T:System.InvalidOperationException">Отслеживание владения потоков отключено.</exception>
      <returns>Значение true, если блокировка удерживается текущим потоком; в противном случае — значение false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>Получает значение, указывающее, включено ли отслеживание владельца потока для данного экземпляра.</summary>
      <returns>Значение true, если для данного экземпляра включено отслеживание владельца потока; в противном случае — значение false.</returns>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>Предоставляет поддержку ожидания на основе прокруток.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>Сбрасывает подсчет прокруток.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>Выполняет одну прокрутку.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary>Выполняет один цикл и вызывает <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> после достижения минимального числа циклов.</summary>
      <param name="sleep1Threshold">Минимальное число циклов, после которого можно использовать <see langword="Thread.Sleep(1)" />. Если задать значение –1, возможность использования <see langword="Thread.Sleep(1)" /> отключается.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="sleep1Threshold" /> меньше -1.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>Выполняет прокрутки до удовлетворения заданного условия.</summary>
      <param name="condition">Делегат для циклического выполнения до возврата этим делегатом значения true.</param>
      <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="condition" /> имеет значение NULL.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>Выполняет прокрутки до удовлетворения заданного условия или истечения заданного времени ожидания.</summary>
      <param name="condition">Делегат для циклического выполнения до возврата этим делегатом значения true.</param>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="condition" /> имеет значение NULL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
      <returns>Значение <see langword="true" />, если условие удовлетворено до истечения времени ожидания; в противном случае значение false.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>Выполняет прокрутки до удовлетворения заданного условия или истечения заданного времени ожидания.</summary>
      <param name="condition">Делегат для циклического выполнения до возврата этим делегатом значения true.</param>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, указывающий время ожидания в миллисекундах, или TimeSpan, представляющий значение -1 миллисекунда, в случае неограниченного ожидания.</param>
      <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="condition" /> имеет значение NULL.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения -1 миллисекунда, которое представляет неограниченное время ожидания, либо время ожидания превышает <see cref="F:System.Int32.MaxValue" />.</exception>
      <returns>Значение <see langword="true" />, если условие удовлетворено до истечения времени ожидания; в противном случае значение false.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>Получает число раз, которое <see cref="M:System.Threading.SpinWait.SpinOnce" /> был вызван для этого экземпляра.</summary>
      <returns>Возвращает целое число, представляющее количество вызовов метода <see cref="M:System.Threading.SpinWait.SpinOnce" /> для данного экземпляра.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>Получает значение, показывающее, даст ли следующий вызов к <see cref="M:System.Threading.SpinWait.SpinOnce" /> доступ к процессору, запуская обязательное переключение контекста.</summary>
      <returns>Даст ли следующий вызов к <see cref="M:System.Threading.SpinWait.SpinOnce" /> доступ к процессору, запуская обязательное переключение контекста.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary>Обеспечивает базовую функциональность для распространения контекста синхронизации в различных моделях синхронизации.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary>Создает новый экземпляр класса <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary>При переопределении в производном классе создает копию контекста синхронизации.</summary>
      <returns>Новый объект <see cref="T:System.Threading.SynchronizationContext" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary>Определяет, нужно ли уведомление об ожидании.</summary>
      <returns>Значение <see langword="true" />, если уведомление об ожидании требуется, в противном случае — <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary>При переопределении в производном классе отвечает на уведомление о завершении операции.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary>При переопределении в производном классе отвечает на уведомление о запуске операции.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>При переопределении в производном классе отправляет асинхронное сообщение в контекст синхронизации.</summary>
      <param name="d">Вызываемый делегат <see cref="T:System.Threading.SendOrPostCallback" />.</param>
      <param name="state">Передаваемый делегату объект.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>При переопределении в производном классе отправляет синхронное сообщение в контекст синхронизации.</summary>
      <param name="d">Вызываемый делегат <see cref="T:System.Threading.SendOrPostCallback" />.</param>
      <param name="state">Передаваемый делегату объект.</param>
      <exception cref="T:System.NotSupportedException">Метод был вызван в приложении для Магазина Windows. Реализация класса <see cref="T:System.Threading.SynchronizationContext" /> для приложений для Магазина Windows не поддерживает метод <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>Задает текущий контекст синхронизации.</summary>
      <param name="syncContext">Задаваемый объект <see cref="T:System.Threading.SynchronizationContext" />.</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary>Задает уведомление о требовании уведомления об ожидании и подготавливает метод обратного вызова. Таким образом, метод может быть вызван более надежным способом, когда происходит ожидание.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Ожидает получения сигнала всеми элементами заданного массива или любым из его элементов.</summary>
      <param name="waitHandles">Массив типа <see cref="T:System.IntPtr" />, содержащий собственные дескрипторы операционной системы.</param>
      <param name="waitAll">
        <see langword="true" /> для ожидания всех обработчиков; <see langword="false" /> для ожидания любого обработчика.</param>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение null.</exception>
      <returns>Индекс объекта, удовлетворившего операцию ожидания, в массиве.</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>Вспомогательная функция, ожидающая сигнала от всех или некоторых элементов заданного массива.</summary>
      <param name="waitHandles">Массив типа <see cref="T:System.IntPtr" />, содержащий собственные дескрипторы операционной системы.</param>
      <param name="waitAll">Значение <see langword="true" /> для ожидания всех дескрипторов; <see langword="false" /> для ожидания любого дескриптора.</param>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <returns>Индекс объекта, удовлетворившего операцию ожидания, в массиве.</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary>Получает контекст синхронизации для текущего потока</summary>
      <returns>Объект <see cref="T:System.Threading.SynchronizationContext" />, представляющий текущий контекст синхронизации.</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary>Исключение, которое создается в то время, когда методу требуется вызвавший его объект для получения блокировки данного монитора, а метод вызван объектом, не являющимся владельцем блокировки.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SynchronizationLockException" /> стандартными свойствами.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SynchronizationLockException" /> с сериализованными данными.</summary>
      <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, хранящий сериализованные данные объекта, относящиеся к выдаваемому исключению.</param>
      <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SynchronizationLockException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SynchronizationLockException" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
      <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
      <param name="innerException">Исключение, которое является причиной текущего исключения. Если значение параметра <paramref name="innerException" /> не равно <see langword="null" />, текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>Предоставляет хранилище для данных, локальных для потока.</summary>
      <typeparam name="T">Указывает тип данных, хранящихся на поток.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> и указывает, доступны ли все значения из любого потока.</summary>
      <param name="trackAllValues">Значение <see langword="true" />, указывающее, следует ли отслеживать все значения, заданные в экземпляре, и представлять их с помощью свойства <see cref="P:System.Threading.ThreadLocal`1.Values" />; в противном случае значение <see langword="false" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> с заданной функцией <paramref name="valueFactory" />.</summary>
      <param name="valueFactory">Объект <see cref="T:System.Func`1" />, вызываемый для получения неактивно инициализированного значения при совершении попытки получить <see cref="P:System.Threading.ThreadLocal`1.Value" /> без предварительной инициализации.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="valueFactory" /> является ссылкой на null (Nothing в Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" />с заданными функцией <paramref name="valueFactory" /> и флагом, указывающим, доступны ли все значения из любого потока.</summary>
      <param name="valueFactory">Объект <see cref="T:System.Func`1" />, вызываемый для получения неактивно инициализированного значения при совершении попытки получить <see cref="P:System.Threading.ThreadLocal`1.Value" /> без предварительной инициализации.</param>
      <param name="trackAllValues">Значение <see langword="true" />, указывающее, следует ли отслеживать все значения, заданные в экземпляре, и представлять их с помощью свойства <see cref="P:System.Threading.ThreadLocal`1.Values" />; в противном случае значение <see langword="false" />.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="valueFactory" /> является пустой (<see langword="null" />) ссылкой (<see langword="Nothing" /> в Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>Освобождает ресурсы, используемые этим экземпляром <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing">Логическое значение, указывающее, вызывается ли данный метод из-за вызова метода <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>Освобождает ресурсы, используемые этим экземпляром <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>Создает и возвращает строковое представление данного экземпляра для текущего потока.</summary>
      <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> удален.</exception>
      <exception cref="T:System.NullReferenceException">
        <see cref="P:System.Threading.ThreadLocal`1.Value" /> для текущего потока представляет пустую ссылку (Nothing в Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">Инициализация попыталась создать рекурсивную ссылку <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">Не заданы конструктор без параметров и фабрика значений.</exception>
      <returns>Результат вызова метода <see cref="M:System.Object.ToString" /> для свойства <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>Получает значение, указывающее, инициализирован ли объект <see cref="P:System.Threading.ThreadLocal`1.Value" /> в текущем потоке.</summary>
      <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> удален.</exception>
      <returns>Значение true, если <see cref="P:System.Threading.ThreadLocal`1.Value" /> инициализируется в текущем потоке; в противном случае — значение false.</returns>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>Получает или задает значение данного экземпляра для текущего потока.</summary>
      <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> удален.</exception>
      <exception cref="T:System.InvalidOperationException">Инициализация попыталась создать рекурсивную ссылку <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">Не заданы конструктор без параметров и фабрика значений.</exception>
      <returns>Возвращает экземпляр объекта, за инициализацию которого ответственен данный ThreadLocal.</returns>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary>Получает список всех значений, хранящихся в настоящий момент всеми потоками, которые получили доступа к данному экземпляру.</summary>
      <exception cref="T:System.InvalidOperationException">Значения, хранящиеся всеми потоками, недоступны, поскольку этот экземпляр был инициализирован с аргументом <paramref name="trackAllValues" />, имеющим значение <see langword="false" />, в вызове конструктора класса.</exception>
      <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> удален.</exception>
      <returns>Список всех значений, хранящихся в настоящий момент всеми потоками, которые получили доступа к данному экземпляру.</returns>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary>Содержит методы для выполнения операций энергонезависимой памяти.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary>Считывает ссылку на объект из указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <param name="location">Считываемое поле.</param>
      <typeparam name="T">Тип считываемого поля. Должен быть ссылочным типом или типом значения.</typeparam>
      <returns>Прочитанная ссылка на объект <paramref name="T" />. Эта ссылка является последней, записанной любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Значение для записи. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary>Записывает заданную ссылку на объект в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается ссылка на объект.</param>
      <param name="value">Записываемая ссылка на объект. Ссылка записывается немедленно, так что она становится видимой для всех процессоров компьютера.</param>
      <typeparam name="T">Тип поля, в которое выполняется запись. Должен быть ссылочным типом или типом значения.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary>Исключение, которое возникает при попытке открыть несуществующий системный семафор или дескриптор ожидания события.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> со значениями по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> с сериализованными данными.</summary>
      <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, содержащий сериализованные данные объекта по возникающему исключению.</param>
      <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
      <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
      <param name="innerException">Исключение, которое является причиной текущего исключения. Если значение параметра <paramref name="innerException" /> не равно <see langword="null" />, текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
    </member>
  </members>
</doc>