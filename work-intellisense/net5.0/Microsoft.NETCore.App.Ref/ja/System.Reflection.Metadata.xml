<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>
        <see cref="T:System.Reflection.AssemblyContentType" /> の値に対応する、コンテンツの種類のマスクされたビット。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>アセンブリに対して Just-In-Time (JIT) コンパイラの最適化が無効です。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>アセンブリに対して Just-In-Time (JIT) コンパイラの追跡が有効です。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>アセンブリ参照では、完全な (ハッシュされていない) 公開キーが保持されます。 アセンブリ定義には適用されません。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>実行時に使用される参照先アセンブリの実装は、コンパイル時に表示されるバージョンと一致しないことが予想されます。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>アセンブリには、Windows ランタイムのコードが含まれています。</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>アセンブリ ファイルのハッシュ処理および厳密な名前の生成に使用されるハッシュ アルゴリズムを指定します。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>MD5 メッセージ ダイジェスト アルゴリズムを取得します。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>ハッシュ アルゴリズムがないことを示すマスク。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>SHA (Secure Hash Algorithm) における未公開の欠陥を修正した SHA のリビジョンを取得します。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>ハッシュ サイズが 256 ビットの SHA (Secure Hash Algorithm) のバージョンを取得します。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>ハッシュ サイズが 384 ビットの SHA (Secure Hash Algorithm) のバージョンを取得します。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>ハッシュ サイズが 512 ビットの SHA (Secure Hash Algorithm) のバージョンを取得します。</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>宣言型セキュリティを使用して実行できるセキュリティ アクションを指定します。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>スタック内の上位にある呼び出し元に現在のアクセス許可オブジェクトによって識別されているリソースへのアクセス許可がない場合でも、呼び出しコードがそのリソースにアクセスできます。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>呼び出しチェーン内の呼び出し元すべてに、指定したアクセス許可が付与されていることを確認します。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>追加のチェックを行わない場合、指定したアクセス許可に対する要求が拒否されます。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>クラスを継承する派生クラスまたはメソッドをオーバーライドする派生クラスには、指定したアクセス許可が付与されている必要があります。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>直接の呼び出し元に、指定したアクセス許可が付与されていることを確認します。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>宣言セキュリティ アクションがありません。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>追加のチェックを行わないと、指定したアクセス許可以外のすべてのアクセス許可に対する要求が拒否されます。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>コードを実行するのに必要な最小限のアクセス許可を要求します。 この操作は、アセンブリのスコープ内でのみ使用できます。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>省略可能な追加のアクセス許可を要求します (実行には必要ありません)。 この要求は、個別に要求されていない、他のすべてのアクセス許可を暗黙的に拒否します。 この操作は、アセンブリのスコープ内でのみ使用できます。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>誤用される可能性のあるアクセス許可が呼び出し元コードに付与されないように要求します。 この操作は、アセンブリのスコープ内でのみ使用できます。</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>リソースはアセンブリからエクスポートされません。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>リソースはアセンブリからエクスポートされます。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>可視性に関連する属性のみをマスクします。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>配列の型のシェイプを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>
        <see cref="T:System.Reflection.Metadata.ArrayShape" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="rank">配列の次元数。</param>
      <param name="sizes">各ディメンションのサイズ。</param>
      <param name="lowerBounds">各ディメンションの下限。</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>すべてのディメンションの下限を取得します。 長さはランクより短くなることがあります。その場合、後続のディメンションには下限が指定されません。</summary>
      <returns>下限の配列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>配列のディメンションの数を取得します。</summary>
      <returns>次元数。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>すべてのディメンションのサイズを取得します。</summary>
      <returns>サイズの配列。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>ファイルにメタデータが含まれているかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> ファイルにメタデータが含まれている場合は <see langword="false" /> 。それ以外の場合は。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>
        <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" /> を使用して計算されたファイル コンテンツのハッシュ値を取得します。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.BlobHandle" />ファイルの内容のハッシュ値を表すインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>その拡張子を含むファイル名を取得します。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />拡張子を持つファイル名を表すインスタンス。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> のコレクションを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>アセンブリ参照のコレクション。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>このライターの現在のコンテンツを別のものと比較します。</summary>
      <param name="other">これと比較する <see cref="T:System.Reflection.Metadata.BlobBuilder" /> インスタンス。</param>
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
      <returns>等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>ビルダーのコンテンツを表す、すべての BLOB からなるシーケンスを返します。</summary>
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
      <returns>BLOB のシーケンス。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>バイトの連続ブロックを予約します。</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> が負の値です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲がバッファー コンテンツの境界外になります。</exception>
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲がバッファー コンテンツの境界外になります。</exception>
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>バイト シーケンスをビルダーに書き込もうとします。 戻り値からは、正常に書き込まれたバイト数が示されます。</summary>
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> が負の値です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
      <returns>
        <paramref name="source" /> から正常に書き込まれたバイト数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>ビルダーに <see cref="T:System.Boolean" /> 値を書き込みます。</summary>
      <param name="value">書き込む値。</param>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>ビルダーに <see cref="T:System.Byte" /> 値を書き込みます。</summary>
      <param name="value">書き込む値。</param>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>バッファーからビルダーに指定バイト数を書き込みます。</summary>
      <param name="buffer" />
      <param name="byteCount">書き込むバイト数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> が負の値です。</exception>
      <exception cref="T:System.InvalidOperationException">このビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>バイト値の指定発生数をビルダーに書き込みます。</summary>
      <param name="value" />
      <param name="byteCount">書き込む <paramref name="value" /> の発生数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> が負の値です。</exception>
      <exception cref="T:System.InvalidOperationException">このビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>バイト配列のコンテンツをビルダーに書き込みます。</summary>
      <param name="buffer">書き込むバイト配列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>バイト配列内で指定されたインデックスから始まる指定バイト数をビルダーに書き込みます。</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">書き込むバイト数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲が <paramref name="buffer" /> の境界外になります。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>不変バイト配列のコンテンツをビルダーに書き込みます。</summary>
      <param name="buffer">書き込む配列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>不変配列の指定インデックスから始まる指定バイト数をビルダーに書き込みます。</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">書き込むバイト数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲が <paramref name="buffer" /> の境界外になります。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>ECMA-335-II chapter 23.2: Blob と signature の定義に従って、圧縮された符号なし整数エンコードを実装します。</summary>
      <param name="value">書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> は、符号なし圧縮整数として表現できません。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>ECMA-335-II chapter 23.2: Blob と signature の定義に従って、圧縮された符号付き整数エンコードを実装します。</summary>
      <param name="value">書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> は、符号付き圧縮整数として表現できません。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>現在位置で定数値を書き込みます (「ECMA-335 Partition II section 22.9」 (ECMA-335 パーティション II セクション 22.9) を参照してください)。</summary>
      <param name="value">書き込む定数値。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> は定数型ではありません。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> は既定値です (<see cref="T:System.Reflection.Metadata.BlobWriter" />)。</exception>
      <exception cref="T:System.InvalidOperationException">コンテンツは利用不可です。ビルダーが別のものとリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>ヒープ (ヒープ オフセット) またはテーブル (行番号) への参照を書き込みます。</summary>
      <param name="reference">ヒープ オフセットまたはテーブル行番号。</param>
      <param name="isSmall">16 ビット整数として参照をエンコードする <see langword="true" />。32 ビット整数としてそれをエンコードする <see langword="false" />。</param>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>SerString 形式で文字列を書き込みます (「ECMA-335-II 23.3 Custom attributes」 (ECMA-335-II 23.3 カスタム属性) を参照してください)。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>User String (#US) ヒープ形式で文字列を書き込みます (「ECMA-335-II 24.2.4 #US and #Blob heaps」 (ECMA-335-II 24.2.4 #US および #Blob ヒープ) を参照してください)。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>現在位置で UTF16 (リトルエンディアン) でエンコードされた文字配列を書き込みます。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>現在位置で UTF16 (リトルエンディアン) でエンコードされた文字列を書き込みます。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>現在位置で UTF8 でエンコードされた文字列を書き込みます。</summary>
      <param name="value">定数値。</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> の場合、ペアになっていないサロゲートを指定どおりエンコードします。<see langword="false" /> の場合、そのサロゲートを U+FFFD 文字で置換します。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>指定されたメモリ ブロックのリーダーを作成します。</summary>
      <param name="buffer">メモリ ブロックの開始へのポインター。</param>
      <param name="length">メモリ ブロックの長さ (バイト単位)。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> は <see langword="null" /> で、<paramref name="length" /> は 0 より大きい値です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> が負の値です。</exception>
      <exception cref="T:System.PlatformNotSupportedException">現在のプラットフォームはリトルエンディアンではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>指定された配置を満たすために必要なバイト数だけリーダーの位置を前方に動かします。</summary>
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>現在の位置から BLOB 内で指定のバイトを検索します。</summary>
      <param name="value">見つけるバイト値。</param>
      <returns>現在位置からの相対インデックス、または現在の位置から BLOB 内でバイトが見つからない場合は -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>圧縮整数としてエンコードされている BLOB ヒープ ハンドルを読み取ります。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>現在位置から始まるバイトを読み取ります。</summary>
      <param name="byteCount">読み取るバイト数。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> バイトが使用できません。</exception>
      <returns>バイト配列。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>現在位置から始まるバイトを読み取り、指定のオフセットから始まる指定のバッファーにそれを書き込みます。</summary>
      <param name="byteCount">読み取るバイト数。</param>
      <param name="buffer">バイト読み取りの書き込み先となるバッファー。</param>
      <param name="bufferOffset">バイト読み取りの書き込み先となるバッファーのオフセット。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> バイトが使用できません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>符号なし圧縮整数値を読み取ります。 「メタデータの指定」セクション 23.2: Blob と署名に関するセクションを参照してください。</summary>
      <exception cref="T:System.BadImageFormatException">現在位置のデータは有効な圧縮整数ではありません。</exception>
      <returns>読み取られた圧縮整数の値。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>符号付き圧縮整数値を読み取ります。 「メタデータの指定」セクション 23.2: Blob と署名に関するセクションを参照してください。</summary>
      <exception cref="T:System.BadImageFormatException">現在位置のデータは有効な圧縮整数ではありません。</exception>
      <returns>読み取られた圧縮整数の値。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>現在位置から定数値を読み取ります (「ECMA-335 Partition II section 22.9」 (ECMA-335 パーティション II セクション 22.9) を参照してください)。</summary>
      <param name="typeCode" />
      <exception cref="T:System.BadImageFormatException">BLOB から読み取り中、エラーが発生しました。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> は有効な <see cref="T:System.Reflection.Metadata.ConstantTypeCode" /> ではありません。</exception>
      <returns>ボックス化された定数値。 オブジェクトの割り当てを避けるには、Read* メソッドを直接使用します。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>
        <see cref="T:System.Decimal" /> 数を読み取ります。</summary>
      <exception cref="T:System.BadImageFormatException">現在位置のデータは有効な <see cref="T:System.Decimal" /> 数ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>シリアル化されたカスタム属性値でエンコードされた型コードを読み取ります。</summary>
      <returns>エンコードが無効な場合は <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>その長さとそのコンテンツが UTF8 で含まれる圧縮整数としてエンコードされた文字列を読み取ります。 null 文字列は 1 つの 0xFF バイトとしてエンコードされます。</summary>
      <exception cref="T:System.BadImageFormatException">エンコードは無効です。</exception>
      <returns>文字列値、または <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>署名でエンコードされている型コードを読み取ります。</summary>
      <returns>エンコードが有効な場合はシリアル化されたカスタム属性値でエンコードされた型コード、またはエンコードが有効な場合は <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>TypeDefOrRefOrSpecEncoded として署名でエンコードされている型ハンドルを読み取ります (「ECMA-335 II.23.2.8」を参照してください)。</summary>
      <returns>エンコードが有効なときのハンドル。 それ以外の場合、<see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> プロパティが <see langword="true" /> のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>現在位置から UTF16 (リトルエンディアン) でエンコードされた文字列を読み取ります。</summary>
      <param name="byteCount">読み取るバイト数。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> バイトが使用できません。</exception>
      <returns>文字列。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>現在位置から UTF8 でエンコードされた文字列を読み取ります。</summary>
      <param name="byteCount">読み取るバイト数。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> バイトが使用できません。</exception>
      <returns>文字列。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>基礎メモリ ブロックの開始にリーダーの位置を変更します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>符号なし圧縮整数値を読み取ります。 「メタデータの指定」セクション 23.2: Blob と署名に関するセクションを参照してください。</summary>
      <param name="value">読み取られた圧縮整数の値。</param>
      <returns>値が正常に読み取られた場合は <see langword="true" />。 現在位置のデータが有効な圧縮整数ではなかった場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>符号付き圧縮整数値を読み取ります。 「メタデータの指定」セクション 23.2: Blob と署名に関するセクションを参照してください。</summary>
      <param name="value">読み取られた圧縮整数の値。</param>
      <returns>値が正常に読み取られた場合は <see langword="true" />。 現在位置のデータが有効な圧縮整数ではなかった場合は <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>リーダーの現在位置でバイトへのポインターを取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>基礎メモリ ブロックの合計長を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>BLOB の開始から現在位置までのオフセットを取得するか、設定します。</summary>
      <exception cref="T:System.BadImageFormatException">基礎リーダーの境界外でオフセットが設定されています。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>現在位置から基礎メモリ ブロックの終わりまで、残りのブロック数を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>基礎メモリ ブロックの開始で、バイトへのポインターを取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>このライターの現在のコンテンツを別のものと比較します。</summary>
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲がバッファー コンテンツの境界外になります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲がバッファー コンテンツの境界外になります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲が <paramref name="buffer" /> の境界外になります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> と <paramref name="byteCount" /> で指定された範囲が <paramref name="buffer" /> の境界外になります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>ECMA-335-II chapter 23.2: Blob と signature の定義に従って、圧縮された符号なし整数エンコードを実装します。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> は、符号なし圧縮整数として表現できません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>ECMA-335-II chapter 23.2: Blob と signature の定義に従って、圧縮された符号付き整数エンコードを実装します。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> は、符号付き圧縮整数として表現できません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>現在位置で定数値を書き込みます (「ECMA-335 Partition II section 22.9」 (ECMA-335 パーティション II セクション 22.9) を参照してください)。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> は定数型ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>ヒープ (ヒープ オフセット) またはテーブル (行番号) への参照を書き込みます。</summary>
      <param name="reference">ヒープ オフセットまたはテーブル行番号。</param>
      <param name="isSmall">
        <see langword="true" /> の場合、16 ビット整数として参照をエンコードします。<see langword="false" /> の場合、32 ビット整数としてエンコードします。</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>SerString 形式で文字列を書き込みます (「ECMA-335-II 23.3 Custom attributes」 (ECMA-335-II 23.3 カスタム属性) を参照してください)。</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>User String (#US) ヒープ形式で文字列を書き込みます (「ECMA-335-II 24.2.4 #US and #Blob heaps」 (ECMA-335-II 24.2.4 #US および #Blob ヒープ) を参照してください)。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">ビルダーは書き込み不可です。別のものにリンクされています。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>現在位置で UTF16 (リトルエンディアン) でエンコードされた文字列を書き込みます。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>現在位置で UTF16 (リトルエンディアン) でエンコードされた文字列を書き込みます。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>現在位置で UTF8 でエンコードされた文字列を書き込みます。</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>親ハンドルを取得します (<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />)。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>定数値の型を識別する型コードを取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>定数値を取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>メタデータ定数の型を表す値を指定します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>ブール型です。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>1 バイトの符号なし整数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>文字型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>8 バイトの浮動小数点型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>2 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>4 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>8 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>無効な型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>null 参照。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>1 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>4 バイトの浮動小数点型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>2 バイトの符号なし整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>4 バイトの符号なし整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>8 バイトの符号なし整数型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>値 BLOB でエンコードされている引数をデコードします。</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>カスタム属性型のコンストラクター (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>属性が適用されるメタデータ エンティティのハンドルを取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>属性の値を取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>カスタム属性シグネチャからデコードされた名前付き引数を表します。</summary>
      <typeparam name="TType">カスタム属性シグネチャからデコードされた値の型を表すために使用される型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>指定した名前、種類、型、値を使用して、<see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="name">引数の名前。</param>
      <param name="kind">引数の種類。</param>
      <param name="type">引数の型。</param>
      <param name="value">引数の値です。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>引数の種類を取得します。</summary>
      <returns>引数の種類。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>引数の名前を取得します。</summary>
      <returns>引数の名前。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>引数の型を取得します。</summary>
      <returns>引数の型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>引数の値を取得します。</summary>
      <returns>引数値を格納しているオブジェクト。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>カスタム属性シグネチャの引数の種類を定義する定数を指定します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>フィールドの引数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>プロパティの引数。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>カスタム メタデータ属性の型指定された引数を表します。</summary>
      <typeparam name="TType">引数の型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>指定した引数の型と値を使用して、<see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="type">引数の型。</param>
      <param name="value">引数値。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>引数の型を取得します。</summary>
      <returns>引数の型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>引数の値を取得します。</summary>
      <returns>引数値。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>
        <paramref name="TType" /> によって指定される型のカスタム属性を表します。</summary>
      <typeparam name="TType">属性の型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>指定された固定引数と名前付き引数を使用し、<see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="fixedArguments">固定引数。</param>
      <param name="namedArguments">名前付き引数。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>カスタム属性の固定引数を取得します。</summary>
      <returns>変更できない引数の配列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>カスタム属性値の名前付き引数を取得します。</summary>
      <returns>変更できない引数の配列。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>メタデータ BLOB の先頭から <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" /> BLOB の先頭までのオフセット (バイト単位) を取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary>デバッグ メタデータ内のソース ドキュメント。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>ドキュメント コンテンツ ハッシュを取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>
        <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1 や SHA256 など) の計算に使用されるハッシュ アルゴリズムを取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>ソース コード言語 (C#、VB、F# など) を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>文書名 BLOB を取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>ドキュメント名として構造化されたポータブル PDB 内で #Blob ヒープの BLOB を表す <see cref="T:System.Reflection.Metadata.BlobHandle" />。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>配列の形状をエンコードします。</summary>
      <param name="rank">配列の次元数 (1 以上になります)。</param>
      <param name="sizes">次元のサイズ。 配列は <paramref name="rank" /> 未満である可能性がありますが、これ以上にはなりません。</param>
      <param name="lowerBounds">次元の下限、または既定 (<see cref="T:System.Collections.Immutable.ImmutableArray`1" />) ではすべての <paramref name="rank" /> の下限が 0 に設定されます。
配列は <paramref name="rank" /> 未満である可能性がありますが、これ以上にはなりません。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="rank" /> が、[1, 0xffff] の範囲外であるか、<see langword="sizes.Length" /> より小さいか、または <see langword="lowerBounds.Length" /> より小さい値です。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sizes" /> が <see langword="null" />です。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary>カスタム属性シグネチャ BLOB をエンコードします。</summary>
      <param name="fixedArguments">固定引数をエンコードする場合は、最初に呼び出されます。</param>
      <param name="namedArguments">名前付き引数をエンコードする場合は、2 番目に呼び出されます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fixedArguments" /> または <paramref name="namedArguments" /> が <see langword="null" /> です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary>カスタム属性シグネチャ BLOB をエンコードします。
パラメーター リストに表示された順に使用する必要があるエンコーダーのペアを返します。</summary>
      <param name="fixedArguments">固定引数をエンコードする場合は、最初に使用します。</param>
      <param name="namedArguments">名前付き引数をエンコードする場合は、2 番目に使用します。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary>フィールド シグネチャ BLOB をエンコードします。</summary>
      <returns>フィールドの種類のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary>ローカル変数シグネチャをエンコードします。</summary>
      <param name="variableCount">ローカル変数の数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="variableCount" /> が [0, 0x1fffffff] の範囲内ではありません。</exception>
      <returns>ローカル変数のシーケンスのエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary>メソッド シグネチャ BLOB をエンコードします。</summary>
      <param name="convention">呼び出し規則。</param>
      <param name="genericParameterCount">ジェネリック パラメーターの数。</param>
      <param name="isInstanceMethod">インスタンス メソッド シグネチャをエンコードする場合は <see langword="true" />、静的メソッド シグネチャをエンコードする場合は <see langword="false" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> が [0, 0xffff] の範囲内ではありません。</exception>
      <returns>戻り値とパラメーターを含む、シグネチャの残りの部分のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary>メソッド仕様シグネチャ BLOB をエンコードします。</summary>
      <param name="genericArgumentCount">汎用引数の数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> が [0, 0xffff] の範囲内ではありません。</exception>
      <returns>汎用引数のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary>アクセス許可セットの引数をエンコードします。</summary>
      <param name="argumentCount">セット内の引数の数。</param>
      <returns>セット内の引数のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary>アクセス許可セット BLOB をエンコードします。</summary>
      <param name="attributeCount">セット内の属性の数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="attributeCount" /> が [0, 0x1fffffff] の範囲内ではありません。</exception>
      <returns>アクセス許可セットのエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary>プロパティ シグネチャ BLOB をエンコードします。</summary>
      <param name="isInstanceProperty">インスタンス プロパティ シグネチャをエンコードする場合は <see langword="true" />、静的プロパティ シグネチャをエンコードする場合は <see langword="false" />。</param>
      <returns>メソッド シグネチャと同じ構造を持つ戻り値とパラメーターを含む、シグネチャの残りの部分のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary>型指定シグネチャをエンコードします。</summary>
      <returns>型指定によって表される構造化型の型エンコーダー (プリミティブ型はエンコードされません)。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの CustomAttributeType でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの HasConstant でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />、 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、または <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの HasCustomAttribute でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、または <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの HasCustomDebugInformation でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、<see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.DocumentHandle" />、<see cref="T:System.Reflection.Metadata.LocalScopeHandle" />、<see cref="T:System.Reflection.Metadata.LocalVariableHandle" />、<see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> または <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />。</param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの HasDeclSecurity でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、または <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの HasFieldMarshal でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> または <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの HasSemantics でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの実装でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> または <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの MemberForwarded でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />、<see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの MemberRefParent でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの MethodDefOrRef でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの ResolutionScope でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> または <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの TypeDefOrRef でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの TypeDefOrRefOrSpec でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したハンドルの TypeOrMethodDef でコード化されたインデックスを計算します。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">ハンドルの型が正しくありません。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>catch 領域を追加します。</summary>
      <param name="tryStart">try ブロックの最初の命令をマークしたラベル。</param>
      <param name="tryEnd">try ブロックの直後の命令をマークしたラベル。</param>
      <param name="handlerStart">ハンドラーの最初の命令をマークしたラベル。</param>
      <param name="handlerEnd">ハンドラーの直後の命令をマークしたラベル。</param>
      <param name="catchType">キャッチされる例外の種類: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">このビルダーが関連付けられている命令エンコーダーによって、ラベルが定義されませんでした。

- または -

<paramref name="catchType" /> が有効な型のハンドルではありません。</exception>
      <exception cref="T:System.ArgumentNullException">ラベルには既定値があります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>fault 領域を追加します。</summary>
      <param name="tryStart">try ブロックの最初の命令をマークしたラベル。</param>
      <param name="tryEnd">try ブロックの直後の命令をマークしたラベル。</param>
      <param name="handlerStart">ハンドラーの最初の命令をマークしたラベル。</param>
      <param name="handlerEnd">ハンドラーの直後の命令をマークしたラベル。</param>
      <exception cref="T:System.ArgumentException">このビルダーが関連付けられている命令エンコーダーによって、ラベルが定義されませんでした。</exception>
      <exception cref="T:System.ArgumentNullException">ラベルには既定値があります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>catch 領域を追加します。</summary>
      <param name="tryStart">try ブロックの最初の命令をマークしたラベル。</param>
      <param name="tryEnd">try ブロックの直後の命令をマークしたラベル。</param>
      <param name="handlerStart">ハンドラーの最初の命令をマークしたラベル。</param>
      <param name="handlerEnd">ハンドラーの直後の命令をマークしたラベル。</param>
      <param name="filterStart">フィルター ブロックの最初の命令をマークしたラベル。</param>
      <exception cref="T:System.ArgumentException">このビルダーが関連付けられている命令エンコーダーによって、ラベルが定義されませんでした。</exception>
      <exception cref="T:System.ArgumentNullException">ラベルには既定値があります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>finally 領域を追加します。</summary>
      <param name="tryStart">try ブロックの最初の命令をマークしたラベル。</param>
      <param name="tryEnd">try ブロックの直後の命令をマークしたラベル。</param>
      <param name="handlerStart">ハンドラーの最初の命令をマークしたラベル。</param>
      <param name="handlerEnd">ハンドラーの直後の命令をマークしたラベル。</param>
      <exception cref="T:System.ArgumentException">このビルダーが関連付けられている命令エンコーダーによって、ラベルが定義されませんでした。</exception>
      <exception cref="T:System.ArgumentNullException">ラベルには既定値があります。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>カスタム修飾子をエンコードします。</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <param name="isOptional">省略可能な修飾子。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> が <see langword="null" /> であるか、または予期しない種類です。</exception>
      <returns>後続の修飾子のエンコーダー。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>exception 句を追加します。</summary>
      <param name="kind">句の種類。</param>
      <param name="tryOffset">try ブロックの開始オフセット。</param>
      <param name="tryLength">try ブロックの長さ。</param>
      <param name="handlerOffset">ハンドラーの開始オフセット。</param>
      <param name="handlerLength">ハンドラーの長さ。</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。<paramref name="kind" /> が <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" /> でない場合は nil</param>
      <param name="filterOffset">フィルター ブロックのオフセット。<paramref name="kind" /> が <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" /> でない場合は 0。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> が無効です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="kind" /> の値が無効です。
          
- または -

<paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" />、または <paramref name="handlerLength" /> が範囲外です。</exception>
      <exception cref="T:System.InvalidOperationException">メソッド本体が、例外領域を持つように宣言されていません。</exception>
      <returns>次の句のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary>fault 句を追加します。</summary>
      <param name="tryOffset">try ブロックの開始オフセット。</param>
      <param name="tryLength">try ブロックの長さ。</param>
      <param name="handlerOffset">ハンドラーの開始オフセット。</param>
      <param name="handlerLength">ハンドラーの長さ。</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> が無効です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" />、または <paramref name="handlerLength" /> が範囲外です。</exception>
      <exception cref="T:System.InvalidOperationException">メソッド本体が、例外領域を持つように宣言されていません。</exception>
      <returns>次の句のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>fault 句を追加します。</summary>
      <param name="tryOffset">try ブロックの開始オフセット。</param>
      <param name="tryLength">try ブロックの長さ。</param>
      <param name="handlerOffset">ハンドラーの開始オフセット。</param>
      <param name="handlerLength">ハンドラーの長さ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" />、または <paramref name="handlerLength" /> が範囲外です。</exception>
      <exception cref="T:System.InvalidOperationException">メソッド本体が、例外領域を持つように宣言されていません。</exception>
      <returns>次の句のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>fault 句を追加します。</summary>
      <param name="tryOffset">try ブロックの開始オフセット。</param>
      <param name="tryLength">try ブロックの長さ。</param>
      <param name="handlerOffset">ハンドラーの開始オフセット。</param>
      <param name="handlerLength">ハンドラーの長さ。</param>
      <param name="filterOffset">フィルター ブロックのオフセット。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" />、または <paramref name="handlerLength" /> が範囲外です。</exception>
      <exception cref="T:System.InvalidOperationException">メソッド本体が、例外領域を持つように宣言されていません。</exception>
      <returns>次の句のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>finally 句を追加します。</summary>
      <param name="tryOffset">try ブロックの開始オフセット。</param>
      <param name="tryLength">try ブロックの長さ。</param>
      <param name="handlerOffset">ハンドラーの開始オフセット。</param>
      <param name="handlerLength">ハンドラーの長さ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" />、または <paramref name="handlerLength" /> が範囲外です。</exception>
      <exception cref="T:System.InvalidOperationException">メソッド本体が、例外領域を持つように宣言されていません。</exception>
      <returns>次の句のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary>領域が小さい形式に収まる場合は <see langword="true" /> を返します。</summary>
      <param name="startOffset">領域の開始オフセット。</param>
      <param name="length">領域の長さ。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary>例外領域の数が小さい形式に収まる場合は <see langword="true" /> を返します。</summary>
      <param name="exceptionRegionCount">例外領域の数。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary>基礎となるビルダー。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary>エンコーダーが小さい形式を使用する場合は <see langword="true" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary>ExportedType テーブルの TypeDefinitionId 列にアクセスするための拡張メソッドを提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary>モジュールの TypeDef テーブル内でターゲットの型の可能性のある行番号にあるヒントを取得します。
名前空間と名前が一致しない場合、解決はターゲットの TypeDef テーブルの完全検索にフォールバックします。 <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> が <see langword="true" /> の場合は無視され、0 になります。</summary>
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary>命令をエンコードします。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary>コードおよび制御フロー ビルダーでサポートされるエンコーダーを作成します。</summary>
      <param name="codeBuilder">エンコードされた命令を書き込むビルダー。</param>
      <param name="controlFlowBuilder">ビルダー追跡ラベル、分岐、および例外ハンドラー。
<see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />、<see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />、<see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /> のような <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" /> の制御フロー ファクトリ メソッドの一部を使用できるようにする場合に指定する必要があります。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>分岐命令をエンコードします。</summary>
      <param name="code">エンコードする分岐命令。</param>
      <param name="label">命令ストリーム内のターゲットの場所のラベル。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="code" /> は分岐命令ではありません。

- または - 
<paramref name="label" /> は、このエンコーダーによって定義されていませんでした。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> には既定値があります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary>
        <c>call</c> 命令とそのオペランドをエンコードします。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>
        <c>call</c> 命令とそのオペランドをエンコードします。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>
        <c>call</c> 命令とそのオペランドをエンコードします。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>
        <c>call</c> 命令とそのオペランドをエンコードします。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>
        <c>calli</c> 命令とそのオペランドをエンコードします。</summary>
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary>後で命令ストリーム内の位置をマークして参照するために使用できるラベルを定義します。</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> が <see langword="null" />です。</exception>
      <returns>ラベル ハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary>引数の読み込み命令をエンコードします。</summary>
      <param name="argumentIndex">引数のインデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary>引数のアドレス読み込み命令をエンコードします。</summary>
      <param name="argumentIndex">引数のインデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary>
        <see cref="T:System.Int32" /> の定数読み込み命令をエンコードします。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary>
        <see cref="T:System.Int64" /> の定数読み込み命令をエンコードします。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary>
        <see cref="T:System.Single" /> の定数読み込み命令をエンコードします。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary>
        <see cref="T:System.Double" /> の定数読み込み命令をエンコードします。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary>ローカル変数の読み込み命令をエンコードします。</summary>
      <param name="slotIndex">ローカル変数のスロットのインデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary>ローカル変数のアドレス読み込み命令をエンコードします。</summary>
      <param name="slotIndex">ローカル変数のスロットのインデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary>
        <c>ldstr</c> 命令とそのオペランドをエンコードします。</summary>
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>指定されたラベルを現在の IL オフセットに関連付けます。</summary>
      <param name="label">マークするラベル。</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="label" /> は、このエンコーダーによって定義されていませんでした。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> には既定値があります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary>指定されたオペコードをエンコードします。</summary>
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary>引数のストア命令をエンコードします。</summary>
      <param name="argumentIndex">引数のインデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary>ローカル変数のストア命令をエンコードします。</summary>
      <param name="slotIndex">ローカル変数のスロットのインデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary>トークンをエンコードします。</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary>トークンをエンコードします。</summary>
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary>エンコードされた命令の書き込み先となる、基礎となるビルダー。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary>ビルダー追跡ラベル、分岐、および例外ハンドラー。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary>次にエンコードされた命令のオフセット。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>1 から始まる ID。<see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" /> のコンテキスト内でラベルを識別します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>リテラルをエンコードするためのメソッドを提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">指定した BLOB ビルダーを使用して、<see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> クラスの新しいインスタンスを作成します。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>リテラル値をエンコードするために使用されるエンコーダーを返します。</summary>
      <returns>リテラル値のエンコーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>指定したデリゲートを使用して、リテラルの型と値をエンコードします。</summary>
      <param name="type">リテラルの型のエンコードに使用されるデリゲート。 このメソッドによって最初に呼び出されます。</param>
      <param name="scalar">リテラルの値のエンコードに使用されるデリゲート。 このメソッドによって 2 番目に呼び出されます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> または <paramref name="scalar" /> が <see langword="null" /> です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>パラメーター一覧に出現する順序でリテラルの型と値のエンコードに使用する必要があるエンコーダーのペアを返します。</summary>
      <param name="type">このメソッドから制御が戻るときに、リテラルの型のエンコードに使用されるカスタム属性要素型エンコーダー。</param>
      <param name="scalar">このメソッドから制御が戻るときに、リテラルの値のエンコードに使用される、エンコードされたスカラー。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>指定したデリゲートを使用して、ベクター リテラルの型と項目をエンコードします。</summary>
      <param name="arrayType">ベクターの型のエンコードに使用されるデリゲート。 このメソッドによって最初に呼び出されます。</param>
      <param name="vector">ベクターの項目のエンコードに使用されるデリゲート。 このメソッドによって 2 番目に呼び出されます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayType" /> または <paramref name="vector" /> が <see langword="null" /> です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>パラメーター一覧に出現する順序でベクター リテラルの型と項目のエンコードに使用する必要があるエンコーダーのペアを返します。</summary>
      <param name="arrayType">このメソッドから制御が戻るときに、ベクターの型のエンコードに使用されるカスタム属性配列型エンコーダー。</param>
      <param name="vector">このメソッドから制御が戻るときに、ベクターの項目のエンコードに使用されるベクター エンコーダー。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>ベクターの項目のエンコードに使用されるベクター エンコーダーを取得します。</summary>
      <returns>ベクターの項目のエンコードに使用されるベクター エンコーダー。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>集計メタデータ内のエンティティのハンドルを指定して、定義されたメタデータ世代内のエンティティのハンドルを計算します。</summary>
      <param name="handle">集計メタデータ内のエンティティのハンドル。</param>
      <param name="generation">エンティティが定義された世代。</param>
      <returns>メタデータ <paramref name="generation" /> 内のエンティティのハンドル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>MetadataBuilder クラスでは、パフォーマンスに非常に優れた方法で、アセンブリのメタデータの読み取りと書き込みが行われます。 コンパイラやその他のアセンブリ生成ツールによる使用を目的として設計されています。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>メタデータ テーブルおよびヒープ用のビルダーを作成します。</summary>
      <param name="userStringHeapStartOffset">ユーザー文字列ヒープの開始オフセット。 メタデータが EnC 差分メタデータの場合を除き、以前のすべての EnC 生成のユーザー文字列ヒープの累積サイズは 0 にする必要があります。</param>
      <param name="stringHeapStartOffset">文字列ヒープの開始オフセット。 メタデータが EnC 差分メタデータの場合を除き、以前のすべての EnC 生成の文字列ヒープの累積サイズは 0 にする必要があります。</param>
      <param name="blobHeapStartOffset">BLOB ヒープの開始オフセット。 メタデータが EnC 差分メタデータの場合を除き、以前のすべての EnC 生成の BLOB ヒープの累積サイズは 0 にする必要があります。</param>
      <param name="guidHeapStartOffset">GUID ヒープの開始オフセット。 メタデータが EnC 差分メタデータの場合を除き、以前のすべての EnC 生成の GUID ヒープの累積サイズは 0 にする必要があります。</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">オフセットが大きすぎます。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">オフセットが負の値です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="guidHeapStartOffset" /> が、GUID のサイズの倍数ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>パラメーター、フィールド、またはプロパティの既定値を追加します。</summary>
      <param name="parent">親エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、または <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="value">定数値。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加された定数のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>カスタム属性を追加します。</summary>
      <param name="parent">カスタム属性のアタッチ先エンティティ: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、または <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />。</param>
      <param name="constructor">カスタム属性コンストラクター: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="value">カスタム属性値の BLOB。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたカスタム属性のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>カスタム デバッグ情報を追加します。</summary>
      <param name="parent">デバッグ情報のアタッチ先エンティティ: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、<see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.DocumentHandle" />、<see cref="T:System.Reflection.Metadata.LocalScopeHandle" />、<see cref="T:System.Reflection.Metadata.LocalVariableHandle" />、<see cref="T:System.Reflection.Metadata.LocalConstantHandle" />、または <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />。</param>
      <param name="kind">情報の種類。 <paramref name="value" /> BLOB の構造を決定します。</param>
      <param name="value">カスタム デバッグ情報 BLOB。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたカスタム デバッグ情報のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>型、メソッド、またはアセンブリに宣言セキュリティ属性を追加します。</summary>
      <param name="parent">親エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、または <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />。</param>
      <param name="action">宣言セキュリティ アクション。</param>
      <param name="permissionSet">アクセス許可セット BLOB。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加された宣言セキュリティ属性のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>ドキュメント デバッグ情報を追加します。</summary>
      <param name="name">ドキュメント名 BLOB。</param>
      <param name="hashAlgorithm">
        <paramref name="hash" /> の値の計算に使用されるハッシュ アルゴリズムの GUID。</param>
      <param name="hash">ドキュメント コンテンツのハッシュ。</param>
      <param name="language">言語の GUID。</param>
      <returns>追加されたドキュメントのハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>イベント定義を追加します。</summary>
      <param name="attributes">イベント属性。</param>
      <param name="name">イベントの名前です。</param>
      <param name="type">イベントの種類: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたイベント定義のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>エクスポートされた型を追加します。</summary>
      <param name="attributes">型属性。</param>
      <param name="namespace">型の名前空間。</param>
      <param name="name">型名。</param>
      <param name="implementation">実装エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、または <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />。</param>
      <param name="typeDefinitionId">型定義 ID。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたエクスポートされた型のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>フィールド定義を追加します。</summary>
      <param name="attributes">フィールド属性。</param>
      <param name="name">フィールド名。</param>
      <param name="signature">フィールド シグネチャ。 <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> を使用して BLOB を構築します。</param>
      <returns>追加されたフィールド定義のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>フィールド定義のフィールド レイアウトを定義します。</summary>
      <param name="field">フィールド定義のハンドル。</param>
      <param name="offset">宣言する型インスタンス内のフィールドのバイト オフセット。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>フィールドから PE イメージに格納されている初期値へのマッピングを追加します。</summary>
      <param name="field">フィールド定義のハンドル。</param>
      <param name="offset">マップされたフィールドの初期値を格納する、PE イメージ内のブロック内のオフセット (通常は .text セクション内)。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>ジェネリック パラメーターの定義を追加します。</summary>
      <param name="parent">親エンティティ ハンドル。<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> となります。</param>
      <param name="attributes">ジェネリック パラメーターの属性。</param>
      <param name="name">パラメーターの名前。</param>
      <param name="index">0 から始まるパラメーター インデックス。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> が、必要なハンドルの型ではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> が <see cref="F:System.UInt16.MaxValue" /> より大きくなっています。</exception>
      <returns>追加されたジェネリック パラメーターのハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>ジェネリック パラメーターに型制約を追加します。</summary>
      <param name="genericParameter">制約対象のジェネリック パラメーター。</param>
      <param name="constraint">型制約。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericParameter" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたジェネリック パラメーター制約のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>ローカル スコープのデバッグ情報を追加します。</summary>
      <param name="parentScope">親スコープ ハンドル。</param>
      <param name="imports">インポート スコープ ハンドル。</param>
      <returns>追加されたインポート スコープのハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>インターフェイスの実装を型に追加します。</summary>
      <param name="type">インターフェイスを実装する型。</param>
      <param name="implementedInterface">実装されるインターフェイス。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementedInterface" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたインターフェイス実装のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>ローカル定数のデバッグ情報を追加します。</summary>
      <param name="name">変数の名前。</param>
      <param name="signature">LocalConstantSig BLOB。</param>
      <returns>追加されたローカル定数のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>ローカル スコープのデバッグ情報を追加します。</summary>
      <param name="method">含まれているメソッド。</param>
      <param name="importScope">関連付けられたインポート スコープのハンドル。</param>
      <param name="variableList">スコープで変数が宣言されている場合は、これは最初のハンドルに設定します。 それ以外の場合は、次のスコープ定義で宣言されている最初の変数のハンドルに設定します。 スコープに変数が定義されていない場合は、<see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" /> とします。</param>
      <param name="constantList">スコープで定数が宣言されている場合は、これを最初のハンドルに設定します。 それ以外の場合は、次のスコープ定義で宣言されている最初の定数のハンドルに設定します。 スコープに定数が定義されていない場合は、<see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" /> とします。</param>
      <param name="startOffset">スコープによってカバーされる最初の命令のオフセット。</param>
      <param name="length">スコープの長さ (バイト単位)。</param>
      <returns>追加されたローカル スコープのハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>ローカル変数のデバッグ情報を追加します。</summary>
      <param name="attributes">ローカル変数の属性。</param>
      <param name="index">ローカル シグネチャ内のローカル変数の 0 から始まるインデックス。</param>
      <param name="name">変数の名前。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> が <see cref="F:System.UInt16.MaxValue" /> より大きくなっています。</exception>
      <returns>追加されたローカル変数のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>マニフェスト リソースを追加します。</summary>
      <param name="attributes">マニフェスト リソース属性。</param>
      <param name="name">マニフェスト リソースの名前。</param>
      <param name="implementation">実装エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、または <see langword="null" />。</param>
      <param name="offset">このリソース レコードが始まる参照先ファイル内のバイト オフセットを指定します。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたマニフェスト リソースのハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>フィールドまたはパラメーターにマーシャリング情報を追加します。</summary>
      <param name="parent">親エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> または <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />。</param>
      <param name="descriptor">既述子 BLOB。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> が、必要なハンドルの型ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>MemberRef テーブル行を追加します。</summary>
      <param name="parent">含まれているエンティティ。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <param name="name">メンバー名。</param>
      <param name="signature">メンバー シグネチャ。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたメンバー参照のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>メソッドのデバッグ情報を追加します。</summary>
      <param name="document">メソッドのすべてのシーケンス ポイントを含む単一のドキュメントのハンドル。メソッドがシーケンス ポイントを持たない場合、または複数のドキュメントにまたがる場合は、<see langword="null" />。</param>
      <param name="sequencePoints">シーケンス ポイント BLOB。メソッドにシーケンス ポイントがない場合は、<see langword="null" />。</param>
      <returns>追加されたメソッドのデバッグ情報のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>メソッド定義を追加します。</summary>
      <param name="attributes">メソッド属性。</param>
      <param name="implAttributes">メソッド実装属性。</param>
      <param name="name">メソッド名。</param>
      <param name="signature">メソッド シグネチャ。</param>
      <param name="bodyOffset">メソッド本体 (IL ストリーム) を格納する、PE イメージ内のブロック内のオフセット。メソッドに本体がない場合は、-1。</param>
      <param name="parameterList">このメソッドを使用して Params テーブル内でパラメーターを宣言する場合は、これを最初のハンドルに設定します。 それ以外の場合は、次のメソッド定義で宣言されている最初のパラメーターのハンドルに設定します。 モジュールでパラメーターが宣言されていない場合は、<see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" /> とします。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bodyOffset" /> が -1 未満です。</exception>
      <returns>追加されたメソッド定義のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>型内のメソッド宣言の実装を定義します。</summary>
      <param name="type">型定義。</param>
      <param name="methodBody">メソッド本体エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="methodDeclaration">メソッド宣言エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodBody" /> または <paramref name="methodDeclaration" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたメソッド実装のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>メソッド定義にインポート情報を追加します。</summary>
      <param name="method">メソッド定義ハンドル。</param>
      <param name="attributes">メソッド インポート属性。</param>
      <param name="name">アンマネージド メソッドの名前。</param>
      <param name="module">アンマネージドメソッドが含まれているモジュール。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>メソッド (getter、setter、adder など) をプロパティまたはイベントに関連付けます。</summary>
      <param name="association">関連付けエンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />または <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="semantics">メソッドのセマンティクス属性。</param>
      <param name="methodDefinition">メソッド定義。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="association" /> が、必要なハンドルの型ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>メソッド仕様 (インスタンス化) を追加します。</summary>
      <param name="method">ジェネリック メソッド エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="instantiation">メソッドの汎用引数をエンコードするインスタンス化 BLOB。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加されたメソッド仕様のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>指定された型定義に対する入れ子のリレーションシップを定義します。</summary>
      <param name="type">入れ子にされた型定義ハンドル。</param>
      <param name="enclosingType">外側の型定義ハンドル。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>パラメーター定義を追加します。</summary>
      <param name="attributes">パラメーター属性。</param>
      <param name="name">任意。 パラメーターの名前。</param>
      <param name="sequenceNumber">パラメーターのシーケンス番号。 値 0 は、所有者メソッドの戻り値の型を表します。その後、そのパラメーターには 1 から順に番号が付けられます。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sequenceNumber" /> が <see cref="F:System.UInt16.MaxValue" /> より大きくなっています。</exception>
      <returns>追加されたパラメーターのハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>プロパティ定義を追加します。</summary>
      <param name="attributes">プロパティ属性。</param>
      <param name="name">プロパティ名。</param>
      <param name="signature">プロパティのシグネチャ。</param>
      <returns>追加されたプロパティ定義のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>ステート マシン メソッドのデバッグ情報を追加します。</summary>
      <param name="moveNextMethod">ステート マシンの <see langword="MoveNext" /> メソッドのハンドル (コンパイラによって生成されるメソッド)。</param>
      <param name="kickoffMethod">キックオフ メソッドのハンドル (ユーザー定義の反復子/非同期メソッド)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>型定義を追加します。</summary>
      <param name="attributes">型属性。</param>
      <param name="namespace">型の名前空間。</param>
      <param name="name">型名。</param>
      <param name="baseType">基本データ型エンティティ ハンドル。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、または <see langword="null" />。</param>
      <param name="fieldList">型でフィールドが宣言されている場合は、これを最初のハンドルに設定します。 それ以外の場合は、次の型定義で宣言されている最初のフィールドのハンドルに設定します。 モジュール内のフィールドを定義する型がない場合は、<see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" /> とします。</param>
      <param name="methodList">型でメソッドが宣言されている場合は、最初のハンドルとします。 それ以外の場合は、次の型定義で宣言されている最初のメソッドのハンドルとします。 モジュール内のメソッドを定義する型がない場合は、<see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" /> とします。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="baseType" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加された型定義のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>型定義の型レイアウトを定義します。</summary>
      <param name="type">型定義。</param>
      <param name="packingSize">フィールドを型インスタンス内の、<paramref name="packingSize" /> の倍数であるバイト アドレスか、またはそのフィールド型の自然整列のいずれか小さい方に配置する必要があることを指定します。 その値は、0、1、2、4、8、16、32、64、128 のいずれかである必要があります。 値 0 は、使用されているパッキング サイズが現在のプラットフォームの既定値と一致する必要があることを示します。</param>
      <param name="size">型インスタンスの最小サイズを示し、埋め込みを可能にすることを目的としています。 割り当てられるメモリの量は、レイアウトと <paramref name="size" /> から計算されたサイズの最大値です。 このディレクティブが値型に適用される場合、サイズは 1 MB 未満になることに注意してください。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>型参照を追加します。</summary>
      <param name="resolutionScope">ターゲットの型を宣言するエンティティ。次のいずれかとなります: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または <see langword="null" />。</param>
      <param name="namespace">型参照の名前空間。</param>
      <param name="name">型参照の名前。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="resolutionScope" /> が、必要なハンドルの型ではありません。</exception>
      <returns>追加した型参照のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>指定された BLOB を BLOB ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">BLOB が格納されている配列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存の BLOB のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>バイト配列の指定された BLOB を BLOB ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">BLOB が格納されている配列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存の BLOB のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>不変バイト配列の指定された BLOB を BLOB ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">BLOB が含まれている BLOB ビルダー インスタンス。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存の BLOB のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>UTF-16 エンコードを使用して文字列を BLOB にエンコードし、BLOB ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">追加する文字列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存の BLOB のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>UTF-8 エンコードを使用して文字列を BLOB にエンコードし、BLOB ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">加算する値。</param>
      <param name="allowUnpairedSurrogates">
        <see langword="true" /> の場合、ペアになっていないサロゲートを指定どおりエンコードします。<see langword="false" /> の場合、そのサロゲートを U+FFFD 文字で置換します。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存の BLOB のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>定数値を BLOB にエンコードし、BLOB ヒープに追加します (まだ存在しない場合)。 UTF-16 を使用して文字列定数をエンコードします。</summary>
      <param name="value">追加する定数値。</param>
      <returns>追加された、または既存の BLOB のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>デバッグ ドキュメント名をエンコードし、BLOB ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">追加するドキュメントの名前。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存のドキュメント名 BLOB のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>指定された GUID を GUID ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="guid">追加する GUID。</param>
      <returns>追加された、または既存の GUID のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>指定された文字列を文字列ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">追加する文字列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存の文字列のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>指定された文字列をユーザー文字列ヒープに追加します (まだ存在しない場合)。</summary>
      <param name="value">追加する文字列。</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">ヒープの残りの領域が小さすぎて文字列が収まりません。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> が <see langword="null" />です。</exception>
      <returns>追加された、または既存の文字列のハンドル。 この値は <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> で使用できます。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>指定されたテーブル内の現在の項目数を返します。</summary>
      <param name="table">テーブル インデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> が有効なテーブル インデックスではありません。</exception>
      <returns>テーブル内の項目の数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>各テーブル内の現在の項目数を返します。</summary>
      <returns>
        <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> サイズの配列。各項目には、対応するテーブルの現在の行数が格納されています。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>GUID の GUID ヒープの領域を予約します。</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">ヒープの残りの領域が小さすぎて文字列が収まりません。</exception>
      <returns>予約済み GUID と、ヒープに格納されている GUID BLOB を表す <see cref="T:System.Reflection.Metadata.Blob" /> のハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>指定された長さの文字列に対して、ユーザー文字列ヒープの領域を予約します。</summary>
      <param name="length">予約する文字数。</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">ヒープの残りの領域が小さすぎて文字列が収まりません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> が負の値です。</exception>
      <returns>予約されたユーザー文字列と、ユーザー文字列 BLOB 全体を表す <see cref="T:System.Reflection.Metadata.Blob" /> (長さと末端文字を含む) のハンドル。 ハンドルは <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" /> で使用できます。
BLOB の内容を入力するには、<see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> を使用します。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>指定されたヒープの容量を設定します。</summary>
      <param name="heap">ヒープ インデックス。</param>
      <param name="byteCount">バイト数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heap" /> が有効なヒープ インデックスではありません。

- または -

<paramref name="byteCount" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>指定されたテーブルの容量を設定します。</summary>
      <param name="table">テーブル インデックス。</param>
      <param name="rowCount">表の行数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> が有効なテーブル インデックスではありません。

- または -

<paramref name="rowCount" /> が負の値です。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>ECMA-335 メタデータ テーブルとヒープの特定の未加工要素を操作する拡張メソッドを提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>EnC ログのエントリを列挙します。</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>EnC マップのエントリを列挙します。</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>メタデータの先頭から指定したヒープまでのオフセットを返します。</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> が有効なヒープ インデックスではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>指定したヒープのサイズを返します。</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> が有効なヒープ インデックスではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>
        <see cref="T:System.Reflection.Metadata.Blob" /> ヒープ内の指定した <see cref="T:System.Reflection.Metadata.Blob" /> ハンドルの次を返します。最後の場合は nil ハンドルを返します。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>文字列ヒープ内の指定した文字列ハンドルの次を返します。最後の場合は nil ハンドルを返します。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>UserString ヒープ内の指定した UserString ハンドルの次を返します。最後の場合は nil ハンドルを返します。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>メタデータの先頭から指定したテーブルまでのオフセットを返します。</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> が有効なテーブル インデックスではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>指定したテーブル内の行数を返します。</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> が有効なテーブル インデックスではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>指定したテーブル内の行のサイズを返します。</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> が有効なテーブル インデックスではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>1 つ以上のイベントを定義する型を列挙します。</summary>
      <param name="reader" />
      <returns>結果のシーケンスは、EventMap テーブル内のエントリに正確に対応します。つまり、n 番目に返される <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> は、EventMap の n 番目の行に格納されます。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>1 つ以上のプロパティを定義する型を列挙します。</summary>
      <param name="reader" />
      <returns>結果のシーケンスは、プロパティ マップ テーブルのエントリに正確に対応します。つまり、n 番目に返される <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> は、プロパティ マップの n 番目の行に格納されます。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>署名 BLOB に、型ハンドルと未加工の型の種類が見つかった場合、それによってターゲットの型が値型か参照型かが決まります。</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>ポータブル実行可能イメージに埋め込まれるメタデータ ルートのビルダー。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>メタデータ ルートのビルダーを作成します。</summary>
      <param name="tablesAndHeaps">テーブルに格納されているメタデータ エンティティとヒープに格納されている値が設定されたビルダー。 メタデータ ルートをシリアル化すると、エンティティと値が列挙されます。</param>
      <param name="metadataVersion">メタデータ ヘッダーに書き込まれるバージョン文字列。 既定値は "v4.0.30319" です。</param>
      <param name="suppressValidation">シリアル化中にメタデータ テーブルの基本的な検証を抑制する場合は <see langword="true" />。それ以外の場合は <paramref name="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataVersion" /> が長すぎます (UTF8 でエンコードされたバイト数は 255 未満である必要があります)。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>メタデータのルート コンテンツを指定した <see cref="T:System.Reflection.Metadata.BlobBuilder" /> にシリアル化します。</summary>
      <param name="builder">書き込み先のビルダー。</param>
      <param name="methodBodyStreamRva">メソッド本体ストリームの開始の相対仮想アドレス。 MethodDef テーブルの RVA フィールドの最終的な値を計算するために使用されます。</param>
      <param name="mappedFieldDataStreamRva">フィールド初期化データ ストリームの開始の相対仮想アドレス。 FieldRVA テーブルの RVA フィールドの最終的な値を計算するために使用されます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="methodBodyStreamRva" /> または <paramref name="mappedFieldDataStreamRva" /> が負の値です。</exception>
      <exception cref="T:System.InvalidOperationException">メタデータ テーブルが仕様で要求されている順序ではなく、<see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> が <see langword="false" /> です。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>メタデータのバージョン。</summary>
      <returns>メタデータのバージョンを表す文字列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>さまざまなメタデータ構造のサイズを返します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>メタデータ テーブルの基本的な検証を抑制するかどうかを決定します。 検証では、テーブル内のエントリが ECMA 仕様で必要な順序で追加されたことが確認されます。 メタデータ テーブルにすべての仕様要件が適用されるわけではありません。</summary>
      <returns>
        <see langword="true" /> メタデータテーブルの基本的な検証を抑制するにはそれ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>さまざまなメタデータ構造のサイズに関する情報を提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>指定したヒープの固定サイズを返します。</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>外部テーブルの行数。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>正確な (整列されていない) ヒープ サイズ。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>テーブルの行数。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>Ecma335 メタデータ内に存在できるテーブルの最大数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>Ecma335 メタデータ内に存在できるテーブルの最大数。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>トークン値からエンティティ ハンドルを作成します。</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> が有効なメタデータ エンティティ トークンではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>トークン値から <see cref="T:System.Reflection.Metadata.EntityHandle" /> を作成します。</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> が有効なテーブル インデックスではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>指定した <paramref name="handle" /> に対応する、メタデータ ヒープ データのオフセットを取得します。</summary>
      <param name="handle" />
      <returns>0 から始まるオフセット、または <paramref name="handle" /> が特定の <see cref="T:System.Reflection.Metadata.MetadataReader" /> または <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> のコンテキストでのみ解釈できる場合は、-1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>指定した <paramref name="handle" /> に対応する、メタデータ ヒープ データのオフセットを取得します。</summary>
      <param name="handle" />
      <returns>1 から始まる #Guid ヒープのインデックス。 実質的にバイト配列である他のヒープとは異なり、#Guid ヒープは 16 バイトの GUID の配列です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>指定した <paramref name="handle" /> に対応する、メタデータ ヒープ データのオフセットを取得します。</summary>
      <param name="handle" />
      <returns>対応するヒープ内のオフセット、または <paramref name="handle" /> が特定の <see cref="T:System.Reflection.Metadata.MetadataReader" /> または <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> のコンテキストでのみ解釈できる場合は、-1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>
        <paramref name="reader" /> のコンテキストで指定した <paramref name="handle" /> に対応する、メタデータ ヒープ データのオフセットを取得します。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">操作が、指定された <paramref name="handle" /> に対してサポートされていません。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> が無効です。</exception>
      <returns>0 から始まるオフセット、または <paramref name="handle" /> がメタデータ ヒープ ハンドルでない場合は -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>指定した <paramref name="handle" /> に対応する、メタデータ ヒープ データのオフセットを取得します。</summary>
      <param name="handle" />
      <returns>0 から始まるオフセット、または <paramref name="handle" /> が特定の <see cref="T:System.Reflection.Metadata.MetadataReader" /> または <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> のコンテキストでのみ解釈できる場合は、-1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>指定した <paramref name="handle" /> に対応する、メタデータ ヒープ データのオフセットを取得します。</summary>
      <param name="handle" />
      <returns>0 から始まるオフセット。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>指定した <paramref name="handle" /> に対応するメタデータ テーブル エントリの行番号を取得します。</summary>
      <param name="handle" />
      <returns>1 から始まるオフセット、または <paramref name="handle" /> が特定の <see cref="T:System.Reflection.Metadata.MetadataReader" /> のコンテキストでのみ解釈できる場合は、-1。
以下を参照してください。<see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" /></returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>
        <paramref name="reader" /> のコンテキストで指定した <paramref name="handle" /> に対応するメタデータ テーブル エントリの行番号を取得します。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> が、有効なメタデータ テーブル ハンドルではありません。</exception>
      <returns>1 から始まる行番号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>指定した <paramref name="handle" /> のメタデータ トークンを取得します。</summary>
      <param name="handle" />
      <returns>メタデータ トークン、または <paramref name="handle" /> が特定の <see cref="T:System.Reflection.Metadata.MetadataReader" /> のコンテキストでのみ解釈できる場合は、0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>指定した <paramref name="handle" /> のメタデータ トークンを取得します。</summary>
      <param name="handle" />
      <exception cref="T:System.ArgumentException">ハンドルが、トークンを持たないメタデータ エンティティを表しています。
トークンは、メタデータ テーブル ハンドルまたは <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 型のヒープ ハンドルに対してのみ取得できます。</exception>
      <returns>メタデータ トークン、または <paramref name="handle" /> が特定の <see cref="T:System.Reflection.Metadata.MetadataReader" /> のコンテキストでのみ解釈できる場合は、0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>
        <paramref name="reader" /> のコンテキストで指定した <paramref name="handle" /> のメタデータ トークンを取得します。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">操作が、指定された <paramref name="handle" /> に対してサポートされていません。</exception>
      <returns>メタデータ トークン。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>
        <paramref name="reader" /> のコンテキストで指定した <paramref name="handle" /> のメタデータ トークンを取得します。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">ハンドルが、トークンを持たないメタデータ エンティティを表しています。
トークンは、メタデータ テーブル ハンドルまたは <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 型のヒープ ハンドルに対してのみ取得できます。</exception>
      <exception cref="T:System.NotSupportedException">操作が、指定された <paramref name="handle" /> に対してサポートされていません。</exception>
      <returns>メタデータ トークン。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>トークン値からハンドルを作成します。</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> が有効なメタデータ トークンではありません。
メタデータ テーブル エンティティまたは <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> ヒープ内のオフセットがエンコードされている必要があります。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>トークン値から <see cref="T:System.Reflection.Metadata.EntityHandle" /> を作成します。</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> が有効なテーブル インデックスではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>指定した <see cref="T:System.Reflection.Metadata.HandleKind" /> に対応するヒープの <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> を取得します。</summary>
      <param name="type">ハンドル型。</param>
      <param name="index">ヒープ インデックス。</param>
      <returns>ハンドル型が Ecma335 ヒープに対応する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>指定した <see cref="T:System.Reflection.Metadata.HandleKind" /> に対応するテーブルの <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> を取得します。</summary>
      <param name="type">ハンドル型。</param>
      <param name="index">テーブル インデックス。</param>
      <returns>ハンドル型が Ecma335 またはポータブル PDB のテーブルに対応する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>メソッド本体の属性を定義します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>メソッドで定義されているローカルをいずれもゼロに初期化し、ローカル メモリを動的に割り当てます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>ローカル メモリの初期化は実行しません。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>メソッド本体ストリームのエンコーダーを提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>メソッド本体をエンコードし、メソッド本体ストリームに追加します。それを行うためには、指定されたコード サイズ、最大スタック サイズ、例外領域の数、ローカル変数のシグネチャ ハンドル、メソッド本体の属性を使用し、さらに、例外領域を小さい形式でエンコードする必要があるかどうかを指定できるようにします。</summary>
      <param name="codeSize">命令用に予約するバイト数。</param>
      <param name="maxStack">最大スタック サイズ。</param>
      <param name="exceptionRegionCount">例外領域の個数。</param>
      <param name="hasSmallExceptionRegions">例外領域を小さい形式でエンコードする必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <param name="localVariablesSignature">ローカル変数のシグネチャ ハンドル。</param>
      <param name="attributes">メソッド本体の属性。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />、<paramref name="exceptionRegionCount" />、または <paramref name="maxStack" /> が許容範囲外です。</exception>
      <returns>メソッド本体ストリーム内のエンコードされた本体のオフセット。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>メソッド本体をエンコードし、メソッド本体ストリームに追加します。それを行うためには、指定されたコード サイズ、最大スタック サイズ、例外領域の数、ローカル変数のシグネチャ ハンドル、メソッド本体の属性を使用し、さらに、例外領域を小さい形式でエンコードする必要があるかどうかを指定できるようにするほか、メソッドを動的ローカル メモリ プールから割り当てる必要があるかどうかを指定できるようにします。</summary>
      <param name="codeSize">命令用に予約するバイト数。</param>
      <param name="maxStack">最大スタック サイズ。</param>
      <param name="exceptionRegionCount">例外領域の個数。</param>
      <param name="hasSmallExceptionRegions">例外領域を小さい形式でエンコードする必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <param name="localVariablesSignature">ローカル変数のシグネチャ ハンドル。</param>
      <param name="attributes">メソッド本体の属性。</param>
      <param name="hasDynamicStackAllocation">メソッドが動的ローカル メモリ プールから割り当てられる場合 (IL には <see langword="localloc" /> 命令) は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />、<paramref name="exceptionRegionCount" />、または <paramref name="maxStack" /> が許容範囲外です。</exception>
      <returns>メソッド本体ストリーム内のエンコードされた本体のオフセット。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>メソッド本体をエンコードし、メソッド本体ストリームに追加します。</summary>
      <param name="instructionEncoder">命令エンコーダー。</param>
      <param name="maxStack">最大スタック サイズ。</param>
      <param name="localVariablesSignature">ローカル変数のシグネチャ ハンドル。</param>
      <param name="attributes">メソッド本体の属性。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> には既定値があります。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> が [0, <see cref="F:System.UInt16.MaxValue" />] の範囲外です。</exception>
      <exception cref="T:System.InvalidOperationException">命令ストリーム内の分岐のターゲットとなるラベルがマークされていません。または、分岐命令とターゲット ラベルの間の距離が、命令オペランドのサイズに適合していません。</exception>
      <returns>メソッド本体ストリーム内のエンコードされた本体のオフセット。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>メソッド本体をエンコードし、メソッド本体ストリームに追加します。それを行うためには、指定された命令エンコーダー、最大スタック サイズ、ローカル変数のシグネチャ ハンドル、およびメソッド本体の属性を使用し、さらにメソッドを動的ローカル メモリ プールから割り当てる必要があるかどうかを指定できるようにします。</summary>
      <param name="instructionEncoder">命令エンコーダー。</param>
      <param name="maxStack">最大スタック サイズ。</param>
      <param name="localVariablesSignature">ローカル変数のシグネチャ ハンドル。</param>
      <param name="attributes">メソッド本体の属性。</param>
      <param name="hasDynamicStackAllocation">メソッドが動的ローカル メモリ プールから割り当てられる場合 (IL には <see langword="localloc" /> 命令が含まれます) は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> には既定値があります。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> が [0, <see cref="F:System.UInt16.MaxValue" />] の範囲外です。</exception>
      <exception cref="T:System.InvalidOperationException">命令ストリーム内の分岐のターゲットとなるラベルがマークされていません。または、分岐命令とターゲット ラベルの間の距離が、命令オペランドのサイズに適合していません。</exception>
      <returns>メソッド本体ストリーム内のエンコードされた本体のオフセット。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>メソッド本体を記述します。 このクラスは <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" /> クラスと共に使用することを意図しています。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>例外領域をメソッド本体にエンコードするために使用できるエンコーダー オブジェクトを取得します。</summary>
      <returns>例外領域エンコーダーインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>命令用に予約されている BLOB を取得します。</summary>
      <returns>指示用に予約されている blob。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>メソッド本体ストリーム内のエンコードされたメソッド本体のオフセットを取得します。</summary>
      <returns>メソッド本体ストリーム内のエンコードされたメソッド本体のオフセット。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>メソッド シグネチャ用のエンコーダーを提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>指定された戻り値の型とパラメーターをエンコードします。</summary>
      <param name="parameterCount">パラメーターの数。</param>
      <param name="returnType">最初に呼び出して戻り値の型をエンコードするメソッド。</param>
      <param name="parameters">2 番目に呼び出してパラメーターをエンコードするメソッド。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> または <paramref name="parameters" /> が <see langword="null" /> です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>指定された戻り値の型とパラメーターをエンコードします。これらは、パラメーター リストに表示された順序で使用する必要があります。</summary>
      <param name="parameterCount">パラメーターの数。</param>
      <param name="returnType">最初に呼び出して戻り値の型をエンコードするメソッド。</param>
      <param name="parameters">2 番目に呼び出してパラメーターをエンコードするメソッド。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>
        <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="builder">名前付き引数をエンコードするためのビルダー。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>名前付き引数 (フィールドまたはプロパティ) をエンコードします。</summary>
      <param name="isField">フィールドをエンコードする場合は <see langword="true" />、プロパティをエンコードする場合は <see langword="false" />。</param>
      <param name="type">最初に呼び出して引数の型をエンコードするためのメソッド。</param>
      <param name="name">2 番目に呼び出してフィールド名またはプロパティ名をエンコードするためのメソッド。</param>
      <param name="literal">3 番目に呼び出して引数のリテラル値をエンコードするためのメソッド。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" />、<paramref name="name" />、または <paramref name="literal" /> が <see langword="null" /> です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>名前付き引数 (フィールドまたはプロパティ) をエンコードし、パラメーター リストに表示された順序で使用する必要がある 3 つのエンコーダーを返します。</summary>
      <param name="isField">フィールドをエンコードする場合は <see langword="true" />、プロパティをエンコードする場合は <see langword="false" />。</param>
      <param name="type">最初に呼び出して引数の型をエンコードするためのメソッド。</param>
      <param name="name">2 番目に呼び出してフィールド名またはプロパティ名をエンコードするためのメソッド。</param>
      <param name="literal">3 番目に呼び出して引数のリテラル値をエンコードするためのメソッド。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>ポータブル PDB イメージのビルダーを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>ポータブル PDB イメージのビルダーを作成します。</summary>
      <param name="tablesAndHeaps">テーブルに格納されているデバッグ メタデータ エンティティとヒープに格納されている値が設定されたビルダー。 このエンティティと値は、ポータブル PDB イメージをシリアル化するときに列挙されます。</param>
      <param name="typeSystemRowCounts">関連する型システム メタデータに含まれているすべてのテーブルの行数。 テーブル (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />) に対応する配列内の各スロット。 配列の長さは、<see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> と等しくする必要があります。</param>
      <param name="entryPoint">エントリ ポイント メソッド定義ハンドル。</param>
      <param name="idProvider">一連の BLOB として表されるコンテンツの ID を計算する関数。 指定しない場合、既定の関数が使用されます。既定の関数では、コンテンツは無視され、現在の時刻に基づいてコンテンツ ID が返されます (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />)。 決定論的ポータブル PDB イメージを作成するには、決定論的関数を指定する必要があります。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> または <paramref name="typeSystemRowCounts" /> が <see langword="null" /> です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>指定された <see cref="T:System.Reflection.Metadata.BlobBuilder" /> にポータブル PDB コンテンツをシリアル化します。</summary>
      <param name="builder">書き込み先のビルダー。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> が <see langword="null" />です。</exception>
      <returns>シリアル化されたコンテンツの ID。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>定数リテラルをエンコードします。</summary>
      <param name="value">次のいずれかの型の定数: <see cref="T:System.Boolean" />、<see cref="T:System.Byte" />、<see cref="T:System.SByte" />、<see cref="T:System.Int16" />、<see cref="T:System.UInt16" />、<see cref="T:System.Int32" />、<see cref="T:System.UInt32" />、<see cref="T:System.Int64" />、<see cref="T:System.UInt64" />、<see cref="T:System.Single" />、<see cref="T:System.Double" /> 型、<see cref="T:System.Char" /> (2 バイトの Unicode 文字としてエンコード)、<see cref="T:System.String" /> (SerString としてエンコード)、<see cref="T:System.Enum" /> 型 (基礎となる整数値としてエンコード)。</param>
      <exception cref="T:System.ArgumentException">予期しない定数型です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>型 <see cref="T:System.Array" /> の <see langword="null" /> リテラルをエンコードします。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>型 <see cref="T:System.Type" /> のリテラル (<see langword="null" /> である可能性があります) をエンコードします。</summary>
      <param name="serializedTypeName">型の名前、または <see langword="null" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="serializedTypeName" /> が空です。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>シグネチャ BLOB をデコードします。</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>新しい <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" /> を作成します。</summary>
      <param name="provider">シグネチャをデコードするときに型シンボルを取得するために使用されるプロバイダー。</param>
      <param name="metadataReader">シグネチャの取得元のメタデータ リーダー。 指定したプロバイダーで許可されている場合は、それを <see langword="null" /> としてもかまいません。</param>
      <param name="genericContext">ジェネリック パラメーターを解決するために必要な追加のコンテキスト。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>フィールド シグネチャ BLOB をデコードし、リーダーをシグネチャより先に進めます。</summary>
      <param name="blobReader">フィールド シグネチャに配置された BLOB リーダー。</param>
      <returns>デコードされたフィールド型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>ローカル変数シグネチャ BLOB をデコードし、リーダーを署名より先に進めます。</summary>
      <param name="blobReader">ローカル変数シグネチャに配置された BLOB リーダー。</param>
      <exception cref="T:System.BadImageFormatException">ローカル変数のシグネチャが無効です。</exception>
      <returns>ローカル変数の型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>メソッド (定義、参照、スタンドアロン) またはプロパティ シグネチャ BLOB をデコードします。</summary>
      <param name="blobReader">メソッド シグネチャに配置された BLOB リーダー。</param>
      <exception cref="T:System.BadImageFormatException">メソッドのシグネチャが無効です。</exception>
      <returns>デコードされたメソッド シグネチャ。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>メソッド仕様シグネチャ BLOB をデコードし、リーダーをシグネチャより先に進めます。</summary>
      <param name="blobReader">有効なメソッド仕様シグネチャに配置された BLOB リーダー。</param>
      <returns>メソッド仕様を使用してジェネリック メソッドをインスタンス化するために使用される型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>シグネチャに埋め込まれている型をデコードし、その型より先にリーダーを進めます。</summary>
      <param name="blobReader">先頭の <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> に配置されている BLOB リーダー。</param>
      <param name="allowTypeSpecifications">
        <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> がシグネチャ内の (CLASS | VALUETYPE) に従うことを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <exception cref="T:System.BadImageFormatException">リーダーが、有効なシグネチャ型に配置されていませんでした。</exception>
      <returns>デコードされた型。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>配列型をエンコードします。</summary>
      <param name="elementType">要素の型をエンコードするために最初に呼び出されます。</param>
      <param name="arrayShape">配列の形状をエンコードするために、2 番目に呼び出されます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="elementType" /> または <paramref name="arrayShape" /> が <see langword="null" /> です。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>配列型をエンコードします。 パラメーター リストに表示された順に使用する必要があるエンコーダーのペアを返します。</summary>
      <param name="elementType">要素の型をエンコードするために、最初に使用します。</param>
      <param name="arrayShape">配列の形状をエンコードするために、2 番目に使用します。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>カスタム修飾子を使用して、型のシグネチャを開始します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>関数ポインターのシグネチャを開始します。</summary>
      <param name="convention">呼び出し規則。</param>
      <param name="attributes">関数ポインター属性。</param>
      <param name="genericParameterCount">ジェネリック パラメーターの数。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributes" /> が無効です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> が [0, 0xffff] の範囲内ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>ジェネリック インスタンス化シグネチャを開始します。</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="genericArgumentCount">ジェネリック引数の数。</param>
      <param name="isValueType">型を値の型としてマークする場合は <see langword="true" />、型をシグネチャ内の参照型としてマークする場合は <see langword="false" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericType" /> が、必要なハンドルの型ではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> が [1, 0xffff] の範囲内ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>格納しているジェネリック メソッドの型パラメーターへの参照をエンコードします。</summary>
      <param name="parameterIndex">パラメーター インデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> が [0, 0xffff] の範囲内ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>格納しているジェネリック型の型パラメーターへの参照をエンコードします。</summary>
      <param name="parameterIndex">パラメーター インデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> が [0, 0xffff] の範囲内ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>ポインターのシグネチャを開始します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>プリミティブ型コードを書き込みます。</summary>
      <param name="type">
        <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> および <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" /> を除く任意のプリミティブ型コード。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="type" /> は、このコンテキストでは有効ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>SZ 配列 (ベクター) シグネチャを開始します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>型への参照をエンコードします。</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="isValueType">型を値の型としてマークする場合は <see langword="true" />、型をシグネチャ内の参照型としてマークする場合は <see langword="false" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> が、必要なハンドルの型ではありません。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>void ポインター (<c>void*</c>) をエンコードします。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>メタデータ エンティティ (型参照、型定義、型指定、メソッド定義、カスタム属性など) を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>現在のインスタンスと、指定されたオブジェクトが等しいかどうかを示す値を返します。</summary>
      <param name="obj">現在のインスタンスと比較するオブジェクト。</param>
      <returns>
        <paramref name="obj" /> が <see cref="T:System.Reflection.Metadata.EntityHandle" /> で、現在のインスタンスと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>現在のインスタンスと指定された <see cref="T:System.Reflection.Metadata.EntityHandle" /> が等しいかどうかを示す値を返します。</summary>
      <param name="other">現在のインスタンスと比較する値。</param>
      <returns>現在のインスタンスと <paramref name="other" /> が等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>このインスタンスのハッシュ コードを返します。</summary>
      <returns>対象のインスタンスのハッシュ コード。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>領域が catch を表す場合、TypeRef、TypeDef、TypeSpec ハンドルを取得します。それ以外の場合、nil トークン (<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />))。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>フィルター ブロックの開始の IL オフセットを取得します。あるいは、領域がフィルターではない場合、-1。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>例外ハンドラーの長さ (バイト単位) を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>例外ハンドラーの開始 IL オフセットを取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>try ブロックの長さ (バイト単位) を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>try ブロックの開始 IL オフセットを取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>ターゲット型の実装を解決するためのハンドルを取得します。</summary>
      <returns>
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> アセンブリ内の別のモジュールを表す。</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> がの場合は、別のアセンブリを表し <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /><see langword="true" /> ます。</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> このが入れ子になったエクスポート型の宣言を表します。</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>ターゲット型の名前を取得します。型が入れ子になっているか、ルート名前空間で定義されている場合は <see langword="default" />。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.StringHandle" />構造体のインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>ターゲット型が含まれている名前空間の完全名を取得します。型が入れ子になっているか、ルート名前空間で定義されている場合は <see langword="default" />。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>ターゲット型が定義されている名前空間の定義ハンドルを取得します。型が入れ子になっているか、ルート名前空間で定義されている場合は <see langword="default" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> インスタンスのコレクションを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>フィールド レイアウトのオフセット、またはそれを使用できない場合は -1 を返します。</summary>
      <returns>フィールド定義のオフセット、またはそれを使用できない場合は -1 を返します。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>分散と制約を指定する属性を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>宣言しているジェネリック型またはメソッド宣言内のパラメーターの 0 から始まるインデックスを取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>ジェネリック パラメーターの名前を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>このジェネリック パラメーターの親を表す <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> または <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> を取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>制約付き <see cref="T:System.Reflection.Metadata.GenericParameterHandle" /> を取得します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>このジェネリック パラメーターが派生を制限されている型またはこのジェネリック パラメーターが実装を制限されているインターフェイスから指定するハンドル (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) を取得します。</summary>
      <returns>
        <see cref="T:System.Reflection.Metadata.EntityHandle" /> のインスタンス。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>ジェネリック型パラメーターの制約のコレクションを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary>読み取り専用のリスト内の指定したインデックスにある要素を取得します。</summary>
      <param name="index">取得する要素の 0 から始まるインデックス。</param>
      <returns>読み取り専用のリスト内の指定したインデックスにある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>メソッドまたは型のジェネリック型パラメーターのコレクションを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary>読み取り専用のリスト内の指定したインデックスにある要素を取得します。</summary>
      <param name="index">取得する要素の 0 から始まるインデックス。</param>
      <returns>読み取り専用のリスト内の指定したインデックスにある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>任意のメタデータ エンティティ (型参照、型定義、型指定、メソッド定義、またはカスタム属性など) または値 (文字列、BLOB、GUID、またはユーザー文字列) を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>2 つのエンティティ ハンドルを比較します。</summary>
      <param name="x">比較する最初のエンティティ ハンドル。</param>
      <param name="y">比較する 2 番目のエンティティ ハンドル。</param>
      <returns>2 つのエンティティ ハンドルが等しい場合は 0、およびそれらが等しくない場合は 0 以外の値。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>2 つのハンドルを比較します。</summary>
      <param name="x">比較する最初のハンドル。</param>
      <param name="y">比較する 2 番目のハンドル。</param>
      <returns>2 つのハンドルが等しい場合は 0、およびそれらが等しくない場合は 0 以外の値。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>指定したオブジェクトが等しいかどうかを判断します。</summary>
      <param name="x">比較対象の <paramref name="T" /> 型の第 1 オブジェクト。</param>
      <param name="y">比較対象の <paramref name="T" /> 型の第 2 オブジェクト。</param>
      <returns>指定したオブジェクトが等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>指定したオブジェクトが等しいかどうかを判断します。</summary>
      <param name="x">比較対象の <paramref name="T" /> 型の第 1 オブジェクト。</param>
      <param name="y">比較対象の <paramref name="T" /> 型の第 2 オブジェクト。</param>
      <returns>指定したオブジェクトが等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary>指定したオブジェクトのハッシュ コードを返します。</summary>
      <param name="obj">ハッシュ コードが返される対象の <see cref="T:System.Object" />。</param>
      <returns>指定したオブジェクトのハッシュ コード。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary>指定したオブジェクトのハッシュ コードを返します。</summary>
      <param name="obj">ハッシュ コードが返される対象の <see cref="T:System.Object" />。</param>
      <returns>指定したオブジェクトのハッシュ コード。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>指定した要素の型とシェイプの汎用化された配列の型のシンボルを取得します。</summary>
      <param name="elementType">配列内の要素の型。</param>
      <param name="shape">配列のシェイプ (ランク、サイズ、および下限)。</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>指定した要素の型へのマネージド ポインターの型のシンボルを取得します。</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>指定した型引数による指定したジェネリック型のジェネリックのインスタンス化の型のシンボルを取得します。</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>指定した要素の型へのアンマネージド ポインターの型のシンボルを取得します。</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>
        <see cref="T:System.Type" /> の <typeparamref name="TType" /> 表現を取得します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>指定したシリアル化された型名の型のシンボルを取得します。</summary>
      <param name="name">いわゆる "リフレクション表記" 形式 (<see cref="M:System.Type.GetType(System.String)" /> メソッドによって認識された) のシリアル化された型名。</param>
      <exception cref="T:System.BadImageFormatException">名前の形式が正しくありません。</exception>
      <returns>
        <typeparamref name="TType" /> のインスタンス。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>指定した列挙型シンボルの基になる型を取得します。</summary>
      <param name="type">列挙型。</param>
      <exception cref="T:System.BadImageFormatException">指定した型のシンボルは、列挙型を表していません。</exception>
      <returns>列挙型の基になる型を示す型コード。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>指定した型が <see cref="T:System.Type" /> を表すかどうかを検証します。</summary>
      <param name="type">検証する型。</param>
      <returns>指定した型が <see cref="T:System.Type" /> の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>指定した分岐命令オペランドのサイズを計算します。</summary>
      <param name="opCode">分岐操作コード。</param>
      <exception cref="T:System.ArgumentException">指定した <paramref name="opCode" /> は分岐操作コードではありません。</exception>
      <returns>
        <paramref name="opCode" /> が短い分岐の場合は 1、または長い分岐の場合は 4。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>指定した分岐操作コードの長い形式を取得します。</summary>
      <param name="opCode">分岐操作コード。</param>
      <exception cref="T:System.ArgumentException">指定した <paramref name="opCode" /> は分岐操作コードではありません。</exception>
      <returns>分岐操作コードの長い形式。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>指定した分岐操作コードの短い形式を取得します。</summary>
      <param name="opCode">分岐操作コード。</param>
      <exception cref="T:System.ArgumentException">指定した <paramref name="opCode" /> は分岐操作コードではありません。</exception>
      <returns>分岐操作コードの短い形式。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>指定した操作コードがラベルへの分岐かどうかを検証します。</summary>
      <param name="opCode" />
      <returns>指定した操作コードがラベルへの分岐の場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>メタデータを書き込もうとして書式指定によって指定された制限を超えた場合にスローされる例外。 たとえば、ヒープ サイズの制限を超えた場合などです。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>
        <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> クラスの新しいインスタンスを初期化します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>シリアル化したデータを使用して、<see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="info">シリアル化されたオブジェクト データを保持するオブジェクト。</param>
      <param name="context">転送元または転送先に関するコンテキスト情報。</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>指定したエラー メッセージを使用して、<see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="message">この例外の原因を説明するエラー メッセージ。</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>エラー メッセージ、およびこの例外の原因である例外を指定して、<see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="message">この例外の原因を説明するエラー メッセージ。</param>
      <param name="innerException">現在の例外の原因である例外。または、内部例外を指定しない場合は <see langword="null" />。</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <exception cref="T:System.BadImageFormatException">無効な BLOB 形式。</exception>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>インポートのグループが使用できる構文スコープに関する情報を提供します。 この情報は、デバッグ メタデータに格納されます。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>実装されているインターフェイス (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />) を取得します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>指定されたメソッド <paramref name="signature" /> の関数ポインター型の型のシンボルを取得します。</summary>
      <param name="signature" />
      <returns>関数ポインター型の型のシンボル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>指定されたゼロベースの <paramref name="index" /> でジェネリック メソッド パラメーターの型のシンボルを取得します。</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>
        <paramref name="index" /> のジェネリック メソッド パラメーターの型のシンボル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>指定されたゼロベースの <paramref name="index" /> でジェネリック型パラメーターの型のシンボルを取得します。</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>指定されたゼロベースの <paramref name="index" /> のジェネリック型パラメーターの型のシンボル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>カスタム修飾子が適用されている型の型のシンボルを取得します。</summary>
      <param name="modifier">適用された修飾子の型。</param>
      <param name="unmodifiedType">修飾子が適用されていない基になる型の型のシンボル。</param>
      <param name="isRequired">修飾子が必要な場合は <see langword="true" />、省略可能である場合は <see langword="false" />。</param>
      <returns>型のシンボル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>ピン留めされているローカル変数型の型のシンボルを取得します。</summary>
      <param name="elementType" />
      <returns>ローカル変数型の型のシンボル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>型指定の型のシンボルを取得します。</summary>
      <param name="reader">署名デコーダーに渡されたメタデータ リーダー。 <see langword="null" /> の可能性もあります。</param>
      <param name="genericContext">署名デコーダーに渡されたコンテキスト。</param>
      <param name="handle">型指定のハンドル。</param>
      <param name="rawTypeKind">署名で指定されている型の種類。 この値を解釈するには、<see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" /> を使用します。</param>
      <returns>型指定の型のシンボル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>プリミティブ型の型のシンボルを取得します。</summary>
      <param name="typeCode" />
      <returns>型のシンボル <param name="typeCode" />.</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>型定義の型のシンボルを取得します。</summary>
      <param name="reader">署名デコーダーに渡されたメタデータ リーダー。 <see langword="null" /> の可能性もあります。</param>
      <param name="handle">型定義のハンドル。</param>
      <param name="rawTypeKind">署名で指定されている型の種類。 この値を解釈するには、<see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" /> を使用します。</param>
      <returns>型のシンボル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>型参照の型のシンボルを取得します。</summary>
      <param name="reader">署名デコーダーに渡されたメタデータ リーダー。 <see langword="null" /> の可能性もあります。</param>
      <param name="handle">型定義のハンドル。</param>
      <param name="rawTypeKind">署名で指定されている型の種類。 この値を解釈するには、<see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" /> を使用します。</param>
      <returns>型のシンボル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>下限が 0 の指定した要素型の 1 次元配列の型のシンボルを取得します。</summary>
      <param name="elementType" />
      <returns>
        <typeparamref name="TType" /> のインスタンス。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>ローカル定数に関する情報を提供します。 この情報は、デバッグ メタデータに格納されます。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>定数シグネチャを取得します。</summary>
      <returns>定数シグネチャ。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>ローカル変数と定数のスコープに関する情報を提供します。 この情報は、デバッグ メタデータに格納されます。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>ローカル変数に関する情報を提供します。 この情報は、デバッグ メタデータに格納されます。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>マニフェスト リソース属性を取得します。</summary>
      <returns>マニフェストリソース属性を指定する列挙値のビットごとの組み合わせ。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>実装エンティティ ハンドルを取得します。</summary>
      <returns>EntityHandle インスタンス。 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" />プロパティがの場合 <see langword="true" /> 、返されるハンドルには既定値が設定されます。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>リソース名を取得します。</summary>
      <returns>リソースの名前。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>このリソース レコードが始まる参照先ファイル内のバイト オフセットを取得します。</summary>
      <returns>このリソースレコードの開始位置を示す、参照されるファイル内のバイトオフセット。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" /> インスタンスのコレクションを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>メンバー参照がメソッドマネージャーはフィールドの参照かどうかを判断します。</summary>
      <exception cref="T:System.BadImageFormatException">メンバー参照シグネチャが無効です。</exception>
      <returns>メンバー参照の種類を示す列挙値の 1 つ。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>親エンティティ ハンドルを取得します。</summary>
      <returns>エンティティハンドルインスタンス。 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" />プロパティがの場合 <see langword="true" /> 、返されるハンドルには既定値が設定されます。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>シグネチャ BLOB へのハンドルを取得します。</summary>
      <returns>署名 blob へのハンドル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> インスタンスのコレクションを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> がメソッドを参照するか、フィールドを参照することを示す定数を指定します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> はフィールドを参照します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> はメソッドを参照します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>CLI メタデータ。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>マネージド コンパイラによって生成される Windows メタデータ。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Windows メタデータ。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>ECMA 335 CLI 仕様で定義されているとおりにメタデータを読み取ります。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>指定のメモリ場所に保存されているメタデータから <see cref="T:System.Reflection.Metadata.MetadataReader" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="metadata">メタデータのブロック内の最初のバイトへのポインター。</param>
      <param name="length">ブロック内のバイト数。</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>指定のメモリ場所に保存されているメタデータから <see cref="T:System.Reflection.Metadata.MetadataReader" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>指定のメモリ場所に保存されているメタデータから <see cref="T:System.Reflection.Metadata.MetadataReader" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> は正の値ではありません。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> のエンコードは、<see cref="T:System.Text.UTF8Encoding" /> ではありません。</exception>
      <exception cref="T:System.PlatformNotSupportedException">現在のプラットフォームはビッグ エンディアンです。</exception>
      <exception cref="T:System.BadImageFormatException">無効なメタデータ ヘッダー。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>#Pdb ストリームからデコードされた情報を取得します。あるいは、ストリームがない場合は <see langword="null" />。</summary>
      <returns>#Pdb ストリームからデコードされた情報 <see langword="null" /> 。ストリームが存在しない場合は。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>メタデータがアセンブリを表すかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> メタデータがアセンブリを表す場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>メタデータの種類を取得します。</summary>
      <returns>メタデータの種類を指定する列挙値の1つ。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>基になるデータの長さを取得します。</summary>
      <returns>基になるデータの長さ。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>基になるデータへのポインターを取得します。</summary>
      <returns>基になるデータへのポインター。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>メタデータ ヘッダーから読み込まれたバージョン文字列を取得します。</summary>
      <returns>メタデータヘッダーから読み取られたバージョン文字列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>コンストラクターに渡された <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> を取得します。</summary>
      <returns>列挙値を表す列挙値のビットごとの組み合わせ <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>メタデータに格納されている文字列を比較するための比較子を取得します。</summary>
      <returns>メタデータに格納されている文字列を比較するために使用される比較子。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>UTF8 でエンコードされたバイト シーケンスから文字列インスタンスを生成するためにリーダーによって使用されるデコーダーを取得します。</summary>
      <returns>UTF8 でエンコードされたバイトシーケンスから文字列インスタンスを生成するためにリーダーが使用するデコーダー。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>Windows ランタイムのプロジェクションが有効になっています (既定ではオン)。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>
        <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 引数を受け取らないオーバーロードを介して <see cref="T:System.Reflection.Metadata.MetadataReader" /> が取得される場合に使用されるオプション。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>すべてのオプションは無効になっています。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>バイト配列、メモリ ブロック、またはストリームに格納されているメタデータに <see cref="T:System.Reflection.Metadata.MetadataReader" /> を提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>リーダーによって割り当てられたすべてのメモリを破棄します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>メモリに格納されているイメージのメタデータ プロバイダーを作成します。</summary>
      <param name="start">メタデータの BLOB の先頭へのポインター。</param>
      <param name="size">メタデータの BLOB のサイズ。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> が <see cref="F:System.IntPtr.Zero" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> が負の値です。</exception>
      <returns>新しいメタデータ プロバイダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>バイト配列に対してプロバイダーを作成します。</summary>
      <param name="image">メタデータのイメージ。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> が <see langword="null" />です。</exception>
      <returns>新しいプロバイダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>現在の位置を起点とする指定されたサイズのストリームのプロバイダーを作成します。</summary>
      <param name="stream">
        <see cref="T:System.IO.Stream" /> のインスタンス。</param>
      <param name="options">ストリームから、イメージのセクションを読み取る方法を指定するオプション。</param>
      <param name="size">ストリームのメタデータ BLOB のサイズ。 指定しない場合、メタデータ BLOB はストリームの末尾まで広がると見なされます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> は読み取りとシークの操作をサポートしません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">サイズは負の値になるか、ストリームの末尾を超えます。</exception>
      <exception cref="T:System.IO.IOException">ストリームからの読み取り中のエラー (<see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> が指定されている場合のみ)。</exception>
      <returns>新しいプロバイダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>メモリに格納された BLOB に対して、ポータブル PDB のメタデータ プロバイダーを作成します。</summary>
      <param name="start">ポータブル PDB の BLOB の先頭へのポインター。</param>
      <param name="size">ポータブル PDB の BLOB のサイズ。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> が <see cref="F:System.IntPtr.Zero" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> が負の値です。</exception>
      <returns>新しいポータブル PDB のメタデータ プロバイダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>バイト配列に対して、ポータブル PDB のメタデータ プロバイダーを作成します。</summary>
      <param name="image">ポータブル PDB イメージ。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> が <see langword="null" />です。</exception>
      <returns>新しいポータブル PDB のメタデータ プロバイダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>現在の位置を起点とする指定されたサイズのストリームのプロバイダーを作成します。</summary>
      <param name="stream">ストリームです。</param>
      <param name="options">ストリームから、イメージのセクションを読み取る方法を指定するオプション。</param>
      <param name="size">ストリームのメタデータ BLOB のサイズ。 指定しない場合、メタデータ BLOB はストリームの末尾まで広がると見なされます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> は読み取りとシークの操作をサポートしません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">サイズは負の値になるか、ストリームの末尾を超えます。</exception>
      <returns>
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> のインスタンス。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> から <see cref="T:System.Reflection.Metadata.MetadataReader" /> を取得します。</summary>
      <param name="options">メタデータの読み取り時の構成を表す、列挙値のビットごとの組み合わせ。</param>
      <param name="utf8Decoder">使用するエンコーディング。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> のエンコードは、<see cref="T:System.Text.UTF8Encoding" /> ではありません。</exception>
      <exception cref="T:System.PlatformNotSupportedException">現在のプラットフォームはビッグ エンディアンです。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <exception cref="T:System.ObjectDisposedException">プロバイダーは破棄されています。</exception>
      <returns>
        <see cref="T:System.Reflection.Metadata.MetadataReader" /> のインスタンス。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>既定では、<see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> が破棄されるとき、ストリームは破棄され、PE イメージの各セクションが遅れて読み込まれます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>
        <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> が破棄されるとき、ストリームを開いている状態が維持されます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>
        <para>直後に PDB メタデータを読み取ります。</para>
        <para>
          <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> が構築されると、基になるファイルが閉じられ、さらには削除されることもあります。 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> が指定されていない場合、<see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />ではコンストラクターが制御を返すまでにストリームが自動的に閉じられます。</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>可能な場合は割り当てを回避しながら、メタデータ内のクエリ文字列に文字列比較ヘルパーを提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>テキストを表すメタデータ内のバイト シーケンスをデコードするためのカスタム メカニズムを備えた <see cref="T:System.Reflection.Metadata.MetadataReader" /> を提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>指定のエンコーディングを使用し、<see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="encoding">使用するエンコーディング。</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>メタデータでバイト シーケンスの文字列を取得します。 これをオーバーライドし、必要に応じて文字列をキャッシュします。 それ以外の場合、<see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> に直接転送することで実装されます。呼び出しごとに新しい文字列が割り当てられます。</summary>
      <param name="bytes">デコードするバイトへのポインター。</param>
      <param name="byteCount">デコードするバイト数。</param>
      <returns>デコードされた文字列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>デコーダーがコンストラクターに与えられないときに UTF-8 をデコードする目的で <see cref="T:System.Reflection.Metadata.MetadataReader" /> で使用される既定のデコーダーを取得します。</summary>
      <returns>UTF-8 をデコードするためにによって使用される既定のデコーダー <see cref="T:System.Reflection.Metadata.MetadataReader" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>このインスタンスで使用されるエンコーディングを取得します。</summary>
      <returns>このインスタンスによって使用されるエンコーディング。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>ヘッダー、IL、および例外のリージョンを含む、メソッド本文のサイズを取得します。</summary>
      <returns>メソッド本体のサイズ。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>メソッド定義に関連付けられたデバッグ情報を提供します。 この情報は、デバッグ メタデータに格納されます。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>
        <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" /> からデコードされたシーケンス ポイントのコレクションを返します。</summary>
      <returns>シーケンス ポイントのコレクション。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>ステート マシンのキックオフ メソッドを返します。</summary>
      <returns>メソッドがステート マシンの <c>MoveNext</c> メソッドである場合、ステート マシンのキックオフ メソッド。 それ以外の場合、<see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> プロパティが <see langword="true" /> であるハンドルを返します。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>メソッドのすべてのシーケンス ポイントを含む単一のドキュメントのハンドルを取得します。</summary>
      <returns>メソッドのすべてのシーケンスポイントを含む単一ドキュメントのハンドル、または <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /><see langword="true" /> メソッドがシーケンスポイントを持たないか複数のドキュメントにまたがる場合は、プロパティがであるハンドル。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>ローカルのシグネチャ ハンドルを返します。</summary>
      <returns>ローカル署名ハンドル <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /><see langword="true" /> 。メソッドがローカル変数を定義していない場合は、プロパティがであるハンドル。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>BLOB エンコード シーケンス ポイントを返します。</summary>
      <returns>Blob エンコーディングシーケンスポイント、または <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /><see langword="true" /> メソッドにシーケンスポイントがない場合はプロパティがであるハンドル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>このハンドルに対応する <see cref="T:System.Reflection.Metadata.MethodDefinition" /> にハンドルを返します。</summary>
      <returns>このハンドルに対応するメソッド定義ハンドル。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>このハンドルに対応する <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> にハンドルを返します。</summary>
      <returns>このハンドルに対応するメソッド デバッグ情報ハンドル。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>メソッド (定義、参照、スタンドアロン) またはプロパティのシグネチャを表します。 プロパティの場合、シグネチャは、他との区別を付ける <see cref="T:System.Reflection.Metadata.SignatureHeader" /> を含むゲッターのシグネチャに一致します。</summary>
      <typeparam name="TType">メソッドの型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>指定されたヘッダー、戻り値の型、パラメーター情報を使用し、<see cref="T:System.Reflection.Metadata.MethodSignature`1" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="header">シグネチャ (種類、呼び出し規則、フラグ) の先頭バイトの情報。</param>
      <param name="returnType">メソッドの戻り値の型。</param>
      <param name="requiredParameterCount">必要なパラメーターの数。</param>
      <param name="genericParameterCount">ジェネリック型パラメーターの数。</param>
      <param name="parameterTypes">パラメーターの型。</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>メソッドのジェネリック型パラメーターの数を取得します。</summary>
      <returns>ジェネリック型パラメーターの数、または非ジェネリックメソッドの場合は0。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>シグネチャ (種類、呼び出し規則、フラグ) の先頭バイトの情報を取得します。</summary>
      <returns>ヘッダー署名。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>メソッドのパラメーターの型を取得します。</summary>
      <returns>パラメーター型の変更できないコレクション。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>メソッドに必要なパラメーターの数を取得します。</summary>
      <returns>必要なパラメーターの数。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>メソッドの戻り値の型を取得します。</summary>
      <returns>戻り値の型。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>このインスタンスの参照先のジェネリック メソッド (つまり、そのインスタンス化の元となるジェネリック メソッド) を指定する <see langword="MethodDef" /> または <see langword="MemberRef" /> ハンドル。</summary>
      <returns>
        <see langword="MethodDef" />
        <see langword="MemberRef" /> このインスタンスが参照するジェネリックメソッドを指定するまたはハンドル。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>シグネチャ BLOB へのハンドルを取得します。</summary>
      <returns>署名 blob へのハンドル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>エクスポートされ、名前空間に直接存在する型をすべて取得します。</summary>
      <returns>エクスポートされた型ハンドルの変更できない配列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>名前空間定義の非修飾名を取得します。</summary>
      <returns>名前空間定義の非修飾名。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>現在の名前空間定義の直接の子である名前空間定義を取得します。</summary>
      <returns>現在の名前空間定義の直接の子である名前空間定義の変更できない配列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>親の名前空間を取得します。</summary>
      <returns>親の名前空間。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>名前空間に直接存在する型定義をすべて取得します。</summary>
      <returns>型定義ハンドルの変更できない配列。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>名前空間定義のハンドルを提供します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>指定したメソッドのパラメーターのコレクションを格納します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEReader" /> から <see cref="T:System.Reflection.Metadata.MetadataReader" /> を取得します。</summary>
      <param name="peReader">現在の <see cref="T:System.Reflection.PortableExecutable.PEReader" /> インスタンス。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.PlatformNotSupportedException">現在のプラットフォームはビッグ エンディアンです。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <returns>メタデータリーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEReader" /> から、指定したメタデータ読み取り構成でメタデータ リーダーを取得します。</summary>
      <param name="peReader">現在の <see cref="T:System.Reflection.PortableExecutable.PEReader" /> インスタンス。</param>
      <param name="options">メタデータの読み取り構成を示す列挙値。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.PlatformNotSupportedException">現在のプラットフォームはビッグ エンディアンです。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <returns>指定したメタデータ読み取り構成によるメタデータ リーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEReader" /> から、指定したメタデータ読み取り構成とエンコード構成でメタデータ リーダーを取得します。</summary>
      <param name="peReader">現在の <see cref="T:System.Reflection.PortableExecutable.PEReader" /> インスタンス。</param>
      <param name="options">メタデータの読み取り構成を示す列挙値。</param>
      <param name="utf8Decoder">エンコード構成によるメタデータ文字列デコーダー。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> のエンコードは、<see cref="T:System.Text.UTF8Encoding" /> ではありません。</exception>
      <exception cref="T:System.PlatformNotSupportedException">現在のプラットフォームはビッグ エンディアンです。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <returns>&gt;指定したメタデータ読み取り構成とエンコード構成によるメタデータ リーダー。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>指定した Relative Virtual Address (RVA) でメソッドの本体ブロックを返します。</summary>
      <param name="peReader">現在の <see cref="T:System.Reflection.PortableExecutable.PEReader" /> インスタンス。</param>
      <param name="relativeVirtualAddress">Relative Virtual Address (RVA)。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.BadImageFormatException">本体が、メタデータに見つからないか、無効です。</exception>
      <exception cref="T:System.InvalidOperationException">メソッドが格納されているセクションを使用できません。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中に IO エラーが発生しました。</exception>
      <returns>メソッド ブロック本体インスタンス。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>
        <see cref="T:System.Reflection.Metadata.CustomAttribute" /> 値 BLOB でプリミティブ値の型をエンコードするために使用された型コードを定義する定数を指定します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>1 バイトの符号なし整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>8 バイトの浮動小数点型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>2 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>4 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>8 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>1 バイトの符号付き整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>4 バイトの浮動小数点型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>2 バイトの符号なし整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>4 バイトの符号なし整数型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>8 バイトの符号なし整数型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>メタデータ シグネチャで検出されるプリミティブ型を定義する定数を指定します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>
        <see cref="T:System.Byte" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>
        <see cref="T:System.Double" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>
        <see cref="T:System.Int16" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>
        <see cref="T:System.Int32" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>
        <see cref="T:System.Int64" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>
        <see cref="T:System.IntPtr" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>
        <see cref="T:System.Object" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>
        <see cref="T:System.SByte" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>
        <see cref="T:System.Single" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>型指定された参照。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>
        <see cref="T:System.UInt16" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>
        <see cref="T:System.UInt32" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>
        <see cref="T:System.UInt64" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>
        <see cref="T:System.UIntPtr" /> 型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>
        <see cref="T:System.Void" /> 型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>将来のコンテンツ更新用に予約されていたメタデータ ヒープ上のハンドルおよび対応する BLOB を表します。</summary>
      <typeparam name="THandle" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>コンテンツの更新に使用される <see cref="T:System.Reflection.Metadata.BlobWriter" /> を返します。</summary>
      <returns>コンテンツの更新に使用される BLOB ライター。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>予約済みの BLOB ハンドルを取得します。</summary>
      <returns>予約されている禁止ハンドル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>
        <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> BLOB の値の型をエンコードするための型コードを指定します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>属性引数は Enum インスタンスです。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>属性引数は "boxed" (型オブジェクトのパラメーター、フィールド、プロパティに渡される) であり、属性 BLOB の型情報を持ちます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>属性引数は <see cref="T:System.Type" /> インスタンスです。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" /> に等しい値。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>
        <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" /> に等しい値。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>メソッド シグネチャに適用できる追加フラグを指定します。 この型のフィールドの基になる値は、<see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体で表される先頭シグネチャ バイトの表現に対応します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>インスタンス ポインターを表す、明示的に宣言された最初のパラメーターを示します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>ジェネリック メソッド。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>インスタンス メソッド。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>フラグなし。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>与えられたシグネチャの引数が呼び出し元から呼び出し先に渡される方法を指定します。 この型のフィールドの基になる値は、<see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体で表される先頭シグネチャ バイトの表現に対応します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>アンマネージ C/C++ スタイル呼び出し規則。呼び出し履歴が呼び出し元によって消去されます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>固定長の引数一覧を含むマネージド呼び出し規則。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>アンマネージ呼び出し規則。可能な場合、レジスタで引数が渡されます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>アンマネージ呼び出し規則。呼び出し履歴が呼び出し元によって消去されます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>インスタンス メンバー関数と固定引数一覧を呼び出すためのアンマネージ C++ スタイル呼び出し規則。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary>アンマネージド呼び出し規約の詳細が modopt としてエンコードされていることを示します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>付加的な引数を渡すためのマネージド呼び出し規則。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>シグネチャ BLOB の先頭バイトにより指定されるシグネチャ特性を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>呼び出し規則またはシグネチャの種類のマスク値を取得します。 既定の <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> 値は 15 (0x0F) です。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>指定したバイト値を使用して、<see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="rawValue">バイト。</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>指定されたシグネチャの種類、呼び出し規則、シグネチャの属性を使用し、<see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="kind">シグネチャの種類。</param>
      <param name="convention">呼び出し規則</param>
      <param name="attributes">シグネチャの属性。</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>指定されたオブジェクトとこの <see cref="T:System.Reflection.Metadata.SignatureHeader" /> を比較し、等しさを調べます。</summary>
      <param name="obj">比較対象のオブジェクト。</param>
      <returns>オブジェクトが等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>2 つの <see cref="T:System.Reflection.Metadata.SignatureHeader" /> の値が等しいかどうかを比較します。</summary>
      <param name="other">比較する値。</param>
      <returns>両方の値が等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>現在のオブジェクトのハッシュ コードを取得します。</summary>
      <returns>現在のオブジェクトのハッシュ コード。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>2 つの <see cref="T:System.Reflection.Metadata.SignatureHeader" /> の値が等しいかどうかを比較します。</summary>
      <param name="left">比較する最初の値です。</param>
      <param name="right">比較する 2 番目の値です。</param>
      <returns>両方の値が等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>2 つの <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 値が等しくないかどうかを判断します。</summary>
      <param name="left">比較する最初の値です。</param>
      <param name="right">比較する 2 番目の値です。</param>
      <returns>値が等しくない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>現在のオブジェクトを表す文字列を返します。</summary>
      <returns>現在のオブジェクトを表す文字列。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>シグネチャの属性を取得します。</summary>
      <returns>属性。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>呼び出し規約を取得します。</summary>
      <returns>呼び出し規則</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>この <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体に <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> シグネチャ属性があるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" />
        <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" />属性が存在する場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>この <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体に <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> シグネチャ属性があるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" />
        <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" />属性が存在する場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>この <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体に <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> シグネチャ属性があるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" />
        <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" />属性が存在する場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>シグネチャの種類を取得します。</summary>
      <returns>シグネチャの種類。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>ヘッダー バイトの生の値を取得します。</summary>
      <returns>ヘッダーバイトの生の値。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>シグネチャの種類を指定します。 この型のフィールドの基になる値は、<see cref="T:System.Reflection.Metadata.SignatureHeader" /> 構造体で表される先頭シグネチャ バイトの表現に対応します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>フィールド シグネチャ。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>ローカル変数シグネチャ。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>メソッド参照、メソッド定義、スタンドアロン メソッド シグネチャ。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>メソッド仕様シグネチャ。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>プロパティ シグネチャ。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>シグネチャ エンコードで使用される型コードを定義する定数を指定します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>シグネチャの汎用 <see cref="T:System.Array" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>シグネチャの <see cref="T:System.Boolean" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>シグネチャのマネージド ポインター (ByRef の戻り値とパラメーター) を表します。 BLOB では、これに基になる型のシグネチャ エンコードが続きます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>シグネチャの <see cref="T:System.Byte" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>シグネチャの <see cref="T:System.Char" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>シグネチャの <see cref="T:System.Double" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>シグネチャの関数ポインターの型を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>シグネチャ内で使用されるジェネリック メソッド パラメーターを表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>シグネチャのジェネリック型のインスタンス化を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>シグネチャ内で使用されるジェネリック型パラメーターを表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>シグネチャの <see cref="T:System.Int16" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>シグネチャの <see cref="T:System.Int32" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>シグネチャの <see cref="T:System.Int64" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>シグネチャの <see cref="T:System.IntPtr" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>無効であるか、初期化されていない型コードを表します。 有効なシグネチャには表示されません。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>シグネチャの <see cref="T:System.Object" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>呼び出し元が無視できるシグネチャ内の型に適用されるカスタム修飾子を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>ガベージ コレクターでピン留めされるローカル変数を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>シグネチャのアンマネージ ポインターを表します。 BLOB では、これに基になる型のシグネチャ エンコードが続きます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>呼び出し元が認識する必要がある、シグネチャ内の型に適用されるカスタム修飾子を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>シグネチャの <see cref="T:System.SByte" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>固定引数の終わりと変数引数の始まりを示すマーカーを表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>シグネチャの <see cref="T:System.Single" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>シグネチャの <see cref="T:System.String" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>下限が 0 の単次元 <see cref="T:System.Array" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>シグネチャの型指定された参照を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>シグネチャの型 <see cref="T:System.Reflection.Metadata.EntityHandle" /> に優先します。 未処理のメタデータでは、参照型の場合 ELEMENT_TYPE_CLASS (0x12)、値の型の場合 ELEMENT_TYPE_VALUETYPE (0x11) としてエンコードされます。 Windows ランタイムのプロジェクションはクラスから値の型へ (またはその逆に) 投影でき、未処理のコードはそのような場合に誤解を招くため、これは 1 つのコードに折りたたまれます。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>シグネチャの <see cref="T:System.UInt16" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>シグネチャの <see cref="T:System.UInt32" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>シグネチャの <see cref="T:System.UInt64" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>シグネチャの <see cref="T:System.UIntPtr" /> を表します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>シグネチャの <see cref="T:System.Void" /> を表します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>シグネチャの型定義を示します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>型定義または型参照はクラスを参照します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>型参照または型定義がクラスか値の型ではない場合、現在のコンテキストでは認識されません。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>型定義または型参照は値の型を参照します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>シグネチャの種類を判断します。<see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> または <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" /> の可能性があります。</summary>
      <exception cref="T:System.BadImageFormatException">シグネチャは無効です。</exception>
      <returns>シグネチャの種類を示す列挙値。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>シグネチャ BLOB へのハンドルを取得します。</summary>
      <returns>署名 blob へのハンドル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> がスタンドアロン メソッドを表すのか、ローカル変数シグネチャを表すのかを示します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> はローカル変数シグネチャを参照します。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> はスタンドアロン メソッド シグネチャを表します。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>指定した入れ子にされた型の外側の型を返します。</summary>
      <returns>指定した入れ子にされた型の外側の型、または型が入れ子にされていない場合に <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> プロパティが <see langword="true" /> であるハンドル。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>指定した型に入れ子にされた型の配列を返します。</summary>
      <returns>指定した型に入れ子にされた型を表す型定義ハンドルの変更できない配列。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>型定義の基本型を取得します。<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、または <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> のいずれかです。</summary>
      <returns>型定義の基本型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>これが入れ子にされた型であるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> 入れ子にされた型の場合は <see langword="false" /> 。それ以外の場合は。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>型の名前を取得します。</summary>
      <returns>型の名前。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>型が定義されている名前空間の完全名を取得します。</summary>
      <returns>型が定義されている名前空間の完全名。または、 <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /> 型が <see langword="true" /> 入れ子になっているか、ルート名前空間で定義されている場合は、プロパティがであるハンドル。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>型が定義されている名前空間の定義ハンドルを取得します。</summary>
      <returns>型が定義されている名前空間の定義ハンドル <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /><see langword="true" />  。型が入れ子になっているかルート名前空間で定義されている場合は、プロパティがであるハンドル。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> インスタンスのコレクションを格納します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>対象の型の名前を取得します。</summary>
      <returns>対象の型の名前。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>対象の型が定義されている名前空間の完全名を取得します。</summary>
      <returns>ターゲットの型が定義されている名前空間の完全名。型が入れ子になって <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /><see langword="true" /> いるかルート名前空間で定義されている場合は、プロパティがであるハンドル。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>対象の型が定義され、指定した <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> と <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> によって一意に識別される解決スコープを取得します。</summary>
      <returns>対象の型が一意に定義される解決スコープ。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>
        <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> インスタンスのコレクションを格納します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションの反復処理に使用できる列挙子。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>コレクションを反復処理する列挙子を返します。</summary>
      <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary>コレクション内の要素の数を取得します。</summary>
      <returns>コレクション内の要素の数です。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary>列挙子をコレクションの次の要素に進めます。</summary>
      <returns>列挙子が次の要素に正常に進んだ場合は <see langword="true" />。列挙子がコレクションの末尾を越えた場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>列挙子を初期位置、つまりコレクションの最初の要素の前に設定します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>列挙子の現在位置にあるコレクション内の要素を取得します。</summary>
      <returns>コレクション内の、列挙子の現在位置にある要素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>ユーザー文字列ヒープへのハンドルを表します。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary>現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。</summary>
      <param name="other">このオブジェクトと比較するオブジェクト。</param>
      <returns>現在のオブジェクトが <paramref name="other" /> パラメーターと等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>
        <para>イベントのハンドラーを追加するために使用されます。 Ecma 335 CLI 仕様の <see langword="AddOn" /> フラグに対応します。</para>
        <para>CLS に準拠している adder には、<see langword="add_" /> プレフィックスを使用した名前が付けられます。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>
        <para>プロパティの値を読み取ります。</para>
        <para>CLS に準拠している getter には、get_ プレフィックスを使用した名前が付けられます。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>プロパティ用のその他のメソッド (getter、setter のいずれでもない) またはイベント用のその他のメソッド (adder、remover、raiser のいずれでもない)。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>
        <para>イベントが発生したことを示すために使用されます。 Ecma 335 CLI 仕様の <see langword="Fire" /> フラグに対応します。</para>
        <para> CLS に準拠している raiser には、<see langword="raise_" /> プレフィックスを使用した名前が付けられます。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>
        <para>イベントのハンドラーを削除するために使用されます。 Ecma 335 CLI 仕様の <see langword="RemoveOn" /> フラグに対応します。</para>
        <para>CLS に準拠している remover には、<see langword="remove_" /> プレフィックスを使用した名前が付けられます。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>
        <para>プロパティの値を変更するために使用されます。</para>
        <para>CLS 準拠にしている setter には、<see langword="set_" /> プレフィックスを使用した名前が付けられます。</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>プログラム デバッグ データベース (PDB) ファイルに関する情報を提供します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>PDB の反復。 最初の反復は 1 です。 反復は、PDB コンテンツが拡張されるたびにインクリメントされます。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>関連する PDB のグローバル一意識別子 (GUID) を取得します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>PE/COFF ファイルに関するデバッグ情報を格納している .pdb ファイルへのパス。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>COFF ファイルのヘッダーを表します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>ファイルの属性を示すフラグを取得します。</summary>
      <returns>ファイルの属性を示すフラグ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>ターゲット コンピューターの型を取得します。</summary>
      <returns>ターゲットコンピューターの種類。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>セクション数を取得します。 これは、ヘッダーのすぐ後に続くセクション テーブルのサイズを示します。</summary>
      <returns>セクションの数。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>シンボル テーブル内のエントリの数を取得します。 このデータを使用すれば、シンボル テーブルのすぐ後に続く文字列テーブルを検索することができます。 PE イメージの場合、この値は 0 とする必要があります。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>COFF シンボル テーブルへのファイル ポインターを取得します。</summary>
      <returns>COFF シンボルテーブルへのファイルポインター。 COFF シンボルテーブルが存在しない場合は0。 PE イメージの場合、この値は 0 とする必要があります。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>オプションのヘッダーのサイズを取得します。これは、実行可能ファイルでは必須ですが、オブジェクト ファイルには必要ありません。 オブジェクト ファイルの場合、この値は 0 とする必要があります。</summary>
      <returns>省略可能なヘッダーのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>ファイルが作成された日時を示す値を取得します。</summary>
      <returns>ファイルが作成された日時を示す、1970の00:00 年1月1日からの経過秒数の下位32ビット。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary>COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>CodeView エントリを追加します。</summary>
      <param name="pdbPath">PDB へのパス。 空にしないでください。</param>
      <param name="pdbContentId">PDB コンテンツの一意の ID。</param>
      <param name="portablePdbVersion">ポータブル PDB 形式のバージョン (例: 1.0 の場合は 0x0100)。PDB がポータブルでない場合は 0。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> に NUL 文字が含まれています。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> が 0x0100 未満です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>埋め込みポータブル PDB エントリを追加します。</summary>
      <param name="debugMetadata">ポータブル PDB メタデータ ビルダー。</param>
      <param name="portablePdbVersion">ポータブル PDB 形式のバージョン (例: 1.0 の場合は 0x0100)。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> が 0x0100 未満です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>指定された種類のエントリを追加します。</summary>
      <param name="type">エントリの種類。</param>
      <param name="version">エントリのバージョン。</param>
      <param name="stamp">エントリのスタンプ。</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>指定された種類のエントリを追加し、そのデータをシリアル化します。</summary>
      <param name="type">エントリの種類。</param>
      <param name="version">エントリのバージョン。</param>
      <param name="stamp">エントリのスタンプ。</param>
      <param name="data">
        <paramref name="dataSerializer" /> に渡されるデータ。</param>
      <param name="dataSerializer">
        <see cref="T:System.Reflection.Metadata.BlobBuilder" /> にデータをシリアル化するためのシリアライザー。</param>
      <typeparam name="TData">に渡されるデータの型 <paramref name="dataSerializer" /> 。</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>PDB チェックサム エントリを追加します。</summary>
      <param name="algorithmName">ハッシュ アルゴリズム名 (たとえば、"SHA256")。</param>
      <param name="checksum">チェックサム。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> または <paramref name="checksum" /> が <see langword="null" /> です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> または <paramref name="checksum" /> が空です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>再現可能なエントリを追加します。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>デバッグ情報のブロックの場所、サイズ、および形式を識別します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>デバッグ データへのファイル ポインターを取得します。</summary>
      <returns>デバッグデータへのファイルポインター。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>読み込み時に、イメージ ベースに相対的なデバッグ データのアドレスを取得します。</summary>
      <returns>イメージベースを基準としたデバッグデータのアドレス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>デバッグ データのサイズを取得します (デバッグ ディレクトリ自体は含まれません)。</summary>
      <returns>デバッグデータのサイズ (デバッグディレクトリを除く)。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>エントリがポータブル PDB をポイントする <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> エントリであるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> エントリが <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> ポータブル PDB を指すエントリである場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>デバッグ データ形式のメジャー バージョン番号を取得します。</summary>
      <returns>デバッグデータ形式のメジャーバージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>デバッグ データ形式のマイナー バージョン番号を取得します。</summary>
      <returns>デバッグデータ形式のマイナーバージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>PE/COFF ファイルが決定論的でない場合に、デバッグ データが作成された日時を取得します。それ以外の場合は、コンテンツのハッシュに基づいて値を取得します。</summary>
      <returns>非決定的な PE/COFF ファイルの場合は、デバッグデータが作成された日時。それ以外の場合は、コンテンツのハッシュに基づく値。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>デバッグ情報の形式を取得します。</summary>
      <returns>デバッグ情報の形式。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> のデバッグ情報の形式を記述する列挙体。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>関連付けされた PDB ファイルに関する説明。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>COFF デバッグ情報 (行番号、シンボル テーブル、および文字列テーブル)。 この種のデバッグ情報はまた、ファイル ヘッダー内のフィールドによって指し示されます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>
        <para>エントリは、埋め込みポータブル PDB を含む BLOB を指しています。 埋め込みポータブル PDB の BLOB の形式は次のとおりです。</para>
        <para>- blob ::= uncompressed-size data</para>
        <para>- データは、BLOB の残りの部分にまたがり、Deflate で圧縮されたポータブル PDB を含みます。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>このエントリには、PE/COFF ファイルのビルド時に使用されたシンボル ファイルの内容の暗号化ハッシュが格納されます。 このハッシュを使用すれば、特定の PDB ファイルが PE/COFF ファイルを使用してビルドされていて、いかなる方法でも変更されていないことを確認できます。 PE/COFF ファイルのビルド中に複数の PDB が生成された場合 (プライベート シンボルやパブリック シンボルなど)、複数のエントリが存在する可能性があります。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>このエントリの存在は、決定論的な PE/COFF ファイルを示しています。 詳細については、次の「解説」を参照してください。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>すべてのツールで無視する必要がある不明な値。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>ダイナミック リンク ライブラリの特性について説明します。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>イメージは、AppContainer 内で実行する必要があります。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>DLL は再配置することができます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>イメージでは、エントロピが高い 64 ビットの仮想アドレス空間を処理できます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>このイメージはバインドしないでください。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>イメージでは分離性が認識されますが、それを必要とはしません。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>イメージでは SEH は使用されません。 このイメージに SE ハンドラーを配置することはできません。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>イメージは NX と互換性があります。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>予約済み。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>予約済み。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>イメージは、ターミナル サーバー対応です。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>予約済み。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>予約済み。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>ドライバーでは WDM モデルが使用されます。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>ターゲット コンピューターの CPU アーキテクチャを指定します。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>アルファ。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM リトル エンディアン。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 リトル エンディアン。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI バイト コード。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R リトル エンディアン。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>FPU を使用した MIPS。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>FPU を使用した MIPS16。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC リトル エンディアン。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 リトル エンディアン。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 リトル エンディアン。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 リトル エンディアン。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>ターゲット CPU が不明であるか、または指定されていません。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS リトルエンディアン WCE v2。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>PDB チェックサム デバッグ ディレクトリ エントリを表します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>チェックサムの計算に使用される暗号ハッシュ アルゴリズムの名前。</summary>
      <returns>チェックサムの計算に使用される暗号ハッシュアルゴリズムの名前を表す文字列。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>PDB コンテンツのチェックサム。</summary>
      <returns>PDB コンテンツのチェックサムを表す、変更できないバイト配列。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>PE ディレクトリをビルドします。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" /> クラスのインスタンスを初期化します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>PE ファイルがメモリに読み込まれるときに、イメージ ベースに相対的なエントリ ポイントのアドレス。</summary>
      <returns>プログラムイメージの場合は、開始アドレスです。 デバイスドライバーの場合、これは初期化関数のアドレスです。 Dll のエントリポイントは省略可能です。 エントリポイントが存在しない場合、このフィールドは0である必要があります。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>ベース再配置テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>バインドされたインポートのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>著作権/アーキテクチャのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>COM 記述子テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>デバッグ テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>遅延インポート テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>例外テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>エクスポート テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>グローバル ポインター テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>インポート アドレス テーブル (IAT) のイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>インポート テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>読み込み構成テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>リソース テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>スレッド ローカル ストレージ (TLS) テーブルのイメージ ディレクトリ エントリ。</summary>
      <returns>ディレクトリエントリのインスタンス。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>PE ファイルがメモリに読み込まれるときに、イメージ ベースに相対的なエントリ ポイントのアドレスを取得します。</summary>
      <returns>イメージベースを基準としたエントリポイントのアドレス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>イメージがメモリに読み込まれるときに、イメージ ベースに相対的なコードの先頭セクションのアドレスを取得します。</summary>
      <returns>イメージベースを基準とした、コードの先頭セクションのアドレス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>イメージがメモリに読み込まれるときに、イメージ ベースに相対的なデータの先頭セクションのアドレスを取得します。</summary>
      <returns>イメージベースを基準とした、データの先頭セクションのアドレス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>属性証明書のテーブルを指す証明書テーブル エントリを取得します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>イメージ ファイルのチェックサムを取得します。</summary>
      <returns>イメージファイルのチェックサム。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>イメージ ファイル内のセクションの生データを揃えるために使用される配置係数 (バイト単位) を取得します。</summary>
      <returns>512 ~ 64K の2の累乗。 既定値は 512 です。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>イメージがメモリに読み込まれるときに、イメージの最初のバイトの優先アドレスを取得します。</summary>
      <returns>推奨アドレス。64K の倍数です。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>イメージ ファイルの形式を識別する値を取得します。</summary>
      <returns>イメージファイルの形式。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>イメージのメジャー バージョン番号を取得します。</summary>
      <returns>イメージのメジャー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>リンカーのメジャー バージョン番号を取得します。</summary>
      <returns>リンカーのメジャー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>必要なオペレーティング システムのメジャー バージョン番号を取得します。</summary>
      <returns>必要なオペレーティング システムのメジャー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>サブアセンブリのメジャー バージョン番号を取得します。</summary>
      <returns>サブアセンブリのメジャー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>イメージのマイナー バージョン番号を取得します。</summary>
      <returns>イメージのマイナー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>リンカーのマイナー バージョン番号を取得します。</summary>
      <returns>リンカーのマイナー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>必要なオペレーティング システムのマイナー バージョン番号を取得します。</summary>
      <returns>必要なオペレーティング システムのマイナー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>サブシステムのマイナー バージョン番号を取得します。</summary>
      <returns>サブアセンブリのマイナー バージョン番号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> の残りの部分にあるデータ ディレクトリ エントリの数を取得します。 それぞれによって、場所とサイズが記述されます。</summary>
      <returns>の残りの部分にあるデータディレクトリエントリの数 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>セクションがメモリに読み込まれるときにその配置 (バイト単位) を取得します。</summary>
      <returns>以上の数値 <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> 。 既定値は、アーキテクチャのページ サイズです。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>コード (テキスト) セクションのサイズを取得、またはセクションが複数ある場合はすべてのコード セクションの合計を取得します。</summary>
      <returns>コード (テキスト) セクションのサイズ。複数のセクションがある場合は、すべてのコードセクションの合計。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>FileAlignment の倍数に切り上げられた、MS DOS スタブ、PE ヘッダー、およびセクション ヘッダーの合計サイズを取得します。</summary>
      <returns>MS DOS スタブ、PE ヘッダー、セクションヘッダーの合計サイズを、FileAlignment の倍数に切り上げた値。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>コミットするローカル ヒープ領域のサイズを取得します。</summary>
      <returns>コミットするローカルヒープ領域のサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>予約するローカル ヒープ領域のサイズを取得します。 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" /> のみがコミットされます。残りは、予約サイズに達するまで、一度に 1 ページずつ使用できるようになります。</summary>
      <returns>予約するローカル ヒープ領域のサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>イメージがメモリに読み込まれるときに、すべてのヘッダーを含む、イメージのサイズ (バイト単位) を取得します。</summary>
      <returns>イメージのサイズ (バイト単位)。これはの倍数です <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>初期化されたデータ セクションのサイズを取得、またはデータ セクションが複数ある場合は、そのようなすべてのセクションの合計を取得します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>コミットするスタックのサイズを取得します。</summary>
      <returns>コミットするスタックのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>予約するスタックのサイズを取得します。 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" /> のみがコミットされます。残りは、予約サイズに達するまで、一度に 1 ページずつ使用できるようになります。</summary>
      <returns>予約するスタックのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>初期化されていないデータ セクション (BSS) のサイズを取得、または BSS セクションが複数ある場合は、そのようなすべてのセクションの合計を取得します。</summary>
      <returns>初期化されていないデータセクション (BSS) のサイズまたはすべてのセクションの合計。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>このイメージを実行するために必要なサブシステムの名前を取得します。</summary>
      <returns>このイメージを実行するために必要なサブシステムの名前。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>移植可能な実行可能 (PE) ファイルのヘッダーを定義します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> クラスの新しいインスタンスを初期化します。</summary>
      <param name="machine">ターゲット マシンの CPU アーキテクチャ。</param>
      <param name="sectionAlignment">セクションがメモリに読み込まれるときのその配置 (バイト単位)。 <paramref name="fileAlignment" /> 以上である必要があります。 既定値は、アーキテクチャのページ サイズです。</param>
      <param name="fileAlignment">イメージ ファイル内のセクションの生データを揃えるために使用される配置係数 (バイト単位)。 値は、512 - 64K (その値を含む) の 2 の累乗にする必要があります。 既定値は 512 です。 <paramref name="sectionAlignment" /> がアーキテクチャのページ サイズより小さい場合、<paramref name="fileAlignment" /> は <paramref name="sectionAlignment" /> と一致する必要があります。</param>
      <param name="imageBase">イメージがメモリに読み込まれるときに、イメージの最初のバイトの優先アドレス。64K の倍数である必要があります。</param>
      <param name="majorLinkerVersion">リンカーのメジャー バージョン番号。</param>
      <param name="minorLinkerVersion">リンカーのマイナー バージョン番号。</param>
      <param name="majorOperatingSystemVersion">必要なオペレーティング システムのメジャー バージョン番号。</param>
      <param name="minorOperatingSystemVersion">必要なオペレーティング システムのマイナー バージョン番号。</param>
      <param name="majorImageVersion">イメージのメジャー バージョン番号。</param>
      <param name="minorImageVersion">イメージのマイナー バージョン番号。</param>
      <param name="majorSubsystemVersion">サブアセンブリのメジャー バージョン番号。</param>
      <param name="minorSubsystemVersion">サブアセンブリのマイナー バージョン番号。</param>
      <param name="subsystem">イメージを実行するために必要なサブシステム。</param>
      <param name="dllCharacteristics">ダイナミック リンク ライブラリの特性を記述するオブジェクト。</param>
      <param name="imageCharacteristics">イメージの特性を記述するオブジェクト。</param>
      <param name="sizeOfStackReserve">予約するスタックのサイズ。 <paramref name="sizeOfStackCommit" /> のみがコミットされます。残りは、予約サイズに達するまで、一度に 1 ページずつ使用できるようになります。</param>
      <param name="sizeOfStackCommit">コミットするスタックのサイズ。</param>
      <param name="sizeOfHeapReserve">予約するローカル ヒープ領域のサイズ。 <paramref name="sizeOfHeapCommit" /> のみがコミットされます。残りは、予約サイズに達するまで、一度に 1 ページずつ使用できるようになります。</param>
      <param name="sizeOfHeapCommit">コミットするローカル ヒープ領域のサイズ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> は、512 - 64K の 2 の累乗ではありません。
- または -

<paramref name="sectionAlignment" /> は 2 の累乗ではありません。

- または -

<paramref name="sectionAlignment" /> は <paramref name="fileAlignment" /> より小さい値です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>実行可能なヘッダーを作成します。</summary>
      <returns>実行可能なヘッダーを表す <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> インスタンス。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>ライブラリ ヘッダーを作成します。</summary>
      <returns>ライブラリ ヘッダーを表す <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> インスタンス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>動的リンカー ライブラリの特性を返します。</summary>
      <returns>動的リンカーライブラリの特性を記述するオブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>イメージ ファイル内のセクションの生データを揃えるために使用される配置係数 (バイト単位)。 値は、512 - 64K (その値を含む) の 2 の累乗にする必要があります。 既定値は 512 です。 セクションの配置がアーキテクチャのページ サイズよりも小さい場合は、ファイルの配置がセクションの配置と一致している必要があります。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>イメージがメモリに読み込まれるときに、イメージの最初のバイトの優先アドレス。64K の倍数である必要があります。</summary>
      <returns>メモリに読み込まれるときに、イメージの最初のバイトの優先アドレスを表す数値。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>イメージの特性を返します。</summary>
      <returns>イメージの特性を表すオブジェクト。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>ターゲット マシンの CPU アーキテクチャ。</summary>
      <returns>異なる CPU アーキテクチャを表す列挙値の1つ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>イメージのメジャー バージョン番号。</summary>
      <returns>
        <see cref="T:System.UInt16" />画像のメジャーバージョン番号を表すのサイズです。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>リンカーのメジャー バージョン番号。</summary>
      <returns>
        <see cref="T:System.Byte" />リンカーのメジャーバージョン番号を表すのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>必要なオペレーティング システムのメジャー バージョン番号。</summary>
      <returns>
        <see cref="T:System.UInt16" />必要なオペレーティングシステムのメジャーバージョン番号を表すのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>サブアセンブリのメジャー バージョン番号。</summary>
      <returns>
        <see cref="T:System.UInt16" />サブシステムのメジャーバージョン番号を表すのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>イメージのマイナー バージョン番号。</summary>
      <returns>
        <see cref="T:System.UInt16" />イメージのマイナーバージョン番号を表すのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>リンカーのマイナー バージョン番号。</summary>
      <returns>
        <see cref="T:System.Byte" />リンカーのマイナーバージョン番号を表すのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>必要なオペレーティング システムのマイナー バージョン番号。</summary>
      <returns>
        <see cref="T:System.UInt16" />必要なオペレーティングシステムのマイナーバージョン番号を表すのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>サブアセンブリのマイナー バージョン番号。</summary>
      <returns>
        <see cref="T:System.UInt16" />サブシステムのマイナーバージョン番号を表すのサイズ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>セクションがメモリに読み込まれるときのその配置 (バイト単位)。</summary>
      <returns>メモリに読み込まれるときのセクションの配置 (バイト単位) を表す数値。 ファイルの配置と同じかそれ以上である必要があります。 既定値は、アーキテクチャのページ サイズです。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>コミットするローカル ヒープ領域のサイズ。</summary>
      <returns>コミットするローカルヒープ領域のサイズを表す数値。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>予約するローカル ヒープ領域のサイズ。 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" /> のみがコミットされます。残りは、予約サイズに達するまで、一度に 1 ページずつ使用できるようになります。</summary>
      <returns>予約するローカルヒープ領域のサイズを表す数値。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>コミットするスタックのサイズ。</summary>
      <returns>コミットするスタックのサイズを表す数値。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>予約するスタックのサイズ。 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" /> のみがコミットされます。残りは、予約サイズに達するまで、一度に 1 ページずつ使用できるようになります。</summary>
      <returns>予約するスタックのサイズを表す数値。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>このイメージを実行するために必要なサブシステム。</summary>
      <returns>
        <see cref="T:System.Reflection.PortableExecutable.Subsystem" /> のインスタンス。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>ストリームから PE (移植可能な実行可能ファイル) ヘッダーおよび COFF (Common Object File Format) ヘッダーを読み取る型を定義します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>指定したストリーム内の現在位置から PE ヘッダーを読み取る <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> クラスの新しいインスタンスをインスタンス化します。</summary>
      <param name="peStream">ストリームの現在位置で開始し、ストリームの末尾で終了する PE イメージを含むストリーム。</param>
      <exception cref="T:System.BadImageFormatException">ストリームから読み取られたデータの形式が無効です。</exception>
      <exception cref="T:System.IO.IOException">ストリームからの読み取り中のエラー。</exception>
      <exception cref="T:System.ArgumentException">ストリームではシーク操作がサポートされていません。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>指定されたサイズの PE イメージを表すストリームから PE ヘッダーを読み取る <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> クラスの新しいインスタンスをインスタンス化します。</summary>
      <param name="peStream">現在の位置から始まる指定されたサイズの PE イメージを含むストリーム。</param>
      <param name="size">PE イメージのサイズです。</param>
      <exception cref="T:System.BadImageFormatException">ストリームから読み取られたデータの形式が無効です。</exception>
      <exception cref="T:System.IO.IOException">ストリームからの読み取り中のエラー。</exception>
      <exception cref="T:System.ArgumentException">ストリームではシーク操作がサポートされていません。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> が負の値であるか、ストリームの末尾を超えています。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>指定されたサイズの PE イメージを表すと共に PE イメージがメモリに読み込まれているかどうかを示すストリームから PE ヘッダーを読み取る <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> クラスの新しいインスタンスをインスタンス化します。</summary>
      <param name="peStream">現在の位置から始まる指定されたサイズの PE イメージを含むストリーム。</param>
      <param name="size">PE イメージのサイズです。</param>
      <param name="isLoadedImage">OS ローダーによって PE イメージがメモリに読み込まれている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
      <exception cref="T:System.BadImageFormatException">ストリームから読み取られたデータの形式が無効です。</exception>
      <exception cref="T:System.IO.IOException">ストリームからの読み取り中のエラー。</exception>
      <exception cref="T:System.ArgumentException">ストリームではシーク操作がサポートされていません。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> が負の値であるか、ストリームの末尾を超えています。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>指定された相対仮想アドレスを含むセクションを求めて PE イメージのセクションを検索します。</summary>
      <param name="relativeVirtualAddress">検索対象の相対仮想アドレス。</param>
      <returns>
        <paramref name="relativeVirtualAddress" /> を含むセクションのインデックス。検索が失敗した場合は -1。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>イメージの先頭から、指定されたディレクトリ データまでのオフセット (バイト単位) を取得します。</summary>
      <param name="directory">PE ディレクトリ エントリ。</param>
      <param name="offset">メソッドから制御が戻るときに、イメージの先頭から、指定されたディレクトリ データまでのオフセットを含めます。</param>
      <returns>ディレクトリ データが見つかった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>イメージの COFF ヘッダーを取得します。</summary>
      <returns>イメージの COFF ヘッダー。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>PE イメージの先頭から COFF ヘッダーの先頭までのバイト オフセットを取得します。</summary>
      <returns>PE イメージの先頭から COFF ヘッダーの先頭までのバイトオフセット。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>COR ヘッダーを取得します。</summary>
      <returns>COR ヘッダー <see langword="null" /> 。イメージに含まれていない場合は。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>イメージの先頭から COR ヘッダーまでのバイト オフセットを取得します。</summary>
      <returns>イメージの先頭から COR ヘッダーまでのバイトオフセット。イメージに COR ヘッダーがない場合は-1。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>イメージが Coff のみであるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> イメージが Coff のみの場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>イメージが Windows コンソール アプリケーションを表すかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> イメージが Windows コンソールアプリケーションの場合は、それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>イメージがダイナミック リンク ライブラリを表すかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> イメージが DLL の場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>イメージが実行可能ファイルを表すかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> イメージが実行可能な場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>CLI メタデータのサイズを取得します。</summary>
      <returns>CLI メタデータのサイズ。イメージにメタデータが含まれていない場合は0。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>PE イメージの先頭から CLI メタデータの先頭までのオフセット (バイト単位) を取得します。</summary>
      <returns>PE イメージの開始から CLI メタデータの先頭までのオフセット (バイト単位)。または、イメージにメタデータが含まれていない場合は-1。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>イメージの PE ヘッダーを取得します。</summary>
      <returns>イメージの PE ヘッダー <see langword="null" /> 。イメージが COFF のみの場合は。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>イメージの先頭からのヘッダーのバイト オフセットを取得します。</summary>
      <returns>イメージの先頭からのヘッダーのバイトオフセット。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>PE セクション ヘッダーを取得します。</summary>
      <returns>PE セクションヘッダーを格納している配列。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>ブロック全体の内容を配列に読み込みます。</summary>
      <returns>変更できないバイト配列。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>ブロックの一部の内容を配列に読み込みます。</summary>
      <param name="start">ブロック内の開始位置。</param>
      <param name="length">読み取るバイト数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">指定された範囲がブロックに含まれていません。</exception>
      <returns>変更できないバイト配列。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>ブロック全体にわたる BLOB 用に <see cref="T:System.Reflection.Metadata.BlobReader" /> を作成します。</summary>
      <returns>ブロック全体にわたる BLOB のリーダー。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>ブロックの一部にわたる BLOB 用に <see cref="T:System.Reflection.Metadata.BlobReader" /> を作成します。</summary>
      <param name="start">ブロック内の開始位置。</param>
      <param name="length">ブロックの一部に含まれるバイト数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">指定された範囲がブロックに含まれていません。</exception>
      <returns>ブロックの一部にわたる BLOB のリーダー。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>ブロックの長さを取得します。</summary>
      <returns>ブロックの長さ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>ブロックの先頭バイトへのポインターを取得します。</summary>
      <returns>ブロックの最初のバイトへのポインター。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>移植可能な実行可能 (PE) 形式ファイルのリーダーを提供します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>メモリに格納されている PE イメージに対して、移植可能な実行可能リーダーを作成します。</summary>
      <param name="peImage">PE イメージの開始へのポインター。</param>
      <param name="size">PE イメージのサイズです。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> が <see cref="F:System.IntPtr.Zero" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>メモリに格納されている PE イメージに対して、移植可能な実行可能リーダーを作成します。 フラグは、イメージが既にメモリに読み込まれているかどうかを示します。</summary>
      <param name="peImage">PE イメージの開始へのポインター。</param>
      <param name="size">PE イメージのサイズです。</param>
      <param name="isLoadedImage">OS ローダーによって PE イメージがメモリに読み込まれている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> が <see cref="F:System.IntPtr.Zero" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> が負の値です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>バイト配列に格納されている PE イメージに対して、移植可能な実行可能リーダーを作成します。</summary>
      <param name="peImage">PE イメージを表す、変更できないバイト配列。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>ストリームに格納されている PE イメージに対して、移植可能な実行可能リーダーを作成します。</summary>
      <param name="peStream">PE イメージ ストリーム。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>現在の位置から開始し、ストリームの末尾で終わるストリームに格納されている PE イメージに対して、移植可能な実行可能リーダーを作成します。</summary>
      <param name="peStream">PE イメージ ストリーム。</param>
      <param name="options">ストリームから、PE イメージのセクションを読み取る方法を指定するオプション。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" /> の値が無効です。</exception>
      <exception cref="T:System.IO.IOException">ストリームから読み取り中のエラー (データをプリフェッチする場合のみ)。</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> が指定されており、イメージの PE ヘッダーが無効です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>ストリームの現在の位置から開始する、指定されたサイズの PE イメージに対して、移植可能な実行可能リーダーを作成します。</summary>
      <param name="peStream">PE イメージ ストリーム。</param>
      <param name="options">ストリームから、PE イメージのセクションを読み取る方法を指定するオプション。</param>
      <param name="size">PE イメージ サイズ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> が負の値であるか、ストリームの末尾を超えています。</exception>
      <exception cref="T:System.IO.IOException">ストリームから読み取り中のエラー (データをプリフェッチする場合のみ)。</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> が指定されており、イメージの PE ヘッダーが無効です。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>リーダーによって割り当てられたすべてのメモリを破棄します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>PE イメージ全体が含まれている <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> オブジェクトを取得します。</summary>
      <exception cref="T:System.InvalidOperationException">PE イメージ全体は使用できません。</exception>
      <returns>PE イメージ全体が含まれているメモリ ブロック。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>CLI メタデータが含まれている PE セクションを読み込みます。</summary>
      <exception cref="T:System.InvalidOperationException">PE イメージにはメタデータが含まれていません (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> は <see langword="false" /> を返します)。</exception>
      <exception cref="T:System.BadImageFormatException">PE ヘッダーに無効なデータが含まれています。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <returns>CLI メタデータが含まれているメモリ ブロック。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>指定した相対仮想アドレスが含まれている PE セクションをメモリに読み込み、そのアドレスから開始し、含まれているセクションの末尾で終了するメモリ ブロックを返します。</summary>
      <param name="relativeVirtualAddress">読み取るデータの相対仮想アドレス。</param>
      <exception cref="T:System.BadImageFormatException">PE ヘッダーに無効なデータが含まれています。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中に IO エラーが発生しました。</exception>
      <exception cref="T:System.InvalidOperationException">PE イメージは使用できません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> が負の値です。</exception>
      <returns>
        <paramref name="relativeVirtualAddress" /> で開始し、含まれているセクションの末尾で終了するメモリ ブロック、または <paramref name="relativeVirtualAddress" /> がこの PE イメージのいずれかの PE セクション内の場所を表していない場合は空のブロック。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>指定した名前の PE セクションをメモリに読み込み、そのセクションにまたがるメモリ ブロックを返します。</summary>
      <param name="sectionName">セクションの名前。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.InvalidOperationException">PE イメージは使用できません。</exception>
      <returns>セクションにまたがるメモリ ブロック。または、指定された <paramref name="sectionName" /> のセクションがこの PE イメージ内に存在しない場合は空のブロック。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>指定されたデバッグ ディレクトリ エントリでポイントされたデータを読み取り、それを CodeView として解釈します。</summary>
      <param name="entry">デバッグ ディレクトリ エントリ インスタンス。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> は CodeView エントリではありません。</exception>
      <exception cref="T:System.BadImageFormatException">データの形式が正しくありません。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <exception cref="T:System.InvalidOperationException">PE イメージは使用できません。</exception>
      <returns>コード ビューのデバッグ ディレクトリ データ インスタンス。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>すべてのデバッグ ディレクトリ テーブル エントリを読み取ります。</summary>
      <exception cref="T:System.BadImageFormatException">エントリの形式が正しくありません。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <exception cref="T:System.InvalidOperationException">PE イメージは使用できません。</exception>
      <returns>デバッグ ディレクトリ テーブル エントリの配列。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>指定されたデバッグ ディレクトリ エントリでポイントされたデータを読み取り、それを埋め込まれたポータブル PDB の BLOB として解釈します。</summary>
      <param name="entry">データの読み取り元のデバッグ ディレクトリ エントリ。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> は <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" /> エントリではありません。</exception>
      <exception cref="T:System.BadImageFormatException">データの形式が正しくありません。</exception>
      <exception cref="T:System.InvalidOperationException">PE イメージは使用できません。</exception>
      <returns>ポータブル PDB イメージを読み取るためのメタデータ リーダーのプロバイダー。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>指定されたデバッグ ディレクトリ エントリでポイントされたデータを読み取り、それを PDB チェックサム エントリとして解釈します。</summary>
      <param name="entry">データの読み取り元のデバッグ ディレクトリ エントリ。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> は PDB チェックサム エントリではありません。</exception>
      <exception cref="T:System.BadImageFormatException">データの形式が正しくありません。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中の入出力エラー。</exception>
      <exception cref="T:System.InvalidOperationException">PE イメージは使用できません。</exception>
      <returns>PDB チェックサム エントリ。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>この PE イメージに関連付けられているポータブル PDB を開きます。</summary>
      <param name="peImagePath">PE イメージへのパス。 このパスは、PE ファイルが含まれているディレクトリ内で PDB ファイルを検索するために使用されます。</param>
      <param name="pdbFileStreamProvider">指定されている場合、指定されたファイル パスの <see cref="T:System.IO.Stream" /> を開くために呼び出されます。 プロバイダーは、読み取り可能でシーク可能な <see cref="T:System.IO.Stream" />、またはターゲット ファイルが存在しないか、何らかの理由で無視する必要がある場合は、<see langword="null" /> のいずれかを返す必要があります。 予期しない IO エラーが原因でファイルを開くことができない場合、プロバイダーは <see cref="T:System.IO.IOException" /> をスローする必要があります。</param>
      <param name="pdbReaderProvider">正常に終了した場合は、ポータブル PDB を読み取るために <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> の新しいインスタンスが使用されます。</param>
      <param name="pdbPath">正常に終了し、PDB がファイル内で見つかった場合は、ファイルへのパス、または PDB が PE イメージ自体に埋め込まれている場合は <see langword="null" /> が使用されます。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> または <paramref name="pdbFileStreamProvider" /> が <see langword="null" /> です。</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="pdbFileStreamProvider" /> から返されたストリームでは、読み取りとシークの操作がサポートされません。</exception>
      <exception cref="T:System.BadImageFormatException">エラーが発生したため、一致する PDB ファイルが見つかりませんでした: PE イメージまたは PDB が無効です。</exception>
      <exception cref="T:System.IO.IOException">エラーが発生したため、一致する PDB ファイルが見つかりませんでした。 PE イメージまたは PDB の読み取り中に IO エラーが発生しました。</exception>
      <returns>PE イメージに PDB が関連付けられていて、PDB が正常に開かれている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>PE イメージに CLI メタデータが含まれているかどうかを示す値を取得します。</summary>
      <exception cref="T:System.BadImageFormatException">PE ヘッダーに無効なデータが含まれています。</exception>
      <exception cref="T:System.IO.IOException">基になるストリームからの読み取り中のエラー。</exception>
      <returns>
        <see langword="true" /> PE イメージに CLI メタデータが含まれている場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>リーダーが PE イメージ全体にアクセスできるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> リーダーが PE イメージ全体にアクセスできる場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>OS ローダーによって PE イメージがメモリに読み込まれているかどうかを示す値を取得します。</summary>
      <returns>OS ローダーによって PE イメージがメモリに読み込まれている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>PE ヘッダーを取得します。</summary>
      <exception cref="T:System.BadImageFormatException">ヘッダーに無効なデータが含まれています。</exception>
      <exception cref="T:System.IO.IOException">ストリームからの読み取り中のエラー。</exception>
      <returns>この PE イメージの PE ヘッダー。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>PE イメージのセクションをストリームから読み取る方法を指定するオプションを提供します。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>既定では、<see cref="T:System.Reflection.PortableExecutable.PEReader" /> が破棄されるときに、ストリームは破棄され、PE イメージのセクションは遅れて読み取られます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>基になる PE イメージが OS ローダーによってメモリに読み込まれたことを示します。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.PEReader" /> が破棄されるとき、ストリームを開いている状態が維持されます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>イメージ全体をメモリにすぐに読み込みます。 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> が指定されていない場合、<see cref="T:System.Reflection.PortableExecutable.PEReader" />ではコンストラクターが制御を返すまでにストリームが自動的に閉じられます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>
        <para>メタデータ セクションをメモリにすぐに読み込みます。</para>
        <para>ファイルの他のセクションからの読み取りは許可されていません (<see cref="T:System.InvalidOperationException" /> は <see cref="T:System.Reflection.PortableExecutable.PEReader" /> によってスローされます)。</para>
        <para>
          <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> が指定されていない場合、
            <see cref="T:System.Reflection.PortableExecutable.PEReader" />ではコンストラクターが制御を返すまでにストリームが自動的に閉じられます。 基になるファイルは、<see cref="T:System.Reflection.PortableExecutable.PEReader" /> が構築された後で、閉じられ、さらに削除されることもあります。</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>PE リソース セクション ビルダーの基本クラスを定義します。 ネイティブ リソース用のシリアル化ロジックを備えた <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> から派生します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>
        <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>指定されたリソースをシリアル化します。</summary>
      <param name="builder">シリアル化するデータを含む BLOB。</param>
      <param name="location">
        <paramref name="builder" /> のシリアル化先とする場所。</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>PE/COFF ファイルのセクション ヘッダーに関する情報を提供します。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>セクションの名前を取得します。</summary>
      <returns>セクションの名前。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>セクションの行番号エントリの数を取得します。</summary>
      <returns>セクションの行番号エントリの数。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>セクションの再配置エントリの数を取得します。</summary>
      <returns>セクションの再配置エントリの数。 PE イメージの場合、その値は0です。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>セクションの行番号エントリの先頭へのファイル ポインターを取得します。</summary>
      <returns>セクションの行番号エントリの先頭へのファイルポインター。 COFF 行番号がない場合は0。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>COFF ファイル内のセクションの先頭ページへのファイル ポインターを取得します。</summary>
      <returns>COFF ファイル内のセクションの最初のページへのファイルポインター。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>セクションの再配置エントリの先頭へのファイル ポインターを取得します。</summary>
      <returns>セクションの再配置エントリの先頭へのファイルポインター。 PE イメージの場合は0に設定され、再配置がない場合はに設定されます。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>セクションの特性を記述したフラグを取得します。</summary>
      <returns>セクションの特性を記述するフラグ。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>セクションのサイズ (オブジェクト ファイルの場合) またはディスク上で初期化されたデータのサイズ (イメージ ファイルの場合) を取得します。</summary>
      <returns>セクションのサイズ (オブジェクトファイルの場合) またはディスク上で初期化されたデータのサイズ (イメージファイルの場合)。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>セクションの仮想アドレスを取得します。</summary>
      <returns>セクションの仮想アドレス。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>メモリに読み込まれるときのセクションの合計サイズを取得します。</summary>
      <returns>メモリに読み込まれるときのセクションの合計サイズ。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>イメージのサブシステム要件について説明します。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>拡張ファームウェア インターフェイス (EFI) アプリケーション。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>ブート サービスを備えた EFI ドライバー。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>EFI ROM イメージ。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>ランタイム サービスを備えた EFI ドライバー。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>このイメージはサブシステムを必要としません。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>このイメージはネイティブの Win9x ドライバーです。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>このイメージは OS/2 文字サブシステムで実行されます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>このイメージは Posix 文字サブシステムで実行されます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>不明なサブシステム。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>このブート アプリケーション。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>このイメージは Windows CE サブシステムで実行されます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>このイメージは Windows 文字サブシステムで実行されます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>このイメージは、Windows GUI サブシステムで実行されます。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Xbox システム。</summary>
    </member>
  </members>
</doc>