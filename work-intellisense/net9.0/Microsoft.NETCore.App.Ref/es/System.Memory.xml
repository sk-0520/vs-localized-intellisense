<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary vsli:raw="Represents a heap-based, array-backed output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Representa un receptor de salida respaldado por matriz y basado en el montón en el que <typeparam name="T" /> se pueden escribir datos.</summary>
      <typeparam name="T" vsli:raw="The type of the items in this &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; instance.">Tipo de los elementos de esta <see cref="T:System.Buffers.ArrayBufferWriter`1" /> instancia.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with the default initial capacity.">Crea una instancia de un elemento <see cref="T:System.Buffers.ArrayBufferWriter`1" /> en la que se pueden escribir datos, con la capacidad inicial predeterminada.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with a specified initial capacity.">Crea una instancia de un elemento <see cref="T:System.Buffers.ArrayBufferWriter`1" /> en la que se pueden escribir datos, con la capacidad inicial especificada.</summary>
      <param name="initialCapacity" vsli:raw="The minimum capacity with which to initialize the underlying buffer.">Capacidad mínima con la que se va a inicializar el búfer subyacente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCapacity&quot; /&gt; is less than or equal to 0.">
        <paramref name="initialCapacity" /> es menor o igual que 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt;/&lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Notifica a <see cref="T:System.Buffers.IBufferWriter`1" /> que los elementos de <paramref name="count" /> se han escrito en la salida <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /></summary>
      <param name="count" vsli:raw="The number of items written.">Número de elementos escritos.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative.">
        <paramref name="count" /> es negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method call attempts to advance past the end of the underlying buffer.">La llamada al método intenta avanzar más allá del final del búfer subyacente.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary vsli:raw="Clears the data written to the underlying buffer.">Borra los datos escritos en el búfer subyacente.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the length specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;.">Devuelve un objeto <see cref="T:System.Memory`1" /> en el que escribir, que tiene al menos la longitud especificada por <paramref name="sizeHint" />.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">La longitud mínima solicitada del elemento <see cref="T:System.Memory`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> es negativo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; whose length is at least &lt;paramref name=&quot;sizeHint&quot; /&gt;.  If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Elemento <see cref="T:System.Memory`1" /> cuya longitud es al menos de <paramref name="sizeHint" />.  Si <paramref name="sizeHint" /> no se proporciona o es igual a 0, se devuelve un búfer no vacío.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least a specified length.">Devuelve un objeto <see cref="T:System.Span`1" /> en el que escribir, que tiene al menos una longitud especificada.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">La longitud mínima solicitada del elemento <see cref="T:System.Span`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> es negativo.</exception>
      <returns vsli:raw="A span of at least &lt;paramref name=&quot;sizeHint&quot; /&gt; in length. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Intervalo cuya longitud es de al menos <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> no se proporciona o es igual a 0, se devuelve un búfer no vacío.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary vsli:raw="Gets the total amount of space within the underlying buffer.">Obtiene la cantidad total de espacio en el búfer subyacente.</summary>
      <returns vsli:raw="The total capacity of the underlying buffer.">Capacidad total del búfer subyacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary vsli:raw="Gets the amount of available space that can be written to without forcing the underlying buffer to grow.">Obtiene la cantidad de espacio disponible que se puede escribir sin forzar el búfer subyacente para crecer.</summary>
      <returns vsli:raw="The space available for writing without forcing the underlying buffer to grow.">Espacio disponible para escritura sin forzar el crecimiento del búfer subyacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary vsli:raw="Gets the amount of data written to the underlying buffer.">Obtiene la cantidad de datos escrita en el búfer subyacente.</summary>
      <returns vsli:raw="The amount of data written to the underlying buffer.">La cantidad de datos que se escriben en el búfer subyacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Obtiene un elemento <see cref="T:System.ReadOnlyMemory`1" /> que contiene los datos que se han escrito en el búfer subyacente.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Datos escritos en el búfer subyacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Obtiene un elemento <see cref="T:System.ReadOnlySpan`1" /> que contiene los datos que se han escrito en el búfer subyacente.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Datos escritos en el búfer subyacente.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary vsli:raw="Reads bytes as primitives with specific endianness.">Lee bytes como primitivos con endian específicos.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Double" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Double" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Single" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Single" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Single" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.Single" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">Intervalo de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
      <returns vsli:raw="The big endian value.">Valor de big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
      <returns vsli:raw="The little endian value.">Valor de little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Byte&quot; /&gt; value, which effectively does nothing for a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Byte" /> especificado, lo que en la práctica no tiene ningún efecto en un valor <see cref="T:System.Byte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The passed-in value, unmodified.">Valor pasado, sin modificar.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int16&quot; /&gt; value.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Int16" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The reversed value.">Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int32&quot; /&gt; value.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Int32" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The reversed value.">Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int64&quot; /&gt; value.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.Int64" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The reversed value.">Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.SByte&quot; /&gt; value, which effectively does nothing for an &lt;see cref=&quot;T:System.SByte&quot; /&gt;.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.SByte" /> especificado, lo que en la práctica no tiene ningún efecto en un valor <see cref="T:System.SByte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The passed-in value, unmodified.">Valor pasado, sin modificar.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt16&quot; /&gt; value.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.UInt16" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The reversed value.">Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt32&quot; /&gt; value.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.UInt32" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The reversed value.">Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt64&quot; /&gt; value.">Invierte un valor primitivo al realizar un intercambio endian del valor <see cref="T:System.UInt64" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">Valor que se invertirá.</param>
      <returns vsli:raw="The reversed value.">Valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Double" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando este método realiza la devolución, incluye el valor que se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Double" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Double" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando este método realiza la devolución, incluye el valor que se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Double" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Int16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Int32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Int64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.Single" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando este método realiza la devolución, incluye el valor que se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Single" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.Single" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando este método realiza la devolución, incluye el valor que se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Single" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.UInt16" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.UInt32" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lee un valor <see cref="T:System.UInt64" /> desde el principio de un intervalo de bytes de solo lectura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">Intervalo de bytes de solo lectura que se leerá.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Cuando finaliza este método, el valor se lee fuera del intervalo de bytes de solo lectura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Double" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Double" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Double" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Double" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un valor <see cref="T:System.Int64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Single" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Single" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Single" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.Single" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt16" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt32" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el intervalo es lo suficientemente grande como para contener un <see cref="T:System.UInt64" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Double" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Double" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Int16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Int32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Int64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.Single" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.Single" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.UInt16" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.UInt32" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">Intervalo de bytes en el que se escribirá el valor, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Escribe un valor <see cref="T:System.UInt64" /> en un intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">Intervalo de bytes en el que se escribirá el valor, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">Valor que se escribirá en el intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener un valor <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary vsli:raw="Provides extension methods for &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Proporciona métodos de extensión para <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to the specified &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Copia el <see cref="T:System.Buffers.ReadOnlySequence`1" /> al <see cref="T:System.Span`1" /> especificado.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> de origen.</param>
      <param name="destination" vsli:raw="The destination &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">
        <see cref="T:System.Span`1" /> de destino.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Tipo de los elementos de <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary vsli:raw="Returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Devuelve la posición de la primera repetición de <paramref name="item" /> en <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> de origen.</param>
      <param name="value" vsli:raw="The item to find in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Elemento para buscar en el <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Tipo de los elementos de <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An object whose &lt;see cref=&quot;M:System.SequencePosition.GetInteger&quot; /&gt; method returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt;, or an object whose &lt;see langword=&quot;Nullable&amp;lt;SequencePosition&amp;gt;.HasValue&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt; .">Un objeto cuyo método <see cref="M:System.SequencePosition.GetInteger" /> devuelve la posición de la primera repetición de <paramref name="item" />, o un objeto cuya propiedad <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary vsli:raw="Converts the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to an array.">Convierte <see cref="T:System.Buffers.ReadOnlySequence`1" /> en una matriz.</summary>
      <param name="sequence" vsli:raw="The read-only sequence to convert to an array.">La secuencia de solo lectura para convertir en una matriz.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Tipo de los elementos de <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An array containing the data in the current read-only sequence.">Matriz que contiene los datos de la secuencia de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Writes the contents of &lt;paramref name=&quot;value&quot; /&gt; to &lt;paramref name=&quot;writer&quot; /&gt;.">Escribe el contenido de <paramref name="value" /> en <paramref name="writer" />.</summary>
      <param name="writer" vsli:raw="The buffer writer to which to write &lt;paramref name=&quot;value&quot; /&gt;.">El escritor de búfer donde se va a escribir <paramref name="value" />.</param>
      <param name="value" vsli:raw="The read-only span to be written to &lt;paramref name=&quot;writer&quot; /&gt;.">El intervalo de solo lectura que se escribirá en <paramref name="writer" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Tipo de los elementos de <see cref="T:System.ReadOnlySpan`1" /> .</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;writer&quot; /&gt; is shorter than &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="writer" /> es más corto que <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary vsli:raw="Represents an output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Representa un receptor de salida en el que se pueden escribir datos de <typeparamref name="T" />.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt;.">Tipo de los elementos de <see cref="T:System.Buffers.IBufferWriter`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; data items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Notifica a <see cref="T:System.Buffers.IBufferWriter`1" /> que los elementos de datos <paramref name="count" /> se han escrito en la salida <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" />.</summary>
      <param name="count" vsli:raw="The number of data items written to the &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">El número de elementos de datos que se escriben en <see cref="T:System.Span`1" /> o <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Devuelve un objeto <see cref="T:System.Memory`1" /> en el que escribir, que tiene al menos el tamaño solicitado (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;. If 0, a non-empty buffer is returned.">Longitud mínima del objeto <see cref="T:System.Memory`1" /> devuelto. Si es 0, se devuelve un búfer no vacío.</param>
      <exception cref="T:System.OutOfMemoryException" vsli:raw="The requested buffer size is not available.">El tamaño de búfer solicitado no está disponible.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Un objeto <see cref="T:System.Memory`1" /> con al menos el tamaño <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> es 0, se devuelve un búfer no vacío.</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Devuelve un objeto <see cref="T:System.Span`1" /> en el que escribir, que tiene al menos el tamaño solicitado (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Span`1&quot; /&gt;. If 0, a non-empty buffer is returned.">Longitud mínima del objeto <see cref="T:System.Span`1" /> devuelto. Si es 0, se devuelve un búfer no vacío.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Un objeto <see cref="T:System.Span`1" /> con al menos el tamaño <paramref name="sizeHint" />. Si <paramref name="sizeHint" /> es 0, se devuelve un búfer no vacío.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary vsli:raw="Represents a pool of memory blocks.">Representa un grupo de bloques de memoria.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the memory pool.">Tipo de los elementos del bloque de memoria.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary vsli:raw="Constructs a new instance of a memory pool.">Construye una nueva instancia de un grupo de memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary vsli:raw="Frees all resources used by the memory pool.">Libera todos los recursos que usa el grupo de memoria.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary vsli:raw="Frees the unmanaged resources used by the memory pool and optionally releases the managed resources.">Libera los recursos no administrados utilizados por el grupo de memoria y, de forma opcional, libera los recursos administrados.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> para liberar tanto recursos administrados como no administrados; <see langword="false" /> para liberar únicamente recursos no administrados.</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary vsli:raw="Returns a memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Devuelve un bloque de memoria capaz de contener al menos <paramref name="minBufferSize" /> elementos de T.</summary>
      <param name="minBufferSize" vsli:raw="The minimum number of elements of &lt;typeparamref name=&quot;T&quot; /&gt; that the memory pool can hold. A value of -1 returns a memory pool set to the default size for the pool.">El número mínimo de elementos de <typeparamref name="T" /> que puede contener el grupo de memoria. Un valor de -1 devuelve un grupo de memoria establecido en el tamaño predeterminado para el grupo.</param>
      <returns vsli:raw="A memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Un bloque de memoria capaz de contener al menos <paramref name="minBufferSize" /> elementos de T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary vsli:raw="Gets the maximum buffer size supported by this pool.">Obtiene el tamaño máximo del búfer admitido por este grupo.</summary>
      <returns vsli:raw="The maximum buffer size supported by this pool.">Tamaño máximo de búfer admitido por este grupo.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary vsli:raw="Gets a singleton instance of a memory pool based on arrays.">Obtiene una instancia singleton de un grupo de memoria basado en matrices.</summary>
      <returns vsli:raw="A singleton instance of a memory pool.">Instancia singleton de un bloque de memoria.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary vsli:raw="Represents a sequence that can read a sequential series of &lt;typeparamref name=&quot;T&quot; /&gt;.">Representa una secuencia que puede leer una serie secuencial de <typeparamref name="T" />.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence.">Tipo de los elementos de la secuencia de solo lectura.</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary vsli:raw="Returns an empty &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Devuelve una <see cref="T:System.Buffers.ReadOnlySequence`1" /> vacía.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from the &lt;paramref name=&quot;array&quot; /&gt;.">Crea una instancia de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <paramref name="array" />.</summary>
      <param name="array" vsli:raw="The array from which to create a read-only sequence.">Matriz desde la que se va a crear una secuencia de solo lectura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a section of an array.">Crea una instancia de un <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de una sección de una matriz.</summary>
      <param name="array" vsli:raw="The array from which to create the read-only sequence.">Matriz desde la que se va a crear la secuencia de solo lectura.</param>
      <param name="start" vsli:raw="The zero-based index of the first element in the array to include in the read-only sequence.">Índice basado en cero del primer elemento de la matriz que se va a incluir en la secuencia de solo lectura.</param>
      <param name="length" vsli:raw="The number of elements to include in the read-only sequence.">Número de elementos que se va a incluir en la secuencia de solo lectura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a linked memory list represented by start and end segments and the corresponding indexes in them.">Crea una instancia de un <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de una lista vinculada de memoria representada por segmentos de inicio y finalización y los índices correspondientes en ellos.</summary>
      <param name="startSegment" vsli:raw="The initial node of the linked memory list.">Nodo inicial de la lista de memoria vinculada.</param>
      <param name="startIndex" vsli:raw="The position to the start of the sequence inside &lt;paramref name=&quot;startSegment&quot; /&gt;.">La posición al inicio de la secuencia dentro de <paramref name="startSegment" />.</param>
      <param name="endSegment" vsli:raw="The final node of the linked memory list.">Nodo final de la lista de memoria vinculada.</param>
      <param name="endIndex" vsli:raw="The position to the end of the sequence inside &lt;paramref name=&quot;endSegment&quot; /&gt;.">La posición al final de la secuencia dentro de <paramref name="endSegment" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;startSegment&quot; /&gt; or &lt;paramref name=&quot;endSegment&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="startSegment" /> o <paramref name="endSegment" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The running index of &lt;paramref name=&quot;startSegment&quot; /&gt; is greater than the running index of &lt;paramref name=&quot;endSegment&quot; /&gt;, even though &lt;paramref name=&quot;startSegment&quot; /&gt; is different to &lt;paramref name=&quot;endSegment&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startSegment&quot; /&gt; is equal to &lt;paramref name=&quot;endSegment&quot; /&gt; but &lt;paramref name=&quot;endIndex&quot; /&gt; is smaller than &lt;paramref name=&quot;startIndex&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startIndex&quot; /&gt; is greater than the length of the underlying memory block of &lt;paramref name=&quot;startSegment&quot; /&gt;.">El índice en ejecución de <paramref name="startSegment" /> es mayor que el de <paramref name="endSegment" />, aunque <paramref name="startSegment" /> sea diferente de <paramref name="endSegment" />.

o bien

<paramref name="startSegment" /> es igual a <paramref name="endSegment" /> pero <paramref name="endIndex" /> es menor que <paramref name="startIndex" />.

o bien

<paramref name="startIndex" /> es mayor que la longitud del bloque de memoria subyacente de <paramref name="startSegment" />.</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Crea una instancia de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="A read-only block of memory of elements of type &lt;typeparamref name=&quot;T&quot; /&gt;.">Bloque de memoria de solo lectura de los elementos de tipo <typeparamref name="T" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Devuelve un enumerador sobre el <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Devuelve un enumerador sobre el <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary vsli:raw="Returns the offset of a &lt;paramref name=&quot;position&quot; /&gt; within this sequence from the start.">Devuelve el desplazamiento de una <paramref name="position" /> dentro de esta secuencia desde el inicio.</summary>
      <param name="position" vsli:raw="The &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of which to get the offset.">La <see cref="T:System.SequencePosition" /> de la que se obtendrá el desplazamiento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The position is out of range.">La posición está fuera del intervalo.</exception>
      <returns vsli:raw="The offset from the start of the sequence.">Desplazamiento desde el inicio de la secuencia.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at an &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Devuelve un nuevo <see cref="T:System.SequencePosition" /> en un <paramref name="offset" /> desde el principio de la secuencia.</summary>
      <param name="offset" vsli:raw="The offset from the start of the sequence.">Desplazamiento desde el inicio de la secuencia.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the specified &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Objeto que representa la posición de la secuencia que comienza en el valor <paramref name="offset" /> especificado desde el inicio de la secuencia.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; starting at the specified offset from the &lt;paramref name=&quot;origin&quot; /&gt; position.">Devuelve un nuevo elemento <see cref="T:System.SequencePosition" /> a partir del desplazamiento especificado desde la posición de <paramref name="origin" />.</summary>
      <param name="offset" vsli:raw="The offset from the specified &lt;paramref name=&quot;origin&quot; /&gt; sequence position.">Desplazamiento desde la posición de la secuencia de <paramref name="origin" /> especificada.</param>
      <param name="origin" vsli:raw="A sequence position representing the point from which to initiate the offset.">Posición de la secuencia que representa el punto desde el que se va a iniciar el desplazamiento.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the &lt;paramref name=&quot;offset&quot; /&gt; position of the specified &lt;paramref name=&quot;origin&quot; /&gt; position object.">Objeto que representa la posición de la secuencia que comienza en la posición <paramref name="offset" /> del objeto de posición <paramref name="origin" /> especificado.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" />, con elementos <paramref name="length" />.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <param name="length" vsli:raw="The length of the slice.">La longitud del segmento.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Un segmento que consta de <paramref name="length" /> elementos desde la instancia actual que empieza en el índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" /> y finaliza en <paramref name="end" /> (exclusivo).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <param name="end" vsli:raw="The end (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Final (exclusivo) <see cref="T:System.SequencePosition" /> del segmento.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Segmento que consta de elementos desde el índice <paramref name="start" /> hasta, pero sin incluir, la posición de secuencia <paramref name="end" /> de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified index and continuing to the end of the read-only sequence.">Forma un segmento del elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> actual que comienza en un índice especificado y continúa hasta el final de la secuencia de solo lectura.</summary>
      <param name="start" vsli:raw="The start index at which to begin this slice.">El índice de inicio en el que va a comenzar este segmento.</param>
      <returns vsli:raw="A slice starting at index &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Segmento que comienza en el índice <paramref name="start" /> y continúa hasta el final de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary vsli:raw="Forms a slice out of the given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma un segmento del <see cref="T:System.Buffers.ReadOnlySequence`1" /> proporcionado, comenzando en <paramref name="start" />, con <paramref name="length" /> elementos.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <param name="length" vsli:raw="The length of the slice.">La longitud del segmento.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Un segmento que consta de <paramref name="length" /> elementos desde la instancia actual que empieza en el índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" /> y finaliza en <paramref name="end" /> (exclusivo).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <param name="end" vsli:raw="The end (exclusive) of the slice.">Final (exclusivo) del segmento.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Segmento que consta de elementos desde el índice <paramref name="start" /> hasta, pero sin incluir, la posición de secuencia <paramref name="end" /> de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified sequence position and continuing to the end of the read-only sequence.">Forma un segmento del elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> actual que comienza en una posición de secuencia especificada y continúa hasta el final de la secuencia de solo lectura.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <returns vsli:raw="A slice starting at sequence position &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Segmento que comienza en la posición de secuencia <paramref name="start" /> y continúa hasta el final de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" />, con elementos <paramref name="length" />.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <param name="length" vsli:raw="The length of the slice.">La longitud del segmento.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Segmento que consta de elementos <paramref name="length" /> desde la instancia actual que empieza en la posición de secuencia <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" />, con elementos <paramref name="length" />.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <param name="length" vsli:raw="The length of the slice.">La longitud del segmento.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Segmento que consta de elementos <paramref name="length" /> desde la instancia actual que empieza en la posición de secuencia <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Forma un segmento del elemento actual <see cref="T:System.Buffers.ReadOnlySequence`1" /> que comienza en <paramref name="start" /> y finaliza en <paramref name="end" /> (exclusivo).</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">El <see cref="T:System.SequencePosition" /> inicial (inclusive) en el que va a comenzar este segmento.</param>
      <param name="end" vsli:raw="The ending (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">Final (exclusivo) <see cref="T:System.SequencePosition" /> del segmento.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; sequence position to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Segmento que consta de elementos desde la posición de secuencia <paramref name="start" /> hasta, pero sin incluir, la posición de secuencia <paramref name="end" /> de la secuencia actual de solo lectura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary vsli:raw="Returns a string that represents the current sequence.">Devuelve una cadena que representa la secuencia actual.</summary>
      <returns vsli:raw="A string that represents the current sequence.">Cadena que representa la secuencia actual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary vsli:raw="Tries to retrieve the next segment after &lt;paramref name=&quot;position&quot; /&gt; and returns a value that indicates whether the operation succeeded.">Intenta recuperar el siguiente segmento después de <paramref name="position" /> y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      <param name="position" vsli:raw="The current sequence position.">La posición de la secuencia actual.</param>
      <param name="memory" vsli:raw="A read-only memory span that contains the next segment after &lt;paramref name=&quot;position&quot; /&gt;.">Un intervalo de memoria de solo lectura que contiene el siguiente segmento después de <paramref name="position" />.</param>
      <param name="advance" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;position&quot; /&gt; should to the beginning of next segment; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="position" /> debe estar al principio del siguiente segmento; de lo contrario, <see langword="false" />.</param>
      <returns vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the method returned the next segment, or &lt;see langword=&quot;false&quot; /&gt; if the end of the read-only sequence was reached.">Devuelve <see langword="true" /> si el método devuelve el siguiente segmento, o <see langword="false" /> si se alcanzó el final de la secuencia de solo lectura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary vsli:raw="Gets the position at the end of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtiene la posición del final de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; from the first segment.">Obtiene el <see cref="T:System.ReadOnlyMemory`1" /> del primer segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; from the first segment.">Obtiene el <see cref="T:System.ReadOnlySpan`1" /> del primer segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; is empty.">Obtiene un valor que indica si <see cref="T:System.Buffers.ReadOnlySequence`1" /> está vacía.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; contains a single &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; segment.">Obtiene un valor que indica si el <see cref="T:System.Buffers.ReadOnlySequence`1" /> contiene un único segmento <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Si la secuencia de solo lectura está vacía; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary vsli:raw="Gets the length of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtiene la longitud de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="The length of the read-only sequence.">Longitud de la secuencia de solo lectura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary vsli:raw="Gets the position to the start of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtiene la posición al inicio de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary vsli:raw="Represents an enumerator over a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Representa un enumerador a través de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" vsli:raw="" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary vsli:raw="Initializes the enumerator.">Inicializa el enumerador.</summary>
      <param name="sequence" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to enumerate.">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> que se van a enumerar.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary vsli:raw="Moves to the next &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Se desplaza a la siguiente clase <see cref="T:System.ReadOnlyMemory`1" /> en <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the sequence has been reached.">
        <see langword="true" /> si el enumerador se ha desplazado correctamente al elemento siguiente; <see langword="false" /> si se ha alcanzado el final de la secuencia.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary vsli:raw="Gets the current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Obtiene la estructura <see cref="T:System.ReadOnlyMemory`1" /> actual.</summary>
      <returns vsli:raw="The current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Objeto <see cref="T:System.ReadOnlyMemory`1" /> actual.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary vsli:raw="Represents a linked list of &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; nodes.">Representa una lista vinculada de <see cref="T:System.ReadOnlyMemory`1" /> nodos.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence segment.">Tipo de los elementos del segmento de la secuencia de solo lectura.</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequenceSegment`1&quot; /&gt; class.">Inicializa una nueva instancia de la clase <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary vsli:raw="Gets or sets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">Obtiene o establece un valor <see cref="T:System.ReadOnlyMemory`1" /> para el nodo actual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">
        <see cref="T:System.ReadOnlyMemory`1" />Valor del nodo actual.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary vsli:raw="Gets or sets the next node.">Obtiene o establece el siguiente nodo.</summary>
      <returns vsli:raw="The next node.">Siguiente nodo.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary vsli:raw="Gets or sets the sum of node lengths before the current node.">Obtiene o establece la suma de las longitudes de nodo antes del nodo actual.</summary>
      <returns vsli:raw="The sum of node lengths before the current node.">La suma de las longitudes de nodo antes del nodo actual.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary vsli:raw="Provides methods for reading binary and text data out of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; with a focus on performance and minimal or zero heap allocations.">Proporciona métodos para leer datos binarios y de texto de <see cref="T:System.Buffers.ReadOnlySequence`1" /> con un enfoque en asignaciones de montón mínimas o nulas y en el rendimiento.</summary>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo de la secuencia de solo lectura.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; over a given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Crea un objeto <see cref="T:System.Buffers.SequenceReader`1" /> sobre una interfaz <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificada.</summary>
      <param name="sequence" vsli:raw="The read-only sequence over which to create the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt;.">Secuencia de solo lectura sobre la que se creará el elemento <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary vsli:raw="Moves the reader ahead a specified number of items.">Avanza el lector en un número especificado de elementos.</summary>
      <param name="count" vsli:raw="The number of items to advance.">Número de elementos que se va a avanzar.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary vsli:raw="Advances past consecutive instances of the given &lt;paramref name=&quot;value&quot; /&gt;.">Avanza más allá de las instancias consecutivas del elemento <paramref name="value" /> especificado.</summary>
      <param name="value" vsli:raw="The value past which the reader is to advance.">Valor más allá del cual el lector va a avanzar.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of either of two specified values.">Avanza más allá de instancias consecutivas de cualquiera de los dos valores especificados.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Primer valor que se va a omitir.</param>
      <param name="value1" vsli:raw="The second value to skip.">Segundo valor que se va a omitir.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of three specified values.">Avanza más allá de instancias consecutivas de cualquiera de los tres valores especificados.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Primer valor que se va a omitir.</param>
      <param name="value1" vsli:raw="The second value to skip.">Segundo valor que se va a omitir.</param>
      <param name="value2" vsli:raw="The third value to skip.">Tercer valor que se va a omitir.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of four specified values.">Avanza más allá de instancias consecutivas de cualquiera de los cuatro valores especificados.</summary>
      <param name="value0" vsli:raw="The first value to skip.">Primer valor que se va a omitir.</param>
      <param name="value1" vsli:raw="The second value to skip.">Segundo valor que se va a omitir.</param>
      <param name="value2" vsli:raw="The third value to skip.">Tercer valor que se va a omitir.</param>
      <param name="value3" vsli:raw="The fourth value to skip.">Cuarto valor que se va a omitir.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary vsli:raw="Skips consecutive instances of any of the specified &lt;paramref name=&quot;values&quot; /&gt;.">Omite instancias consecutivas de cualquiera de los elementos <paramref name="values" /> especificados.</summary>
      <param name="values" vsli:raw="The values to be skipped.">Valores que se van a omitir.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">Número de posiciones que el lector ha avanzado.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary vsli:raw="Moves the reader to the end of the sequence.">Mueve el lector hasta el final de la secuencia.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary vsli:raw="Checks whether a specified value is next in the sequence.">Comprueba si un valor especificado está en el siguiente lugar en la secuencia.</summary>
      <param name="next" vsli:raw="The value to compare the next items to.">Valor con el que se compararán los siguientes elementos.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de los valores de <paramref name="next" />, si se encuentran; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si los valores son los siguientes en la secuencia; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Checks whether the values specified in a read-only span are next in the sequence.">Comprueba si los valores especificados en un intervalo de solo lectura están en el siguiente lugar en la secuencia.</summary>
      <param name="next" vsli:raw="The span to compare the next items to.">Intervalo en el que se compararán los siguientes elementos.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de los valores de <paramref name="next" />, si se encuentran; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si los valores son los siguientes en la secuencia; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary vsli:raw="Moves the reader back the specified number of items.">Retrocede el lector en un número especificado de elementos.</summary>
      <param name="count" vsli:raw="The number of items.">Número de elementos.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative or greater than &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Consumed&quot; /&gt;.">
        <paramref name="count" /> es negativo o mayor que <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary vsli:raw="Searches for a specified delimiter and optionally advances past it if it is found.">Busca un delimitador especificado y, opcionalmente, avanza más allá, si se encuentra.</summary>
      <param name="delimiter" vsli:raw="The delimiter to search for.">Delimitador que se buscará.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if it is found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra el elemento <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Searches for any of a number of specified delimiters and optionally advances past the first one to be found.">Busca cualquier número de delimitadores especificados y, opcionalmente, avanza más allá del primero que se encuentre.</summary>
      <param name="delimiters" vsli:raw="The delimiters to search for.">Delimitadores que se buscarán.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to not move past the delimiter.">
        <see langword="true" /> para avanzar más allá de la primera instancia de cualquier <paramref name="delimiters" /> especificado; <see langword="false" /> para no avanzar más allá del delimitador.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the given &lt;paramref name=&quot;delimiters&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se ha encontrado cualquier <paramref name="delimiters" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary vsli:raw="Copies data from the current position to the given destination span if there is enough data to fill it.">Copia los datos desde la posición actual en el intervalo de destino especificado si hay suficientes datos para rellenar.</summary>
      <param name="destination" vsli:raw="Destination span to copy to.">Intervalo de destino para realizar la copia.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is enough data to completely fill the &lt;paramref name=&quot;destination&quot; /&gt; span; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si no hay suficientes datos para rellenar completamente el intervalo <paramref name="destination" />; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary vsli:raw="Peeks at the next value without advancing the reader.">Inspecciona el valor siguiente sin avanzar el lector.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Siguiente valor, o valor predeterminado, si está al final del lector.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> si el lector no está al final y la operación de inspección es correcta; <see langword="false" /> si está al final del lector.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary vsli:raw="Peeks at the next value at the specified offset without advancing the reader.">Inspecciona el siguiente valor en el desplazamiento especificado sin avanzar el lector.</summary>
      <param name="offset" vsli:raw="The offset from current position.">Desplazamiento desde la posición actual.</param>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Siguiente valor, o valor predeterminado, si está al final del lector.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> si el lector no está al final y la operación de inspección es correcta; <see langword="false" /> si está al final del lector.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary vsli:raw="Reads the next value and advance the reader.">Lee el siguiente valor y avanza el lector.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">Siguiente valor, o valor predeterminado, si está al final del lector.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the read operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> si el lector no está al final y la operación de lectura es correcta; <see langword="false" /> si está al final del lector.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado, omitiendo los delimitadores que van precedidos de <paramref name="delimiterEscape" />.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Delimitador que se buscará.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Valor que indica que se omitirá un elemento <paramref name="delimiter" /> inmediatamente después.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Delimitador que se buscará.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read data until the entire delimiter specified as a read-only span matches.">Intenta leer los datos hasta que coincide con el delimitador entero especificado como intervalo de solo lectura.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter" vsli:raw="A read-only span that contains one or more delimiters.">Intervalo de solo lectura que contiene uno o varios delimitadores.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado, omitiendo los delimitadores que van precedidos de <paramref name="delimiterEscape" />.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Delimitador que se buscará.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Valor que indica que se omitirá un elemento <paramref name="delimiter" /> inmediatamente después.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Delimitador que se buscará.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de <paramref name="delimiter" /> si se encuentra; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Try to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Intenta leer todo hasta el elemento <paramref name="delimiter" /> especificado.</summary>
      <param name="sequence" vsli:raw="The read data, if any.">Datos de lectura, si los hay.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">Delimitador que se buscará.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found.">
        <see langword="true" /> para avanzar más allá del elemento <paramref name="delimiter" />, si se encuentra.</param>
      <param name="span" vsli:raw="The read data, if any.">Datos de lectura, si los hay.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra <paramref name="delimiter" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Intenta leer todo hasta cualquiera de los elementos <paramref name="delimiters" /> especificados.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Delimitadores que se buscarán.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de la primera instancia encontrada de cualquier <paramref name="delimiters" /> especificado; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra alguno de los elementos <paramref name="delimiters" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Intenta leer todo hasta cualquiera de los elementos <paramref name="delimiters" /> especificados.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">El resultado que devuelve este método contiene la lectura de los datos, si los hay.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Delimitadores que se buscarán.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para avanzar más allá de la primera instancia encontrada de cualquier <paramref name="delimiters" /> especificado; en caso contrario, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se encuentra alguno de los elementos <paramref name="delimiters" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary vsli:raw="Gets the total number of &lt;typeparamref name=&quot;T&quot; /&gt; values processed by the reader.">Obtiene el número total de valores <typeparamref name="T" /> procesados por el lector.</summary>
      <returns vsli:raw="The total number of values processed by the reader.">Número total de valores procesados por el lector.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; that contains the current segment in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtiene un elemento <see cref="T:System.Span`1" /> que contiene el segmento actual en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="A span that contains the current segment in the sequence.">Intervalo que contiene el segmento actual de la secuencia.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary vsli:raw="Gets the index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Obtiene el índice en el elemento <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Índice de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary vsli:raw="Gets a value that indicates whether there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtiene un valor que indica si ya no hay más datos en <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; when there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> cuando no hay más datos en; en <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary vsli:raw="Gets the count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtiene el número de elementos en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lector.</summary>
      <returns vsli:raw="The count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Recuento de elementos de la del lector <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary vsli:raw="Gets the current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtiene la posición actual en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="The current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">La posición actual en <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary vsli:raw="Gets  the remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtiene los elementos restantes en el elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> del lector.</summary>
      <returns vsli:raw="The remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;">Los elementos restantes de la <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; for the reader.">Obtiene el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> subyacente para el lector.</summary>
      <returns vsli:raw="The underlying read-only sequence for the reader.">Secuencia subyacente de solo lectura para el lector.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtiene la parte no leída del elemento <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Parte no leída de <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Obtiene la parte no leída del elemento <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Parte no leída de <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary vsli:raw="Provides extended functionality for the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; class that allows reading of endian specific numeric values from binary data.">Proporciona funcionalidad extendida para la clase <see cref="T:System.Buffers.SequenceReader`1" /> que permite la lectura de valores numéricos específicos endian desde los datos binarios.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as big endian.">Intenta leer un <see cref="T:System.Int16" /> como big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as big endian.">Intenta leer un <see cref="T:System.Int32" /> como big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader from which to read the value.">El lector de la secuencia de bytes desde donde se leerá el valor.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as big endian.">Intenta leer un <see cref="T:System.Int64" /> como big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as little endian.">Intenta leer un <see cref="T:System.Int16" /> como little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as little endian.">Intenta leer un <see cref="T:System.Int32" /> como little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as little endian.">Intenta leer un <see cref="T:System.Int64" /> como little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">La instancia del lector de la secuencia de bytes desde donde se va a leer el valor.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Cuando el método se devuelve, el valor leído del lector de la secuencia de bytes, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> si la operación de lectura se realiza correctamente; <see langword="false" /> si no hay suficientes datos para un elemento <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary vsli:raw="Represents a standard format string without using an actual string.">Representa una cadena de formato estándar sin utilizar una cadena real.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary vsli:raw="Defines the maximum valid precision value.">Define el valor máximo de precisión válido.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary vsli:raw="Indicates that a format doesn't use a precision or that the precision is unspecified.">Indica que un formato no utiliza una precisión o que no se especifica la precisión.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; structure.">Inicializa una nueva instancia de la estructura <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol" vsli:raw="A type-specific format specifier, such as 'G', 'D', or 'X'.">Un especificador de formato específico de tipo, como "G","D" o "X".</param>
      <param name="precision" vsli:raw="An optional precision ranging from 0 to 99, or the special value &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; (the default).">Una precisión opcional comprendida entre 0 y 99, o bien el valor especial <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (predeterminado).</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;symbol&quot; /&gt; is not &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, and its value is greater than &lt;see cref=&quot;F:System.Buffers.StandardFormat.MaxPrecision&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;symbol&quot; /&gt; cannot be converted to a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">
        <paramref name="symbol" /> no es <see cref="F:System.Buffers.StandardFormat.NoPrecision" />, y su valor es mayor que <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

o bien

<paramref name="symbol" /> no se puede convertir en <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether the specified &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; is equal to the current instance.">Devuelve un valor que indica si el objeto <see cref="T:System.Buffers.StandardFormat" /> especificado es igual a la instancia actual.</summary>
      <param name="other" vsli:raw="The format to compare to the current instance.">El formato que se va a comparar con la instancia actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si las dos instancias son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the specified object is a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; object that is equal to the current instance.">Devuelve un valor que indica si el objeto especificado es un objeto <see cref="T:System.Buffers.StandardFormat" /> que equivale a la instancia actual.</summary>
      <param name="obj" vsli:raw="An object to compare to the current instance.">Objeto que se va a comparar con la instancia actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si las dos instancias son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Devuelve el código hash de esta instancia.</summary>
      <returns vsli:raw="The hash code for this instance.">Código hash de esta instancia.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are equal.">Devuelve un valor que indica si dos instancias de <see cref="T:System.Buffers.StandardFormat" /> son iguales.</summary>
      <param name="left" vsli:raw="The first format to compare.">El primer formato que se va a comparar.</param>
      <param name="right" vsli:raw="The second format to compare.">El segundo formato que se va a comparar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si las dos instancias son iguales; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary vsli:raw="Converts a character to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Convierte un carácter en una instancia <see cref="T:System.Buffers.StandardFormat" /> mediante la precisión <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol" vsli:raw="The character to convert to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; value.">EL carácter que se va a convertir en un valor <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns vsli:raw="A format with a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property equal to &lt;paramref name=&quot;symbol&quot; /&gt; and a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Un formato con una propiedad <see cref="P:System.Buffers.StandardFormat.Symbol" /> igual a <paramref name="symbol" /> y una propiedad <see cref="P:System.Buffers.StandardFormat.Precision" /> igual a <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are unequal.">Determina si dos instancias de <see cref="T:System.Buffers.StandardFormat" /> no son iguales.</summary>
      <param name="left" vsli:raw="The first format to compare.">El primer formato que se va a comparar.</param>
      <param name="right" vsli:raw="The second format to compare.">El segundo formato que se va a comparar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two formats are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si los dos formatos son distintos; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Converts a &lt;see langword=&quot;ReadOnlySpan&amp;lt;System.Char&amp;gt;&quot; /&gt; into a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Convierte un carácter <see langword="ReadOnlySpan&lt;System.Char&gt;" /> en una instancia <see cref="T:System.Buffers.StandardFormat" /> mediante la precisión <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to parse.">Un intervalo de solo lectura que contiene el carácter que se va a analizar.</param>
      <returns vsli:raw="A value whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property value is the character in &lt;paramref name=&quot;format&quot; /&gt; and whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property value is &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Un valor cuyo valor de propiedad <see cref="P:System.Buffers.StandardFormat.Symbol" /> es el carácter de <paramref name="format" /> y cuyo valor de propiedad <see cref="P:System.Buffers.StandardFormat.Precision" /> es <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary vsli:raw="Converts a classic .NET standard format string to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance.">Convierte una cadena de formato estándar de .NET clásica en una instancia <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format" vsli:raw="A classic .NET standard format string.">Una cadena de formato estándar de .NET clásica.</param>
      <exception cref="T:System.FormatException" vsli:raw="&lt;paramref name=&quot;format&quot; /&gt; is not a valid standard format string.">
        <paramref name="format" /> no es una cadena de formato estándar válido.</exception>
      <returns vsli:raw="A format.">Un formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary vsli:raw="Returns the string representation of this format.">Devuelve la representación en forma de cadena de este formato.</summary>
      <returns vsli:raw="The string representation of this format.">La representación en forma de cadena de este formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary vsli:raw="Attempts to convert a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Char&amp;gt;&quot; /&gt; to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance and returns a value that indicates whether the parsing operation succeeded.">Intenta analizar un carácter <see langword="ReadOnlySpan&lt;Char&gt;" /> en una instancia <see cref="T:System.Buffers.StandardFormat" /> y devuelve un valor que indica si la operación de análisis se realizó correctamente.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to convert.">Un intervalo de solo lectura que contiene el carácter que se va a convertir.</param>
      <param name="result" vsli:raw="When the method returns, contains the parsed &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance if the operation was successful.">Cuando este método devuelve un valor, contiene la instancia <see cref="T:System.Buffers.StandardFormat" /> analizada si la operación se realizó correctamente.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the parsing operation was successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si la operación de análisis se realizó correctamente; de lo contrario, es <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary vsli:raw="Gets a value that indicates whether a format has a defined precision.">Obtiene un valor que indica si un formato tiene una precisión definida.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the format has a precision other than &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Si el formato tiene una precisión distinta de <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary vsli:raw="Gets a value that indicates whether the current instance is a default format.">Obtiene un valor que indica si la instancia actual tiene un formato predeterminado.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance is a default format; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Si la instancia actual es un formato predeterminado; en caso contrario, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary vsli:raw="Gets the precision component of the format.">Obtiene el componente de precisión del formato.</summary>
      <returns vsli:raw="The precision component, which can be &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, or can range from 0 to 9.">El componente de precisión, que puede ser <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> o puede oscilar entre 0 y 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary vsli:raw="Gets the character component of the format.">Obtiene el componente de carácter del formato.</summary>
      <returns vsli:raw="The character component of the format.">Componente de carácter del formato.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Convierte entre los datos binarios y texto codificado UTF-8 que se representa en base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Descodifica el intervalo de texto codificado UTF-8 representado como base 64 en datos binarios. Si la entrada no es un múltiplo de 4, descodificará tanto como sea posible, al múltiplo más cercano de 4.</summary>
      <param name="utf8">El intervalo de entrada que contiene texto codificado UTF-8 en base 64 que tiene que descodificar.</param>
      <param name="bytes">El intervalo de salida que contiene el resultado de la operación, es decir, los datos binarios descodificados.</param>
      <param name="bytesConsumed">El número de bytes de entrada utilizados durante la operación. Esto puede usarse para segmentar la entrada en llamadas posteriores, si es necesario.</param>
      <param name="bytesWritten">El número de bytes escritos en el intervalo de salida. Esto puede usarse para segmentar la salida en llamadas posteriores, si es necesario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (predeterminado) si el intervalo de entrada contiene todos los datos para descodificar. <see langword="false" /> si el intervalo de entrada contiene datos parciales con más datos para seguir.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de descodificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Descodifica el intervalo de texto codificado UTF-8 en base 64 (en contexto) en datos binarios. La salida binaria descodificada es menor que los datos de texto contenidos en la entrada (la operación comprime los datos). Si la entrada no es un múltiplo de 4, el método no descodificará los datos.</summary>
      <param name="buffer">El intervalo de entrada que contiene los datos de texto en base 64 que se deben descodificar.</param>
      <param name="bytesWritten">El número de bytes escritos en el búfer.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de descodificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codifica el intervalo de datos binarios en texto codificado UTF-8 representado como base 64.</summary>
      <param name="bytes">El intervalo de entrada que contiene los datos binarios que se deben codificar.</param>
      <param name="utf8">El intervalo de salida que contiene el resultado de la operación, es decir, el texto codificado UTF-8 en base 64.</param>
      <param name="bytesConsumed">El número de bytes de entrada utilizados durante la operación. Esto puede usarse para segmentar la entrada en llamadas posteriores, si es necesario.</param>
      <param name="bytesWritten">El número de bytes escritos en el intervalo de salida. Esto puede usarse para segmentar la salida en llamadas posteriores, si es necesario.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (predeterminado) si el intervalo de entrada contiene todos los datos para codificar. <see langword="false" /> si el intervalo de entrada contiene datos parciales con más datos para seguir.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de codificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codifica el intervalo de datos binarios (en contexto) en texto codificado UTF-8 representado como base 64. La salida de texto codificado es mayor que los datos binarios contenidos en la entrada (la operación expande los datos).</summary>
      <param name="buffer">El intervalo de entrada que contiene los datos binarios que se deben codificar. Dado que el método realiza una conversión en contexto, debe ser lo suficientemente grande como para almacenar el resultado de la operación.</param>
      <param name="dataLength">El número de bytes de datos binarios contenidos en el búfer que debe codificarse. Este valor debe ser menor que el tamaño del búfer.</param>
      <param name="bytesWritten">El número de bytes escritos en el búfer.</param>
      <returns>Uno de los valores de enumeración que indica el estado de la operación de codificación.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Devuelve la longitud máxima (en bytes) del resultado si fuera a descodificar el texto codificado en base 64 en un intervalo de bytes con la longitud especificada.</summary>
      <param name="length">Tamaño del intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> es menor que 0.</exception>
      <returns>Longitud máxima (en bytes) del resultado.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Devuelve la longitud máxima (en bytes) del resultado si fuera a codificar datos binarios en un intervalo de bytes con la longitud especificada.</summary>
      <param name="length">Tamaño del intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> es menor que 0 o mayor que 1610612733 (ya que la codificación expande los datos en 4/3).</exception>
      <returns>Longitud máxima (en bytes) del resultado.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary vsli:raw="Provides static methods to format common data types as Utf8 strings.">Proporciona métodos estáticos para dar formato a los tipos de datos comunes como cadenas Utf8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Boolean" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Byte&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Byte" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.DateTime" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.DateTimeOffset" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Decimal" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Double&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Double" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Guid&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Guid" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Int16" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Int32" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Int64" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.SByte&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.SByte" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Single&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.Single" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.TimeSpan" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.UInt16" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.UInt32" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; as a UTF8 string.">Da formato a un elemento <see cref="T:System.UInt64" /> como una cadena UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">Valor al que se va a aplicar formato.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">Búfer en el que se escribirá el valor con formato UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">El resultado que devuelve este método contiene la longitud del texto con formato en bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">Formato estándar que se usará.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> si la operación de formato se realiza correctamente; <see langword="false" /> si el tamaño de <paramref name="buffer" /> es demasiado pequeño.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary vsli:raw="Provides static methods to parse Utf8 strings to common data types.">Proporciona métodos estáticos para analizar cadenas Utf8 para tipos de datos comunes.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Boolean" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Byte&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Byte" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.DateTime" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.DateTimeOffset" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Decimal" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Double&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Double" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Guid&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Guid" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int16&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Int16" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int32&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Int32" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int64&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Int64" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.SByte&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.SByte" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Single&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.Single" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.TimeSpan" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.UInt16" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.UInt32" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; at the start of a Utf8 string.">Analiza un elemento <see cref="T:System.UInt64" /> al principio de una cadena Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">Cadena Utf8 que se va a analizar.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">El resultado que devuelve este método contiene el valor analizado desde <paramref name="source" />, si la operación de análisis se ha realizado correctamente.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Si la operación de análisis se ha realizado correctamente, contiene la longitud en bytes del elemento substring analizado cuando lo devuelve el método. Si se produce un error en el método, <paramref name="bytesConsumed" /> se establece en 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">Formato esperado de la cadena Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para lograr una operación correcta; <see langword="false" /> si la cadena no era válida sintácticamente o ha habido un desbordamiento o subdesbordamiento.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary vsli:raw="Provides extension methods for the memory- and span-related types, such as &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;, &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Proporciona métodos de extensión para los tipos relativos a la memoria y el intervalo, como <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> y <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over the portion of the target string.">Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en la parte de la cadena de destino.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Representación de memoria de caracteres de solo lectura de la cadena, o <see langword="default" /> si <paramref name="text" /> es <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified index.">Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en una parte de la cadena de destino a partir de un índice especificado.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <param name="startIndex" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Representación de memoria de caracteres de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified character position.">Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en una parte de la cadena de destino a partir de una posición de caracteres especificada.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt; (&lt;paramref name=&quot;start&quot; /&gt; is &amp;lt; 0 or &amp;gt; &lt;c&gt;text.Length&lt;/c&gt;).">
        <paramref name="start" /> no está en el intervalo de <paramref name="text" /> (<paramref name="start" /> es &lt; 0 o &gt; <c>text.Length</c>).</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Representación de memoria de caracteres de solo lectura de la cadena, o <see langword="default" /> si <paramref name="text" /> es <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string beginning at a specified position with a length.">Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en una parte de la cadena de destino a partir de una posición especificada con una longitud.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Longitud deseada del segmento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">Representación de memoria de caracteres de solo lectura de la cadena, o <see langword="default" /> si <paramref name="text" /> es <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a specified range of the target string.">Crea un objeto <see langword="ReadOnlyMemory&lt;Char&gt;" /> en un intervalo especificado de la cadena de destino.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <param name="range" vsli:raw="The range that indicates the start and length of the sliced string.">Intervalo que indica el inicio y la longitud de la cadena segmentada.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">Representación de memoria de caracteres de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary vsli:raw="Creates a new memory region over the target array.">Crea una región de memoria en la matriz de destino.</summary>
      <param name="array" vsli:raw="The array to convert.">Matriz que se va a convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.">Crea una región de memoria en la parte de la matriz de destino a partir de un índice especificado y hasta el final de la matriz.</summary>
      <param name="array" vsli:raw="The array to convert.">Matriz que se va a convertir.</param>
      <param name="startIndex" vsli:raw="The first position of the array.">Primera posición de la matriz.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.">Crea una región de memoria en la parte de la matriz de destino a partir de una posición especificada y hasta el final de la matriz.</summary>
      <param name="array" vsli:raw="The target array.">Matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Índice en el que va a comenzar la memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; index less than 0 or greater than &lt;see langword=&quot;array.Length&quot; /&gt;.">El índice <paramref name="start" /> es menor que 0 o mayor que <see langword="array.Length" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.">Crea una región de memoria en la parte de la matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="array" vsli:raw="The target array.">Matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory region.">Índice donde comienza la región de memoria.</param>
      <param name="length" vsli:raw="The number of items in the memory region.">Número de elementos de la región de memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="array" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.">Crea una región de memoria en la parte de la matriz de destino que comienza en el índice de inicio inclusivo del intervalo y termina en el índice de finalización exclusivo del intervalo.</summary>
      <param name="array" vsli:raw="The array to convert.">Matriz que se va a convertir.</param>
      <param name="range" vsli:raw="The range to convert from the array.">Intervalo que se va a convertir de la matriz.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment.">Crea una región de memoria en la parte del segmento de matriz de destino.</summary>
      <param name="segment" vsli:raw="The segment to convert.">Segmento que se va a convertir.</param>
      <typeparam name="T" vsli:raw="The type of the segment.">Tipo del segmento.</typeparam>
      <returns vsli:raw="The memory representation of the segment.">Representación de memoria del segmento.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.">Crea una región de memoria en la parte del segmento de la matriz de destino a partir de una posición especificada hasta el final del segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento de la matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Índice en el que va a comenzar la memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;segment&quot; /&gt; is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> es covariante y el tipo de <paramref name="segment" /> no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> es menor que 0 o mayor que <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.">Crea una región de memoria en la parte del segmento de la matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento de la matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">Índice en el que va a comenzar la memoria.</param>
      <param name="length" vsli:raw="The number of items in the memory.">Número de elementos de la memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="segment" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">Representación de memoria de la totalidad o parte de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary vsli:raw="Creates a new read-only span over a string.">Crea un intervalo de solo lectura en una parte de la cadena de destino a partir de una posición especificada y con un número de caracteres especificado.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <returns vsli:raw="The read-only span representation of the string.">Representación de intervalo de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position to the end of the string.">Crea un intervalo de solo lectura en una parte de la cadena de destino desde una posición especificada hasta el final de la cadena.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="Thrown when &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="text" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;text.Length&quot; /&gt;.">
        <paramref name="start" /> es menor que 0 o mayor que <see langword="text.Length" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">Representación de intervalo de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.">Crea un intervalo de solo lectura en una cadena.</summary>
      <param name="text" vsli:raw="The target string.">Cadena de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">Índice en el que va a comenzar este segmento.</param>
      <param name="length" vsli:raw="The desired length for the slice.">Longitud deseada del segmento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">Representación de intervalo de solo lectura de la cadena.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary vsli:raw="Creates a new span over a target array.">Crea un intervalo en una matriz de destino.</summary>
      <param name="array" vsli:raw="The array to convert.">Matriz que se va a convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new span over the portion of the target array defined by an &lt;see cref=&quot;T:System.Index&quot; /&gt; value.">Crea un intervalo en la parte de la matriz de destino definida por un valor de <see cref="T:System.Index" />.</summary>
      <param name="array" vsli:raw="The array to convert.">Matriz que se va a convertir.</param>
      <param name="startIndex" vsli:raw="The starting index.">Índice de inicio.</param>
      <typeparam name="T" vsli:raw="The array type.">Tipo de matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of the target array starting at a specified position to the end of the array.">Crea un intervalo en una parte de la matriz de destino a partir de una posición especificada y hasta el final de la matriz.</summary>
      <param name="array" vsli:raw="The array to convert.">Matriz que se va a convertir.</param>
      <param name="start" vsli:raw="The initial index from which the array will be converted.">Índice inicial desde el que se convertirá la matriz.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over the portion of the target array beginning at a specified position for a specified length.">Crea un intervalo en la parte de la matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="array" vsli:raw="The target array.">Matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Índice en el que va a comenzar el intervalo.</param>
      <param name="length" vsli:raw="The number of items in the span.">Número de elementos del intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;&quot;.">
        <paramref name="array" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />".</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="text" />.</exception>
      <returns vsli:raw="The span representation of the array.">Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array defined by a &lt;see cref=&quot;T:System.Range&quot; /&gt; value.">Crea un intervalo en una parte de una matriz de destino definida por un valor de <see cref="T:System.Range" />.</summary>
      <param name="array" vsli:raw="The array to convert.">Matriz que se va a convertir.</param>
      <param name="range" vsli:raw="The range of the array to convert.">Intervalo de la matriz que se va a convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new span over a target array segment.">Crea un intervalo en un segmento de la matriz de destino.</summary>
      <param name="segment" vsli:raw="The array segment to convert.">Segmento de la matriz que se va a convertir.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento de la matriz.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Representación de intervalo del segmento de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary vsli:raw="Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.">Crea un intervalo en una parte del segmento de la matriz de destino a partir de un índice especificado y hasta el final del segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento de la matriz de destino.</param>
      <param name="startIndex" vsli:raw="The index at which to begin the Span.">Índice en el que va a comenzar el intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento de la matriz.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Representación de intervalo del segmento de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position to the end of the segment.">Crea un intervalo en una parte de un segmento de la matriz de destino a partir de una posición especificada hasta el final del segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento de la matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the san.">Índice en el que va a comenzar el intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento de la matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> es menor que 0 o mayor que <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The span representation of the array segment.">Representación de intervalo del segmento de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position for a specified length.">Crea un intervalo en una parte de un segmento de una matriz de destino a partir de una posición especificada y con una longitud especificada.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento de la matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">Índice en el que va a comenzar el intervalo.</param>
      <param name="length" vsli:raw="The number of items in the span.">Número de elementos del intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento de la matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> es covariante, y el tipo de matriz no es exactamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> o <paramref name="start" /> + <paramref name="length" /> no están en el intervalo de <paramref name="segment" />.</exception>
      <returns vsli:raw="The span representation of the array.">Representación de intervalo de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment using the range start and end indexes.">Crea un intervalo en una parte de un segmento de la matriz de destino mediante los índices inicial y final del intervalo.</summary>
      <param name="segment" vsli:raw="The target array segment.">Segmento de la matriz de destino.</param>
      <param name="range" vsli:raw="The range which has start and end indexes to use for slicing the array.">Intervalo que tiene los índices inicial y final que se van a usar para segmentar la matriz.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">Tipo del segmento de la matriz.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">Representación de intervalo del segmento de la matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Busca un valor en un objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado completo, utilizando la interfaz genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado que se va a buscar.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">Objeto <see cref="T:System.IComparable`1" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo de elemento del intervalo.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Busca un valor en un objeto <see cref="T:System.Span`1" /> ordenado completo, utilizando la interfaz genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Objeto <see cref="T:System.Span`1" /> ordenado que se va a buscar.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">Objeto <see cref="T:System.IComparable`1" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo de elemento del intervalo.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Busca un valor especificado en un objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparer" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado que se va a buscar.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Objeto que se va a buscar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">Objeto <typeparamref name="TComparer" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> es <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Índice de base cero de <paramref name="value" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="value" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="value" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Busca un valor en un objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparable" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">Objeto <see cref="T:System.ReadOnlySpan`1" /> ordenado que se va a buscar.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">Objeto <typeparamref name="TComparable" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Tipo específico de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Busca un valor especificado en un objeto <see cref="T:System.Span`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparer" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Objeto <see cref="T:System.Span`1" /> ordenado que se va a buscar.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">Objeto que se va a buscar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">Objeto <typeparamref name="TComparer" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">Tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> es <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Índice de base cero de <paramref name="value" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="value" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="value" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Busca un valor en un objeto <see cref="T:System.Span`1" /> ordenado completo, utilizando el tipo genérico <typeparamref name="TComparable" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">Objeto <see cref="T:System.Span`1" /> ordenado que se va a buscar.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">Objeto <typeparamref name="TComparable" /> que se va a utilizar en la comparación.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">Tipo de elemento del intervalo.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">Tipo específico de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> es <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">Índice de base cero de <paramref name="comparable" /> en la <paramref name="span" /> ordenada, si es que se encuentra <paramref name="comparable" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="comparable" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.">Compara un intervalo de caracteres con otro utilizando una comparación de cadenas especificada, y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Valor que se va a comparar con el intervalo de origen.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="other" />.</param>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Entero con signo que indica el orden relativo de <paramref name="span" /> y <paramref name="other" />:   - Si es menor que 0, <paramref name="span" /> va delante de <paramref name="other" />.   - Si es 0, <paramref name="span" /> es igual que <paramref name="other" />.   - Si es mayor que 0, <paramref name="span" /> va detrás de <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Indicates whether a specified value occurs within a read-only character span.">Indica si un valor especificado aparece dentro de un intervalo de caracteres de solo lectura.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valor que se va a buscar dentro del intervalo de origen.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how the characters in &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valor de enumeración que determina cómo se comparan los caracteres en <paramref name="span" /> y <paramref name="value" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; occurs within the span, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si <paramref name="value" /> aparece en el intervalo; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a read-only span. Values are compared using IEquatable{T}.Equals(T).">Indica si un valor especificado se encuentra en un intervalo de solo lectura. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The value to search for.">Valor que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Tipo del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if found, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si se encuentra; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a span. Values are compared using IEquatable{T}.Equals(T).">Indica si un valor especificado se encuentra en un intervalo. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The value to search for.">Valor que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="&lt;code data-dev-comment-type=&quot;langword&quot;&gt;true&lt;/code&gt; if found, &lt;code data-dev-comment-type=&quot;langword&quot;&gt;false&lt;/code&gt; otherwise.">
        <see langword="true" /> si se encuentra; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary vsli:raw="Copies the contents of the array into a memory region.">Copia el contenido de la matriz en una región de memoria.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Matriz de la que copiar elementos.</param>
      <param name="destination" vsli:raw="The memory to copy items into.">Matriz en la que copiar elementos.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination is shorter than the source array.">El destino es más corto que la matriz de origen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary vsli:raw="Copies the contents of the array into the span.">Copia el contenido de la matriz en el intervalo.</summary>
      <param name="source" vsli:raw="The array to copy items from.">Matriz de la que copiar elementos.</param>
      <param name="destination" vsli:raw="The span to copy items into.">El intervalo en el que copiar los elementos.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination Span is shorter than the source array.">El intervalo de destino es más corto que la matriz de origen.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether the end of the &lt;paramref name=&quot;span&quot; /&gt; matches the specified &lt;paramref name=&quot;value&quot; /&gt; when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Determina si el final de <paramref name="span" /> coincide con el objeto <paramref name="value" /> especificado cuando se comparan usando la opción <paramref name="comparisonType" /> especificada.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Secuencia que se va a comparar con el final del intervalo de origen.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> coincide con la propiedad <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a read-only span.">Determina si la secuencia especificada aparece al final de un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Secuencia que se va a comparar con el final del intervalo de origen.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Tipo del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> coincide con la propiedad <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a span.">Determina si la secuencia especificada aparece al final de un intervalo.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">Secuencia que se va a comparar con el final del intervalo de origen.</param>
      <typeparam name="T" vsli:raw="The type of the span.">Tipo del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> coincide con la propiedad <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided read-only span.">Devuelve una enumeración de <see cref="T:System.Text.Rune" /> a partir del intervalo de solo lectura proporcionado.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <returns vsli:raw="A rune enumerator.">Enumerador Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided span.">Devuelve una enumeración de <see cref="T:System.Text.Rune" /> a partir del intervalo proporcionado.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <returns vsli:raw="A rune enumerator.">Enumerador Rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether this &lt;paramref name=&quot;span&quot; /&gt; and the specified &lt;paramref name=&quot;other&quot; /&gt; span have the same characters when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Determina si este objeto <paramref name="span" /> y el intervalo <paramref name="other" /> especificado tienen los mismos caracteres cuando se comparan usando la opción <paramref name="comparisonType" /> especificada.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">Valor que se va a comparar con el intervalo de origen.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="other" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the first occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Devuelve el índice de base cero de la primera aparición del objeto <paramref name="value" /> especificado en el objeto <paramref name="span" /> actual.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valor que se va a buscar dentro del intervalo de origen.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns vsli:raw="The index of the occurrence of the value in the span.">Índice de la aparición del valor en el intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca el valor especificado y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The value to search for.">Valor que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca la secuencia especificada y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The sequence to search for.">Secuencia que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca el valor especificado y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The value to search for.">Valor que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca la secuencia especificada y devuelve el índice de su primera aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The sequence to search for.">Secuencia que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">Índice de la aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="values" vsli:raw="The set of values to search for.">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Busca el primer índice de cualquiera de los valores especificados, similar a llamar a IndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="values" vsli:raw="The set of values to search for.">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">Primer índice de la aparición de cualquiera de los valores del intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Indicates whether the specified span contains only whitespace characters.">Indica si el intervalo especificado contiene solo caracteres de espacio en blanco.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span contains only whitespace characters, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si el intervalo solo contiene caracteres de espacio en blanco; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the last occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Devuelve el índice de base cero de la última aparición del objeto <paramref name="value" /> especificado en el objeto <paramref name="span" /> actual.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">Valor que se va a buscar dentro del intervalo de origen.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns vsli:raw="The index of the last occurrence of the value in the span.">Índice de la última aparición del valor en el intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca el valor especificado y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The value to search for.">Valor que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca la secuencia especificada y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The sequence to search for.">Secuencia que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca el valor especificado y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The value to search for.">Valor que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Busca la secuencia especificada y devuelve el índice de su última aparición. Los valores se comparan mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="The sequence to search for.">Secuencia que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">Tipo del intervalo y del valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">Índice de la última aparición del valor en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="values" vsli:raw="The set of values to search for.">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Uno de los valores de que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Busca el último índice de cualquiera de los valores especificados, similar a llamar a LastIndexOf varias veces con el operador lógico OR.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="values" vsli:raw="The set of values to search for.">Conjunto de valores que se va a buscar.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">Tipo del intervalo y de los valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">Índice de la última aparición de cualquiera de los valores en el intervalo. Si no se encuentra, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory.">Determina si dos secuencias de solo lectura se superponen en la memoria.</summary>
      <param name="span" vsli:raw="The first sequence.">La primera secuencia.</param>
      <param name="other" vsli:raw="The second sequence.">La segunda secuencia.</param>
      <typeparam name="T" vsli:raw="The type of elements in the read-only sequence.">Tipo de elementos de la secuencia de solo lectura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory and outputs the element offset.">Determina si dos secuencias de solo lectura se superponen en la memoria y genera el desplazamiento del elemento.</summary>
      <param name="span" vsli:raw="The first sequence.">La primera secuencia.</param>
      <param name="other" vsli:raw="The second sequence.">La segunda secuencia.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Cuando el método finaliza, contiene el desplazamiento entre <paramref name="span" /> y <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo de elementos del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory.">Determina si un intervalo y un intervalo de solo lectura se superponen en la memoria.</summary>
      <param name="span" vsli:raw="The span to compare.">Intervalo que se va a comparar.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Intervalo de solo lectura que se va a comparar.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo de elementos del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory and outputs the element offset.">Determina si un intervalo y un intervalo de solo lectura se superponen en la memoria y genera el desplazamiento del elemento.</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Primera secuencia que se va a comparar.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Segunda secuencia que se va a comparar.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Cuando el método finaliza, contiene el desplazamiento entre <paramref name="span" /> y <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo de elementos del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las dos secuencias se superponen; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary vsli:raw="Reverses the sequence of the elements in the entire span.">Invierte la secuencia de los elementos de todo el intervalo.</summary>
      <param name="span" vsli:raw="The span to reverse.">Intervalo que se va a invertir.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo de elementos del intervalo.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).">Determina el orden relativo de dos secuencias de solo lectura, comparando sus elementos mediante IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Primera secuencia que se va a comparar.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Segunda secuencia que se va a comparar.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Tipo de los elementos de la secuencia.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Entero con signo que indica el orden relativo de <paramref name="span" /> y <paramref name="other" />:   - Si es menor que 0, <paramref name="span" /> va delante de <paramref name="other" />.   - Si es 0, <paramref name="span" /> es igual que <paramref name="other" />.   - Si es mayor que 0, <paramref name="span" /> va detrás de <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).">Determina el orden relativo de dos secuencias de solo lectura, comparando sus elementos mediante IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The span to compare.">Intervalo que se va a comparar.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Intervalo de solo lectura que se va a comparar.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo de elementos del intervalo.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Entero con signo que indica el orden relativo de <paramref name="span" /> y <paramref name="other" />:   - Si es menor que 0, <paramref name="span" /> va delante de <paramref name="other" />.   - Si es 0, <paramref name="span" /> es igual que <paramref name="other" />.   - Si es mayor que 0, <paramref name="span" /> va detrás de <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).">Determina si dos secuencias de solo lectura son iguales comparando los elementos mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">Primera secuencia que se va a comparar.</param>
      <param name="other" vsli:raw="The second sequence to compare.">Segunda secuencia que se va a comparar.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Tipo de los elementos de la secuencia.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las dos secuencias son iguales; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).">Determina si un intervalo y un intervalo de solo lectura son iguales comparando los elementos mediante IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to compare.">Intervalo que se va a comparar.</param>
      <param name="other" vsli:raw="The read-only span to compare.">Intervalo de solo lectura que se va a comparar.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">Tipo de los elementos de la secuencia.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si las dos secuencias son iguales; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each element of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Ordena todos los elementos de <see cref="T:System.Span`1" /> mediante la implementación de <see cref="T:System.IComparable`1" /> de cada elemento de <see cref="T:System.Span`1" />.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Intervalo de memoria que se va a ordenar.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Tipo de los elementos del intervalo.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">Uno o más elementos de la <paramref name="span" /> no implementan la interfaz de <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt;.">Ordena los elementos de toda la <see cref="T:System.Span`1" /> utilizando el <see cref="T:System.Comparison`1" /> especificado.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Intervalo de memoria que se va a ordenar.</param>
      <param name="comparison" vsli:raw="The method to use when comparing elements.">Método que se va a usar al comparar los elementos.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Tipo de los elementos del intervalo.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> es <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;typeparamref name=&quot;TComparer&quot; /&gt;.">Ordena todos los elementos de <see cref="T:System.Span`1" /> mediante <typeparamref name="TComparer" />.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">Intervalo de memoria que se va a ordenar.</param>
      <param name="comparer" vsli:raw="The method to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use each element's &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation.">Método que se va a utilizar al comparar los elementos, o bien <see langword="null" /> para usar la implementación de la interfaz <see cref="T:System.IComparable`1" /> de cada elemento.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">Tipo de los elementos del intervalo.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">Tipo del comparador que se va a utilizar para comparar los elementos.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> es <see langword="null" /> y uno o más elementos de la <paramref name="span" /> no implementan la interfaz de <see cref="T:System.IComparable`1" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The implementation of &lt;paramref name=&quot;comparer&quot; /&gt; caused an error during the sort.">La implementación de <paramref name="comparer" /> produjo un error durante la ordenación.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each key.">Ordena un par de intervalos (uno que contiene las claves y el otro con los elementos correspondientes) en función de las claves de la primera instancia de <see cref="T:System.Span`1" /> mediante la implementación de <see cref="T:System.IComparable`1" /> de cada clave.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Intervalo que contiene las claves que se van a ordenar.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Intervalo que contiene los elementos que se corresponden a las claves de <paramref name="keys" />.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Tipo de los elementos del intervalo de claves.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Tipo de los elementos del intervalo de elementos.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">La longitud de <paramref name="keys" /> no es igual a la de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">Uno o más elementos de la <paramref name="keys" /> no implementan la interfaz de <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparison.">Ordena un par de intervalos (uno que contiene las claves y el otro con los elementos correspondientes) en función de las claves de la primera instancia de <see cref="T:System.Span`1" /> mediante la comparación especificada.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Intervalo que contiene las claves que se van a ordenar.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Intervalo que contiene los elementos que se corresponden a las claves de <paramref name="keys" />.</param>
      <param name="comparison" vsli:raw="The &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt; to use when comparing elements.">
        <see cref="T:System.Comparison`1" /> que se va a utilizar al comparar elementos.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Tipo de los elementos del intervalo de claves.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Tipo de los elementos del intervalo de elementos.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> es <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">La longitud de <paramref name="keys" /> no es igual a la de <paramref name="items" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparer.">Ordena un par de intervalos (uno que contiene las claves y el otro con los elementos correspondientes) en función de las claves de la primera instancia de <see cref="T:System.Span`1" /> mediante el comparador especificado.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">Intervalo que contiene las claves que se van a ordenar.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">Intervalo que contiene los elementos que se corresponden a las claves de <paramref name="keys" />.</param>
      <param name="comparer" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt; implementation to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation of each element.">Implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar los elementos, o bien <see langword="null" /> para usar la implementación de la interfaz <see cref="T:System.IComparable`1" /> de cada elemento.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">Tipo de los elementos del intervalo de claves.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">Tipo de los elementos del intervalo de elementos.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">Tipo del comparador que se va a utilizar para comparar los elementos.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">La longitud de <paramref name="keys" /> no es igual a la de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> es <see langword="null" /> y uno o más elementos de la <paramref name="keys" /> no implementan la interfaz de <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether a read-only character span begins with a specified value when compared using a specified &lt;see cref=&quot;T:System.StringComparison&quot; /&gt; value.">Determina si un intervalo de caracteres de solo lectura comienza por un valor especificado cuando se comparan utilizando un valor <see cref="T:System.StringComparison" /> especificado.</summary>
      <param name="span" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="value" vsli:raw="The sequence to compare to the beginning of the source span.">Secuencia que se va a comparar con el inicio del intervalo de origen.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Valor de enumeración que determina cómo se comparan <paramref name="span" /> y <paramref name="value" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> coincide con el principio de <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a read-only span.">Determina si una secuencia especificada aparece al inicio de un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The read-only character span to search.">Intervalo de caracteres de solo lectura que se va a buscar.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Secuencia que se va a buscar al inicio de <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">Tipo de elementos del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> coincide con el principio de <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a span.">Determina si una secuencia especificada aparece al inicio de un intervalo.</summary>
      <param name="span" vsli:raw="The span to search.">Intervalo que se va a buscar.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Secuencia que se va a buscar al inicio de <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="value" /> coincide con el principio de <paramref name="span" />; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.">Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en minúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural especificada.</summary>
      <param name="source" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervalo de destino que contiene los caracteres transformados.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Los búferes de origen y destino se superponen.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.">Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en minúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural invariable.</summary>
      <param name="source" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervalo de destino que contiene los caracteres transformados.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Los búferes de origen y destino se superponen.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.">Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en mayúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural especificada.</summary>
      <param name="source" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervalo de destino que contiene los caracteres transformados.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Los búferes de origen y destino se superponen.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.">Copia los caracteres del intervalo de origen en el destino, convirtiendo cada carácter en mayúsculas mediante las reglas de mayúsculas y minúsculas de la referencia cultural invariable.</summary>
      <param name="source" vsli:raw="The source span.">Intervalo de origen.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">Intervalo de destino que contiene los caracteres transformados.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Los búferes de origen y destino se superponen.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">Número de caracteres escritos en el intervalo de destino. Si el destino es demasiado pequeño, devuelve -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character memory region.">Quita todos los caracteres de espacio en blanco iniciales y finales de una región de memoria de caracteres.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria de origen de la que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed character memory region.">Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character memory region.">Quita todos los caracteres de espacio en blanco iniciales y finales de una región de memoria de caracteres de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria de origen de la que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed character memory region.">Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character span.">Quita todos los caracteres de espacio en blanco iniciales y finales de un intervalo de caracteres de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified character from a read-only character span.">Quita todas las apariciones iniciales y finales de un carácter especificado de un intervalo de caracteres de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Intervalo de origen del que se quita el carácter.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Carácter especificado que se va a buscar y quitar.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Quita de un intervalo de caracteres de solo lectura todas las apariciones iniciales y finales de un conjunto de caracteres especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Intervalo que contiene el conjunto de caracteres que se va a quitar.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character span.">Quita todos los caracteres de espacio en blanco iniciales y finales de un intervalo de caracteres.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed character span.">Intervalo de caracteres recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a memory region.">Quita todas las apariciones iniciales y finales de un elemento especificado de una región de memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo de los elementos de la región de memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.">Quita de una región de memoria todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo de los elementos de la región de memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only memory region.">Quita todas las apariciones iniciales y finales de un elemento especificado de una región de memoria de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Quita de una región de memoria de solo lectura todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only span.">Quita todas las apariciones iniciales y finales de un elemento especificado de un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Quita de un intervalo de solo lectura todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a span.">Quita todas las apariciones iniciales y finales de un elemento especificado de un intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.">Quita de un intervalo todas las apariciones iniciales y finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character memory region.">Quita todos los caracteres de espacio en blanco finales de una región de memoria de caracteres.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria de origen de la que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed character memory region.">Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character memory region.">Quita todos los caracteres de espacio en blanco finales de una región de memoria de caracteres de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria de origen de la que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character span.">Quita todos los caracteres de espacio en blanco finales de un intervalo de caracteres de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all trailing occurrences of a specified character from a read-only span.">Quita todas las apariciones finales de un carácter especificado de un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Intervalo de origen del que se quita el carácter.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Carácter especificado que se va a buscar y quitar.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Quita de un intervalo de caracteres de solo lectura todas las apariciones finales de un conjunto de caracteres especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Intervalo que contiene el conjunto de caracteres que se va a quitar.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character span.">Quita todos los caracteres de espacio en blanco finales de un intervalo de caracteres.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed character span.">Intervalo de caracteres recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a character memory region.">Quita todas las apariciones finales de un elemento especificado de una región de memoria de caracteres.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo de los elementos de la región de memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.">Quita de una región de memoria todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo de los elementos de la región de memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only memory region.">Quita todas las apariciones finales de un elemento especificado de una región de memoria de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Quita de una región de memoria de solo lectura todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only span.">Quita todas las apariciones finales de un elemento especificado de un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Quita de un intervalo de solo lectura todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a span.">Quita todas las apariciones finales de un elemento especificado de un intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a span.">Quita de un intervalo todas las apariciones finales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a memory region.">Quita todos los caracteres de espacio en blanco iniciales de una región de memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria de origen de la que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed character memory region.">Región de memoria de caracteres recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only memory region.">Quita todos los caracteres de espacio en blanco iniciales de una región de memoria de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">Memoria de origen de la que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed read-only character memory region.">Región de memoria de caracteres de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only span.">Quita todos los caracteres de espacio en blanco iniciales de un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading occurrences of a specified character from the span.">Quita todas las apariciones iniciales de un carácter especificado de un intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">Intervalo de origen del que se quita el carácter.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">Carácter especificado que se va a buscar y quitar.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading occurrences of a set of characters specified in a read-only span from the span.">Quita del intervalo todas las apariciones iniciales de un conjunto de caracteres especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">Intervalo que contiene el conjunto de caracteres que se va a quitar.</param>
      <returns vsli:raw="The trimmed read-only character span.">Intervalo de caracteres de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a span.">Quita todos los caracteres de espacio en blanco iniciales de un intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">Intervalo de origen del que se quitan los caracteres.</param>
      <returns vsli:raw="The trimmed character span.">Intervalo de caracteres recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Quita todas las apariciones iniciales de un elemento especificado de una región de memoria.</summary>
      <param name="memory" vsli:raw="The source memory region from which the element is removed.">Región de memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo de los elementos de la región de memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Quita de una región de memoria todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">Tipo de los elementos de la región de memoria.</typeparam>
      <returns vsli:raw="The trimmed memory region.">Región de memoria recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Quita todas las apariciones iniciales de un elemento especificado de una región de memoria.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">Memoria de origen de la que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Quita de una región de memoria todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">Memoria de origen de la que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">Tipo de los elementos de la región de memoria de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">Región de memoria de solo lectura recortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Quita todas las apariciones iniciales de un elemento especificado del intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Quita del intervalo todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">Tipo de los elementos del intervalo de solo lectura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">Intervalo de solo lectura recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Quita todas las apariciones iniciales de un elemento especificado del intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">Intervalo de origen del que se quita el elemento.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">Elemento especificado que se va a buscar y quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervalo recortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Quita del intervalo todas las apariciones iniciales de un conjunto de elementos especificados en un intervalo de solo lectura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">Intervalo de origen del que se quitan los elementos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">Intervalo que contiene el conjunto de elementos que se va a quitar.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">Tipo de los elementos del intervalo.</typeparam>
      <returns vsli:raw="The trimmed span.">Intervalo recortado.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary vsli:raw="Provides methods to interoperate with &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;,  &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and  &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Proporciona métodos para interoperar con <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" />, y <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Byte&amp;gt;&quot; /&gt;.">Convierte un <see cref="T:System.ReadOnlySpan`1" /> de un tipo primitivo, <paramref name="T" />, a un <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">El segmento de origen para convertir.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only span.">Tipo de elementos del intervalo de solo lectura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">La propiedad <see cref="P:System.ReadOnlySpan`1.Length" /> del nuevo <see cref="T:System.ReadOnlySpan`1" /> superaría <see cref="F:System.Int32.MaxValue" /></exception>
      <returns vsli:raw="A read-only span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Un intervalo de solo lectura de tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;Span&amp;lt;Byte&amp;gt;&quot; /&gt;.">Convierte un <see cref="T:System.Span`1" /> de un tipo primitivo, <paramref name="T" />, a un <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">El segmento de origen para convertir.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Tipo de elementos del intervalo.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">La propiedad <see cref="P:System.Span`1.Length" /> del nuevo <see cref="T:System.Span`1" /> superaría <see cref="F:System.Int32.MaxValue" /></exception>
      <returns vsli:raw="A span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Un intervalo de tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Crea una instancia de <see cref="T:System.Memory`1" /> a partir de un <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer.">El búfer de memoria de solo lectura.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Tipo de elementos del búfer de memoria de solo lectura.</typeparam>
      <returns vsli:raw="A memory block that represents the same memory as the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Bloque de memoria que representa la misma memoria que <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reinterprets a read-only span of bytes as a read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Reinterpreta un intervalo de bytes de solo lectura como una referencia de solo lectura a la estructura de tipo <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The read-only span to reinterpret.">Intervalo de solo lectura que se va a reinterpretar.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Tipo de la referencia devuelta.</typeparam>
      <returns vsli:raw="The read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Referencia de solo lectura a la estructura de tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary vsli:raw="Reinterprets a span of bytes as a reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Reinterpreta un intervalo de bytes como una referencia a la estructura de tipo <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The span to reinterpret.">Intervalo que se va a reinterpretar.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">Tipo de la referencia devuelta.</typeparam>
      <returns vsli:raw="The reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Referencia a la estructura de tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a read-only span of one primitive type to a read-only span of another primitive type.">Convierte un intervalo de solo lectura de un tipo primitivo a un intervalo de solo lectura de otro tipo primitivo.</summary>
      <param name="span" vsli:raw="The source slice to convert.">El segmento de origen para convertir.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Tipo del intervalo de origen.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Tipo del intervalo de destino.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene referencias o punteros.</exception>
      <returns vsli:raw="The converted read-only span.">El intervalo de solo lectura convertido.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary vsli:raw="Casts a span of one primitive type to a span of another primitive type.">Convierte un intervalo de un tipo primitivo a un intervalo de otro tipo primitivo.</summary>
      <param name="span" vsli:raw="The source slice to convert.">El segmento de origen para convertir.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">Tipo del intervalo de origen.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">Tipo del intervalo de destino.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> o <paramref name="TTo" /> contiene referencias o punteros.</exception>
      <returns vsli:raw="The converted span.">El intervalo convertido.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory buffer over the portion of the pre-pinned target array beginning at the &lt;paramref name=&quot;start&quot; /&gt; index and consisting of &lt;paramref name=&quot;length&quot; /&gt; items.">Crea un nuevo búfer de memoria sobre la parte de la matriz de destino anclada previamente que empieza en el índice <paramref name="start" /> y contiene <paramref name="length" /> elementos.</summary>
      <param name="array" vsli:raw="The pre-pinned source array.">La matriz de origen previamente anclada.</param>
      <param name="start" vsli:raw="The index of &lt;paramref name=&quot;array&quot; /&gt; at which to begin the memory block.">El índice de <paramref name="array" /> donde comienza el bloque de memoria.</param>
      <param name="length" vsli:raw="The number of items to include in the memory block.">El número de elementos para incluir en el bloque de memoria.</param>
      <typeparam name="T" vsli:raw="The type of the array.">Tipo de matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;array&quot; /&gt; is not exactly &lt;paramref name=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> es covariante y el tipo de <paramref name="array" /> no es exactamente <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;start&quot; /&gt; or the end index is not in the range of 0 to &lt;see cref=&quot;P:System.Array.Length&quot; /&gt;.">El <paramref name="start" /> o el índice final no está en el intervalo de 0 a <see cref="P:System.Array.Length" />.</exception>
      <returns vsli:raw="A block of memory over the specified elements of &lt;paramref name=&quot;array&quot; /&gt;. If &lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, or if &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; are 0, the method returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance of &lt;see cref=&quot;P:System.Memory`1.Length&quot; /&gt; zero.">Un bloque de memoria sobre los elementos especificados de <paramref name="array" />. Si <paramref name="array" /> es <see langword="null" />, o si <paramref name="start" /> y <paramref name="length" /> son 0, el método devuelve una instancia <see cref="T:System.Memory`1" /> de <see cref="P:System.Memory`1.Length" /> cero.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of a regular managed object.">Crea un intervalo de solo lectura sobre una parte de un objeto administrado normal.</summary>
      <param name="reference" vsli:raw="A reference to data.">Una referencia a los datos.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Número de elementos de <paramref name="T" /> que contiene <paramref name="reference" />.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Tipo de los elementos de datos.</typeparam>
      <returns vsli:raw="A read-only span.">Un intervalo de solo lectura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a regular managed object.">Crea un nuevo intervalo sobre una parte de un objeto administrado normal.</summary>
      <param name="reference" vsli:raw="A reference to data.">Una referencia a los datos.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">Número de elementos de <paramref name="T" /> que contiene <paramref name="reference" />.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">Tipo de los elementos de datos.</typeparam>
      <returns vsli:raw="A span.">Un intervalo.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary vsli:raw="Returns a reference to the 0th element of &lt;paramref name=&quot;array&quot; /&gt;. If the array is empty, returns a reference to where the 0th element would have been stored. Such a reference may be used for pinning but must never be dereferenced.">Devuelve una referencia al elemento 0 del objeto <paramref name="array" />. Si la matriz está vacía, devuelve una referencia a la ubicación donde se habría almacenado el elemento 0. Esta referencia se puede utilizar para el anclaje, pero nunca se debe desreferenciar.</summary>
      <param name="array" vsli:raw="The array to analyze.">Matriz que se va a analizar.</param>
      <typeparam name="T" vsli:raw="The type of the array elements.">El tipo de los elementos de la matriz.</typeparam>
      <exception cref="T:System.NullReferenceException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> es <see langword="null" />.</exception>
      <returns vsli:raw="Reference to the 0th element in &lt;paramref name=&quot;array&quot; /&gt;.">Referencia al elemento 0 en <paramref name="array" /></returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Returns a reference to the element of the read-only span at index 0.">Devuelve una referencia al elemento del intervalo de solo lectura en el índice cero.</summary>
      <param name="span" vsli:raw="The read-only span from which the reference is retrieved.">El intervalo de solo lectura desde el que se recupera la referencia.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Tipo de elementos del intervalo.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Una referencia al elemento en el índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary vsli:raw="Returns a reference to the element of the span at index 0.">Devuelve una referencia al elemento del intervalo en el índice 0.</summary>
      <param name="span" vsli:raw="The span from which the reference is retrieved.">El intervalo desde el que se recupera la referencia.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">Tipo de elementos del intervalo.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Una referencia al elemento en el índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a structure of type &lt;typeparamref name=&quot;T&quot; /&gt; out of a read-only span of bytes.">Lee una estructura de tipo <param name="T" /> fuera de un intervalo de solo lectura de bytes.</summary>
      <param name="source" vsli:raw="A read-only span.">Un intervalo de solo lectura.</param>
      <typeparam name="T" vsli:raw="The type of the item to retrieve from the read-only span.">Tipo del elemento que se va a recuperar del intervalo de solo lectura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is smaller than &lt;paramref name=&quot;T&quot; /&gt;'s length in bytes.">
        <paramref name="source" /> es menor que <paramref name="T" />.</exception>
      <returns vsli:raw="The structure retrieved from the read-only span.">La estructura recuperada del intervalo de solo lectura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; view of the given read-only memory buffer.">Crea una vista <see cref="T:System.Collections.Generic.IEnumerable`1" /> del búfer de memoria de solo lectura especificado.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Un búfer de memoria de solo lectura.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Tipo de los elementos en el búfer de memoria de solo lectura.</typeparam>
      <returns vsli:raw="An enumerable view of &lt;paramref name=&quot;memory&quot; /&gt;.">Vista enumerable de <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Tries to get an array segment from the underlying memory buffer. The return value indicates the success of the operation.">Intenta obtener un segmento de matriz desde el búfer de memoria subyacente. El valor devuelto indica si la operación se completó correctamente.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Un búfer de memoria de solo lectura.</param>
      <param name="segment" vsli:raw="When this method returns, contains the array segment retrieved from the underlying read-only memory buffer. If the method fails, the method returns a default array segment.">Cuando se devuelve este método, contiene el segmento de matrices recuperado del búfer de memoria de solo lectura subyacente. Si se produce un error en el método, el método devuelve un segmento de matriz predeterminado.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">Tipo de elementos del búfer de memoria de solo lectura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method call succeeds; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si la llamada al método se realiza correctamente; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; from the underlying read-only memory buffer.">Intenta recuperar un <see cref="T:System.Buffers.MemoryManager`1" /> desde el búfer de memoria de solo lectura subyacente.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">El búfer de memoria de solo lectura para el que se va a obtener el administrador de memoria.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Cuando el método finaliza, administrador de <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Tipo de los elementos en el búfer de memoria de solo lectura.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Tipo del <see cref="T:System.Buffers.MemoryManager`1" /> que se va a recuperar.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method retrieved the memory manager; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el método recuperó el administrador de memoria; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt;, start index, and length from the underlying read-only memory buffer.">Intenta recuperar un <see cref="T:System.Buffers.MemoryManager`1" />, iniciar un índice y una longitud desde el búfer de memoria de solo lectura subyacente.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">El búfer de memoria de solo lectura para el que se va a obtener el administrador de memoria.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Cuando el método finaliza, administrador de <paramref name="memory" />.</param>
      <param name="start" vsli:raw="When the method returns, the offset from the start of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Cuando el método finaliza, desplazamiento desde el principio de <paramref name="manager" /> que representa <paramref name="memory" />.</param>
      <param name="length" vsli:raw="When the method returns, the length of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Cuando el método finaliza, longitud de <paramref name="manager" /> que representa <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">Tipo de los elementos en el búfer de memoria de solo lectura.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">Tipo del <see cref="T:System.Buffers.MemoryManager`1" /> que se va a recuperar.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">Es <see langword="true" /> si el método se ha ejecutado correctamente; en caso contrario, es <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to get the underlying string from a &lt;see langword=&quot;System.ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt;.">Intenta obtener la cadena subyacente de un <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory" vsli:raw="Read-only memory containing a block of characters.">Memoria de solo lectura que contiene un bloque de caracteres.</param>
      <param name="text" vsli:raw="When the method returns, the string contained in the memory buffer.">Cuando el método lo devuelve, la cadena contenida en el búfer de memoria.</param>
      <param name="start" vsli:raw="The starting location in &lt;paramref name=&quot;text&quot; /&gt;.">La ubicación de inicio de <paramref name="text" />.</param>
      <param name="length" vsli:raw="The number of characters in &lt;paramref name=&quot;text&quot; /&gt;.">Número de caracteres de <paramref name="text" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method successfully retrieves the underlying string; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Si el método recupera correctamente la cadena subyacente; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary vsli:raw="Tries to read a structure of type &lt;paramref name=&quot;T&quot; /&gt; from a read-only span of bytes.">Intenta leer una estructura de tipo <paramref name="T" /> desde un intervalo de bytes de solo lectura.</summary>
      <param name="source" vsli:raw="A read-only span of bytes.">Un intervalo de bytes de solo lectura.</param>
      <param name="value" vsli:raw="When the method returns, an instance of &lt;paramref name=&quot;T&quot; /&gt;.">Cuando el método finaliza, instancia de <paramref name="T" />.</param>
      <typeparam name="T" vsli:raw="The type of the structure to retrieve.">Tipo de la estructura que se va a recuperar.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeds in retrieving an instance of the structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si el método recupera correctamente una instancia de la estructura; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Tries to write a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Intenta escribir una estructura de tipo <paramref name="T" /> en un intervalo de bytes.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">El intervalo de bytes que contiene la estructura.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">La estructura que se escribirá en el intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Tipo de la estructura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the write operation succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;. The method returns &lt;see langword=&quot;false&quot; /&gt; if the span is too small to contain &lt;paramref name=&quot;T&quot; /&gt;.">
        <see langword="true" /> si la operación se realiza correctamente; de lo contrario, <see langword="false" />. El método devuelve <see langword="false" /> si el intervalo es demasiado pequeño para incluir <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Writes a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Escribe una estructura de tipo <paramref name="T" /> en un intervalo de bytes.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">El intervalo de bytes que contiene la estructura.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">La estructura que se escribirá en el intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">Tipo de la estructura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contiene referencias o punteros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="destination" /> es demasiado pequeño para contener <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary vsli:raw="Provides a collection of methods for interoperating with &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Proporciona una colección de métodos para interoperar con <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Gets an array segment from the underlying read-only sequence.">Obtiene un segmento de la matriz de la secuencia de solo lectura subyacente.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the array segment will be retrieved.">Secuencia de solo lectura a partir de la cual se recuperará el segmento de la matriz.</param>
      <param name="segment" vsli:raw="The returned array segment.">Segmento de la matriz devuelto.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo de la secuencia de solo lectura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it's possible to retrieve the array segment; otherwise, &lt;see langword=&quot;false&quot; /&gt; and a default array segment is returned.">
        <see langword="true" /> si es posible recuperar el segmento de la matriz; de lo contrario, <see langword="false" />, se devuelve un segmento de matriz predeterminado.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary vsli:raw="Attempts to retrieve a read-only memory from the specified read-only sequence.">Intenta recuperar una memoria de solo lectura de la secuencia de solo lectura especificada.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the memory will be retrieved.">Secuencia de solo lectura a partir de la cual se recuperará la memoria.</param>
      <param name="memory" vsli:raw="The returned read-only memory of type T.">Memoria de solo lectura de tipo T devuelta.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo de la secuencia de solo lectura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only memory can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se puede recuperar la memoria de solo lectura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary vsli:raw="Attempts to retrieve a read-only sequence segment from the specified read-only sequence.">Intenta recuperar un segmento de secuencia de solo lectura a partir de la secuencia de solo lectura especificada.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the read-only sequence segment will be retrieved.">Secuencia de solo lectura a partir de la cual se recuperará el segmento de la secuencia de solo lectura.</param>
      <param name="startSegment" vsli:raw="The beginning read-only sequence segment.">Segmento de la secuencia de solo lectura inicial.</param>
      <param name="startIndex" vsli:raw="The initial position.">Posición inicial.</param>
      <param name="endSegment" vsli:raw="The ending read-only sequence segment.">Segmento de la secuencia de solo lectura final.</param>
      <param name="endIndex" vsli:raw="The final position.">Posición final.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">Tipo de la secuencia de solo lectura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence segment can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si se puede recuperar el segmento de secuencia de solo lectura; de lo contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary vsli:raw="Attempts to read the specified type out of the buffer. It's dangerous to use this method with arbitrary structs - see remarks for more information.">Intenta leer el tipo especificado del búfer. Usar este método con structs arbitrarios es peligroso; vea los comentarios para más información.</summary>
      <param name="reader" vsli:raw="A reference to the sequence reader.">Referencia al lector de secuencias.</param>
      <param name="value" vsli:raw="The returned value if the read was successful. &lt;paramref name=&quot;value&quot; /&gt; will be &lt;see langword=&quot;default&quot; /&gt; if failed (due to lack of space).">Valor devuelto si la lectura se realizó correctamente. <paramref name="value" /> será <see langword="default" /> si se produce un error (debido a la falta de espacio).</param>
      <typeparam name="T" vsli:raw="The type of the value.">Tipo del valor.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read attempt was successful, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si el intento de lectura se realizó correctamente; de lo contrario <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary vsli:raw="Represents a position in a non-contiguous set of memory. Properties of this type should not be interpreted by anything but the type that created it.">Representa una posición en un conjunto de memoria no contiguo. Las propiedades de este tipo no deben interpretarse mediante ningún elemento que no sea el tipo que las creó.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; struct.">Inicializa una nueva instancia del struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object" vsli:raw="A non-contiguous set of memory.">Conjunto de memoria no contiguo.</param>
      <param name="integer" vsli:raw="The position in &lt;paramref name=&quot;object&quot; /&gt;.">Posición en <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance is equal to another object.">Devuelve un valor que indica si la instancia actual es igual que otro objeto.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">Objeto que se va a comparar con la instancia actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is of type &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> si <paramref name="obj" /> es del tipo <see cref="T:System.SequencePosition" /> y es igual a la instancia actual; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary vsli:raw="Indicates whether the current instance is equal to another &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Indica si la instancia actual es igual que otro <see cref="T:System.SequencePosition" />.</summary>
      <param name="other" vsli:raw="The sequence position to compare with the current instance.">Posición de la secuencia que se va a comparar con la instancia actual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> si las dos instancias son iguales; en caso contrario, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Devuelve el código hash de esta instancia.</summary>
      <returns vsli:raw="The hash code for this instance.">Código hash de esta instancia.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary vsli:raw="Returns the integer part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Devuelve la parte de entero de este objeto <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The integer part of this sequence position.">Parte entera de la posición de esta secuencia.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary vsli:raw="Returns the object part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Devuelve la parte de objeto de este objeto <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The object part of this sequence position.">Parte de objeto de esta posición de la secuencia.</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary vsli:raw="Provides extension methods for the encoding types, such as &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;, &lt;see cref=&quot;T:System.Text.Encoder&quot; /&gt;, and &lt;see cref=&quot;T:System.Text.Decoder&quot; /&gt;.">Proporciona métodos de extensión para los tipos de codificación, como <see cref="T:System.Text.Encoding" />, <see cref="T:System.Text.Encoder" /> y <see cref="T:System.Text.Decoder" />.</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to UTF-16 encoded characters and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Convierte <see cref="T:System.Buffers.ReadOnlySequence`1" /> en caracteres con codificación UTF-16 y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">Instancia del descodificador que puede convertir bytes en valores <see langword="char" />.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Secuencia de bytes que se va a descodificar.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded characters will be written.">Búfer en el que se escribirán los caracteres descodificados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que no se van a convertir más datos; de lo contrario, <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of characters that were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Cuando este método devuelve un valor, contiene el recuento de caracteres escritos en <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Cuando este método devuelve un valor, contiene <see langword="true" /> si <paramref name="decoder" /> no contiene ningún estado interno parcial; de lo contrario, <see langword="false" />.
Si <paramref name="flush" /> es <see langword="true" />, siempre se establecerá en <see langword="true" /> cuando el método devuelva un valor.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene datos que no se pueden descodificar y <paramref name="decoder" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to chars using &lt;paramref name=&quot;decoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Convierte <see cref="T:System.ReadOnlySpan`1" /> en caracteres mediante <paramref name="decoder" /> y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">Instancia del descodificador que puede convertir bytes en valores <see langword="char" />.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Secuencia de bytes que se va a descodificar.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Búfer en el que se escribirán los caracteres descodificados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que no se van a convertir más datos; de lo contrario, <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;char&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Cuando este método devuelve un valor, contiene el recuento de <see langword="char" />s escritos en <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Cuando este método devuelve un valor, contiene <see langword="true" /> si <paramref name="decoder" /> no contiene ningún estado interno parcial; de lo contrario, <see langword="false" />.
Si <paramref name="flush" /> es <see langword="true" />, siempre se establecerá en <see langword="true" /> cuando el método devuelva un valor.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene datos que no se pueden codificar y <paramref name="decoder" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to encoded bytes and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Convierte <see cref="T:System.Buffers.ReadOnlySequence`1" /> en bytes codificados y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">Instancia del codificador que puede convertir valores <see langword="char" /> en bytes.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Secuencia de caracteres que se va a codificar.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Búfer en el que se escribirán los bytes codificados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que no se van a convertir más datos; de lo contrario, <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Cuando este método devuelve un valor, contiene el recuento de <see langword="byte" />s escritos en <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if all input up until &lt;paramref name=&quot;bytesUsed&quot; /&gt; was converted; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Cuando este método devuelve un valor, contiene <see langword="true" /> si se convirtieron todas las entradas hasta <paramref name="bytesUsed" />; de lo contrario, <see langword="false" />. Si <paramref name="flush" /> es <see langword="true" />, siempre se establecerá en <see langword="true" /> cuando el método devuelva un valor.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene datos que no se pueden codificar y <paramref name="encoder" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to bytes using &lt;paramref name=&quot;encoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Convierte <see cref="T:System.ReadOnlySpan`1" /> en bytes mediante <paramref name="encoder" /> y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">Instancia del codificador que puede convertir valores <see langword="char" /> en bytes.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Secuencia de caracteres que se va a codificar.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Búfer en el que se escribirán los bytes codificados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que no se van a convertir más datos; de lo contrario, <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Cuando este método devuelve un valor, contiene el recuento de <see langword="byte" />s escritos en <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;encoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Cuando este método devuelve un valor, contiene <see langword="true" /> si <paramref name="encoder" /> no contiene ningún estado interno parcial; de lo contrario, <see langword="false" />.
Si <paramref name="flush" /> es <see langword="true" />, siempre se establecerá en <see langword="true" /> cuando el método devuelva un valor.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene datos que no se pueden codificar y <paramref name="encoder" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.Byte&quot; /&gt; array using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Codifica el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado en una matriz <see cref="T:System.Byte" /> mediante el elemento <see cref="T:System.Text.Encoding" /> especificado.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codificación que representa cómo se deben codificar los datos de <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Secuencia que se va a codificar en bytes.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene datos que no se pueden codificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; array that represents the encoded contents of &lt;paramref name=&quot;chars&quot; /&gt;.">Matriz <see cref="T:System.Byte" /> que representa el contenido codificado de <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Descodifica el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado en <see langword="byte" />s mediante el elemento <see cref="T:System.Text.Encoding" /> especificado y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codificación que representa cómo se deben codificar los datos de <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; whose contents should be encoded.">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> cuyo contenido se debe codificar.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Búfer en el que se escribirán los bytes codificados.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene datos que no se pueden codificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">Número de bytes escritos en <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;bytes&quot; /&gt;.">Codifica el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado en <see langword="byte" />s mediante el elemento <see cref="T:System.Text.Encoding" /> especificado y envía el resultado a <paramref name="bytes" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codificación que representa cómo se deben codificar los datos de <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Secuencia que se va a codificar en bytes.</param>
      <param name="bytes" vsli:raw="The destination buffer to which the encoded bytes will be written.">Búfer de destino en el que se escribirán los bytes codificados.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;chars&quot; /&gt;.">
        <paramref name="bytes" /> no es lo suficientemente grande como para contener el formato codificado de <paramref name="chars" />.</exception>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene datos que no se pueden codificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;bytes&quot; /&gt;.">Número de bytes escritos en <paramref name="bytes" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Codifica el elemento <see cref="T:System.ReadOnlySpan`1" /> especificado en <see langword="byte" />s mediante el elemento <see cref="T:System.Text.Encoding" /> especificado y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">Codificación que representa cómo se deben codificar los datos de <paramref name="chars" />.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">Secuencia que se va a codificar en bytes.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">Búfer en el que se escribirán los bytes codificados.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contiene datos que no se pueden codificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">Número de bytes escritos en <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Descodifica el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado en <see langword="char" />s mediante el elemento <see cref="T:System.Text.Encoding" /> especificado y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">Codificación que representa cómo se deben descodificar los datos de <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The sequence whose bytes should be decoded.">Secuencia cuyos bytes se deben descodificar.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Búfer en el que se escribirán los caracteres descodificados.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene datos que no se pueden descodificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">Número de caracteres escritos en <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;chars&quot; /&gt;.">Descodifica el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado en <see langword="char" />s mediante el elemento <see cref="T:System.Text.Encoding" /> especificado y envía el resultado a <paramref name="chars" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">Codificación que representa cómo se codifican los datos de <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The sequence to decode to characters.">Secuencia que se va a descodificar en caracteres.</param>
      <param name="chars" vsli:raw="The destination buffer to which the decoded characters will be written.">Búfer de destino en el que se escribirán los caracteres descodificados.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;bytes&quot; /&gt;.">
        <paramref name="chars" /> no es lo suficientemente grande como para contener el formato codificado de <paramref name="bytes" />.</exception>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene datos que no se pueden descodificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;chars&quot; /&gt;.">Número de caracteres escritos en <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Descodifica el elemento <see cref="T:System.ReadOnlySpan`1" /> especificado en <see langword="char" />s mediante el elemento <see cref="T:System.Text.Encoding" /> especificado y escribe el resultado en <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">Codificación que representa cómo se deben descodificar los datos de <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The span of bytes to decode.">Intervalo de bytes que se va a descodificar.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">Búfer en el que se escribirán los caracteres descodificados.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene datos que no se pueden descodificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">Número de caracteres escritos en <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.String&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Descodifica el elemento <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado en <see cref="T:System.String" /> mediante el elemento <see cref="T:System.Text.Encoding" /> especificado.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">Codificación que representa cómo se codifican los datos de <paramref name="bytes" />.</param>
      <param name="bytes" vsli:raw="The sequence to decode into characters.">Secuencia que se va a descodificar en caracteres.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contiene datos que no se pueden descodificar y <paramref name="encoding" /> está configurado para iniciarse al mostrarse dichos datos.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; which represents the decoded contents of &lt;paramref name=&quot;bytes&quot; /&gt;.">
        <see cref="T:System.String" /> que representa el contenido descodificado de <paramref name="bytes" />.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary vsli:raw="Provides an enumerator for the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; values represented by a span containing UTF-16 text.">Proporciona un enumerador para los valores <see cref="T:System.Text.Rune" /> representado por un intervalo que contiene texto UTF-16.</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary vsli:raw="Returns the current enumerator instance.">Devuelve la instancia de enumerador actual.</summary>
      <returns vsli:raw="The current enumerator instance.">La instancia de enumerador actual.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; of the span.">Desplaza el enumerador al <see cref="T:System.Text.Rune" /> siguiente del intervalo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the span has been reached.">
        <see langword="true" /> si el enumerador se ha desplazado correctamente al elemento siguiente; <see langword="false" /> si se ha llegado al final del intervalo.</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Obtiene <see cref="T:System.Text.Rune" /> en la posición actual del enumerador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Obtiene <see cref="T:System.Text.Rune" /> en la posición actual del enumerador.</returns>
    </member>
  </members>
</doc>