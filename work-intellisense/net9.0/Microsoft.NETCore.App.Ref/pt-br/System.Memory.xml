<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:vsli="https://github.com/sk-0520/vs-localized-intellisense/tree/master/schema/2024">
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary vsli:raw="Represents a heap-based, array-backed output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Representa um sink de saída com apoio de matriz baseado em heap nos quais <typeparam name="T" /> dados podem ser gravados.</summary>
      <typeparam name="T" vsli:raw="The type of the items in this &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; instance.">O tipo dos itens nesta <see cref="T:System.Buffers.ArrayBufferWriter`1" /> instância.</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with the default initial capacity.">Cria uma instância de um <see cref="T:System.Buffers.ArrayBufferWriter`1" /> na qual os dados podem ser gravados, com a capacidade inicial padrão.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary vsli:raw="Creates an instance of an &lt;see cref=&quot;T:System.Buffers.ArrayBufferWriter`1&quot; /&gt; to which data can be written, with a specified initial capacity.">Cria uma instância de um <see cref="T:System.Buffers.ArrayBufferWriter`1" /> na qual os dados podem ser gravados, com uma capacidade inicial especificada.</summary>
      <param name="initialCapacity" vsli:raw="The minimum capacity with which to initialize the underlying buffer.">A capacidade mínima com a qual inicializar o buffer subjacente.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;initialCapacity&quot; /&gt; is less than or equal to 0.">
        <paramref name="initialCapacity" /> é menor ou igual a 0.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt;/&lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Notifica o <see cref="T:System.Buffers.IBufferWriter`1" /> que os itens <paramref name="count" /> foram gravados no <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /> de saída</summary>
      <param name="count" vsli:raw="The number of items written.">O número de itens gravados.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative.">
        <paramref name="count" /> é negativo.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The method call attempts to advance past the end of the underlying buffer.">A chamada de método tenta ignorar o fim do buffer subjacente.</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary vsli:raw="Clears the data written to the underlying buffer.">Limpa os dados gravados no buffer subjacente.</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the length specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;.">Retorna um <see cref="T:System.Memory`1" /> no qual gravar que tem o tamanho mínimo especificado por <paramref name="sizeHint" />.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">O comprimento solicitado mínimo do <see cref="T:System.Memory`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> é negativo.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; whose length is at least &lt;paramref name=&quot;sizeHint&quot; /&gt;.  If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Um <see cref="T:System.Memory`1" /> cujo comprimento é de pelo menos <paramref name="sizeHint" />.  Se <paramref name="sizeHint" /> não for fornecido ou for igual a 0, algum buffer diferente de vazio será retornado.</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least a specified length.">Retorna um <see cref="T:System.Span`1" /> no qual gravar que tem o tamanho mínimo especificado.</summary>
      <param name="sizeHint" vsli:raw="The minimum requested length of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">O comprimento solicitado mínimo do <see cref="T:System.Span`1" />.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;sizeHint&quot; /&gt; is negative.">
        <paramref name="sizeHint" /> é negativo.</exception>
      <returns vsli:raw="A span of at least &lt;paramref name=&quot;sizeHint&quot; /&gt; in length. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is not provided or is equal to 0, some non-empty buffer is returned.">Um intervalo de pelo menos <paramref name="sizeHint" /> de comprimento. Se <paramref name="sizeHint" /> não for fornecido ou for igual a 0, algum buffer diferente de vazio será retornado.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary vsli:raw="Gets the total amount of space within the underlying buffer.">Obtém a quantidade total de espaço dentro do buffer subjacente.</summary>
      <returns vsli:raw="The total capacity of the underlying buffer.">A capacidade total do buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary vsli:raw="Gets the amount of available space that can be written to without forcing the underlying buffer to grow.">Obtém a quantidade de espaço disponível no qual é possível gravar sem forçar o buffer subjacente a crescer.</summary>
      <returns vsli:raw="The space available for writing without forcing the underlying buffer to grow.">O espaço disponível para gravação sem forçar o crescimento do buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary vsli:raw="Gets the amount of data written to the underlying buffer.">Obtém a quantidade de dados gravados no buffer subjacente.</summary>
      <returns vsli:raw="The amount of data written to the underlying buffer.">A quantidade de dados gravados no buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Obtém um <see cref="T:System.ReadOnlyMemory`1" /> que contém os dados gravados no buffer subjacente até o momento.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Os dados gravados no buffer subjacente.</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; that contains the data written to the underlying buffer so far.">Obtém um <see cref="T:System.ReadOnlySpan`1" /> que contém os dados gravados no buffer subjacente até o momento.</summary>
      <returns vsli:raw="The data written to the underlying buffer.">Os dados gravados no buffer subjacente.</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary vsli:raw="Reads bytes as primitives with specific endianness.">Lê bytes como primitivos com endians específicos.</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="source" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span to read.">O intervalo somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
      <returns vsli:raw="The big endian value.">O valor big endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="source" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
      <returns vsli:raw="The little endian value.">O valor little endian.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Byte&quot; /&gt; value, which effectively does nothing for a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Byte" /> especificado, o que não faz nada para um <see cref="T:System.Byte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The passed-in value, unmodified.">O valor passado, não modificado.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int16&quot; /&gt; value.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Int16" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The reversed value.">O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int32&quot; /&gt; value.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Int32" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The reversed value.">O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.Int64&quot; /&gt; value.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.Int64" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The reversed value.">O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.SByte&quot; /&gt; value, which effectively does nothing for an &lt;see cref=&quot;T:System.SByte&quot; /&gt;.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.SByte" /> especificado, o que não faz nada para um <see cref="T:System.SByte" />.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The passed-in value, unmodified.">O valor passado, não modificado.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt16&quot; /&gt; value.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.UInt16" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The reversed value.">O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt32&quot; /&gt; value.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.UInt32" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The reversed value.">O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary vsli:raw="Reverses a primitive value by performing an endianness swap of the specified &lt;see cref=&quot;T:System.UInt64&quot; /&gt; value.">Inverte um valor primitivo executando uma permuta de endian do valor de <see cref="T:System.UInt64" /> especificado.</summary>
      <param name="value" vsli:raw="The value to reverse.">O valor a ser invertido.</param>
      <returns vsli:raw="The reversed value.">O valor invertido.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Double&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Double" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Int16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Int32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary vsli:raw="Reads an &lt;see cref=&quot;T:System.Int64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Int64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.Single&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.Single" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando este método é retornado, contém o valor lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.UInt16" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.UInt32" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as big endian.">Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como big endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as big endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary vsli:raw="Reads a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; from the beginning of a read-only span of bytes, as little endian.">Lê um <see cref="T:System.UInt64" /> desde o início de um intervalo de bytes somente leitura, como little endian.</summary>
      <param name="source" vsli:raw="The read-only span of bytes to read.">O intervalo de bytes somente leitura a ser lido.</param>
      <param name="value" vsli:raw="When this method returns, contains the value read out of the read-only span of bytes, as little endian.">Quando esse método é retornado, o valor é lido do intervalo de bytes somente leitura, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Double" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a extensão for grande o suficiente para conter um <see cref="T:System.Int64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.Single" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt16" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt32" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span is large enough to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o intervalo for grande o suficiente para conter um <see cref="T:System.UInt64" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Double&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Double" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Double&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int16&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Int16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int32&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Int32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary vsli:raw="Writes an &lt;see cref=&quot;T:System.Int64&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Int64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <paramref name="destination" /> é muito pequeno para conter um <see cref="T:System.Int64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.Single&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.Single" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.Single&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.Single" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.UInt16" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt16&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt16" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.UInt32" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt32&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt32" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as big endian.">Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como big endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as big endian.">O intervalo de bytes em que o valor deve ser gravado, como big endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary vsli:raw="Writes a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; into a span of bytes, as little endian.">Grava um <see cref="T:System.UInt64" /> em um intervalo de bytes, como little endian.</summary>
      <param name="destination" vsli:raw="The span of bytes where the value is to be written, as little endian.">O intervalo de bytes em que o valor deve ser gravado, como little endian.</param>
      <param name="value" vsli:raw="The value to write into the span of bytes.">O valor a ser gravado no intervalo de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain a &lt;see cref=&quot;T:System.UInt64&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter um <see cref="T:System.UInt64" />.</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary vsli:raw="Provides extension methods for &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Fornece métodos de extensão para <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary vsli:raw="Copies the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to the specified &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Copia o <see cref="T:System.Buffers.ReadOnlySequence`1" /> para o <see cref="T:System.Span`1" /> especificado.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">A fonte de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="destination" vsli:raw="The destination &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">O <see cref="T:System.Span`1" /> de destino.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">O tipo dos itens no <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary vsli:raw="Returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retorna a posição da primeira ocorrência de <paramref name="item" /> em <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="source" vsli:raw="The source &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">A fonte de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <param name="value" vsli:raw="The item to find in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">O item a ser localizado em <see cref="T:System.Buffers.ReadOnlySequence`1" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">O tipo dos itens no <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An object whose &lt;see cref=&quot;M:System.SequencePosition.GetInteger&quot; /&gt; method returns the position of the first occurrence of &lt;paramref name=&quot;item&quot; /&gt;, or an object whose &lt;see langword=&quot;Nullable&amp;lt;SequencePosition&amp;gt;.HasValue&quot; /&gt; property is &lt;see langword=&quot;false&quot; /&gt; .">Um objeto cujo método <see cref="M:System.SequencePosition.GetInteger" /> retorna a posição da primeira ocorrência de <paramref name="item" /> ou um objeto cuja propriedade <see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> é <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary vsli:raw="Converts the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to an array.">Converte <see cref="T:System.Buffers.ReadOnlySequence`1" /> em uma matriz.</summary>
      <param name="sequence" vsli:raw="The read-only sequence to convert to an array.">A sequência somente leitura a ser convertida em uma matriz.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">O tipo dos itens no <see cref="T:System.Buffers.ReadOnlySequence`1" /> .</typeparam>
      <returns vsli:raw="An array containing the data in the current read-only sequence.">Uma matriz que contém os dados na sequência atual de somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Writes the contents of &lt;paramref name=&quot;value&quot; /&gt; to &lt;paramref name=&quot;writer&quot; /&gt;.">Grava o conteúdo de <paramref name="value" /> em <paramref name="writer" />.</summary>
      <param name="writer" vsli:raw="The buffer writer to which to write &lt;paramref name=&quot;value&quot; /&gt;.">O gravador de buffer no qual gravar <paramref name="value" />.</param>
      <param name="value" vsli:raw="The read-only span to be written to &lt;paramref name=&quot;writer&quot; /&gt;.">A extensão somente leitura a ser gravada em <paramref name="writer" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">O tipo dos itens no <see cref="T:System.ReadOnlySpan`1" /> .</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;writer&quot; /&gt; is shorter than &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="writer" /> é menor do que <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary vsli:raw="Represents an output sink into which &lt;typeparamref name=&quot;T&quot; /&gt; data can be written.">Representa um coletor de saída no qual os dados <typeparamref name="T" /> podem ser gravados.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt;.">O tipo dos itens no <see cref="T:System.Buffers.IBufferWriter`1" /> .</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary vsli:raw="Notifies the &lt;see cref=&quot;T:System.Buffers.IBufferWriter`1&quot; /&gt; that &lt;paramref name=&quot;count&quot; /&gt; data items were written to the output &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">Notifica <see cref="T:System.Buffers.IBufferWriter`1" /> que os itens de dados de <paramref name="count" /> foram gravados na saída <see cref="T:System.Span`1" /> ou <see cref="T:System.Memory`1" />.</summary>
      <param name="count" vsli:raw="The number of data items written to the &lt;see cref=&quot;T:System.Span`1&quot; /&gt; or &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;.">O número de itens de dados gravados em <see cref="T:System.Span`1" /> ou em <see cref="T:System.Memory`1" />.</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Retorna um <see cref="T:System.Memory`1" /> para gravar que é o tamanho mínimo solicitado ou superior (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;. If 0, a non-empty buffer is returned.">O comprimento mínimo de <see cref="T:System.Memory`1" /> retornado. Se for 0, um buffer não vazio será retornado.</param>
      <exception cref="T:System.OutOfMemoryException" vsli:raw="The requested buffer size is not available.">O tamanho do buffer solicitado não está disponível.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Um <see cref="T:System.Memory`1" /> de tamanho mínimo <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> for 0, retornará um buffer não vazio.</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary vsli:raw="Returns a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to write to that is at least the requested size (specified by &lt;paramref name=&quot;sizeHint&quot; /&gt;).">Retorna um <see cref="T:System.Span`1" /> para gravar que é o tamanho mínimo solicitado ou superior (especificado por <paramref name="sizeHint" />).</summary>
      <param name="sizeHint" vsli:raw="The minimum length of the returned &lt;see cref=&quot;T:System.Span`1&quot; /&gt;. If 0, a non-empty buffer is returned.">O comprimento mínimo de <see cref="T:System.Span`1" /> retornado. Se for 0, um buffer não vazio será retornado.</param>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of at least the size &lt;paramref name=&quot;sizeHint&quot; /&gt;. If &lt;paramref name=&quot;sizeHint&quot; /&gt; is 0, returns a non-empty buffer.">Um <see cref="T:System.Span`1" /> de tamanho mínimo <paramref name="sizeHint" />. Se <paramref name="sizeHint" /> for 0, retornará um buffer não vazio.</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary vsli:raw="Represents a pool of memory blocks.">Representa um pool de blocos de memória.</summary>
      <typeparam name="T" vsli:raw="The type of the items in the memory pool.">O tipo dos itens no pool de memória.</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary vsli:raw="Constructs a new instance of a memory pool.">Constrói uma nova instância de um pool de memória.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary vsli:raw="Frees all resources used by the memory pool.">Libera todos os recursos usados pelo pool de memória.</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary vsli:raw="Frees the unmanaged resources used by the memory pool and optionally releases the managed resources.">Libera os recursos não gerenciados usados pelo pool de memória e, opcionalmente, libera os recursos gerenciados.</summary>
      <param name="disposing" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to release both managed and unmanaged resources; &lt;see langword=&quot;false&quot; /&gt; to release only unmanaged resources.">
        <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary vsli:raw="Returns a memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Retorna um bloco de memória capaz de conter pelo menos <paramref name="minBufferSize" /> elementos de T.</summary>
      <param name="minBufferSize" vsli:raw="The minimum number of elements of &lt;typeparamref name=&quot;T&quot; /&gt; that the memory pool can hold. A value of -1 returns a memory pool set to the default size for the pool.">O número mínimo de elementos de <typeparamref name="T" /> que o pool de memória pode conter. Um valor de -1 retorna um pool de memória definido no tamanho padrão do pool.</param>
      <returns vsli:raw="A memory block capable of holding at least &lt;paramref name=&quot;minBufferSize&quot; /&gt; elements of T.">Um bloco de memória capaz de conter pelo menos <paramref name="minBufferSize" /> elementos de T.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary vsli:raw="Gets the maximum buffer size supported by this pool.">Obtém o tamanho máximo de buffer com suporte para este pool.</summary>
      <returns vsli:raw="The maximum buffer size supported by this pool.">O tamanho máximo de buffer suportado por este pool.</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary vsli:raw="Gets a singleton instance of a memory pool based on arrays.">Obtém uma instância singleton de um pool de memória com base em matrizes.</summary>
      <returns vsli:raw="A singleton instance of a memory pool.">Uma instância singleton de um pool de memória.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary vsli:raw="Represents a sequence that can read a sequential series of &lt;typeparamref name=&quot;T&quot; /&gt;.">Representa uma sequência que pode ler uma série sequencial de <typeparamref name="T" />.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence.">O tipo dos elementos na sequência somente leitura.</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary vsli:raw="Returns an empty &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retorna um <see cref="T:System.Buffers.ReadOnlySequence`1" /> vazio.</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from the &lt;paramref name=&quot;array&quot; /&gt;.">Cria uma instância de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <paramref name="array" />.</summary>
      <param name="array" vsli:raw="The array from which to create a read-only sequence.">A matriz com base na qual criar uma sequência somente leitura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a section of an array.">Cria uma instância de um <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de uma seção de uma matriz.</summary>
      <param name="array" vsli:raw="The array from which to create the read-only sequence.">A matriz com base na qual criar a sequência somente leitura.</param>
      <param name="start" vsli:raw="The zero-based index of the first element in the array to include in the read-only sequence.">O índice de base zero do primeiro elemento na matriz a ser incluído na sequência somente leitura.</param>
      <param name="length" vsli:raw="The number of elements to include in the read-only sequence.">O número de elementos a ser incluídos na sequência somente leitura.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary vsli:raw="Creates an instance of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a linked memory list represented by start and end segments and the corresponding indexes in them.">Cria uma instância de um <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de uma lista de memória vinculada representada pelos segmentos inicial e final e os índices correspondentes neles.</summary>
      <param name="startSegment" vsli:raw="The initial node of the linked memory list.">O nó inicial da lista de memória vinculada.</param>
      <param name="startIndex" vsli:raw="The position to the start of the sequence inside &lt;paramref name=&quot;startSegment&quot; /&gt;.">A posição para o início da sequência dentro de <paramref name="startSegment" />.</param>
      <param name="endSegment" vsli:raw="The final node of the linked memory list.">O nó final da lista de memória vinculada.</param>
      <param name="endIndex" vsli:raw="The position to the end of the sequence inside &lt;paramref name=&quot;endSegment&quot; /&gt;.">A posição para o final da sequência dentro de <paramref name="endSegment" />.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;startSegment&quot; /&gt; or &lt;paramref name=&quot;endSegment&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="startSegment" /> ou <paramref name="endSegment" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The running index of &lt;paramref name=&quot;startSegment&quot; /&gt; is greater than the running index of &lt;paramref name=&quot;endSegment&quot; /&gt;, even though &lt;paramref name=&quot;startSegment&quot; /&gt; is different to &lt;paramref name=&quot;endSegment&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startSegment&quot; /&gt; is equal to &lt;paramref name=&quot;endSegment&quot; /&gt; but &lt;paramref name=&quot;endIndex&quot; /&gt; is smaller than &lt;paramref name=&quot;startIndex&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;startIndex&quot; /&gt; is greater than the length of the underlying memory block of &lt;paramref name=&quot;startSegment&quot; /&gt;.">O índice em execução de <paramref name="startSegment" /> é maior que o índice em execução de <paramref name="endSegment" />, mesmo que <paramref name="startSegment" /> seja diferente de <paramref name="endSegment" />.

- ou -

<paramref name="startSegment" /> é igual a <paramref name="endSegment" />, mas <paramref name="endIndex" /> é menor que <paramref name="startIndex" />.

- ou -

<paramref name="startIndex" /> é maior que o comprimento do bloco de memória subjacente de <paramref name="startSegment" />.</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary vsli:raw="Creates an instance of &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Cria uma instância de <see cref="T:System.Buffers.ReadOnlySequence`1" /> a partir de <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="A read-only block of memory of elements of type &lt;typeparamref name=&quot;T&quot; /&gt;.">Um bloco de memória somente leitura de elementos do tipo <typeparamref name="T" />.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retorna um enumerador sobre o <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="Returns an enumerator over the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Retorna um enumerador sobre o <see cref="T:System.Buffers.ReadOnlySequence`1" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary vsli:raw="Returns the offset of a &lt;paramref name=&quot;position&quot; /&gt; within this sequence from the start.">Retorna o deslocamento de um <paramref name="position" /> dentro dessa sequência desde o início.</summary>
      <param name="position" vsli:raw="The &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of which to get the offset.">O <see cref="T:System.SequencePosition" /> do qual obter o deslocamento.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The position is out of range.">A posição está fora do intervalo.</exception>
      <returns vsli:raw="The offset from the start of the sequence.">O deslocamento do início da sequência.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at an &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Retorna um novo <see cref="T:System.SequencePosition" /> em um <paramref name="offset" /> a partir do início da sequência.</summary>
      <param name="offset" vsli:raw="The offset from the start of the sequence.">O deslocamento do início da sequência.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the specified &lt;paramref name=&quot;offset&quot; /&gt; from the start of the sequence.">Um objeto que representa a posição da sequência que começa no <paramref name="offset" /> especificado desde o início da sequência.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Returns a new &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; starting at the specified offset from the &lt;paramref name=&quot;origin&quot; /&gt; position.">Retorna um novo <see cref="T:System.SequencePosition" /> começando no deslocamento especificado da posição <paramref name="origin" />.</summary>
      <param name="offset" vsli:raw="The offset from the specified &lt;paramref name=&quot;origin&quot; /&gt; sequence position.">O deslocamento da posição da sequência <paramref name="origin" /> especificada.</param>
      <param name="origin" vsli:raw="A sequence position representing the point from which to initiate the offset.">Uma posição de sequência que representa o ponto do qual iniciar o deslocamento.</param>
      <returns vsli:raw="An object representing the sequence position that starts at the &lt;paramref name=&quot;offset&quot; /&gt; position of the specified &lt;paramref name=&quot;origin&quot; /&gt; position object.">Um objeto que representa a posição da sequência que começa na posição <paramref name="offset" /> do objeto de posição <paramref name="origin" /> especificado.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <param name="length" vsli:raw="The length of the slice.">O comprimento da fatia.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando no índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" /> e terminando em <paramref name="end" /> (exclusivo).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <param name="end" vsli:raw="The end (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">O final (exclusivo) <see cref="T:System.SequencePosition" /> da fatia.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Uma fatia que consiste em itens do índice <paramref name="start" />, não incluindo a posição de sequência <paramref name="end" /> na sequência atual somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified index and continuing to the end of the read-only sequence.">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em um índice especificado e continuando até o final da sequência somente leitura.</summary>
      <param name="start" vsli:raw="The start index at which to begin this slice.">O índice inicial no qual começar essa fatia.</param>
      <returns vsli:raw="A slice starting at index &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Uma fatia começando no índice <paramref name="start" /> e continuando até o final da sequência somente leitura atual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary vsli:raw="Forms a slice out of the given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma uma fatia a partir do <see cref="T:System.Buffers.ReadOnlySequence`1" /> dado, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <param name="length" vsli:raw="The length of the slice.">O comprimento da fatia.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at index &lt;paramref name=&quot;start&quot; /&gt;.">Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando no índice <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" /> e terminando em <paramref name="end" /> (exclusivo).</summary>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <param name="end" vsli:raw="The end (exclusive) of the slice.">O final (exclusivo) da fatia.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; index to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Uma fatia que consiste em itens do índice <paramref name="start" />, não incluindo a posição de sequência <paramref name="end" /> na sequência atual somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at a specified sequence position and continuing to the end of the read-only sequence.">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em uma posição de sequência especificada e continuando até o final da sequência somente leitura.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <returns vsli:raw="A slice starting at sequence position &lt;paramref name=&quot;start&quot; /&gt; and continuing to the end of the current read-only sequence.">Uma fatia começando na posição de sequência <paramref name="start" /> e continuando até o final da sequência somente leitura atual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <param name="length" vsli:raw="The length of the slice.">O comprimento da fatia.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando na posição de sequência <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt;, with &lt;paramref name=&quot;length&quot; /&gt; items.">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" />, com <paramref name="length" /> itens.</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <param name="length" vsli:raw="The length of the slice.">O comprimento da fatia.</param>
      <returns vsli:raw="A slice that consists of &lt;paramref name=&quot;length&quot; /&gt; elements from the current instance starting at sequence position &lt;paramref name=&quot;start&quot; /&gt;.">Uma fatia que consiste em elementos <paramref name="length" /> da instância atual, começando na posição de sequência <paramref name="start" />.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary vsli:raw="Forms a slice out of the current &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;, beginning at &lt;paramref name=&quot;start&quot; /&gt; and ending at &lt;paramref name=&quot;end&quot; /&gt; (exclusive).">Forma uma fatia do <see cref="T:System.Buffers.ReadOnlySequence`1" /> atual, começando em <paramref name="start" /> e terminando em <paramref name="end" /> (exclusivo).</summary>
      <param name="start" vsli:raw="The starting (inclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; at which to begin this slice.">O ponto inicial (inclusivo) <see cref="T:System.SequencePosition" /> no qual começar essa fatia.</param>
      <param name="end" vsli:raw="The ending (exclusive) &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; of the slice.">O final (exclusivo) <see cref="T:System.SequencePosition" /> da fatia.</param>
      <returns vsli:raw="A slice that consists of items from the &lt;paramref name=&quot;start&quot; /&gt; sequence position to, but not including, the &lt;paramref name=&quot;end&quot; /&gt; sequence position in the current read-only sequence.">Uma fatia que consiste em itens da posição de sequência <paramref name="start" />, não incluindo a posição de sequência <paramref name="end" /> na sequência atual somente leitura.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary vsli:raw="Returns a string that represents the current sequence.">Retorna uma cadeia de caracteres que representa a sequência atual.</summary>
      <returns vsli:raw="A string that represents the current sequence.">Uma cadeia de caracteres que representa a sequência atual.</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary vsli:raw="Tries to retrieve the next segment after &lt;paramref name=&quot;position&quot; /&gt; and returns a value that indicates whether the operation succeeded.">Tenta recuperar o próximo segmento após <paramref name="position" /> e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      <param name="position" vsli:raw="The current sequence position.">A posição atual da sequência.</param>
      <param name="memory" vsli:raw="A read-only memory span that contains the next segment after &lt;paramref name=&quot;position&quot; /&gt;.">Uma extensão de memória somente leitura que contém o próximo segmento após <paramref name="position" />.</param>
      <param name="advance" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;position&quot; /&gt; should to the beginning of next segment; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="position" /> deve ir para o começo do próximo segmento. Caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="Returns &lt;see langword=&quot;true&quot; /&gt; if the method returned the next segment, or &lt;see langword=&quot;false&quot; /&gt; if the end of the read-only sequence was reached.">Retornará <see langword="true" />, se o método tiver retornado o próximo segmento, ou <see langword="false" />, se o final da sequência somente leitura tiver sido atingido.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary vsli:raw="Gets the position at the end of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtém a posição no final de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; from the first segment.">Obtém o <see cref="T:System.ReadOnlyMemory`1" /> a partir do primeiro segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; from the first segment.">Obtém o <see cref="T:System.ReadOnlySpan`1" /> a partir do primeiro segmento.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; is empty.">Obtém um valor que indica se a <see cref="T:System.Buffers.ReadOnlySequence`1" /> está vazia.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary vsli:raw="Gets a value that indicates whether the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; contains a single &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; segment.">Obtém um valor que indica se <see cref="T:System.Buffers.ReadOnlySequence`1" /> contém um único segmento <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence is empty; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a sequência somente leitura estiver vazia; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary vsli:raw="Gets the length of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtém o comprimento do <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="The length of the read-only sequence.">O comprimento da sequência somente leitura.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary vsli:raw="Gets the position to the start of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Obtém a posição para o início do <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary vsli:raw="Represents an enumerator over a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Representa um enumerador acima de <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <typeparam name="T" vsli:raw="" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary vsli:raw="Initializes the enumerator.">Inicializa o enumerador.</summary>
      <param name="sequence" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to enumerate.">A <see cref="T:System.Buffers.ReadOnlySequence`1" /> a ser enumerada.</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary vsli:raw="Moves to the next &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; in the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Avança para o próximo <see cref="T:System.ReadOnlyMemory`1" /> no <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the sequence has been reached.">
        <see langword="true" /> se o enumerador foi avançado com êxito para o próximo item; <see langword="false" /> se o final da sequência foi alcançado.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary vsli:raw="Gets the current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Obtém o <see cref="T:System.ReadOnlyMemory`1" /> atual.</summary>
      <returns vsli:raw="The current &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">O <see cref="T:System.ReadOnlyMemory`1" /> atual.</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary vsli:raw="Represents a linked list of &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; nodes.">Representa uma lista vinculada de nós <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only sequence segment.">O tipo dos elementos no segmento de sequência somente leitura.</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.ReadOnlySequenceSegment`1&quot; /&gt; class.">Inicializa uma nova instância da classe <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" />.</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary vsli:raw="Gets or sets a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">Obtém ou define um valor <see cref="T:System.ReadOnlyMemory`1" /> para o nó atual.</summary>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt; value for the current node.">Um <see cref="T:System.ReadOnlyMemory`1" /> valor para o nó atual.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary vsli:raw="Gets or sets the next node.">Obtém ou define o próximo nó.</summary>
      <returns vsli:raw="The next node.">O próximo nó.</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary vsli:raw="Gets or sets the sum of node lengths before the current node.">Obtém ou define a soma dos comprimentos de nó antes do nó atual.</summary>
      <returns vsli:raw="The sum of node lengths before the current node.">A soma de comprimentos de nó antes do nó atual.</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary vsli:raw="Provides methods for reading binary and text data out of a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; with a focus on performance and minimal or zero heap allocations.">Fornece métodos para ler dados binários e de texto de um <see cref="T:System.Buffers.ReadOnlySequence`1" /> com foco no desempenho e em alocações de heap mínimas ou zero.</summary>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">O tipo da sequência somente leitura.</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; over a given &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Cria um <see cref="T:System.Buffers.SequenceReader`1" /> sobre um determinado <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
      <param name="sequence" vsli:raw="The read-only sequence over which to create the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt;.">A sequência somente leitura sobre a qual criar o <see cref="T:System.Buffers.SequenceReader`1" />.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary vsli:raw="Moves the reader ahead a specified number of items.">Move o leitor para frente um número especificado de itens.</summary>
      <param name="count" vsli:raw="The number of items to advance.">O número de itens a ser avançado.</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary vsli:raw="Advances past consecutive instances of the given &lt;paramref name=&quot;value&quot; /&gt;.">Ignora instâncias consecutivas do <paramref name="value" /> fornecido.</summary>
      <param name="value" vsli:raw="The value past which the reader is to advance.">O valor que o leitor deve ignorar.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of either of two specified values.">Ignora instâncias consecutivas de qualquer um dos dois valores especificados.</summary>
      <param name="value0" vsli:raw="The first value to skip.">O primeiro valor a ser ignorado.</param>
      <param name="value1" vsli:raw="The second value to skip.">O segundo valor a ser ignorado.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of three specified values.">Ignora instâncias consecutivas de qualquer um dos três valores especificados.</summary>
      <param name="value0" vsli:raw="The first value to skip.">O primeiro valor a ser ignorado.</param>
      <param name="value1" vsli:raw="The second value to skip.">O segundo valor a ser ignorado.</param>
      <param name="value2" vsli:raw="The third value to skip.">O terceiro valor a ser ignorado.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary vsli:raw="Advances past consecutive instances of any of four specified values.">Ignora instâncias consecutivas de qualquer um dos quatro valores especificados.</summary>
      <param name="value0" vsli:raw="The first value to skip.">O primeiro valor a ser ignorado.</param>
      <param name="value1" vsli:raw="The second value to skip.">O segundo valor a ser ignorado.</param>
      <param name="value2" vsli:raw="The third value to skip.">O terceiro valor a ser ignorado.</param>
      <param name="value3" vsli:raw="The fourth value to skip.">O quarto valor a ser ignorado.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary vsli:raw="Skips consecutive instances of any of the specified &lt;paramref name=&quot;values&quot; /&gt;.">Ignora instâncias consecutivas de qualquer um dos <paramref name="values" /> especificados.</summary>
      <param name="values" vsli:raw="The values to be skipped.">Os valores a serem ignorados.</param>
      <returns vsli:raw="The number of positions the reader has advanced.">O número de posições que o leitor avançou.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary vsli:raw="Moves the reader to the end of the sequence.">Move o leitor para o fim da sequência.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary vsli:raw="Checks whether a specified value is next in the sequence.">Verifica se um valor especificado é o próximo na sequência.</summary>
      <param name="next" vsli:raw="The value to compare the next items to.">O valor com o qual comprar os próximos itens.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar os valores <paramref name="next" /> se eles forem encontrados; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os valores forem os próximos na sequência; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Checks whether the values specified in a read-only span are next in the sequence.">Verifica se os valores especificados em um intervalo somente leitura são os próximos na sequência.</summary>
      <param name="next" vsli:raw="The span to compare the next items to.">O intervalo com o qual comparar os próximos itens.</param>
      <param name="advancePast" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;next&quot; /&gt; values if they are found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar os valores <paramref name="next" /> se eles forem encontrados; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the values are next in sequence; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os valores forem os próximos na sequência; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary vsli:raw="Moves the reader back the specified number of items.">Move o leitor de volta o número especificado de itens.</summary>
      <param name="count" vsli:raw="The number of items.">O número de itens.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;count&quot; /&gt; is negative or greater than &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Consumed&quot; /&gt;.">
        <paramref name="count" /> é negativo ou maior que <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary vsli:raw="Searches for a specified delimiter and optionally advances past it if it is found.">Procura um delimitador especificado e, opcionalmente, o ignorará se for encontrado.</summary>
      <param name="delimiter" vsli:raw="The delimiter to search for.">O delimitador a ser pesquisado.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if it is found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the given &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <paramref name="delimiter" /> fornecido tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Searches for any of a number of specified delimiters and optionally advances past the first one to be found.">Procura qualquer número de delimitadores especificados e, opcionalmente, ignora o primeiro encontrado.</summary>
      <param name="delimiters" vsli:raw="The delimiters to search for.">Os delimitadores a serem pesquisados.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; &lt;see langword=&quot;false&quot; /&gt; to not move past the delimiter.">
        <see langword="true" /> para ignorar a primeira instância de qualquer um dos <paramref name="delimiters" /> fornecidos; <see langword="false" /> para não ignorar o delimitador.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the given &lt;paramref name=&quot;delimiters&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se um dos <paramref name="delimiters" /> fornecidos tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary vsli:raw="Copies data from the current position to the given destination span if there is enough data to fill it.">Copiará dados da posição atual para o intervalo de destino fornecido se houver dados suficientes para preenchê-lo.</summary>
      <param name="destination" vsli:raw="Destination span to copy to.">Intervalo de destino para o qual copiar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if there is enough data to completely fill the &lt;paramref name=&quot;destination&quot; /&gt; span; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se houver dados suficientes para preencher completamente o intervalo <paramref name="destination" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary vsli:raw="Peeks at the next value without advancing the reader.">Espia o próximo valor sem avançar o leitor.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">O próximo valor ou o valor padrão se estiver no fim do leitor.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> se o leitor não estiver no seu fim e a operação de espiada for bem-sucedida; <see langword="false" /> se estiver no final do leitor.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary vsli:raw="Peeks at the next value at the specified offset without advancing the reader.">Inspeciona o próximo valor no deslocamento especificado sem avançar o leitor.</summary>
      <param name="offset" vsli:raw="The offset from current position.">O deslocamento da posição atual.</param>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">O próximo valor ou o valor padrão se estiver no fim do leitor.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the peek operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> se o leitor não estiver no seu fim e a operação de espiada for bem-sucedida; <see langword="false" /> se estiver no final do leitor.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary vsli:raw="Reads the next value and advance the reader.">Lê o próximo valor e avança o leitor.</summary>
      <param name="value" vsli:raw="The next value, or the default value if at the end of the reader.">O próximo valor ou o valor padrão se estiver no fim do leitor.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the reader is not at its end and the read operation succeeded; &lt;see langword=&quot;false&quot; /&gt; if at the end of the reader.">
        <see langword="true" /> se o leitor não estiver no seu fim e a operação de leitura for bem-sucedida; <see langword="false" /> se estiver no final do leitor.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Tenta ler tudo até o <paramref name="delimiter" /> fornecido, ignorando os delimitadores precedidos por <paramref name="delimiterEscape" />.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">O delimitador a ser procurado.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Um valor que indica que um <paramref name="delimiter" /> imediatamente após deve ser ignorado.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Tenta ler tudo até o <paramref name="delimiter" /> fornecido.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">O delimitador a ser procurado.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read data until the entire delimiter specified as a read-only span matches.">Tenta ler dados até a correspondência do delimitador inteiro especificado como um intervalo somente leitura.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter" vsli:raw="A read-only span that contains one or more delimiters.">Um intervalo somente leitura que contém um ou mais delimitadores.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;, ignoring delimiters that are preceded by &lt;paramref name=&quot;delimiterEscape&quot; /&gt;.">Tenta ler tudo até o <paramref name="delimiter" /> fornecido, ignorando os delimitadores precedidos por <paramref name="delimiterEscape" />.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">O delimitador a ser procurado.</param>
      <param name="delimiterEscape" vsli:raw="A value that indicates that an immediately following &lt;paramref name=&quot;delimiter&quot; /&gt; is to be skipped.">Um valor que indica que um <paramref name="delimiter" /> imediatamente após deve ser ignorado.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary vsli:raw="Tries to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Tenta ler tudo até o <paramref name="delimiter" /> fornecido.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">O delimitador a ser procurado.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se for encontrado; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Try to read everything up to the given &lt;paramref name=&quot;delimiter&quot; /&gt;.">Tente ler tudo até o <paramref name="delimiter" /> fornecido.</summary>
      <param name="sequence" vsli:raw="The read data, if any.">Os dados lidos, se houver.</param>
      <param name="delimiter" vsli:raw="The delimiter to look for.">O delimitador a ser procurado.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the &lt;paramref name=&quot;delimiter&quot; /&gt; if found.">
        <see langword="true" /> para ignorar o <paramref name="delimiter" /> se encontrado.</param>
      <param name="span" vsli:raw="The read data, if any.">Os dados lidos, se houver.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the &lt;paramref name=&quot;delimiter&quot; /&gt; was found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o <paramref name="delimiter" /> tiver sido encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Tenta ler tudo até o qualquer um dos <paramref name="delimiters" /> especificados.</summary>
      <param name="sequence" vsli:raw="When the method returns, contains the data read, if any.">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Os delimitadores a serem procurados.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar a primeira instância encontrada de qualquer um dos <paramref name="delimiters" /> fornecidos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="delimiters" /> forem encontrados; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary vsli:raw="Tries to read everything up to any of the specified &lt;paramref name=&quot;delimiters&quot; /&gt;.">Tenta ler tudo até o qualquer um dos <paramref name="delimiters" /> especificados.</summary>
      <param name="span" vsli:raw="When the method returns, contains the data read, if any.">Quando o método é retornado, contém os dados lidos, se houver.</param>
      <param name="delimiters" vsli:raw="The delimiters to look for.">Os delimitadores a serem procurados.</param>
      <param name="advancePastDelimiter" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to move past the first found instance of any of the given &lt;paramref name=&quot;delimiters&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para ignorar a primeira instância encontrada de qualquer um dos <paramref name="delimiters" /> fornecidos; caso contrário, <see langword="false" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if any of the &lt;paramref name=&quot;delimiters&quot; /&gt; were found; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="delimiters" /> forem encontrados; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary vsli:raw="Gets the total number of &lt;typeparamref name=&quot;T&quot; /&gt; values processed by the reader.">Obtém o número total de valores <typeparamref name="T" /> processados pelo leitor.</summary>
      <returns vsli:raw="The total number of values processed by the reader.">O número total de valores processados pelo leitor.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary vsli:raw="Gets a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; that contains the current segment in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtém um <see cref="T:System.Span`1" /> que contém o segmento atual no <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="A span that contains the current segment in the sequence.">Um Span que contém o segmento atual na sequência.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary vsli:raw="Gets the index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Obtém o índice no <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The index in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">O índice no <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary vsli:raw="Gets a value that indicates whether there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtém um valor que indica se não há mais dados no <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; when there is no more data in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Quando não há mais dados no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary vsli:raw="Gets the count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtém a contagem de itens no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> do leitor.</summary>
      <returns vsli:raw="The count of items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">A contagem de itens nos leitores <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary vsli:raw="Gets the current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtém a posição atual no <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="The current position in the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">A posição atual no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary vsli:raw="Gets  the remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtém os itens restantes no <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> do leitor.</summary>
      <returns vsli:raw="The remaining items in the reader's &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;">Os itens restantes nas <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary vsli:raw="Gets the underlying &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; for the reader.">Obtém o <see cref="T:System.Buffers.ReadOnlySequence`1" /> subjacente do leitor.</summary>
      <returns vsli:raw="The underlying read-only sequence for the reader.">A sequência de somente leitura subjacente para o leitor.</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">Obtém a parte não lida do <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.Sequence&quot; /&gt;.">A parte não lida do <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> .</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary vsli:raw="Gets the unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">Obtém a parte não lida do <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</summary>
      <returns vsli:raw="The unread portion of the &lt;see cref=&quot;P:System.Buffers.SequenceReader`1.CurrentSpan&quot; /&gt;.">A parte não lida do <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> .</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary vsli:raw="Provides extended functionality for the &lt;see cref=&quot;T:System.Buffers.SequenceReader`1&quot; /&gt; class that allows reading of endian specific numeric values from binary data.">Fornece funcionalidade estendida para a classe <see cref="T:System.Buffers.SequenceReader`1" /> que permite a leitura de valores numéricos específicos de endian de dados binários.</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as big endian.">Tenta ler um <see cref="T:System.Int16" /> como big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as big endian.">Tenta ler um <see cref="T:System.Int32" /> como big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader from which to read the value.">O leitor de sequência de bytes do qual ler o valor.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as big endian.">Tenta ler um <see cref="T:System.Int64" /> como big endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as big endian.">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como big endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as little endian.">Tenta ler um <see cref="T:System.Int16" /> como little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int16&quot; /&gt;.">
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as little endian.">Tenta ler um <see cref="T:System.Int32" /> como little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int32&quot; /&gt;.">
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary vsli:raw="Tries to read an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as little endian.">Tenta ler um <see cref="T:System.Int64" /> como little endian.</summary>
      <param name="reader" vsli:raw="The byte sequence reader instance from which the value is to be read.">A instância do leitor de sequência de bytes da qual o valor deve ser lido.</param>
      <param name="value" vsli:raw="When the method returns, the value read out of the byte sequence reader, as little endian.">Quando o método é retornado, o valor lido do leitor de sequência de bytes, como little endian.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read operation is successful; &lt;see langword=&quot;false&quot; /&gt; if there isn't enough data for an &lt;see cref=&quot;T:System.Int64&quot; /&gt;.">
        <see langword="true" /> se a operação de leitura for bem-sucedida; <see langword="false" /> se não houver dados suficientes para um <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary vsli:raw="Represents a standard format string without using an actual string.">Representa uma cadeia de caracteres de formato padrão sem usar uma cadeia de caracteres real.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary vsli:raw="Defines the maximum valid precision value.">Define o valor máximo válido da precisão.</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary vsli:raw="Indicates that a format doesn't use a precision or that the precision is unspecified.">Indica se um formato não usa uma precisão ou se a precisão não está especificada.</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; structure.">Inicializa uma nova instância da estrutura <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="symbol" vsli:raw="A type-specific format specifier, such as 'G', 'D', or 'X'.">Um especificador de formato de tipo específico, como 'G','D' ou 'X'.</param>
      <param name="precision" vsli:raw="An optional precision ranging from 0 to 99, or the special value &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; (the default).">Uma precisão opcional que varia de 0 a 99, ou o valor especial <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (o padrão).</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;symbol&quot; /&gt; is not &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, and its value is greater than &lt;see cref=&quot;F:System.Buffers.StandardFormat.MaxPrecision&quot; /&gt;.&#xA;&#xA;-or-&#xA;&#xA;&lt;paramref name=&quot;symbol&quot; /&gt; cannot be converted to a &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">
        <paramref name="symbol" /> não é <see cref="F:System.Buffers.StandardFormat.NoPrecision" />, e seu valor é maior que <see cref="F:System.Buffers.StandardFormat.MaxPrecision" />.

- ou -

<paramref name="symbol" /> não pode ser convertido para um <see cref="T:System.Byte" />.</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether the specified &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; is equal to the current instance.">Retorna um valor que indica se a instância <see cref="T:System.Buffers.StandardFormat" /> especificada é igual à instância atual.</summary>
      <param name="other" vsli:raw="The format to compare to the current instance.">O formato para ser comparado com a instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas instâncias forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the specified object is a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; object that is equal to the current instance.">Retorna um valor que indica se o objeto especificado é um objeto <see cref="T:System.Buffers.StandardFormat" /> igual à instância atual.</summary>
      <param name="obj" vsli:raw="An object to compare to the current instance.">Um objeto a ser comparado à instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas instâncias forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retorna o código hash para a instância.</summary>
      <returns vsli:raw="The hash code for this instance.">O código hash para essa instância.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Returns a value that indicates whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are equal.">Retorna um valor que indica se duas instâncias <see cref="T:System.Buffers.StandardFormat" /> são iguais.</summary>
      <param name="left" vsli:raw="The first format to compare.">O primeiro formato a comparar.</param>
      <param name="right" vsli:raw="The second format to compare.">O segundo formato a comparar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas instâncias forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary vsli:raw="Converts a character to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Converte um caractere em uma instância <see cref="T:System.Buffers.StandardFormat" /> usando a precisão <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="symbol" vsli:raw="The character to convert to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; value.">O caractere a converter em um valor <see cref="T:System.Buffers.StandardFormat" />.</param>
      <returns vsli:raw="A format with a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property equal to &lt;paramref name=&quot;symbol&quot; /&gt; and a &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property equal to &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Um formato com a propriedade <see cref="P:System.Buffers.StandardFormat.Symbol" /> igual a <paramref name="symbol" /> e uma propriedade <see cref="P:System.Buffers.StandardFormat.Precision" /> igual a <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary vsli:raw="Determines whether two &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instances are unequal.">Determina se duas instâncias <see cref="T:System.Buffers.StandardFormat" /> são diferentes.</summary>
      <param name="left" vsli:raw="The first format to compare.">O primeiro formato a comparar.</param>
      <param name="right" vsli:raw="The second format to compare.">O segundo formato a comparar.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two formats are unequal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se os dois formatos forem diferentes; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Converts a &lt;see langword=&quot;ReadOnlySpan&amp;lt;System.Char&amp;gt;&quot; /&gt; into a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance using &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt; precision.">Converte <see langword="ReadOnlySpan&lt;System.Char&gt;" /> em uma instância <see cref="T:System.Buffers.StandardFormat" /> usando a precisão <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to parse.">Uma extensão somente leitura que contém o caractere a analisar.</param>
      <returns vsli:raw="A value whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Symbol&quot; /&gt; property value is the character in &lt;paramref name=&quot;format&quot; /&gt; and whose &lt;see cref=&quot;P:System.Buffers.StandardFormat.Precision&quot; /&gt; property value is &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;.">Um valor cujo valor de propriedade <see cref="P:System.Buffers.StandardFormat.Symbol" /> é o caractere em <paramref name="format" /> e cujo valor de propriedade <see cref="P:System.Buffers.StandardFormat.Precision" /> é <see cref="F:System.Buffers.StandardFormat.NoPrecision" />.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary vsli:raw="Converts a classic .NET standard format string to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance.">Converte uma cadeia clássica de caracteres de formato padrão .NET em uma instância <see cref="T:System.Buffers.StandardFormat" />.</summary>
      <param name="format" vsli:raw="A classic .NET standard format string.">Uma cadeia clássica de formato padrão do .NET.</param>
      <exception cref="T:System.FormatException" vsli:raw="&lt;paramref name=&quot;format&quot; /&gt; is not a valid standard format string.">
        <paramref name="format" /> não é uma cadeia de caracteres de formato padrão válida.</exception>
      <returns vsli:raw="A format.">Um formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary vsli:raw="Returns the string representation of this format.">Retorna a representação de cadeia de caracteres desse formato.</summary>
      <returns vsli:raw="The string representation of this format.">A representação de cadeia de caracteres desse formato.</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary vsli:raw="Attempts to convert a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Char&amp;gt;&quot; /&gt; to a &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance and returns a value that indicates whether the parsing operation succeeded.">Tenta converter uma instância <see langword="ReadOnlySpan&lt;Char&gt;" /> em <see cref="T:System.Buffers.StandardFormat" /> e retorna um valor que indica se a operação de análise foi bem-sucedida.</summary>
      <param name="format" vsli:raw="A read-only span that contains the character to convert.">Uma extensão somente leitura que contém o caractere a converter.</param>
      <param name="result" vsli:raw="When the method returns, contains the parsed &lt;see cref=&quot;T:System.Buffers.StandardFormat&quot; /&gt; instance if the operation was successful.">Quando o método retorna, contém a instância <see cref="T:System.Buffers.StandardFormat" /> analisada se a operação for bem-sucedida.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the parsing operation was successful; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a operação de análise for bem-sucedida; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary vsli:raw="Gets a value that indicates whether a format has a defined precision.">Obtém um valor que indica se um formato tem uma precisão definida.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the format has a precision other than &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> Se o formato tiver uma precisão diferente de <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary vsli:raw="Gets a value that indicates whether the current instance is a default format.">Obtém um valor que indica se a instância atual é o formato padrão.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the current instance is a default format; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a instância atual for um formato padrão; caso contrário, <see langword="false" /> .</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary vsli:raw="Gets the precision component of the format.">Obtém o componente de precisão do formato.</summary>
      <returns vsli:raw="The precision component, which can be &lt;see cref=&quot;F:System.Buffers.StandardFormat.NoPrecision&quot; /&gt;, or can range from 0 to 9.">O componente de precisão, que pode ser <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> , ou pode variar de 0 a 9.</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary vsli:raw="Gets the character component of the format.">Obtém o componente de caracteres do formato.</summary>
      <returns vsli:raw="The character component of the format.">O componente de caractere do formato.</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>Faz a conversão entre dados binários e texto codificado em UTF-8 representado na base 64.</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Decodifica a extensão de texto codificado em UTF-8 representado como base 64 em dados binários. Se a entrada não for um múltiplo de 4, ela fará o maior número de decodificações possível até o múltiplo mais próximo de 4.</summary>
      <param name="utf8">A extensão de entrada que contém o texto codificado em UTF-8 na base 64 que precisa ser decodificado.</param>
      <param name="bytes">A extensão de saída que contém o resultado da operação, ou seja, os dados binários decodificados.</param>
      <param name="bytesConsumed">O número de bytes de entrada consumidos durante a operação. Isso pode ser usado para fatiar a entrada para chamadas subsequentes, se necessário.</param>
      <param name="bytesWritten">O número de bytes gravados na extensão de saída. Isso pode ser usado para fatiar a saída para chamadas subsequentes, se necessário.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (padrão) se a extensão de entrada contiver todos os dados a ser decodificados. <see langword="false" /> se a extensão de entrada contiver dados parciais com mais dados para seguir.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de decodificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>Decodifica a extensão do texto codificado em UTF-8 na base 64 (in-loco) em dados binários. A saída binária decodificada é menor que os dados de texto contidos na entrada (a operação compacta os dados). Se a entrada não for um múltiplo de 4, o método não decodificará nenhum dado.</summary>
      <param name="buffer">A extensão de entrada que contém os dados de texto da base 64 que precisam ser decodificados.</param>
      <param name="bytesWritten">O número de bytes gravados no buffer.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de decodificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>Codifica a extensão de dados binários em texto codificado em UTF-8 representado como base 64.</summary>
      <param name="bytes">A extensão de entrada que contém dados binários que precisam ser codificados.</param>
      <param name="utf8">A extensão de saída que contém o resultado da operação, ou seja, o texto codificado em UTF-8 na base 64.</param>
      <param name="bytesConsumed">O número de bytes de entrada consumidos durante a operação. Isso pode ser usado para fatiar a entrada para chamadas subsequentes, se necessário.</param>
      <param name="bytesWritten">O número de bytes gravados na extensão de saída. Isso pode ser usado para fatiar a saída para chamadas subsequentes, se necessário.</param>
      <param name="isFinalBlock">
        <see langword="true" /> (o padrão) se a extensão de entrada contiver todos os dados a ser codificados. <see langword="false" /> se a extensão de entrada contiver dados parciais com mais dados para seguir.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de codificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>Codifica a extensão de dados binários (in-loco) em texto codificado em UTF-8 representado como base 64. A saída de texto codificada é maior que os dados binários contidos na entrada (a operação descompacta os dados).</summary>
      <param name="buffer">A extensão de entrada que contém dados binários que precisam ser codificados. Visto que o método realiza uma conversão in-loco, ele precisa ser grande o suficiente para armazenar o resultado da operação.</param>
      <param name="dataLength">O número de bytes de dados binários contidos no buffer que precisam ser codificados. Esse valor deve ser menor que o tamanho do buffer.</param>
      <param name="bytesWritten">O número de bytes gravados no buffer.</param>
      <returns>Um dos valores de enumeração que indica o status da operação de codificação.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>Retorna o tamanho máximo (em bytes) do resultado caso seja necessário decodificar um texto codificado como base 64 sem a extensão de bytes com o tamanho especificado.</summary>
      <param name="length">O tamanho da extensão de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> é menor que 0.</exception>
      <returns>O tamanho máximo (em bytes) do resultado.</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>Retorna o tamanho máximo (em bytes) do resultado caso seja necessário codificar dados binários sem a extensão de bytes com o tamanho especificado.</summary>
      <param name="length">O tamanho da extensão de bytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> é menor que 0 ou maior que 1610612733 (pois a codificação infla os dados em 4/3).</exception>
      <returns>O tamanho máximo (em bytes) do resultado.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary vsli:raw="Provides static methods to format common data types as Utf8 strings.">Fornece métodos estáticos para formatar tipos de dados comuns como cadeias de caracteres UTF8.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Boolean" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Byte&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Byte" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.DateTime" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.DateTimeOffset" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Decimal" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Double&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Double" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Guid&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Guid" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int16&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Int16" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int32&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Int32" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.Int64&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Int64" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats an &lt;see cref=&quot;T:System.SByte&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.SByte" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.Single&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.Single" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.TimeSpan" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.UInt16" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.UInt32" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary vsli:raw="Formats a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; as a UTF8 string.">Formata um <see cref="T:System.UInt64" /> como uma cadeia de caracteres UTF8.</summary>
      <param name="value" vsli:raw="The value to format.">O valor a ser formatado.</param>
      <param name="destination" vsli:raw="The buffer to write the UTF8-formatted value to.">O buffer no qual gravar o valor formatado por UTF8.</param>
      <param name="bytesWritten" vsli:raw="When the method returns, contains the length of the formatted text in bytes.">Quanto o método é retornado, contém o comprimento do texto formatado em bytes.</param>
      <param name="format" vsli:raw="The standard format to use.">O formato padrão a ser usado.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the formatting operation succeeds; &lt;see langword=&quot;false&quot; /&gt; if &lt;paramref name=&quot;destination&quot; /&gt; is too small.">
        <see langword="true" /> se a operação de formatação for bem-sucedida; <see langword="false" /> se <paramref name="buffer" /> for muito pequeno.</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary vsli:raw="Provides static methods to parse Utf8 strings to common data types.">Fornece métodos estáticos para analisar cadeias de caracteres Utf8 para tipos de dados comuns.</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Boolean&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Boolean" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Byte&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Byte" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.DateTime" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.DateTimeOffset&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.DateTimeOffset" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Decimal&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Decimal" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Double&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Double" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Guid&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Guid" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int16&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Int16" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int32&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Int32" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.Int64&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Int64" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses an &lt;see cref=&quot;T:System.SByte&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.SByte" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.Single&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.Single" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.TimeSpan&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.TimeSpan" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt16&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.UInt16" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt32&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.UInt32" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary vsli:raw="Parses a &lt;see cref=&quot;T:System.UInt64&quot; /&gt; at the start of a Utf8 string.">Analisa um <see cref="T:System.UInt64" /> no início de uma cadeia de caracteres Utf8.</summary>
      <param name="source" vsli:raw="The Utf8 string to parse.">A cadeia de caracteres Utf8 a ser analisada.</param>
      <param name="value" vsli:raw="When the method returns, contains the value parsed from &lt;paramref name=&quot;source&quot; /&gt;, if the parsing operation succeeded.">Quando o método é retornado, contém o valor analisado de <paramref name="source" />, se a operação de análise foi bem-sucedida.</param>
      <param name="bytesConsumed" vsli:raw="If the parsing operation was successful, contains the length in bytes of the parsed substring when the method returns. If the method fails, &lt;paramref name=&quot;bytesConsumed&quot; /&gt; is set to 0.">Se a operação de análise tiver sido bem-sucedida, conterá o comprimento em bytes da substring de caracteres analisada quando o método for retornado. Se o método falhar, <paramref name="bytesConsumed" /> será definido como 0.</param>
      <param name="standardFormat" vsli:raw="The expected format of the Utf8 string.">O formato esperado da cadeia de caracteres Utf8.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; for success; &lt;see langword=&quot;false&quot; /&gt; if the string was not syntactically valid or an overflow or underflow occurred.">
        <see langword="true" /> para êxito; <see langword="false" /> se a cadeia de caracteres não era sintaticamente válida ou se ocorreu um estouro ou estouro negativo.</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary vsli:raw="Provides extension methods for the memory- and span-related types, such as &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;, &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Fornece métodos de extensão para os tipos relacionados à memória e ao intervalo, como <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over the portion of the target string.">Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> na parte da cadeia de caracteres de destino.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">A representação de memória de caracteres somente leitura da cadeia de caracteres ou <see langword="default" /> se <paramref name="text" /> é <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified index.">Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em uma parte da cadeia de caracteres de destino começando em um índice especificado.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <param name="startIndex" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">A representação de memória de caracteres somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string starting at a specified character position.">Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em uma parte da cadeia de caracteres de destino começando em uma posição de caractere especificada.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt; (&lt;paramref name=&quot;start&quot; /&gt; is &amp;lt; 0 or &amp;gt; &lt;c&gt;text.Length&lt;/c&gt;).">
        <paramref name="start" /> não está no intervalo de <paramref name="text" /> (<paramref name="start" /> é &lt; 0 ou &gt; <c>text.Length</c>).</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">A representação de memória de caracteres somente leitura da cadeia de caracteres ou <see langword="default" /> se <paramref name="text" /> é <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a portion of the target string beginning at a specified position with a length.">Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em uma parte da cadeia de caracteres de destino começando em uma posição especificada com um tamanho.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <param name="length" vsli:raw="The desired length for the slice.">O tamanho desejado da fatia.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only character memory representation of the string, or &lt;see langword=&quot;default&quot; /&gt; if &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">A representação de memória de caracteres somente leitura da cadeia de caracteres ou <see langword="default" /> se <paramref name="text" /> é <see langword="null" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary vsli:raw="Creates a new &lt;see langword=&quot;ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt; over a specified range of the target string.">Cria um <see langword="ReadOnlyMemory&lt;Char&gt;" /> em um intervalo especificado da cadeia de caracteres de destino.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <param name="range" vsli:raw="The range that indicates the start and length of the sliced string.">O intervalo que indica o início e o tamanho da cadeia de caracteres segmentada.</param>
      <returns vsli:raw="The read-only character memory representation of the string.">A representação de memória de caracteres somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary vsli:raw="Creates a new memory region over the target array.">Cria uma região de memória na matriz de destino.</summary>
      <param name="array" vsli:raw="The array to convert.">A matriz a ser convertida.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.">Cria uma região de memória na parte da matriz de destino começando em um índice especificado até o final da matriz.</summary>
      <param name="array" vsli:raw="The array to convert.">A matriz a ser convertida.</param>
      <param name="startIndex" vsli:raw="The first position of the array.">A primeira posição da matriz.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.">Cria uma região de memória na parte da matriz de destino começando em uma posição especificada até o final da matriz.</summary>
      <param name="array" vsli:raw="The target array.">A matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">O índice no qual a memória será iniciada.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; index less than 0 or greater than &lt;see langword=&quot;array.Length&quot; /&gt;.">O índice <paramref name="start" /> é menor que 0 ou maior que <see langword="array.Length" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.">Cria uma região de memória na parte da matriz de destino começando em uma posição especificada com um tamanho especificado.</summary>
      <param name="array" vsli:raw="The target array.">A matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory region.">O índice no qual a região de memória será iniciada.</param>
      <param name="length" vsli:raw="The number of items in the memory region.">O número de itens na região de memória.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;array&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="array" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.">Cria uma região de memória na parte da matriz de destino começando no índice de início inclusivo do intervalo e terminando no índice final exclusivo do intervalo.</summary>
      <param name="array" vsli:raw="The array to convert.">A matriz a ser convertida.</param>
      <param name="range" vsli:raw="The range to convert from the array.">O intervalo a ser convertido com base na matriz.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <returns vsli:raw="The memory representation of the whole or part of the array.">A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment.">Cria uma região de memória na parte do segmento de matriz de destino.</summary>
      <param name="segment" vsli:raw="The segment to convert.">O segmento a ser convertido.</param>
      <typeparam name="T" vsli:raw="The type of the segment.">O tipo do segmento.</typeparam>
      <returns vsli:raw="The memory representation of the segment.">A representação de memória do segmento.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.">Cria uma região de memória na parte do segmento de matriz de destino começando em uma posição especificada até o final do segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">O segmento de matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">O índice no qual a memória será iniciada.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;segment&quot; /&gt; is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> é covariante e o tipo de <paramref name="segment" /> não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> é menor que 0 ou maior que <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.">Cria uma região de memória na parte do segmento de matriz de destino começando em uma posição especificada com um tamanho especificado.</summary>
      <param name="segment" vsli:raw="The target array segment.">O segmento de matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the memory.">O índice no qual a memória será iniciada.</param>
      <param name="length" vsli:raw="The number of items in the memory.">O número de itens na memória.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="segment" />.</exception>
      <returns vsli:raw="The memory representation of the whole or part of the array.">A representação de memória de todo ou parte da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary vsli:raw="Creates a new read-only span over a string.">Cria um intervalo somente leitura em uma parte da cadeia de caracteres de destino com base em uma posição especificada para um número especificado de caracteres.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <returns vsli:raw="The read-only span representation of the string.">A representação de intervalo somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position to the end of the string.">Cria um intervalo somente leitura em uma parte da cadeia de caracteres de destino com base em uma posição especificada até o final da cadeia de caracteres.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <exception cref="T:System.ArgumentNullException" vsli:raw="Thrown when &lt;paramref name=&quot;text&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="text" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;text.Length&quot; /&gt;.">
        <paramref name="start" /> é menor que 0 ou maior que <see langword="text.Length" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">A representação de intervalo somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.">Cria um intervalo somente leitura em uma cadeia de caracteres.</summary>
      <param name="text" vsli:raw="The target string.">A cadeia de caracteres de destino.</param>
      <param name="start" vsli:raw="The index at which to begin this slice.">O índice no qual começar essa fatia.</param>
      <param name="length" vsli:raw="The desired length for the slice.">O tamanho desejado da fatia.</param>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="text" />.</exception>
      <returns vsli:raw="The read-only span representation of the string.">A representação de intervalo somente leitura da cadeia de caracteres.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary vsli:raw="Creates a new span over a target array.">Cria um intervalo em uma matriz de destino.</summary>
      <param name="array" vsli:raw="The array to convert.">A matriz a ser convertida.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary vsli:raw="Creates a new span over the portion of the target array defined by an &lt;see cref=&quot;T:System.Index&quot; /&gt; value.">Cria um intervalo na parte da matriz de destino definida por um valor <see cref="T:System.Index" />.</summary>
      <param name="array" vsli:raw="The array to convert.">A matriz a ser convertida.</param>
      <param name="startIndex" vsli:raw="The starting index.">O índice inicial.</param>
      <typeparam name="T" vsli:raw="The array type.">O tipo de matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of the target array starting at a specified position to the end of the array.">Cria um intervalo em uma parte da matriz de destino começando em uma posição especificada até o fim da matriz.</summary>
      <param name="array" vsli:raw="The array to convert.">A matriz a ser convertida.</param>
      <param name="start" vsli:raw="The initial index from which the array will be converted.">O índice inicial do qual a matriz será convertida.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over the portion of the target array beginning at a specified position for a specified length.">Cria um intervalo na parte da matriz de destino começando em uma posição especificada para um tamanho especificado.</summary>
      <param name="array" vsli:raw="The target array.">A matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">O índice no qual o intervalo será iniciado.</param>
      <param name="length" vsli:raw="The number of items in the span.">O número de itens no intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;&quot;.">
        <paramref name="array" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;text&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="text" />.</exception>
      <returns vsli:raw="The span representation of the array.">A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array defined by a &lt;see cref=&quot;T:System.Range&quot; /&gt; value.">Cria um intervalo em uma parte de uma matriz de destino definida por um valor <see cref="T:System.Range" />.</summary>
      <param name="array" vsli:raw="The array to convert.">A matriz a ser convertida.</param>
      <param name="range" vsli:raw="The range of the array to convert.">O intervalo da matriz a ser convertido.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <returns vsli:raw="The span representation of the array.">A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary vsli:raw="Creates a new span over a target array segment.">Cria um intervalo em um segmento de matriz de destino.</summary>
      <param name="segment" vsli:raw="The array segment to convert.">O segmento de matriz a ser convertido.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">O tipo do segmento da matriz.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary vsli:raw="Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.">Cria um intervalo em uma parte do segmento de matriz de destino começando em um índice especificado e terminando no final do segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">O segmento de matriz de destino.</param>
      <param name="startIndex" vsli:raw="The index at which to begin the Span.">O índice no qual o intervalo será iniciado.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">O tipo do segmento da matriz.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position to the end of the segment.">Cria um intervalo em uma parte de um segmento de matriz de destino com base em uma posição especificada até o final do segmento.</summary>
      <param name="segment" vsli:raw="The target array segment.">O segmento de matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the san.">O índice no qual o intervalo será iniciado.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">O tipo do segmento da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt; is less than 0 or greater than &lt;see langword=&quot;segment.Count&quot; /&gt;.">
        <paramref name="start" /> é menor que 0 ou maior que <see langword="segment.Count" />.</exception>
      <returns vsli:raw="The span representation of the array segment.">A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment from a specified position for a specified length.">Cria um intervalo em uma parte de um segmento de matriz de destino com base em uma posição especificada para um tamanho especificado.</summary>
      <param name="segment" vsli:raw="The target array segment.">O segmento de matriz de destino.</param>
      <param name="start" vsli:raw="The index at which to begin the span.">O índice no qual o intervalo será iniciado.</param>
      <param name="length" vsli:raw="The number of items in the span.">O número de itens no intervalo.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">O tipo do segmento da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;segment&quot; /&gt; is covariant, and the array's type is not exactly &lt;see langword=&quot;T[]&quot; /&gt;.">
        <paramref name="segment" /> é covariante, e o tipo da matriz não é exatamente <see langword="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;start&quot; /&gt;, &lt;paramref name=&quot;length&quot; /&gt;, or &lt;paramref name=&quot;start&quot; /&gt; + &lt;paramref name=&quot;length&quot; /&gt; is not in the range of &lt;paramref name=&quot;segment&quot; /&gt;.">
        <paramref name="start" />, <paramref name="length" /> ou <paramref name="start" /> + <paramref name="length" /> não está no intervalo de <paramref name="segment" />.</exception>
      <returns vsli:raw="The span representation of the array.">A representação de intervalo da matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary vsli:raw="Creates a new span over a portion of a target array segment using the range start and end indexes.">Cria um intervalo em uma parte de um segmento de matriz de destino usando os índices de início e término do intervalo.</summary>
      <param name="segment" vsli:raw="The target array segment.">O segmento de matriz de destino.</param>
      <param name="range" vsli:raw="The range which has start and end indexes to use for slicing the array.">O intervalo que tem os índices de início e término a serem usados para dividir a matriz.</param>
      <typeparam name="T" vsli:raw="The type of the array segment.">O tipo do segmento da matriz.</typeparam>
      <returns vsli:raw="The span representation of the array segment.">A representação de intervalo do segmento de matriz.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Pesquisa um <see cref="T:System.ReadOnlySpan`1" /> inteiro classificado por um valor usando a interface genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">O <see cref="T:System.ReadOnlySpan`1" /> classificado a ser pesquisado.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">O <see cref="T:System.IComparable`1" /> a ser usado na comparação.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">O tipo de elemento da extensão.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; generic interface.">Pesquisa um <see cref="T:System.Span`1" /> inteiro classificado por um valor usando a interface genérica <see cref="T:System.IComparable`1" /> especificada.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">O <see cref="T:System.Span`1" /> classificado a ser pesquisado.</param>
      <param name="comparable" vsli:raw="The &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; to use when comparing.">O <see cref="T:System.IComparable`1" /> a ser usado na comparação.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">O tipo de elemento da extensão.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Pesquisa um <see cref="T:System.ReadOnlySpan`1" /> inteiro classificado por um valor especificado usando o tipo genérico <typeparamref name="TComparer" /> especificado.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">O <see cref="T:System.ReadOnlySpan`1" /> classificado a ser pesquisado.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">O <typeparamref name="TComparer" /> a ser usado na comparação.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">O tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">O índice baseado em zero da <paramref name="value" /> no <paramref name="span" /> classificado, se <paramref name="value" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="value" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Pesquisa um <see cref="T:System.ReadOnlySpan`1" /> inteiro classificado por um valor usando o tipo genérico <typeparamref name="TComparable" /> especificado.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to search.">O <see cref="T:System.ReadOnlySpan`1" /> classificado a ser pesquisado.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">O <typeparamref name="TComparable" /> a ser usado na comparação.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">O tipo específico de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt;.">O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.ReadOnlySpan`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a specified value using the specified &lt;typeparamref name=&quot;TComparer&quot; /&gt; generic type.">Pesquisa um <see cref="T:System.Span`1" /> inteiro classificado por um valor especificado usando o tipo genérico <typeparamref name="TComparer" /> especificado.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">O <see cref="T:System.Span`1" /> classificado a ser pesquisado.</param>
      <param name="value" vsli:raw="The object to locate. The value can be &lt;see langword=&quot;null&quot; /&gt; for reference types.">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
      <param name="comparer" vsli:raw="The &lt;typeparamref name=&quot;TComparer&quot; /&gt; to use when comparing.">O <typeparamref name="TComparer" /> a ser usado na comparação.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparer" vsli:raw="The specific type of &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt;.">O tipo específico de <see cref="T:System.Collections.Generic.IComparer`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparer" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;value&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;value&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;value&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">O índice baseado em zero da <paramref name="value" /> no <paramref name="span" /> classificado, se <paramref name="value" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="value" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary vsli:raw="Searches an entire sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; for a value using the specified &lt;typeparamref name=&quot;TComparable&quot; /&gt; generic type.">Pesquisa um <see cref="T:System.Span`1" /> inteiro classificado por um valor usando o tipo genérico <typeparamref name="TComparable" /> especificado.</summary>
      <param name="span" vsli:raw="The sorted &lt;see cref=&quot;T:System.Span`1&quot; /&gt; to search.">O <see cref="T:System.Span`1" /> classificado a ser pesquisado.</param>
      <param name="comparable" vsli:raw="The &lt;typeparamref name=&quot;TComparable&quot; /&gt; to use when comparing.">O <typeparamref name="TComparable" /> a ser usado na comparação.</param>
      <typeparam name="T" vsli:raw="The element type of the span.">O tipo de elemento da extensão.</typeparam>
      <typeparam name="TComparable" vsli:raw="The specific type of &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt;.">O tipo específico de <see cref="T:System.IComparable`1" /> .</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparable&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparable" /> é <see langword="null" />.</exception>
      <returns vsli:raw="The zero-based index of &lt;paramref name=&quot;comparable&quot; /&gt; in the sorted &lt;paramref name=&quot;span&quot; /&gt;, if &lt;paramref name=&quot;comparable&quot; /&gt; is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than &lt;paramref name=&quot;comparable&quot; /&gt; or, if there is no larger element, the bitwise complement of &lt;see cref=&quot;P:System.Span`1.Length&quot; /&gt;.">O índice baseado em zero da <paramref name="comparable" /> no <paramref name="span" /> classificado, se <paramref name="comparable" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="comparable" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Span`1.Length" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.">Compara um intervalo de caracteres com outro usando uma comparação de cadeia de caracteres especificada e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">O valor a ser comparado com o intervalo de origem.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="other" /> são comparados.</param>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Um inteiro com sinal que indica a ordem relativa de <paramref name="span" /> e <paramref name="other" />:   – Se for menor que 0, <paramref name="span" /> precederá <paramref name="other" />.   - Se for 0, <paramref name="span" /> será igual a <paramref name="other" />.   – Se for maior que 0, <paramref name="span" /> seguirá <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Indicates whether a specified value occurs within a read-only character span.">Indica se um valor especificado ocorre em um intervalo de caracteres somente leitura.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">O valor a ser buscado no intervalo de origem.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how the characters in &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Um valor de enumeração que determina como os caracteres em <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; occurs within the span, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se <paramref name="value" /> ocorre dentro do intervalo; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a read-only span. Values are compared using IEquatable{T}.Equals(T).">Indica se um valor especificado é encontrado em um intervalo somente leitura. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The value to search for.">O valor a ser procurado.</param>
      <typeparam name="T" vsli:raw="The type of the span.">O tipo da extensão.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if found, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary vsli:raw="Indicates whether a specified value is found in a span. Values are compared using IEquatable{T}.Equals(T).">Indica se um valor especificado é encontrado em um intervalo. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The value to search for.">O valor a ser procurado.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="&lt;code data-dev-comment-type=&quot;langword&quot;&gt;true&lt;/code&gt; if found, &lt;code data-dev-comment-type=&quot;langword&quot;&gt;false&lt;/code&gt; otherwise.">
        <see langword="true" /> se encontrado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary vsli:raw="Copies the contents of the array into a memory region.">Copia o conteúdo da matriz para uma região de memória.</summary>
      <param name="source" vsli:raw="The array to copy items from.">A matriz da qual os itens serão copiados.</param>
      <param name="destination" vsli:raw="The memory to copy items into.">A memória para a qual os itens serão copiados.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination is shorter than the source array.">O destino é menor que a matriz de origem.</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary vsli:raw="Copies the contents of the array into the span.">Copia o conteúdo da matriz para o intervalo.</summary>
      <param name="source" vsli:raw="The array to copy items from.">A matriz da qual os itens serão copiados.</param>
      <param name="destination" vsli:raw="The span to copy items into.">O intervalo no qual copiar itens.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The destination Span is shorter than the source array.">O intervalo de destino é menor que a matriz de origem.</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether the end of the &lt;paramref name=&quot;span&quot; /&gt; matches the specified &lt;paramref name=&quot;value&quot; /&gt; when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Determina se o final do <paramref name="span" /> corresponde ao <paramref name="value" /> especificado quando comparado usando a opção <paramref name="comparisonType" /> especificada.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">A sequência a ser comparada com o final do intervalo de origem.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corresponde ao final de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a read-only span.">Determina se a sequência especificada aparece no final de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">A sequência a ser comparada com o final do intervalo de origem.</param>
      <typeparam name="T" vsli:raw="The type of the span.">O tipo da extensão.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corresponde ao final de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether the specified sequence appears at the end of a span.">Determina se a sequência especificada aparece no final de um intervalo.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="value" vsli:raw="The sequence to compare to the end of the source span.">A sequência a ser comparada com o final do intervalo de origem.</param>
      <typeparam name="T" vsli:raw="The type of the span.">O tipo da extensão.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the end of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corresponde ao final de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided read-only span.">Retorna uma enumeração de <see cref="T:System.Text.Rune" /> do intervalo somente leitura fornecido.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <returns vsli:raw="A rune enumerator.">Um enumerador de rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary vsli:raw="Returns an enumeration of &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; from the provided span.">Retorna uma enumeração de <see cref="T:System.Text.Rune" /> do intervalo fornecido.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <returns vsli:raw="A rune enumerator.">Um enumerador de rune.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether this &lt;paramref name=&quot;span&quot; /&gt; and the specified &lt;paramref name=&quot;other&quot; /&gt; span have the same characters when compared using the specified &lt;paramref name=&quot;comparisonType&quot; /&gt; option.">Determina se este <paramref name="span" /> e o intervalo <paramref name="other" /> especificado têm os mesmos caracteres quando comparados usando a opção <paramref name="comparisonType" /> especificada.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="other" vsli:raw="The value to compare with the source span.">O valor a ser comparado com o intervalo de origem.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt; are compared.">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="other" /> são comparados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if equal, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se é igual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the first occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Relata o índice baseado em zero da primeira ocorrência do <paramref name="value" /> especificado no <paramref name="span" /> atual.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">O valor a ser buscado no intervalo de origem.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns vsli:raw="The index of the occurrence of the value in the span.">O índice da ocorrência do valor no intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa o valor especificado e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The value to search for.">O valor a ser procurado.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa a sequência especificada e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The sequence to search for.">A sequência a ser pesquisada.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa o valor especificado e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The value to search for.">O valor a ser procurado.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor.</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its first occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa a sequência especificada e retorna o índice de sua primeira ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The sequence to search for.">A sequência a ser pesquisada.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor..</typeparam>
      <returns vsli:raw="The index of the occurrence of the value in the span. If not found, returns -1.">O índice da ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="values" vsli:raw="The set of values to search for.">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.">Pesquisa o primeiro índice de qualquer um dos valores especificados, semelhante à chamada de IndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="values" vsli:raw="The set of values to search for.">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The first index of the occurrence of any of the values in the span. If not found, returns -1.">O primeiro índice da ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Indicates whether the specified span contains only whitespace characters.">Indica se o intervalo especificado contém apenas caracteres de espaço em branco.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the span contains only whitespace characters, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se o intervalo contém apenas caracteres de espaço em branco; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Reports the zero-based index of the last occurrence of the specified &lt;paramref name=&quot;value&quot; /&gt; in the current &lt;paramref name=&quot;span&quot; /&gt;.">Relata o índice baseado em zero da última ocorrência do <paramref name="value" /> especificado no <paramref name="span" /> atual.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="value" vsli:raw="The value to seek within the source span.">O valor a ser buscado no intervalo de origem.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns vsli:raw="The index of the last occurrence of the value in the span.">O índice da última ocorrência do valor no intervalo.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa o valor especificado e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The value to search for.">O valor a ser procurado.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa a sequência especificada e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The sequence to search for.">A sequência a ser pesquisada.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary vsli:raw="Searches for the specified value and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa o valor especificado e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The value to search for.">O valor a ser procurado.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the specified sequence and returns the index of its last occurrence. Values are compared using IEquatable{T}.Equals(T).">Pesquisa a sequência especificada e retorna o índice de sua última ocorrência. Os valores são comparados usando IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="The sequence to search for.">A sequência a ser pesquisada.</param>
      <typeparam name="T" vsli:raw="The type of the span and value.">O tipo do intervalo e do valor.</typeparam>
      <returns vsli:raw="The index of the last occurrence of the value in the span. If not found, returns -1.">O índice da última ocorrência do valor no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="values" vsli:raw="The set of values to search for.">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value0" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value1" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <param name="value2" vsli:raw="One of the values to search for.">Um dos valores a serem pesquisados.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.">Pesquisa o último índice de qualquer um dos valores especificados, semelhante à chamada de LastIndexOf várias vezes com o operador OR lógico.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="values" vsli:raw="The set of values to search for.">O conjunto de valores a ser pesquisado.</param>
      <typeparam name="T" vsli:raw="The type of the span and values.">O tipo do intervalo e dos valores.</typeparam>
      <returns vsli:raw="The index of the last occurrence of any of the values in the span. If not found, returns -1.">O índice da última ocorrência de qualquer um dos valores no intervalo. Se não é encontrado, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory.">Determina se duas sequências somente leitura se sobrepõem na memória.</summary>
      <param name="span" vsli:raw="The first sequence.">A primeira sequência.</param>
      <param name="other" vsli:raw="The second sequence.">A segunda sequência.</param>
      <typeparam name="T" vsli:raw="The type of elements in the read-only sequence.">O tipo de elementos na sequência somente leitura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether two read-only sequences overlap in memory and outputs the element offset.">Determina se duas sequências somente leitura se sobrepõem na memória e gera o deslocamento do elemento.</summary>
      <param name="span" vsli:raw="The first sequence.">A primeira sequência.</param>
      <param name="other" vsli:raw="The second sequence.">A segunda sequência.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Quando o método é retornado, contém o deslocamento entre <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">O tipo de elementos no span.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory.">Determina se um intervalo e um intervalo somente leitura se sobrepõem na memória.</summary>
      <param name="span" vsli:raw="The span to compare.">O intervalo a ser comparado.</param>
      <param name="other" vsli:raw="The read-only span to compare.">O intervalo somente leitura a ser comparado.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">O tipo de elementos no span.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary vsli:raw="Determines whether a span and a read-only span overlap in memory and outputs the element offset.">Determina se um intervalo e um intervalo somente leitura se sobrepõem na memória e gera o deslocamento do elemento.</summary>
      <param name="span" vsli:raw="The first sequence to compare.">A primeira sequência a ser comparada.</param>
      <param name="other" vsli:raw="The second sequence to compare.">A segunda sequência a ser comparada.</param>
      <param name="elementOffset" vsli:raw="When the method returns, contains the offset between &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;.">Quando o método é retornado, contém o deslocamento entre <paramref name="span" /> e <paramref name="other" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">O tipo de elementos no span.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences overlap; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas sequências se sobrepõem; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary vsli:raw="Reverses the sequence of the elements in the entire span.">Reverte a sequência dos elementos em todo o intervalo.</summary>
      <param name="span" vsli:raw="The span to reverse.">O intervalo a ser revertido.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">O tipo de elementos no span.</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).">Determina a ordem relativa de duas sequências somente leitura comparando seus elementos com o uso de IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">A primeira sequência a ser comparada.</param>
      <param name="other" vsli:raw="The second sequence to compare.">A segunda sequência a ser comparada.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">O tipo de elementos na sequência.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Um inteiro com sinal que indica a ordem relativa de <paramref name="span" /> e <paramref name="other" />:   – Se for menor que 0, <paramref name="span" /> precederá <paramref name="other" />.   - Se for 0, <paramref name="span" /> será igual a <paramref name="other" />.   – Se for maior que 0, <paramref name="span" /> seguirá <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).">Determina a ordem relativa de um intervalo e um intervalo somente leitura comparando os elementos com o uso de IComparable{T}.CompareTo(T).</summary>
      <param name="span" vsli:raw="The span to compare.">O intervalo a ser comparado.</param>
      <param name="other" vsli:raw="The read-only span to compare.">O intervalo somente leitura a ser comparado.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">O tipo de elementos no span.</typeparam>
      <returns vsli:raw="A signed integer that indicates the relative order of &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;other&quot; /&gt;:&lt;br /&gt;   - If less than 0, &lt;paramref name=&quot;span&quot; /&gt; precedes than &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If 0, &lt;paramref name=&quot;span&quot; /&gt; equals &lt;paramref name=&quot;other&quot; /&gt;.&lt;br /&gt;   - If greater than 0, &lt;paramref name=&quot;span&quot; /&gt; follows &lt;paramref name=&quot;other&quot; /&gt;.">Um inteiro com sinal que indica a ordem relativa de <paramref name="span" /> e <paramref name="other" />:   – Se for menor que 0, <paramref name="span" /> precederá <paramref name="other" />.   - Se for 0, <paramref name="span" /> será igual a <paramref name="other" />.   – Se for maior que 0, <paramref name="span" /> seguirá <paramref name="other" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).">Determina se duas sequências somente leitura são iguais comparando os elementos com o uso de IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The first sequence to compare.">A primeira sequência a ser comparada.</param>
      <param name="other" vsli:raw="The second sequence to compare.">A segunda sequência a ser comparada.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">O tipo de elementos na sequência.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas sequências são iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).">Determina se um intervalo e um intervalo somente leitura são iguais comparando os elementos com o uso de IEquatable{T}.Equals(T).</summary>
      <param name="span" vsli:raw="The span to compare.">O intervalo a ser comparado.</param>
      <param name="other" vsli:raw="The read-only span to compare.">O intervalo somente leitura a ser comparado.</param>
      <typeparam name="T" vsli:raw="The type of elements in the sequence.">O tipo de elementos na sequência.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two sequences are equal; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se as duas sequências são iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each element of the &lt;see cref=&quot;T:System.Span`1&quot; /&gt;.">Classifica os elementos em todo o <see cref="T:System.Span`1" /> usando a implementação <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Span`1" /></summary>
      <param name="span" vsli:raw="The span of memory to sort.">O intervalo de memória a ser classificado.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">O tipo dos elementos do span.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">Um ou mais elementos em <paramref name="span" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt;.">Classifica os elementos em todo o <see cref="T:System.Span`1" /> usando o <see cref="T:System.Comparison`1" /> especificado.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">O intervalo de memória a ser classificado.</param>
      <param name="comparison" vsli:raw="The method to use when comparing elements.">O método a ser usado ao comparar elementos.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">O tipo dos elementos do span.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> é <see langword="null" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary vsli:raw="Sorts the elements in the entire &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;typeparamref name=&quot;TComparer&quot; /&gt;.">Classifica os elementos em todo o <see cref="T:System.Span`1" /> usando o <typeparamref name="TComparer" />.</summary>
      <param name="span" vsli:raw="The span of memory to sort.">O intervalo de memória a ser classificado.</param>
      <param name="comparer" vsli:raw="The method to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use each element's &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation.">O método a ser usado ao comparar elementos ou <see langword="null" /> para usar a implementação de interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
      <typeparam name="T" vsli:raw="The type of the elements of the span.">O tipo dos elementos do span.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">O tipo do comparador a ser usado para comparar elementos.</typeparam>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;span&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="span" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The implementation of &lt;paramref name=&quot;comparer&quot; /&gt; caused an error during the sort.">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; implementation of each key.">Classifica um par de intervalos (um contendo as chaves e o outro contendo os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Span`1" /> usando a implementação <see cref="T:System.IComparable`1" /> de cada chave.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">A extensão que contém as chaves a serem classificadas.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">A extensão que contém os itens que correspondem às chaves em <paramref name="keys" />.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">O tipo dos elementos do intervalo de chaves.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">O tipo dos elementos do span de itens.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">O tamanho de <paramref name="keys" /> não é igual ao tamanho de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="One or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">Um ou mais elementos em <paramref name="keys" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparison.">Classifica um par de intervalos (um contendo as chaves e o outro contendo os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Span`1" /> usando a comparação especificada.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">A extensão que contém as chaves a serem classificadas.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">A extensão que contém os itens que correspondem às chaves em <paramref name="keys" />.</param>
      <param name="comparison" vsli:raw="The &lt;see cref=&quot;T:System.Comparison`1&quot; /&gt; to use when comparing elements.">O <see cref="T:System.Comparison`1" /> a ser usado na comparação de elementos.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">O tipo dos elementos do intervalo de chaves.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">O tipo dos elementos do span de itens.</typeparam>
      <exception cref="T:System.ArgumentNullException" vsli:raw="&lt;paramref name=&quot;comparison&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="comparison" /> é <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">O tamanho de <paramref name="keys" /> não é igual ao tamanho de <paramref name="items" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary vsli:raw="Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first &lt;see cref=&quot;T:System.Span`1&quot; /&gt; using the specified comparer.">Classifica um par de intervalos (um contendo as chaves e o outro contendo os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Span`1" /> usando o comparador especificado.</summary>
      <param name="keys" vsli:raw="The span that contains the keys to sort.">A extensão que contém as chaves a serem classificadas.</param>
      <param name="items" vsli:raw="The span that contains the items that correspond to the keys in &lt;paramref name=&quot;keys&quot; /&gt;.">A extensão que contém os itens que correspondem às chaves em <paramref name="keys" />.</param>
      <param name="comparer" vsli:raw="The &lt;see cref=&quot;T:System.Collections.Generic.IComparer`1&quot; /&gt; implementation to use when comparing elements, or &lt;see langword=&quot;null&quot; /&gt; to use the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface implementation of each element.">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada ao comparar elementos ou <see langword="null" /> para usar a implementação da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
      <typeparam name="TKey" vsli:raw="The type of the elements of the key span.">O tipo dos elementos do intervalo de chaves.</typeparam>
      <typeparam name="TValue" vsli:raw="The type of the elements of the items span.">O tipo dos elementos do span de itens.</typeparam>
      <typeparam name="TComparer" vsli:raw="The type of the comparer to use to compare elements.">O tipo do comparador a ser usado para comparar elementos.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="The length of &lt;paramref name=&quot;keys&quot; /&gt; isn't equal to the length of &lt;paramref name=&quot;items&quot; /&gt;.">O tamanho de <paramref name="keys" /> não é igual ao tamanho de <paramref name="items" />.</exception>
      <exception cref="T:System.InvalidOperationException" vsli:raw="&lt;paramref name=&quot;comparer&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, and one or more elements in &lt;paramref name=&quot;keys&quot; /&gt; do not implement the &lt;see cref=&quot;T:System.IComparable`1&quot; /&gt; interface.">
        <paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="keys" /> não implementam a interface <see cref="T:System.IComparable`1" />.</exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary vsli:raw="Determines whether a read-only character span begins with a specified value when compared using a specified &lt;see cref=&quot;T:System.StringComparison&quot; /&gt; value.">Determina se um intervalo de caracteres somente leitura começa com um valor especificado quando comparado usando um valor <see cref="T:System.StringComparison" /> especificado.</summary>
      <param name="span" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="value" vsli:raw="The sequence to compare to the beginning of the source span.">A sequência a ser comparada com o início do intervalo de origem.</param>
      <param name="comparisonType" vsli:raw="An enumeration value that determines how &lt;paramref name=&quot;span&quot; /&gt; and &lt;paramref name=&quot;value&quot; /&gt; are compared.">Um valor de enumeração que determina como <paramref name="span" /> e <paramref name="value" /> são comparados.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corresponde ao início de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a read-only span.">Determina se uma sequência especificada aparece no início de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The read-only character span to search.">O intervalo de caracteres somente leitura a ser pesquisado.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Uma sequência a ser pesquisada no início de <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of elements in the span.">O tipo de elementos no span.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corresponde ao início de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Determines whether a specified sequence appears at the start of a span.">Determina se uma sequência especificada aparece no início de um intervalo.</summary>
      <param name="span" vsli:raw="The span to search.">O intervalo a ser pesquisado.</param>
      <param name="value" vsli:raw="A sequence to search for at the start of &lt;paramref name=&quot;span&quot; /&gt;.">Uma sequência a ser pesquisada no início de <paramref name="span" />.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;value&quot; /&gt; matches the beginning of &lt;paramref name=&quot;span&quot; /&gt;; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="value" /> corresponde ao início de <paramref name="span" />; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.">Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em minúsculas, usando as regras de uso de maiúsculas da cultura especificada.</summary>
      <param name="source" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">O intervalo de destino que contém os caracteres transformados.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Os buffers de origem e destino se sobrepõem.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.">Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em minúsculas, usando as regras de uso de maiúsculas da cultura invariável.</summary>
      <param name="source" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">O intervalo de destino que contém os caracteres transformados.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Os buffers de origem e destino se sobrepõem.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.">Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em maiúsculas, usando as regras de uso de maiúsculas da cultura especificada.</summary>
      <param name="source" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">O intervalo de destino que contém os caracteres transformados.</param>
      <param name="culture" vsli:raw="An object that supplies culture-specific casing rules.">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Os buffers de origem e destino se sobrepõem.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary vsli:raw="Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.">Copia os caracteres do intervalo de origem para o destino, convertendo cada caractere em maiúsculas, usando as regras de uso de maiúsculas da cultura invariável.</summary>
      <param name="source" vsli:raw="The source span.">O intervalo de origem.</param>
      <param name="destination" vsli:raw="The destination span which contains the transformed characters.">O intervalo de destino que contém os caracteres transformados.</param>
      <exception cref="T:System.InvalidOperationException" vsli:raw="The source and destination buffers overlap.">Os buffers de origem e destino se sobrepõem.</exception>
      <returns vsli:raw="The number of characters written into the destination span. If the destination is too small, returns -1.">O número de caracteres gravados no intervalo de destino. Se o destino é muito pequeno, retorna -1.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character memory region.">Remove todos os caracteres de espaço em branco à esquerda e à direita de uma região de memória de caracteres.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">A memória de origem da qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed character memory region.">A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character memory region.">Remove todos os caracteres de espaço em branco à esquerda e à direita de uma região de memória de caracteres somente leitura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">A memória de origem da qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed character memory region.">A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a read-only character span.">Remove todos os caracteres de espaço em branco à esquerda e à direita de um intervalo de caracteres somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified character from a read-only character span.">Remove todas as ocorrências à esquerda e à direita de um caractere especificado de um intervalo de caracteres somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">O intervalo de origem do qual o caractere é removido.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">O caractere especificado a ser procurado e removido.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Remove todas as ocorrências à esquerda e à direita de um conjunto de caracteres especificado em um intervalo somente leitura de um intervalo de caracteres somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">O intervalo que contém o conjunto de caracteres a ser removido.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading and trailing whitespace characters from a character span.">Remove todos os caracteres de espaço em branco à esquerda e à direita de um intervalo de caracteres.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed character span.">O intervalo de caracteres cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a memory region.">Remove todas as ocorrências à esquerda e à direita de um elemento especificado de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">O tipo dos elementos na região de memória.</typeparam>
      <returns vsli:raw="The trimmed memory region.">A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.">Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">O tipo dos elementos na região de memória.</typeparam>
      <returns vsli:raw="The trimmed memory region.">A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only memory region.">Remove todas as ocorrências à esquerda e à direita de um elemento especificado de uma região de memória ROM.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificado em um intervalo somente leitura de uma região de memória ROM.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a read-only span.">Remove todas as ocorrências à esquerda e à direita de um elemento especificado de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">O tipo dos elementos no span somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">O tipo dos elementos no span somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading and trailing occurrences of a specified element from a span.">Remove todas as ocorrências à esquerda e à direita de um elemento especificado de um intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="The trimmed span.">O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.">Remove todas as ocorrências à esquerda e à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="The trimmed span.">O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character memory region.">Remove todos os caracteres de espaço em branco à direita de uma região de memória de caracteres.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">A memória de origem da qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed character memory region.">A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character memory region.">Remove todos os caracteres de espaço em branco à direita de uma região de memória de caracteres somente leitura.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">A memória de origem da qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a read-only character span.">Remove todos os caracteres de espaço em branco à direita de um intervalo de caracteres somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all trailing occurrences of a specified character from a read-only span.">Remove todas as ocorrências à direita de um caractere especificado de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">O intervalo de origem do qual o caractere é removido.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">O caractere especificado a ser procurado e removido.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.">Remove todas as ocorrências à direita de um conjunto de caracteres especificado em um intervalo somente leitura de um intervalo de caracteres somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">O intervalo que contém o conjunto de caracteres a ser removido.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary vsli:raw="Removes all trailing whitespace characters from a character span.">Remove todos os caracteres de espaço em branco à direita de um intervalo de caracteres.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed character span.">O intervalo de caracteres cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a character memory region.">Remove todas as ocorrências à direita de um elemento especificado de uma região de memória de caracteres.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">O tipo dos elementos na região de memória.</typeparam>
      <returns vsli:raw="The trimmed memory region.">A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.">Remove todas as ocorrências à direita de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">O tipo dos elementos na região de memória.</typeparam>
      <returns vsli:raw="The trimmed memory region.">A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only memory region.">Remove todas as ocorrências à direita de um elemento especificado de uma região de memória ROM.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.">Remove todas as ocorrências à direita de um conjunto de elementos especificado em um intervalo somente leitura de uma região de memória ROM.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a read-only span.">Remove todas as ocorrências à direita de um elemento especificado de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">O tipo dos elementos no span somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.">Remove todas as ocorrências à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">O tipo dos elementos no span somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all trailing occurrences of a specified element from a span.">Remove todas as ocorrências à direita de um elemento especificado de um intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="The trimmed span.">O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all trailing occurrences of a set of elements specified in a read-only span from a span.">Remove todas as ocorrências à direita de um conjunto de elementos especificado em um intervalo somente leitura de um intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="The trimmed span.">O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a memory region.">Remove todos os caracteres de espaço em branco à esquerda de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">A memória de origem da qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed character memory region.">A região de memória de caractere cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only memory region.">Remove todos os caracteres de espaço em branco à esquerda de uma região de memória ROM.</summary>
      <param name="memory" vsli:raw="The source memory from which the characters are removed.">A memória de origem da qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed read-only character memory region.">A região de memória do caractere somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a read-only span.">Remove todos os caracteres de espaço em branco à esquerda de um intervalo somente leitura.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary vsli:raw="Removes all leading occurrences of a specified character from the span.">Remove todas as ocorrências à esquerda de um caractere especificado do intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the character is removed.">O intervalo de origem do qual o caractere é removido.</param>
      <param name="trimChar" vsli:raw="The specified character to look for and remove.">O caractere especificado a ser procurado e removido.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary vsli:raw="Removes all leading occurrences of a set of characters specified in a read-only span from the span.">Remove todas as ocorrências à esquerda de um conjunto de caracteres especificado em um intervalo somente leitura do intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <param name="trimChars" vsli:raw="The span which contains the set of characters to remove.">O intervalo que contém o conjunto de caracteres a ser removido.</param>
      <returns vsli:raw="The trimmed read-only character span.">O intervalo de caracteres somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary vsli:raw="Removes all leading whitespace characters from a span.">Remove todos os caracteres de espaço em branco à esquerda de um intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the characters are removed.">O intervalo de origem do qual os caracteres são removidos.</param>
      <returns vsli:raw="The trimmed character span.">O intervalo de caracteres cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Remove todas as ocorrências à esquerda de um elemento especificado de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory region from which the element is removed.">A região de memória de origem da qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">O tipo dos elementos na região de memória.</typeparam>
      <returns vsli:raw="The trimmed memory region.">A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Remove todas as ocorrências à esquerda de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the memory region.">O tipo dos elementos na região de memória.</typeparam>
      <returns vsli:raw="The trimmed memory region.">A região de memória cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from a memory region.">Remove todas as ocorrências à esquerda de um elemento especificado de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory from which the element is removed.">A memória de origem da qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.">Remove todas as ocorrências à esquerda de um conjunto de elementos especificados em um intervalo somente leitura de uma região de memória.</summary>
      <param name="memory" vsli:raw="The source memory from which the elements are removed.">A memória de origem da qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only memory region.">O tipo dos elementos na região de memória somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only memory region.">A região de memória ROM cortada.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Remove todas as ocorrências à esquerda de um elemento especificado do intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">O tipo dos elementos no span somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Remove todas as ocorrências à esquerda de um conjunto de elementos especificado em um intervalo somente leitura do intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the read-only span.">O tipo dos elementos no span somente leitura.</typeparam>
      <returns vsli:raw="The trimmed read-only span.">O intervalo somente leitura cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary vsli:raw="Removes all leading occurrences of a specified element from the span.">Remove todas as ocorrências à esquerda de um elemento especificado do intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the element is removed.">O intervalo de origem do qual o elemento é removido.</param>
      <param name="trimElement" vsli:raw="The specified element to look for and remove.">O elemento especificado a ser pesquisado e removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="The trimmed span.">O intervalo cortado.</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary vsli:raw="Removes all leading occurrences of a set of elements specified in a read-only span from the span.">Remove todas as ocorrências à esquerda de um conjunto de elementos especificado em um intervalo somente leitura do intervalo.</summary>
      <param name="span" vsli:raw="The source span from which the elements are removed.">O intervalo de origem do qual os elementos são removidos.</param>
      <param name="trimElements" vsli:raw="The span which contains the set of elements to remove.">O intervalo que contém o conjunto de elementos a ser removido.</param>
      <typeparam name="T" vsli:raw="The type of the elements in the span.">O tipo dos elementos no span.</typeparam>
      <returns vsli:raw="The trimmed span.">O intervalo cortado.</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary vsli:raw="Provides methods to interoperate with &lt;see cref=&quot;T:System.Memory`1&quot; /&gt;, &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;,  &lt;see cref=&quot;T:System.Span`1&quot; /&gt;, and  &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt;.">Oferece métodos para interoperar com <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" />e <see cref="T:System.ReadOnlySpan`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;ReadOnlySpan&amp;lt;Byte&amp;gt;&quot; /&gt;.">Converte um <see cref="T:System.ReadOnlySpan`1" /> de um tipo primitivo, <paramref name="T" />, em um <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">A fatia de origem a ser convertida.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only span.">O tipo de itens no span somente leitura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">A propriedade <see cref="P:System.ReadOnlySpan`1.Length" /> da nova <see cref="T:System.ReadOnlySpan`1" /> excederia o <see cref="F:System.Int32.MaxValue" /></exception>
      <returns vsli:raw="A read-only span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Uma extensão de somente leitura do tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary vsli:raw="Casts a &lt;see cref=&quot;T:System.Span`1&quot; /&gt; of one primitive type, &lt;paramref name=&quot;T&quot; /&gt;, to a &lt;see langword=&quot;Span&amp;lt;Byte&amp;gt;&quot; /&gt;.">Converte um <see cref="T:System.Span`1" /> de um tipo primitivo, <paramref name="T" />, em um <see langword="Span&lt;Byte&gt;" />.</summary>
      <param name="span" vsli:raw="The source slice to convert.">A fatia de origem a ser convertida.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">O tipo de itens no intervalo.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.OverflowException" vsli:raw="The &lt;see cref=&quot;P:System.ReadOnlySpan`1.Length&quot; /&gt; property of the new &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; would exceed &lt;see cref=&quot;F:System.Int32.MaxValue&quot;&gt;Int32.MaxValue&lt;/see&gt;">A propriedade <see cref="P:System.Span`1.Length" /> da nova <see cref="T:System.Span`1" /> excederia o <see cref="F:System.Int32.MaxValue" /></exception>
      <returns vsli:raw="A span of type &lt;see cref=&quot;T:System.Byte&quot; /&gt;.">Uma extensão do tipo <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance from a &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Cria uma instância <see cref="T:System.Memory`1" /> de uma <see cref="T:System.ReadOnlyMemory`1" />.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer.">O buffer de memória de somente leitura.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">O tipo de itens no buffer de memória somente leitura.</typeparam>
      <returns vsli:raw="A memory block that represents the same memory as the &lt;see cref=&quot;T:System.ReadOnlyMemory`1&quot; /&gt;.">Um bloco de memória que representa a mesma memória que o <see cref="T:System.ReadOnlyMemory`1" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reinterprets a read-only span of bytes as a read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Reinterpreta um intervalo somente leitura de bytes como uma referência somente leitura para a estrutura do tipo <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The read-only span to reinterpret.">O intervalo somente leitura a se reinterpretado.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">O tipo da referência retornada.</typeparam>
      <returns vsli:raw="The read-only reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">A referência somente leitura para a estrutura do tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary vsli:raw="Reinterprets a span of bytes as a reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">Reinterpreta um intervalo de bytes como uma referência à estrutura do tipo <paramref name="T" />.</summary>
      <param name="span" vsli:raw="The span to reinterpret.">O intervalo para reinterpretar.</param>
      <typeparam name="T" vsli:raw="The type of the returned reference.">O tipo da referência retornada.</typeparam>
      <returns vsli:raw="The reference to the structure of type &lt;paramref name=&quot;T&quot; /&gt;.">A referência à estrutura do tipo <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Casts a read-only span of one primitive type to a read-only span of another primitive type.">Converte uma extensão de somente leitura de um tipo primitivo em uma extensão de outro tipo primitivo.</summary>
      <param name="span" vsli:raw="The source slice to convert.">A fatia de origem a ser convertida.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">O tipo do span de origem.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">O tipo do span de destino.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contém referências ou ponteiros.</exception>
      <returns vsli:raw="The converted read-only span.">A extensão de somente leitura convertida.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary vsli:raw="Casts a span of one primitive type to a span of another primitive type.">Converte um período de um tipo primitivo em um período de outro tipo primitivo.</summary>
      <param name="span" vsli:raw="The source slice to convert.">A fatia de origem a ser convertida.</param>
      <typeparam name="TFrom" vsli:raw="The type of the source span.">O tipo do span de origem.</typeparam>
      <typeparam name="TTo" vsli:raw="The type of the target span.">O tipo do span de destino.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;TFrom&quot; /&gt; or &lt;paramref name=&quot;TTo&quot; /&gt; contains managed object references.">
        <paramref name="TFrom" /> ou <paramref name="TTo" /> contém referências ou ponteiros.</exception>
      <returns vsli:raw="The converted span.">A extensão convertida.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary vsli:raw="Creates a new memory buffer over the portion of the pre-pinned target array beginning at the &lt;paramref name=&quot;start&quot; /&gt; index and consisting of &lt;paramref name=&quot;length&quot; /&gt; items.">Cria um novo buffer de memória sobre a parte da matriz de destino pré-fixada começando pelo índice <paramref name="start" /> e formado por itens <paramref name="length" />.</summary>
      <param name="array" vsli:raw="The pre-pinned source array.">A matriz de origem pré-fixada.</param>
      <param name="start" vsli:raw="The index of &lt;paramref name=&quot;array&quot; /&gt; at which to begin the memory block.">O índice de <paramref name="array" /> no qual o bloco de memória será iniciado.</param>
      <param name="length" vsli:raw="The number of items to include in the memory block.">O número de itens a serem incluídos no bloco de memória.</param>
      <typeparam name="T" vsli:raw="The type of the array.">O tipo da matriz.</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is covariant, and the type of &lt;paramref name=&quot;array&quot; /&gt; is not exactly &lt;paramref name=&quot;T[]&quot; /&gt;.">
        <paramref name="array" /> é covariante e o tipo de <paramref name="array" /> não é exatamente <paramref name="T[]" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="The &lt;paramref name=&quot;start&quot; /&gt; or the end index is not in the range of 0 to &lt;see cref=&quot;P:System.Array.Length&quot; /&gt;.">O <paramref name="start" /> ou o índice final não está no intervalo de 0 a <see cref="P:System.Array.Length" />.</exception>
      <returns vsli:raw="A block of memory over the specified elements of &lt;paramref name=&quot;array&quot; /&gt;. If &lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, or if &lt;paramref name=&quot;start&quot; /&gt; and &lt;paramref name=&quot;length&quot; /&gt; are 0, the method returns a &lt;see cref=&quot;T:System.Memory`1&quot; /&gt; instance of &lt;see cref=&quot;P:System.Memory`1.Length&quot; /&gt; zero.">Um bloco de memória nos elementos especificados de <paramref name="array" />. Se <paramref name="array" /> for <see langword="null" />, ou se <paramref name="start" /> e <paramref name="length" /> forem 0, o método retornará uma instância <see cref="T:System.Memory`1" /> de <see cref="P:System.Memory`1.Length" /> com valor zero.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new read-only span over a portion of a regular managed object.">Cria uma nova extensão de somente leitura sobre uma parte de um objeto gerenciado regular.</summary>
      <param name="reference" vsli:raw="A reference to data.">Uma referência aos dados.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">O número de elementos <paramref name="T" /> que <paramref name="reference" /> contém.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">O tipo dos itens de dados.</typeparam>
      <returns vsli:raw="A read-only span.">Uma extensão de somente leitura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary vsli:raw="Creates a new span over a portion of a regular managed object.">Cria uma nova extensão sobre uma parte de um objeto gerenciado regular.</summary>
      <param name="reference" vsli:raw="A reference to data.">Uma referência aos dados.</param>
      <param name="length" vsli:raw="The number of &lt;paramref name=&quot;T&quot; /&gt; elements that &lt;paramref name=&quot;reference&quot; /&gt; contains.">O número de elementos <paramref name="T" /> que <paramref name="reference" /> contém.</param>
      <typeparam name="T" vsli:raw="The type of the data items.">O tipo dos itens de dados.</typeparam>
      <returns vsli:raw="A span.">Uma extensão.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary vsli:raw="Returns a reference to the 0th element of &lt;paramref name=&quot;array&quot; /&gt;. If the array is empty, returns a reference to where the 0th element would have been stored. Such a reference may be used for pinning but must never be dereferenced.">Retorna uma referência ao elemento 0 de <paramref name="array" />. Se a matriz estiver vazia, retornará uma referência ao local em que o elemento 0 teria sido armazenado. Essa referência pode ser usada para fixação, mas nunca deve ser desreferenciada.</summary>
      <param name="array" vsli:raw="The array to analyze.">A matriz a ser analisada.</param>
      <typeparam name="T" vsli:raw="The type of the array elements.">O tipo dos elementos da matriz.</typeparam>
      <exception cref="T:System.NullReferenceException" vsli:raw="&lt;paramref name=&quot;array&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;.">
        <paramref name="array" /> é <see langword="null" />.</exception>
      <returns vsli:raw="Reference to the 0th element in &lt;paramref name=&quot;array&quot; /&gt;.">Referência ao elemento 0 em <paramref name="array" /></returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary vsli:raw="Returns a reference to the element of the read-only span at index 0.">Retorna uma referência ao elemento da extensão de somente leitura no índice 0.</summary>
      <param name="span" vsli:raw="The read-only span from which the reference is retrieved.">A extensão de somente leitura da qual a referência é recuperada.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">O tipo de itens no intervalo.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Uma referência ao elemento no índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary vsli:raw="Returns a reference to the element of the span at index 0.">Retorna uma referência ao elemento da extensão no índice 0.</summary>
      <param name="span" vsli:raw="The span from which the reference is retrieved.">A extensão da qual a referência é recuperada.</param>
      <typeparam name="T" vsli:raw="The type of items in the span.">O tipo de itens no intervalo.</typeparam>
      <returns vsli:raw="A reference to the element at index 0.">Uma referência ao elemento no índice 0.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary vsli:raw="Reads a structure of type &lt;typeparamref name=&quot;T&quot; /&gt; out of a read-only span of bytes.">Lê uma estrutura de tipo <param name="T" /> de uma extensão de somente leitura de bytes.</summary>
      <param name="source" vsli:raw="A read-only span.">Uma extensão de somente leitura.</param>
      <typeparam name="T" vsli:raw="The type of the item to retrieve from the read-only span.">O tipo do item a ser recuperado do span somente leitura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;source&quot; /&gt; is smaller than &lt;paramref name=&quot;T&quot; /&gt;'s length in bytes.">
        <paramref name="source" /> é menor que <paramref name="T" />.</exception>
      <returns vsli:raw="The structure retrieved from the read-only span.">A estrutura recuperada da extensão de somente leitura.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary vsli:raw="Creates an &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt; view of the given read-only memory buffer.">Cria uma exibição <see cref="T:System.Collections.Generic.IEnumerable`1" /> de determinado buffer de memória de somente leitura.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Um buffer de memória de somente leitura.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">O tipo dos itens no buffer de memória somente leitura.</typeparam>
      <returns vsli:raw="An enumerable view of &lt;paramref name=&quot;memory&quot; /&gt;.">Uma exibição enumerável de <paramref name="memory" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Tries to get an array segment from the underlying memory buffer. The return value indicates the success of the operation.">Tenta obter um segmento de matriz do buffer de memória subjacente. O valor retornado indica o sucesso da operação.</summary>
      <param name="memory" vsli:raw="A read-only memory buffer.">Um buffer de memória de somente leitura.</param>
      <param name="segment" vsli:raw="When this method returns, contains the array segment retrieved from the underlying read-only memory buffer. If the method fails, the method returns a default array segment.">Ao retornar, esse método contém o segmento da matriz recuperado do buffer de memória de somente leitura subjacente. Se o método falhar, ele retornará um segmento de matriz padrão.</param>
      <typeparam name="T" vsli:raw="The type of items in the read-only memory buffer.">O tipo de itens no buffer de memória somente leitura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method call succeeds; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se a chamada de método for bem-sucedida. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; from the underlying read-only memory buffer.">Tenta recuperar um <see cref="T:System.Buffers.MemoryManager`1" /> do buffer de memória de somente leitura subjacente.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">O buffer de memória de somente leitura para o qual obter o gerenciador de memória.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Quando o método retorna, o gerenciador de <paramref name="memory" />.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">O tipo dos itens no buffer de memória somente leitura.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">O tipo de a <see cref="T:System.Buffers.MemoryManager`1" /> ser recuperado.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method retrieved the memory manager; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o método tiver recuperado o gerenciador de memória. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to retrieve a &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt;, start index, and length from the underlying read-only memory buffer.">Tenta recuperar um <see cref="T:System.Buffers.MemoryManager`1" />, índice de início e comprimento do buffer de memória de somente leitura subjacente.</summary>
      <param name="memory" vsli:raw="The read-only memory buffer for which to get the memory manager.">O buffer de memória de somente leitura para o qual obter o gerenciador de memória.</param>
      <param name="manager" vsli:raw="When the method returns, the manager of &lt;paramref name=&quot;memory&quot; /&gt;.">Quando o método retorna, o gerenciador de <paramref name="memory" />.</param>
      <param name="start" vsli:raw="When the method returns, the offset from the start of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Quando o método retorna, o deslocamento do início do <paramref name="manager" /> que o <paramref name="memory" /> representa.</param>
      <param name="length" vsli:raw="When the method returns, the length of the &lt;paramref name=&quot;manager&quot; /&gt; that the &lt;paramref name=&quot;memory&quot; /&gt; represents.">Quando o método retorna, o comprimento do <paramref name="manager" /> que o <paramref name="memory" /> representa.</param>
      <typeparam name="T" vsli:raw="The type of the items in the read-only memory buffer.">O tipo dos itens no buffer de memória somente leitura.</typeparam>
      <typeparam name="TManager" vsli:raw="The type of the &lt;see cref=&quot;T:System.Buffers.MemoryManager`1&quot; /&gt; to retrieve.">O tipo de a <see cref="T:System.Buffers.MemoryManager`1" /> ser recuperado.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" />, se o método for bem-sucedido. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary vsli:raw="Tries to get the underlying string from a &lt;see langword=&quot;System.ReadOnlyMemory&amp;lt;Char&amp;gt;&quot; /&gt;.">Tenta obter a cadeia de caracteres subjacente de um <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
      <param name="memory" vsli:raw="Read-only memory containing a block of characters.">Memória somente leitura que contém um bloco de caracteres.</param>
      <param name="text" vsli:raw="When the method returns, the string contained in the memory buffer.">Quando o método retorna, a cadeia de caracteres contida no buffer de memória.</param>
      <param name="start" vsli:raw="The starting location in &lt;paramref name=&quot;text&quot; /&gt;.">A localização inicial em <paramref name="text" />.</param>
      <param name="length" vsli:raw="The number of characters in &lt;paramref name=&quot;text&quot; /&gt;.">O número de caracteres em <paramref name="text" />.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method successfully retrieves the underlying string; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o método recuperar a cadeia de caracteres subjacente com eficiência. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary vsli:raw="Tries to read a structure of type &lt;paramref name=&quot;T&quot; /&gt; from a read-only span of bytes.">Tenta ler uma estrutura do tipo <paramref name="T" /> de um intervalo de bytes somente leitura.</summary>
      <param name="source" vsli:raw="A read-only span of bytes.">Uma extensão de somente leitura de bytes.</param>
      <param name="value" vsli:raw="When the method returns, an instance of &lt;paramref name=&quot;T&quot; /&gt;.">Quando o método retorna, uma instância do <paramref name="T" />.</param>
      <typeparam name="T" vsli:raw="The type of the structure to retrieve.">O tipo da estrutura a ser recuperada.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the method succeeds in retrieving an instance of the structure; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o método tiver êxito na recuperação de uma instância da estrutura. Caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Tries to write a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Tenta gravar uma estrutura do tipo <paramref name="T" /> em um intervalo de bytes.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">O extensão de bytes para conter a estrutura.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">A estrutura a ser gravada na extensão.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">O tipo da estrutura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the write operation succeeded; otherwise, &lt;see langword=&quot;false&quot; /&gt;. The method returns &lt;see langword=&quot;false&quot; /&gt; if the span is too small to contain &lt;paramref name=&quot;T&quot; /&gt;.">
        <see langword="true" /> se a operação de gravação for bem-sucedida. Caso contrário, <see langword="false" />. O método retornará <see langword="false" /> se o intervalo for muito pequeno para conter <paramref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary vsli:raw="Writes a structure of type &lt;paramref name=&quot;T&quot; /&gt; into a span of bytes.">Grava uma estrutura do tipo <paramref name="T" /> em um intervalo de bytes.</summary>
      <param name="destination" vsli:raw="The span of bytes to contain the structure.">O extensão de bytes para conter a estrutura.</param>
      <param name="value" vsli:raw="The structure to be written to the span.">A estrutura a ser gravada na extensão.</param>
      <typeparam name="T" vsli:raw="The type of the structure.">O tipo da estrutura.</typeparam>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;T&quot; /&gt; contains managed object references.">
        <paramref name="T" /> contém referências ou ponteiros.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException" vsli:raw="&lt;paramref name=&quot;destination&quot; /&gt; is too small to contain &lt;paramref name=&quot;value&quot; /&gt;.">
        <paramref name="destination" /> é muito pequena para conter <paramref name="value" />.</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary vsli:raw="Provides a collection of methods for interoperating with &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt;.">Fornece uma coleção de métodos para interoperar com o <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary vsli:raw="Gets an array segment from the underlying read-only sequence.">Obtém um segmento de matriz da sequência somente leitura subjacente.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the array segment will be retrieved.">A sequência somente leitura da qual o segmento de matriz será recuperado.</param>
      <param name="segment" vsli:raw="The returned array segment.">O segmento de matriz retornado.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">O tipo da sequência somente leitura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if it's possible to retrieve the array segment; otherwise, &lt;see langword=&quot;false&quot; /&gt; and a default array segment is returned.">
        <see langword="true" /> se é possível recuperar o segmento de matriz; caso contrário, <see langword="false" /> e um segmento de matriz padrão é retornado.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary vsli:raw="Attempts to retrieve a read-only memory from the specified read-only sequence.">Tenta recuperar uma memória ROM da sequência somente leitura especificada.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the memory will be retrieved.">A sequência somente leitura da qual a memória será recuperada.</param>
      <param name="memory" vsli:raw="The returned read-only memory of type T.">A memória ROM retornada do tipo T.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">O tipo da sequência somente leitura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only memory can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se a memória ROM pode ser recuperada; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary vsli:raw="Attempts to retrieve a read-only sequence segment from the specified read-only sequence.">Tenta recuperar um segmento de sequência somente leitura da sequência somente leitura especificada.</summary>
      <param name="sequence" vsli:raw="The read-only sequence from which the read-only sequence segment will be retrieved.">A sequência somente leitura da qual o segmento de sequência somente leitura será recuperado.</param>
      <param name="startSegment" vsli:raw="The beginning read-only sequence segment.">O segmento de sequência somente leitura inicial.</param>
      <param name="startIndex" vsli:raw="The initial position.">A posição inicial.</param>
      <param name="endSegment" vsli:raw="The ending read-only sequence segment.">O segmento de sequência somente leitura final.</param>
      <param name="endIndex" vsli:raw="The final position.">A posição final.</param>
      <typeparam name="T" vsli:raw="The type of the read-only sequence.">O tipo da sequência somente leitura.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read-only sequence segment can be retrieved; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se o segmento de sequência somente leitura pode ser recuperado; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary vsli:raw="Attempts to read the specified type out of the buffer. It's dangerous to use this method with arbitrary structs - see remarks for more information.">Tenta ler o tipo especificado fora do buffer. É perigoso usar esse método com structs arbitrários – confira os comentários para obter mais informações.</summary>
      <param name="reader" vsli:raw="A reference to the sequence reader.">Uma referência ao leitor de sequência.</param>
      <param name="value" vsli:raw="The returned value if the read was successful. &lt;paramref name=&quot;value&quot; /&gt; will be &lt;see langword=&quot;default&quot; /&gt; if failed (due to lack of space).">O valor retornado se a leitura foi bem-sucedida. <paramref name="value" /> será <see langword="default" /> se houver falha (devido à falta de espaço).</param>
      <typeparam name="T" vsli:raw="The type of the value.">O tipo do valor.</typeparam>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the read attempt was successful, &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se a tentativa de leitura foi bem-sucedida; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary vsli:raw="Represents a position in a non-contiguous set of memory. Properties of this type should not be interpreted by anything but the type that created it.">Representa uma posição em um conjunto não contíguo de memória. As propriedades desse tipo não devem ser interpretadas por nada, exceto pelo tipo que a criou.</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary vsli:raw="Initializes a new instance of the &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; struct.">Inicializa uma nova instância do struct <see cref="T:System.SequencePosition" />.</summary>
      <param name="object" vsli:raw="A non-contiguous set of memory.">Um conjunto não contíguo de memória.</param>
      <param name="integer" vsli:raw="The position in &lt;paramref name=&quot;object&quot; /&gt;.">A posição em <paramref name="object" />.</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary vsli:raw="Returns a value that indicates whether the current instance is equal to another object.">Retorna um valor que indica se a instância atual é igual a outro objeto.</summary>
      <param name="obj" vsli:raw="The object to compare with the current instance.">O objeto a ser comparado com a instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;obj&quot; /&gt; is of type &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt; and is equal to the current instance; otherwise, &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> se <paramref name="obj" /> for do tipo <see cref="T:System.SequencePosition" /> e igual à instância atual; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary vsli:raw="Indicates whether the current instance is equal to another &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Indica se a instância atual é igual a outra <see cref="T:System.SequencePosition" />.</summary>
      <param name="other" vsli:raw="The sequence position to compare with the current instance.">A posição da sequência a ser comparada com a instância atual.</param>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the two instances are equal; &lt;see langword=&quot;false&quot; /&gt; otherwise.">
        <see langword="true" /> se as duas instâncias de forem iguais; caso contrário, <see langword="false" />.</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary vsli:raw="Returns the hash code for this instance.">Retorna o código hash para a instância.</summary>
      <returns vsli:raw="The hash code for this instance.">O código hash para essa instância.</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary vsli:raw="Returns the integer part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Retorna a parte inteira desta <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The integer part of this sequence position.">A parte inteira desta posição de sequência.</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary vsli:raw="Returns the object part of this &lt;see cref=&quot;T:System.SequencePosition&quot; /&gt;.">Retorna a parte do objeto desta <see cref="T:System.SequencePosition" />.</summary>
      <returns vsli:raw="The object part of this sequence position.">A parte do objeto dessa posição de sequência.</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary vsli:raw="Provides extension methods for the encoding types, such as &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;, &lt;see cref=&quot;T:System.Text.Encoder&quot; /&gt;, and &lt;see cref=&quot;T:System.Text.Decoder&quot; /&gt;.">Fornece métodos de extensão para tipos de codificação, como <see cref="T:System.Text.Encoding" />, <see cref="T:System.Text.Encoder" /> e <see cref="T:System.Text.Decoder" />.</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to UTF-16 encoded characters and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte um <see cref="T:System.Buffers.ReadOnlySequence`1" /> para caracteres codificados em UTF-16 e grava o resultado em <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">A instância do decodificador que pode converter bytes em valores <see langword="char" />.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Uma sequência de bytes a ser decodificada.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded characters will be written.">O buffer no qual os caracteres decodificados serão gravados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of characters that were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando este método é retornado, contém o número de caracteres gravados em <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando este método é retornado, contém <see langword="true" /> caso <paramref name="decoder" /> não tenha nenhum estado interno parcial; caso contrário, <see langword="false" />.
Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="decoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to chars using &lt;paramref name=&quot;decoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte um <see cref="T:System.ReadOnlySpan`1" /> em caracteres usando <paramref name="decoder" /> e grava o resultado em <paramref name="writer" />.</summary>
      <param name="decoder" vsli:raw="The decoder instance that can convert bytes to &lt;see langword=&quot;char&quot; /&gt; values.">A instância do decodificador que pode converter bytes em valores <see langword="char" />.</param>
      <param name="bytes" vsli:raw="A sequence of bytes to decode.">Uma sequência de bytes a ser decodificada.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">O buffer no qual os caracteres decodificados serão gravados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="charsUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;char&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando este método é retornado, contém o número de <see langword="char" />s gravados em <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;decoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando este método é retornado, contém <see langword="true" /> caso <paramref name="decoder" /> não tenha nenhum estado interno parcial; caso contrário, <see langword="false" />.
Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;decoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contém dados que não podem ser codificados e <paramref name="decoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to encoded bytes and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte um <see cref="T:System.Buffers.ReadOnlySequence`1" /> em bytes codificados e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">A instância do codificador que pode converter valores <see langword="char" /> em bytes.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Uma sequência de caracteres a ser codificada.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">O buffer no qual os bytes codificados serão gravados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando este método é retornado, contém o número de <see langword="byte" />s gravados em <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if all input up until &lt;paramref name=&quot;bytesUsed&quot; /&gt; was converted; otherwise, &lt;see langword=&quot;false&quot; /&gt;. If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando este método é retornado, contém <see langword="true" /> se toda a entrada até <paramref name="bytesUsed" /> foi convertida; caso contrário, <see langword="false" />. Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary vsli:raw="Converts a &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to bytes using &lt;paramref name=&quot;encoder&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Converte um <see cref="T:System.ReadOnlySpan`1" /> em bytes usando <paramref name="encoder" /> e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoder" vsli:raw="The encoder instance that can convert &lt;see langword=&quot;char&quot; /&gt; values to bytes.">A instância do codificador que pode converter valores <see langword="char" /> em bytes.</param>
      <param name="chars" vsli:raw="A sequence of characters to encode.">Uma sequência de caracteres a ser codificada.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">O buffer no qual os bytes codificados serão gravados.</param>
      <param name="flush" vsli:raw="&lt;see langword=&quot;true&quot; /&gt; to indicate no further data is to be converted; otherwise &lt;see langword=&quot;false&quot; /&gt;.">
        <see langword="true" /> para indicar que não há mais dados a serem convertidos; caso contrário, <see langword="false" />.</param>
      <param name="bytesUsed" vsli:raw="When this method returns, contains the count of &lt;see langword=&quot;byte&quot; /&gt;s which were written to &lt;paramref name=&quot;writer&quot; /&gt;.">Quando este método é retornado, contém o número de <see langword="byte" />s gravados em <paramref name="writer" />.</param>
      <param name="completed" vsli:raw="When this method returns, contains &lt;see langword=&quot;true&quot; /&gt; if &lt;paramref name=&quot;encoder&quot; /&gt; contains no partial internal state; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&#xA; If &lt;paramref name=&quot;flush&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, this will always be set to &lt;see langword=&quot;true&quot; /&gt; when the method returns.">Quando este método é retornado, contém <see langword="true" /> caso <paramref name="encoder" /> não tenha nenhum estado interno parcial; caso contrário, <see langword="false" />.
Se <paramref name="flush" /> for <see langword="true" />, será sempre definido como <see langword="true" /> quando o método for retornado.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoder&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoder" /> é configurado para gerar quando esses dados são vistos.</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.Byte&quot; /&gt; array using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Codifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado em uma matriz <see cref="T:System.Byte" /> usando o <see cref="T:System.Text.Encoding" /> especificado.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">A sequência a ser codificada em bytes.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.Byte&quot; /&gt; array that represents the encoded contents of &lt;paramref name=&quot;chars&quot; /&gt;.">Uma matriz <see cref="T:System.Byte" /> que representa o conteúdo codificado de <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="byte" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars" vsli:raw="The &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; whose contents should be encoded.">O <see cref="T:System.Buffers.ReadOnlySequence`1" /> cujo conteúdo deve ser codificado.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">O buffer no qual os bytes codificados serão gravados.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">O número de bytes gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;bytes&quot; /&gt;.">Codifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="byte" />s usando o <see cref="T:System.Text.Encoding" /> especificado e gera o resultado para <paramref name="bytes" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">A sequência a ser codificada em bytes.</param>
      <param name="bytes" vsli:raw="The destination buffer to which the encoded bytes will be written.">O buffer de destino no qual os bytes codificados serão gravados.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;chars&quot; /&gt;.">
        <paramref name="bytes" /> não é grande o suficiente para conter a forma codificada de <paramref name="chars" />.</exception>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;bytes&quot; /&gt;.">O número de bytes gravados em <paramref name="bytes" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary vsli:raw="Encodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;byte&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Codifica o <see cref="T:System.ReadOnlySpan`1" /> especificado para <see langword="byte" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;chars&quot; /&gt; should be encoded.">A codificação que representa como os dados em <paramref name="chars" /> devem ser codificados.</param>
      <param name="chars" vsli:raw="The sequence to encode to bytes.">A sequência a ser codificada em bytes.</param>
      <param name="writer" vsli:raw="The buffer to which the encoded bytes will be written.">O buffer no qual os bytes codificados serão gravados.</param>
      <exception cref="T:System.Text.EncoderFallbackException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; contains data that cannot be encoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="chars" /> contém dados que não podem ser codificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="The number of bytes written to &lt;paramref name=&quot;writer&quot; /&gt;.">O número de bytes gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="char" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">A codificação que representa como os dados em <paramref name="bytes" /> devem ser decodificados.</param>
      <param name="bytes" vsli:raw="The sequence whose bytes should be decoded.">A sequência cujos bytes devem ser decodificados.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">O buffer no qual os caracteres decodificados serão gravados.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">O número de caracteres gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and outputs the result to &lt;paramref name=&quot;chars&quot; /&gt;.">Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado para <see langword="char" />s usando o <see cref="T:System.Text.Encoding" /> especificado e gera o resultado para <paramref name="chars" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">A codificação que representa como os dados em <paramref name="bytes" /> são codificados.</param>
      <param name="bytes" vsli:raw="The sequence to decode to characters.">A sequência a ser decodificada em caracteres.</param>
      <param name="chars" vsli:raw="The destination buffer to which the decoded characters will be written.">O buffer de destino no qual os caracteres decodificados serão gravados.</param>
      <exception cref="T:System.ArgumentException" vsli:raw="&lt;paramref name=&quot;chars&quot; /&gt; is not large enough to contain the encoded form of &lt;paramref name=&quot;bytes&quot; /&gt;.">
        <paramref name="chars" /> não é grande o suficiente para conter a forma codificada de <paramref name="bytes" />.</exception>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;chars&quot; /&gt;.">O número de caracteres gravados em <paramref name="chars" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.ReadOnlySpan`1&quot; /&gt; to &lt;see langword=&quot;char&quot; /&gt;s using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt; and writes the result to &lt;paramref name=&quot;writer&quot; /&gt;.">Decodifica o <see cref="T:System.ReadOnlySpan`1" /> especificado para <see langword="char" />s usando o <see cref="T:System.Text.Encoding" /> especificado e grava o resultado em <paramref name="writer" />.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; should be decoded.">A codificação que representa como os dados em <paramref name="bytes" /> devem ser decodificados.</param>
      <param name="bytes" vsli:raw="The span of bytes to decode.">O intervalo de bytes a ser decodificado.</param>
      <param name="writer" vsli:raw="The buffer to which the decoded chars will be written.">O buffer no qual os caracteres decodificados serão gravados.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="The number of chars written to &lt;paramref name=&quot;writer&quot; /&gt;.">O número de caracteres gravados em <paramref name="writer" />.</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary vsli:raw="Decodes the specified &lt;see cref=&quot;T:System.Buffers.ReadOnlySequence`1&quot; /&gt; into a &lt;see cref=&quot;T:System.String&quot; /&gt; using the specified &lt;see cref=&quot;T:System.Text.Encoding&quot; /&gt;.">Decodifica o <see cref="T:System.Buffers.ReadOnlySequence`1" /> especificado em um <see cref="T:System.String" /> usando o <see cref="T:System.Text.Encoding" /> especificado.</summary>
      <param name="encoding" vsli:raw="The encoding that represents how the data in &lt;paramref name=&quot;bytes&quot; /&gt; is encoded.">A codificação que representa como os dados em <paramref name="bytes" /> são codificados.</param>
      <param name="bytes" vsli:raw="The sequence to decode into characters.">A sequência a ser decodificada em caracteres.</param>
      <exception cref="T:System.Text.DecoderFallbackException" vsli:raw="&lt;paramref name=&quot;bytes&quot; /&gt; contains data that cannot be decoded and &lt;paramref name=&quot;encoding&quot; /&gt; is configured to throw when such data is seen.">
        <paramref name="bytes" /> contém dados que não podem ser decodificados e <paramref name="encoding" /> é configurado para gerar quando esses dados são vistos.</exception>
      <returns vsli:raw="A &lt;see cref=&quot;T:System.String&quot; /&gt; which represents the decoded contents of &lt;paramref name=&quot;bytes&quot; /&gt;.">Uma <see cref="T:System.String" /> que representa o conteúdo decodificado de <paramref name="bytes" />.</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary vsli:raw="Provides an enumerator for the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; values represented by a span containing UTF-16 text.">Fornece um enumerador para os valores de <see cref="T:System.Text.Rune" /> representados por um intervalo contendo texto em UTF-16.</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary vsli:raw="Returns the current enumerator instance.">Retorna a instância do enumerador atual.</summary>
      <returns vsli:raw="The current enumerator instance.">A instância do enumerador atual.</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary vsli:raw="Advances the enumerator to the next &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; of the span.">Avança o enumerador para o próximo <see cref="T:System.Text.Rune" /> do intervalo.</summary>
      <returns vsli:raw="&lt;see langword=&quot;true&quot; /&gt; if the enumerator successfully advanced to the next item; &lt;see langword=&quot;false&quot; /&gt; if the end of the span has been reached.">
        <see langword="true" /> se o enumerador avançou com êxito para o próximo item; <see langword="false" /> se o final do intervalo foi atingido.</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary vsli:raw="Gets the &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">Obtém o <see cref="T:System.Text.Rune" /> na posição atual do enumerador.</summary>
      <returns vsli:raw="The &lt;see cref=&quot;T:System.Text.Rune&quot; /&gt; at the current position of the enumerator.">O <see cref="T:System.Text.Rune" /> na posição atual do enumerador.</returns>
    </member>
  </members>
</doc>