<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Security.Cryptography.Algorithms</name>
  </assembly>
  <members>
    <member name="T:System.Security.Cryptography.Aes">
      <summary>Stellt die abstrakte Basisklasse dar, von der alle Implementierungen von Advanced Encryption Standard (AES) erben müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Aes" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create">
      <summary>Erstellt ein Kryptografieobjekt zum Ausführen des symmetrischen Algorithmus.</summary>
      <returns>Ein Kryptografieobjekt zum Ausführen des symmetrischen Algorithmus.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Aes.Create(System.String)">
      <summary>Erstellt unter Angabe der AES-Implementierung ein Kryptografieobjekt zum Ausführen des symmetrischen Algorithmus.</summary>
      <param name="algorithmName">Der Name der zu verwendenden AES-Implementierung.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="algorithmName" />-Parameter ist <see langword="null" />.</exception>
      <returns>Ein Kryptografieobjekt zum Ausführen des symmetrischen Algorithmus.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesCcm">
      <summary>Stellt einen AES-Schlüssel (Advanced Encryption Standard) dar, der mit dem CCM-Modus (Counter with CBC-MAC) des Vorgangs verwendet werden soll.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.AesCcm" />-Klasse mit einem angegebenen Schlüssel.</summary>
      <param name="key">Der zu verwendende geheime Schlüssel für diese Instanz.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Länge des <paramref name="key" />-Parameters entspricht nicht 16, 24 oder 32 Bytes (128, 192 oder 256 Bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.AesCcm" />-Klasse mit einem angegebenen Schlüssel.</summary>
      <param name="key">Der zu verwendende geheime Schlüssel für diese Instanz.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Länge des <paramref name="key" />-Parameters entspricht nicht 16, 24 oder 32 Bytes (128, 192 oder 256 Bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Entschlüsselt den Chiffretext in den angegebenen Zielpuffer, wenn das Authentifizierungstag validiert werden kann.</summary>
      <param name="nonce">Die dieser Nachricht zugeordneten Nonce, die mit dem Wert übereinstimmen muss, der während der Verschlüsselung bereitgestellt wird.</param>
      <param name="ciphertext">Der verschlüsselte Inhalt, der entschlüsselt werden soll.</param>
      <param name="tag">Das Authentifizierungstag, das während der Verschlüsselung für diese Nachricht produziert wird.</param>
      <param name="plaintext">Das Bytearray, das den entschlüsselten Inhalt empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die mit dem Wert übereinstimmen müssen, der während der Verschlüsselung bereitgestellt wird.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="nonce" />, <paramref name="ciphertext" />,<paramref name="tag" /> oder <paramref name="plaintext" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Tagwert konnte nicht verifiziert werden, oder der Entschlüsselungsvorgang ist anderweitig fehlgeschlagen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Entschlüsselt den Chiffretext in den angegebenen Zielpuffer, wenn das Authentifizierungstag validiert werden kann.</summary>
      <param name="nonce">Die dieser Nachricht zugeordneten Nonce, die mit dem Wert übereinstimmen muss, der während der Verschlüsselung bereitgestellt wird.</param>
      <param name="ciphertext">Der verschlüsselte Inhalt, der entschlüsselt werden soll.</param>
      <param name="tag">Das Authentifizierungstag, das während der Verschlüsselung für diese Nachricht produziert wird.</param>
      <param name="plaintext">Die Bytespanne, die den entschlüsselten Inhalt empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die mit dem Wert übereinstimmen müssen, der während der Verschlüsselung bereitgestellt wird.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Tagwert konnte nicht verifiziert werden, oder der Entschlüsselungsvorgang ist anderweitig fehlgeschlagen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Dispose">
      <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Security.Cryptography.AesCcm" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Entschlüsselt den Klartext als Chiffretext in den Zielpuffer und generiert das Authentifizierungstag in einem separaten Puffer.</summary>
      <param name="nonce">Die der Nachricht zugeordnete Nonce, bei der es sich für jeden Vorgang mit demselben Schlüssel um einen eindeutigen Wert handeln sollte.</param>
      <param name="plaintext">Der zu verschlüsselnde Inhalt.</param>
      <param name="ciphertext">Das Bytearray, das den verschlüsselten Inhalt empfangen soll.</param>
      <param name="tag">Das Bytearray, das das generierte Authentifizierungstag empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die ebenfalls bei der Entschlüsselung bereitgestellt werden müssen.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="nonce" />, <paramref name="ciphertext" />,<paramref name="tag" /> oder <paramref name="plaintext" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Verschlüsselungsvorgang ist fehlgeschlagen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesCcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Entschlüsselt den Klartext als Chiffretext in den Zielpuffer und generiert das Authentifizierungstag in einem separaten Puffer.</summary>
      <param name="nonce">Die der Nachricht zugeordnete Nonce, bei der es sich für jeden Vorgang mit demselben Schlüssel um einen eindeutigen Wert handeln sollte.</param>
      <param name="plaintext">Der zu verschlüsselnde Inhalt.</param>
      <param name="ciphertext">Die Bytespanne, die den verschlüsselten Inhalt empfangen soll.</param>
      <param name="tag">Die Bytespanne, die das generierte Authentifizierungstag empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die ebenfalls bei der Entschlüsselung bereitgestellt werden müssen.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesCcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Verschlüsselungsvorgang ist fehlgeschlagen.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.NonceByteSizes">
      <summary>Ruft die von dieser Instanz unterstützten Noncengrößen in Bytes ab.</summary>
      <returns>Die Nonce-Größen, die von dieser Instanz unterstützt werden: 7, 8, 9, 10, 11, 12 oder 13 bytes (56, 64, 72, 80, 88, 96 oder 104 Bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesCcm.TagByteSizes">
      <summary>Ruft die von dieser Instanz unterstützten Taggrößen in Bytes ab.</summary>
      <returns>Die von dieser Instanz unterstützten taggrößen: 4, 6, 8, 10, 12, 14 oder 16 Bytes (32, 48, 64, 80, 96, 112 oder 128 Bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesGcm">
      <summary>Stellt einen AES-Schlüssel (Advanced Encryption Standard) dar, der mit dem GCM-Modus (Galois/Counter Mode) des Vorgangs verwendet werden soll.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.AesGcm" />-Klasse mit einem angegebenen Schlüssel.</summary>
      <param name="key">Der zu verwendende geheime Schlüssel für diese Instanz.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Länge des <paramref name="key" />-Parameters entspricht nicht 16, 24 oder 32 Bytes (128, 192 oder 256 Bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.#ctor(System.ReadOnlySpan{System.Byte})">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.AesGcm" />-Klasse mit einem angegebenen Schlüssel.</summary>
      <param name="key">Der zu verwendende geheime Schlüssel für diese Instanz.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Länge des <paramref name="key" />-Parameters entspricht nicht 16, 24 oder 32 Bytes (128, 192 oder 256 Bits).</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Entschlüsselt den Chiffretext in den angegebenen Zielpuffer, wenn das Authentifizierungstag validiert werden kann.</summary>
      <param name="nonce">Die dieser Nachricht zugeordneten Nonce, die mit dem Wert übereinstimmen muss, der während der Verschlüsselung bereitgestellt wird.</param>
      <param name="ciphertext">Der verschlüsselte Inhalt, der entschlüsselt werden soll.</param>
      <param name="tag">Das Authentifizierungstag, das während der Verschlüsselung für diese Nachricht produziert wird.</param>
      <param name="plaintext">Das Bytearray, das den entschlüsselten Inhalt empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die mit dem Wert übereinstimmen müssen, der während der Verschlüsselung bereitgestellt wird.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="nonce" />, <paramref name="ciphertext" />,<paramref name="tag" /> oder <paramref name="plaintext" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Tagwert konnte nicht verifiziert werden, oder der Entschlüsselungsvorgang ist anderweitig fehlgeschlagen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Decrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Entschlüsselt den Chiffretext in den angegebenen Zielpuffer, wenn das Authentifizierungstag validiert werden kann.</summary>
      <param name="nonce">Die dieser Nachricht zugeordneten Nonce, die mit dem Wert übereinstimmen muss, der während der Verschlüsselung bereitgestellt wird.</param>
      <param name="ciphertext">Der verschlüsselte Inhalt, der entschlüsselt werden soll.</param>
      <param name="tag">Das Authentifizierungstag, das während der Verschlüsselung für diese Nachricht produziert wird.</param>
      <param name="plaintext">Die Bytespanne, die den entschlüsselten Inhalt empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die mit dem Wert übereinstimmen müssen, der während der Verschlüsselung bereitgestellt wird.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Tagwert konnte nicht verifiziert werden, oder der Entschlüsselungsvorgang ist anderweitig fehlgeschlagen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Dispose">
      <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Security.Cryptography.AesGcm" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
      <summary>Entschlüsselt den Klartext als Chiffretext in den Zielpuffer und generiert das Authentifizierungstag in einem separaten Puffer.</summary>
      <param name="nonce">Die der Nachricht zugeordnete Nonce, bei der es sich für jeden Vorgang mit demselben Schlüssel um einen eindeutigen Wert handeln sollte.</param>
      <param name="plaintext">Der zu verschlüsselnde Inhalt.</param>
      <param name="ciphertext">Das Bytearray, das den verschlüsselten Inhalt empfangen soll.</param>
      <param name="tag">Das Bytearray, das das generierte Authentifizierungstag empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die ebenfalls bei der Entschlüsselung bereitgestellt werden müssen.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="nonce" />, <paramref name="ciphertext" />,<paramref name="tag" /> oder <paramref name="plaintext" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Verschlüsselungsvorgang ist fehlgeschlagen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesGcm.Encrypt(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Entschlüsselt den Klartext als Chiffretext in den Zielpuffer und generiert das Authentifizierungstag in einem separaten Puffer.</summary>
      <param name="nonce">Die der Nachricht zugeordnete Nonce, bei der es sich für jeden Vorgang mit demselben Schlüssel um einen eindeutigen Wert handeln sollte.</param>
      <param name="plaintext">Der zu verschlüsselnde Inhalt.</param>
      <param name="ciphertext">Das Bytearray, das den verschlüsselten Inhalt empfangen soll.</param>
      <param name="tag">Das Bytearray, das das generierte Authentifizierungstag empfangen soll.</param>
      <param name="associatedData">Die dieser Nachricht zugeordneten zusätzlichen Daten, die ebenfalls bei der Entschlüsselung bereitgestellt werden müssen.</param>
      <exception cref="T:System.ArgumentException">Die Parameter <paramref name="plaintext" /> und <paramref name="ciphertext" /> weisen nicht die gleiche Länge auf.

- oder -

Die Länge des <paramref name="nonce" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.NonceByteSizes" /> nicht zugelassen.

- oder -

Die Länge des <paramref name="tag" />-Parameters wird von <see cref="P:System.Security.Cryptography.AesGcm.TagByteSizes" /> nicht zugelassen.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Verschlüsselungsvorgang ist fehlgeschlagen.</exception>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.NonceByteSizes">
      <summary>Ruft die von dieser Instanz unterstützten Noncengrößen in Bytes ab.</summary>
      <returns>Die Nonce-Größen, die von dieser Instanz unterstützt werden: 12 Bytes (96 Bits).</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesGcm.TagByteSizes">
      <summary>Ruft die von dieser Instanz unterstützten Taggrößen in Bytes ab.</summary>
      <returns>Die von dieser Instanz unterstützten taggrößen: 12, 13, 14, 15 oder 16 Bytes (96, 104, 112, 120 oder 128 Bits).</returns>
    </member>
    <member name="T:System.Security.Cryptography.AesManaged">
      <summary>Stellt eine verwaltete Implementierung des symmetrischen AES (Advanced Encryption Standard)-Algorithmus bereit.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.AesManaged" />-Klasse.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Windows-Sicherheitsrichtlinieneinstellung für FIPS ist aktiviert.</exception>
      <exception cref="T:System.InvalidOperationException">Diese Implementierung ist nicht Bestandteil der auf der Windows-Plattform FIPS-überprüften kryptografischen Algorithmen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor">
      <summary>Erstellt ein symmetrisches Entschlüsselungsobjekt mit dem aktuellen Schlüssel und Initialisierungsvektor (IV).</summary>
      <returns>Ein symmetrisches Entschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Erstellt ein symmetrisches Entschlüsselungsobjekt mit dem angegebenen Schlüssel und Initialisierungsvektor (IV).</summary>
      <param name="rgbKey">Der geheime Schlüssel, der für den symmetrischen Algorithmus verwendet werden soll.</param>
      <param name="rgbIV">Der Initialisierungsvektor, der für den symmetrischen Algorithmus verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> oder <paramref name="iv" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> ist ungültig.</exception>
      <returns>Ein symmetrisches Entschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor">
      <summary>Erstellt ein symmetrisches Verschlüsselungsobjekt mit dem aktuellen Schlüssel und Initialisierungsvektor (IV).</summary>
      <returns>Ein symmetrisches Verschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Erstellt ein symmetrisches Verschlüsselungsobjekt mit dem angegebenen Schlüssel und Initialisierungsvektor (IV).</summary>
      <param name="rgbKey">Der geheime Schlüssel, der für den symmetrischen Algorithmus verwendet werden soll.</param>
      <param name="rgbIV">Der Initialisierungsvektor, der für den symmetrischen Algorithmus verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> oder <paramref name="iv" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> ist ungültig.</exception>
      <returns>Ein symmetrisches Verschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateIV">
      <summary>Generiert einen zufälligen Initialisierungsvektor (IV) für den symmetrischen Algorithmus.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateKey">
      <summary>Generiert einen zufälligen Schlüssel für den symmetrischen Algorithmus.</summary>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.BlockSize">
      <summary>Ruft die Blockgröße des kryptografischen Vorgangs in Bits ab oder legt diese fest.</summary>
      <returns>Die Blockgröße des kryptografischen Vorgangs in Bits. Der Standardwert ist 128 Bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.FeedbackSize">
      <summary>Ruft die Anzahl der Bits ab, die als Feedback verwendet werden, oder legt diese fest.</summary>
      <returns>Die Feedbackgröße in Bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.IV">
      <summary>Ruft den Initialisierungsvektor (IV) für den symmetrischen Algorithmus ab oder legt diesen fest.</summary>
      <returns>Der Initialisierungsvektor, der für den symmetrischen Algorithmus verwendet wird.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Key">
      <summary>Ruft den geheimen Schlüssel für den symmetrischen Algorithmus ab oder legt diesen fest.</summary>
      <returns>Der Schlüssel für den symmetrischen Algorithmus.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.KeySize">
      <summary>Ruft die Größe des geheimen Schlüssels für den symmetrischen Algorithmus in Bits ab oder legt diese fest.</summary>
      <returns>Die Schlüsselgröße für den symmetrischen Algorithmus in Bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalBlockSizes">
      <summary>Ruft die vom symmetrischen Algorithmus unterstützten Blockgrößen in Bits ab.</summary>
      <returns>Die Blockgrößen in Bits, die vom symmetrischen Algorithmus unterstützt werden.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.LegalKeySizes">
      <summary>Ruft die vom symmetrischen Algorithmus unterstützten Schlüsselgrößen in Bits ab.</summary>
      <returns>Die Schlüsselgrößen in Bits, die vom symmetrischen Algorithmus unterstützt werden.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Mode">
      <summary>Ruft den Modus für die Ausführung des symmetrischen Algorithmus ab oder legt diesen fest.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <see cref="P:System.Security.Cryptography.AesManaged.Mode" /> wird auf <see cref="F:System.Security.Cryptography.CipherMode.CFB" /> oder <see cref="F:System.Security.Cryptography.CipherMode.OFB" /> festgelegt.</exception>
      <returns>Einer der Enumerationswerte, der den Blockverschlüsselungsmodus für die Verschlüsselung angibt. Der Standardwert ist <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Padding">
      <summary>Ruft den im symmetrischen Algorithmus verwendeten Füllzeichenmodus ab oder legt diesen fest.</summary>
      <returns>Einer der Enumerationswerte, der den Abstandstyp angibt. Der Standardwert ist <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter">
      <summary>Stellt die Basisklasse dar, aus der alle Deformatierungsprogramme für asymmetrischen Schlüsselaustausch abgeleitet werden.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrahiert beim Überschreiben in einer abgeleiteten Klasse geheime Informationen aus den verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="rgb">Die Schlüsselaustauschdaten, in denen die geheimen Informationen verborgen sind.</param>
      <returns>Die geheimen Informationen, die aus den Schlüsselaustauschdaten abgeleitet werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt beim Überschreiben in einer abgeleiteten Klasse den privaten Schlüssel fest, der zum Entschlüsseln der geheimen Informationen verwendet werden soll.</summary>
      <param name="key">Die Instanz der Implementierung von <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />, die den privaten Schlüssel enthält.</param>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.Parameters">
      <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Parameter für den asymmetrischen Schlüsselaustausch ab oder legt diese fest.</summary>
      <returns>Eine Zeichenfolge im XML-Format, die die Parameter für den asymmetrischen Schlüsselaustauschvorgang enthält.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter">
      <summary>Stellt die Basisklasse dar, von der alle Formatierungsprogramme für den asymmetrischen Schlüsselaustausch abgeleitet werden.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.AsymmetricKeyExchangeFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Erstellt, falls in einer abgeleiteten Klasse überschrieben, anhand der angegebenen Eingabedaten die verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="data">Die beim Schlüsselaustausch zu übergebenden geheimen Informationen.</param>
      <returns>Die an den beabsichtigten Empfänger zu sendenden verschlüsselten Schlüsselaustauschdaten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Erstellt, falls in einer abgeleiteten Klasse überschrieben, anhand der angegebenen Eingabedaten die verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="data">Die beim Schlüsselaustausch zu übergebenden geheimen Informationen.</param>
      <param name="symAlgType">Dieser Parameter wird in der aktuellen Version nicht verwendet.</param>
      <returns>Die an den beabsichtigten Empfänger zu sendenden verschlüsselten Schlüsselaustauschdaten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt beim Überschreiben in einer abgeleiteten Klasse den öffentlichen Schlüssel fest, der zum Verschlüsseln der geheimen Informationen verwendet werden soll.</summary>
      <param name="key">Die Instanz der Implementierung von <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />, die den öffentlichen Schlüssel enthält.</param>
    </member>
    <member name="P:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.Parameters">
      <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Parameter für den asymmetrischen Schlüsselaustausch ab.</summary>
      <returns>Eine Zeichenfolge im XML-Format, die die Parameter für den asymmetrischen Schlüsselaustauschvorgang enthält.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureDeformatter">
      <summary>Stellt die abstrakte Basisklasse dar, von der alle Implementierungen asymmetrischer Signaturdeformatierer abgeleitet sind.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Legt beim Überschreiben in einer abgeleiteten Klasse den Hashalgorithmus fest, der zum Überprüfen der Signatur verwendet werden soll.</summary>
      <param name="strName">Der Name des Hashalgorithmus, der zum Überprüfen der Signatur verwendet werden soll.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt beim Überschreiben in einer abgeleiteten Klasse den öffentlichen Schlüssel fest, der zum Überprüfen der Signatur verwendet werden soll.</summary>
      <param name="key">Die Instanz einer Implementierung von <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />, die den öffentlichen Schlüssel enthält.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Überprüft beim Überschreiben in einer abgeleiteten Klasse die Signatur für die angegebenen Daten.</summary>
      <param name="rgbHash">Die mit <paramref name="rgbSignature" /> signierten Daten.</param>
      <param name="rgbSignature">Die für <paramref name="rgbHash" /> zu überprüfende Signatur.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="rgbSignature" /> der Signatur entspricht, die mit dem angegebenen Hashalgorithmus und Schlüssel für <paramref name="rgbHash" /> berechnet wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Security.Cryptography.HashAlgorithm,System.Byte[])">
      <summary>Überprüft die Signatur aus dem angegebenen Hashwert.</summary>
      <param name="hash">Der zum Überprüfen der Signatur zu verwendende Hashalgorithmus.</param>
      <param name="rgbSignature">Die zu überprüfende Signatur.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="hash" />-Parameter ist <see langword="null" />.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur für den Hash gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.AsymmetricSignatureFormatter">
      <summary>Stellt die Basisklasse dar, von der alle Implementierungen asymmetrischer Signaturformatierungsprogrammen abgeleitet sind.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse die Signatur für die angegebenen Daten.</summary>
      <param name="rgbHash">Die zu signierenden Daten.</param>
      <returns>Die digitale Signatur für den <paramref name="rgbHash" />-Parameter.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Security.Cryptography.HashAlgorithm)">
      <summary>Erstellt die Signatur aus dem angegebenen Hashwert.</summary>
      <param name="hash">Der zum Erstellen der Signatur zu verwendende Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="hash" />-Parameter ist <see langword="null" />.</exception>
      <returns>Die Signatur für den angegebenen Hashwert.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Legt, falls in einer abgeleiteten Klasse überschrieben, den Hashalgorithmus fest, der zum Erstellen der Signatur verwendet werden soll.</summary>
      <param name="strName">Der Name des Hashalgorithmus, der zum Erstellen der Signatur verwendet werden soll.</param>
    </member>
    <member name="M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt, falls in einer abgeleiteten Klasse überschrieben, den asymmetrischen Algorithmus fest, der zum Erstellen der Signatur verwendet werden soll.</summary>
      <param name="key">Die Instanz der Implementierung von <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />, die zum Erstellen der Signatur verwendet werden soll.</param>
    </member>
    <member name="T:System.Security.Cryptography.CryptoConfig">
      <summary>Greift auf Informationen über die Kryptografiekonfiguration zu.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.CryptoConfig" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddAlgorithm(System.Type,System.String[])">
      <summary>Fügt den Algorithmuszuordnungen, die für die aktuelle Anwendungsdomäne verwendet werden sollen, einen Satz von Namen hinzu.</summary>
      <param name="algorithm">Der zuzuordnende Algorithmusname.</param>
      <param name="names">Ein Array von Namen, die dem Algorithmus zugeordnet werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="algorithm" />-Parameter oder der <paramref name="names" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Auf <paramref name="algorithm" /> kann nicht von außerhalb der Assembly zugegriffen werden.  
  
- oder - 
Einer der Einträge im <paramref name="names" />-Parameter ist leer oder <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.AddOID(System.String,System.String[])">
      <summary>Fügt den Objektbezeichnerzuordnungen (OID), die für die aktuelle Anwendungsdomäne verwendet werden sollen, einen Satz von Namen hinzu.</summary>
      <param name="oid">Der zuzuordnende Objektbezeichner (OID).</param>
      <param name="names">Ein Array von Namen, die dem Objektbezeichner zugeordnet werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="oid" />-Parameter oder der <paramref name="names" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">Einer der Einträge im <paramref name="names" />-Parameter ist leer oder <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String)">
      <summary>Erstellt eine neue Instanz des angegebenen Kryptografieobjekts.</summary>
      <param name="name">Der einfache Name des Kryptografieobjekts, von dem eine Instanz erstellt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Der durch den <paramref name="name" />-Parameter beschriebene Algorithmus wurde bei aktiviertem FIPS-Modus (Federal Information Processing Standards) verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz des angegebenen Kryptografieobjekts.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String,System.Object[])">
      <summary>Erstellt eine neue Instanz des angegebenen Kryptografieobjekts mit den angegebenen Argumenten.</summary>
      <param name="name">Der einfache Name des Kryptografieobjekts, von dem eine Instanz erstellt werden soll.</param>
      <param name="args">Die zum Erstellen des angegebenen Kryptografieobjekts verwendeten Argumente.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Der durch den <paramref name="name" />-Parameter beschriebene Algorithmus wurde bei aktiviertem FIPS-Modus (Federal Information Processing Standards) verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz des angegebenen Kryptografieobjekts.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.EncodeOID(System.String)">
      <summary>Codiert den angegebenen Objektbezeichner (OID).</summary>
      <param name="str">Der zu codierende OID.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="str" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Fehler beim Codieren des OID.</exception>
      <returns>Ein Bytearray, das den codierten OID enthält.</returns>
    </member>
    <member name="M:System.Security.Cryptography.CryptoConfig.MapNameToOID(System.String)">
      <summary>Ruft den Objektbezeichner (OID) des Algorithmus ab, der dem angegebenen einfachen Namen entspricht.</summary>
      <param name="name">Der einfache Name des Algorithmus, dessen OID abgerufen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      <returns>Der OID des angegebenen Algorithmus.</returns>
    </member>
    <member name="P:System.Security.Cryptography.CryptoConfig.AllowOnlyFipsAlgorithms">
      <summary>Gibt an, ob die Runtime die Richtlinie erzwingen soll, um nur FIPS-zertifizierte (Federal Information Processing Standard) Algorithmen zu erstellen.</summary>
      <returns>
        <see langword="true" />, um die Richtlinie zu erzwingen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DeriveBytes">
      <summary>Stellt die abstrakte Basisklasse dar, von der alle Klassen erben, die Bytefolgen angegebener Länge ableiten.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DeriveBytes" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose">
      <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse alle Ressourcen frei, die von der aktuellen Instanz der <see cref="T:System.Security.Cryptography.DeriveBytes" />-Klasse verwendet werden.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)">
      <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse die von der <see cref="T:System.Security.Cryptography.DeriveBytes" />-Klasse verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)">
      <summary>Gibt nach Überschreiben in einer abgeleiteten Klasse pseudozufällige Schlüsselbytes zurück.</summary>
      <param name="cb">Die Anzahl der zu generierenden pseudozufälligen Schlüsselbytes.</param>
      <returns>Ein mit pseudozufälligen Schlüsselbytes gefülltes Bytearray.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DeriveBytes.Reset">
      <summary>Setzt nach Überschreiben in einer abgeleiteten Klasse den Zustand der Operation zurück.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DES">
      <summary>Stellt die Basisklasse für den DES-Algorithmus (Data Encryption Standard) dar, von der alle <see cref="T:System.Security.Cryptography.DES" />-Implementierungen abgeleitet werden müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DES" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create">
      <summary>Erstellt eine Instanz eines Kryptografieobjekts, um den Datenverschlüsselungsstandardalgorithmus (Data Encryption Standard, <see cref="T:System.Security.Cryptography.DES" />) auszuführen.</summary>
      <returns>Ein Kryptografieobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.Create(System.String)">
      <summary>Erstellt eine Instanz eines Kryptographieobjekts für die Ausführung der angegebenen Implementierung des <see cref="T:System.Security.Cryptography.DES" /> (Data Encryption Standard)-Algorithmus.</summary>
      <param name="algName">Der Name der spezifischen Implementierung von <see cref="T:System.Security.Cryptography.DES" />, die verwendet werden soll.</param>
      <returns>Ein Kryptografieobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])">
      <summary>Bestimmt, ob der angegebene Schlüssel semiweak ist.</summary>
      <param name="rgbKey">Der geheime Schlüssel zum Testen auf Semiweakheit.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Größe des <paramref name="rgbKey" />-Parameters ist nicht gültig.</exception>
      <returns>
        <see langword="true" />, wenn der Schlüssel semiweak ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])">
      <summary>Bestimmt, ob der angegebene Schlüssel schwach ist.</summary>
      <param name="rgbKey">Der geheime Schlüssel zum Testen auf Schwächen.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Größe des <paramref name="rgbKey" />-Parameters ist nicht gültig.</exception>
      <returns>
        <see langword="true" />, wenn der Schlüssel schwach ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.DES.Key">
      <summary>Ruft den geheimen Schlüssel für den <see cref="T:System.Security.Cryptography.DES" />-Algorithmus (Data Encryption Standard) ab oder legt ihn fest.</summary>
      <exception cref="T:System.ArgumentNullException">Es wurde versucht, den Schlüssel auf <see langword="null" /> festzulegen.</exception>
      <exception cref="T:System.ArgumentException">Es wurde versucht, einen Schlüssel festzulegen, dessen Länge nicht gleich <see cref="F:System.Security.Cryptography.SymmetricAlgorithm.BlockSizeValue" /> ist.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Es wurde versucht, einen Weak-Schlüssel (siehe <see cref="M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])" />) oder einen Semiweak-Schlüssel (siehe <see cref="M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])" />) festzulegen.</exception>
      <returns>Der geheime Schlüssel für den <see cref="T:System.Security.Cryptography.DES" />-Algorithmus.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DSA">
      <summary>Stellt die abstrakte Basisklasse dar, von der alle Implementierungen des digitalen Signaturalgorithmus (<see cref="T:System.Security.Cryptography.DSA" />) erben müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DSA" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create">
      <summary>Erstellt das Standardkryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</summary>
      <returns>Ein Kryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Int32)">
      <summary>Erstellt einen neuen kurzlebigen DSA-Schlüssel mit der angegebenen Schlüsselgröße.</summary>
      <param name="keySizeInBits">Die Schlüsselgröße in Bits.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> wird von <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes" /> nicht zugelassen.</exception>
      <returns>Ein neuer kurzlebiger DSA-Schlüssel mit der angegebenen Schlüsselgröße.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.Security.Cryptography.DSAParameters)">
      <summary>Erstellt einen neuen kurzlebigen DSA-Schlüssel mit den angegebenen DSA-Schlüsselparametern.</summary>
      <param name="parameters">Die Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus.</param>
      <returns>Ein neuer kurzlebiger DSA-Schlüssel.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.Create(System.String)">
      <summary>Erstellt das angegebene Kryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</summary>
      <param name="algName">Der Name der spezifischen Implementierung von <see cref="T:System.Security.Cryptography.DSA" />, die verwendet werden soll.</param>
      <returns>Ein Kryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[])">
      <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Security.Cryptography.DSA" />-Signatur für die angegebenen Hashdaten</summary>
      <param name="rgbHash">Der Hashwert, der signiert werden soll.</param>
      <returns>Die digitale Signatur für den angegebenen Hashwert.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Erstellt die DSA-Signatur für den angegebenen Hashwert im angegebenen Format.</summary>
      <param name="rgbHash">Der zu signierende Hashwert.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.CreateSignatureCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Erstellt die DSA-Signatur für den angegebenen Hashwert im angegebenen Format.</summary>
      <param name="hash">Der zu signierende Hashwert.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ExportParameters(System.Boolean)">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Security.Cryptography.DSAParameters" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <returns>Die Parameter für <see cref="T:System.Security.Cryptography.DSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.FromXmlString(System.String)">
      <summary>Stellt ein <see cref="T:System.Security.Cryptography.DSA" />-Objekt aus einer XML-Zeichenfolge wieder her.</summary>
      <param name="xmlString">Die XML-Zeichenfolge zur Wiederherstellung des <see cref="T:System.Security.Cryptography.DSA" />-Objekts.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="xmlString" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Format des <paramref name="xmlString" />-Parameters ist nicht gültig.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)">
      <summary>Ruft die größte Größe (in Bytes) für eine Signatur ab, die von diesem Schlüssel im angegeben Format generiert wird.</summary>
      <param name="signatureFormat">Das Codierungsformat für eine Signatur.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <returns>Die größte Größe (in Bytes) für eine Signatur, die von diesem Schlüssel im angegeben Format generiert wird.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert eines angegebenen Teils eines Bytearrays mithilfe eines angegebenen Hashalgorithmus.</summary>
      <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
      <param name="offset">Der Index des ersten Bytes in <paramref name="data" />, für das der Hashwert berechnet werden soll.</param>
      <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert eines angegebenen Binärdatenstroms mithilfe eines angegebenen Hashalgorithmus.</summary>
      <param name="data">Der binäre Datenstrom, für den der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem bytebasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass die anzuwendende Schlüsselableitungsfunktion die Legacy-PKCS#12-KDF ist, die <see cref="T:System.Char" />-basierte Kennwörter erfordert.

- oder - 

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem zeichenbasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder - 

            <paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder - 

            <paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen mit RFC 7468 PEM-codierten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des Schlüssels, der importiert werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder - 

            <paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.

- oder - 

            <paramref name="input" /> enthält einen verschlüsselten PEM-codierten Schlüssel.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportParameters(System.Security.Cryptography.DSAParameters)">
      <summary>Importiert beim Überschreiben in einer abgeleiteten Klasse die angegebenen <see cref="T:System.Security.Cryptography.DSAParameters" />.</summary>
      <param name="parameters">Die Parameter für <see cref="T:System.Security.Cryptography.DSA" />.</param>
      <exception cref="T:System.ArgumentException">In <paramref name="parameters" /> fehlen Pflichtfelder.

- oder - 

<paramref name="parameters" /> weist Felder mit inkonsistenten Längen für einen gültigen Schlüssel auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> stellt keinen gültigen DSA-Schlüsselparametersatz dar.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-PrivateKeyInfo-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer PKCS#8-PrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-PrivateKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert den öffentlichen Schlüssel aus einer X.509-SubjectPublicKeyInfo-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer X.509-SubjectPublicKeyInfo-Struktur in der ASN.1-DER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-DER-codierte X.509-SubjectPublicKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet den Hashwert eines Teils des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und signiert den sich ergebenden Hashwert.</summary>
      <param name="data">Die Eingabedaten, für die der Hashwert berechnet werden soll.</param>
      <param name="offset">Der Offset im Array, ab dem Daten verwendet werden sollen.</param>
      <param name="count">Die Anzahl der Bytes im Array, die als Daten verwendet werden sollen.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="offset">Der Offset in <paramref name="data" />, ab dem Hashing erfolgen soll.</param>
      <param name="count">Die Anzahl der aus <paramref name="data" /> zu lesenden Bytes.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.
 
Oder <paramref name="offset" /> ist kleiner als 0 (null).
 
Oder <paramref name="count" /> ist kleiner als 0 (null).
 
<paramref name="offset" /> + <paramref name="count" /> – 1 führt zu einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet den Hashwert des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und signiert den resultierenden Hashwert.</summary>
      <param name="data">Die Eingabedaten, für die der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet den Hashwert des angegebenen Datenstroms mithilfe des angegebenen Hashalgorithmus und signiert den resultierenden Hashwert.</summary>
      <param name="data">Der Eingabedatenstrom, für den der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignDataCore(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.SignDataCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.ToXmlString(System.Boolean)">
      <summary>Erstellt eine XML-Zeichenfolgendarstellung des aktuellen <see cref="T:System.Security.Cryptography.DSA" />-Objekts und gibt diese zurück.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <returns>Eine XML-Zeichenfolgencodierung des aktuellen <see cref="T:System.Security.Cryptography.DSA" />-Objekts.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignature(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die DSA-Signatur für den angegebenen Hash im angegebenen Puffer zu erstellen.</summary>
      <param name="hash">Der zu signierende Hash.</param>
      <param name="destination">Die Bytespanne, die die Signatur empfangen soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder - 

Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und <paramref name="hash" /> ist kein 20-Byte-Wert.

- oder - 

Die Erstellung der Signatur schlägt andernfalls fehl.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, das Ergebnis zu empfangen. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignature(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die DSA-Signatur für den angegebenen Hashwert im angegebenen Format im angegebenen Puffer zu erstellen und im bereitgestellten Puffer zu platzieren.</summary>
      <param name="hash">Der zu signierende Hashwert.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryCreateSignatureCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die DSA-Signatur für den angegebenen Hashwert im angegebenen Format im angegebenen Puffer zu erstellen und im bereitgestellten Puffer zu platzieren.</summary>
      <param name="hash">Der zu signierende Hashwert.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem bytebasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Verschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.

- oder - 

<paramref name="pbeParameters" /> gibt an, dass <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> verwendet werden soll, wofür <see cref="T:System.Char" />-basierte Kennwörter erforderlich sind.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem zeichenbasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="password">Das Kennwort, das bei der Verschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-PrivateKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die PKCS#8-PrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im X.509-SubjectPublicKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die X.509-SubjectPublicKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Versucht, den Hashwert der angegebenen Daten in einen angegebenen Puffer zu berechnen.</summary>
      <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
      <param name="destination">Die Bytespanne, die den Hashwert empfangen soll.</param>
      <param name="hashAlgorithm">Der Name des zu verwendeten Hash-Algorithmus.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, das Ergebnis zu empfangen. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Versucht, die DSA-Signatur für die angegebenen Daten im angegebenen Puffer zu erstellen.</summary>
      <param name="data">Die Daten, die gehasht und signiert werden sollen.</param>
      <param name="destination">Die Bytespanne, die die Signatur empfangen soll.</param>
      <param name="hashAlgorithm">Der Name des zu verwendeten Hash-Algorithmus.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, das Ergebnis zu empfangen. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die DSA-Signatur für die angegebenen Daten im angegebenen Format im angegebenen Puffer zu erstellen und im bereitgestellten Puffer zu platzieren.</summary>
      <param name="data">Die Daten, die gehasht und signiert werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.TrySignDataCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die DSA-Signatur für die angegebenen Daten im angegebenen Format im angegebenen Puffer zu erstellen und im bereitgestellten Puffer zu platzieren.</summary>
      <param name="data">Die Daten, die gehasht und signiert werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der angegebenen Daten unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder - 

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der Daten in einem Teil eines Bytearrays unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="offset">Der Startindex, an dem der Hashwert berechnet werden soll.</param>
      <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder - 

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Ein Array, das die signierten Daten enthält.</param>
      <param name="offset">Der Startindex des signierten Teils von <paramref name="data" />.</param>
      <param name="count">Die Anzahl der Bytes in <paramref name="data" />, die signiert wurden.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.
 
Oder <paramref name="offset" /> ist kleiner als 0 (null).
 
Oder <paramref name="count" /> ist kleiner als 0 (null).
 
<paramref name="offset" /> + <paramref name="count" /> – 1 führt zu einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert des angegebenen Datenstroms unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder - 

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der Daten in einer Bytespanne unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder - 

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyDataCore(System.IO.Stream,System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifyDataCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Überprüft beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Security.Cryptography.DSA" />-Signatur für die angegebenen Daten.</summary>
      <param name="rgbHash">Der Hash der mit <paramref name="rgbSignature" /> signierten Daten.</param>
      <param name="rgbSignature">Die für <c>rgbData</c> zu überprüfende Signatur.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashwert ist keine 20 Byte lang.

- oder - 

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="rgbSignature" /> der Signatur entspricht, die mit dem angegebenen Hashalgorithmus und Schlüssel für <paramref name="rgbHash" /> berechnet wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für den bereitgestellten Hash gültig ist.</summary>
      <param name="rgbHash">Der signierte Hash.</param>
      <param name="rgbSignature">Die zu überprüfende Signatur.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="rgbSignature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> oder <paramref name="rgbSignature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Überprüft, ob eine digitale Signatur für einen angegebenen Datenhash gültig ist.</summary>
      <param name="hash">Der zu überprüfende Datenhash.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashwert ist keine 20 Byte lang.

- oder - 

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für den Hash gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignature(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für den bereitgestellten Hash gültig ist.</summary>
      <param name="hash">Der signierte Hash.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSA.VerifySignatureCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für den bereitgestellten Hash gültig ist.</summary>
      <param name="hash">Der signierte Hash.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DSAParameters">
      <summary>Enthält die typischen Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Counter">
      <summary>Gibt den Zähler für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.G">
      <summary>Gibt den <see langword="G" />-Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.J">
      <summary>Gibt den <see langword="J" />-Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.P">
      <summary>Gibt den <see langword="P" />-Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Q">
      <summary>Gibt den <see langword="Q" />-Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Seed">
      <summary>Gibt den Startwert für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.X">
      <summary>Gibt den <see langword="X" />-Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSAParameters.Y">
      <summary>Gibt den <see langword="Y" />-Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus an.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureDeformatter">
      <summary>Überprüft eine <see cref="T:System.Security.Cryptography.DSA" />-Signatur (Digital Signature Algorithm) für PKCS#1 v1.5.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DSASignatureDeformatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz von <see cref="T:System.Security.Cryptography.DSA" /> (Digital Signature Algorithm), die den Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Gibt den Hashalgorithmus für das Deformatierungsprogramm für <see cref="T:System.Security.Cryptography.DSA" />-Signaturen (Digital Signature Algorithm) an.</summary>
      <param name="strName">Der Name des Hashalgorithmus für das Signaturdeformatierungsprogramm.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der <paramref name="strName" />-Parameter wird dem <see cref="T:System.Security.Cryptography.SHA1" />-Hashalgorithmus nicht zugeordnet.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Gibt den Schlüssel für das Deformatierungsprogramm für <see cref="T:System.Security.Cryptography.DSA" />-Signaturen (Digital Signature Algorithm) an.</summary>
      <param name="key">Die Instanz von <see cref="T:System.Security.Cryptography.DSA" />, die den Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Überprüft die <see cref="T:System.Security.Cryptography.DSA" />-Signatur (Digital Signature Algorithm) für die Daten.</summary>
      <param name="rgbHash">Die mit <paramref name="rgbSignature" /> signierten Daten.</param>
      <param name="rgbSignature">Die für <paramref name="rgbHash" /> zu überprüfende Signatur.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="rgbSignature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der DSA-Schlüssel fehlt.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur für die Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureFormat">
      <summary>Gibt das Datenformat für Signaturen mit der DSA-Familie von Algorithmen an.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSASignatureFormat.IeeeP1363FixedFieldConcatenation">
      <summary>Das Signaturformat aus IEEE P1363, das eine Signatur fester Größe für einen angegebenen Schlüssel generiert.</summary>
    </member>
    <member name="F:System.Security.Cryptography.DSASignatureFormat.Rfc3279DerSequence">
      <summary>Das Signaturformat aus IETF RFC 3279, das eine Signatur variabler Größen generiert.</summary>
    </member>
    <member name="T:System.Security.Cryptography.DSASignatureFormatter">
      <summary>Erstellt eine DSA-Signatur (Digitale Signature Algorithm) (<see cref="T:System.Security.Cryptography.DSA" />).</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DSASignatureFormatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DSASignatureFormatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz von <see cref="T:System.Security.Cryptography.DSA" /> (Digital Signature Algorithm), die den Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Erstellt die <see cref="T:System.Security.Cryptography.DSA" />-PKCS #1-Signatur (Digital Signature Algorithm) für die angegebenen Daten.</summary>
      <param name="rgbHash">Die zu signierenden Daten.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="rgbHash" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Die OID ist <see langword="null" />.  
  
- oder - 
Der DSA-Schlüssel ist <see langword="null" />.</exception>
      <returns>Die digitale Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Gibt den Hashalgorithmus für das Formatierungsprogramm für <see cref="T:System.Security.Cryptography.DSA" />-Signaturen (Digital Signature Algorithm) an.</summary>
      <param name="strName">Der Name des Hashalgorithmus für das Signaturformatierungsprogramm.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der <paramref name="strName" />-Parameter wird dem <see cref="T:System.Security.Cryptography.SHA1" />-Hashalgorithmus nicht zugeordnet.</exception>
    </member>
    <member name="M:System.Security.Cryptography.DSASignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Gibt den Schlüssel für das Formatierungsprogramm für <see cref="T:System.Security.Cryptography.DSA" />-Signaturen (Digital Signature Algorithm) an.</summary>
      <param name="key">Die Instanz von <see cref="T:System.Security.Cryptography.DSA" />, die den Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve">
      <summary>Stellt eine elliptische Kurve dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.A">
      <summary>Der erste Koeffizient für eine explizite Kurve. <c>A</c> für kurze Weierstraßsche, Montgomery- und verdrehte Edwards-Kurven.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.B">
      <summary>Der zweite Koeffizient für eine explizite Kurve. <c>B</c> für kurze Weierstraßsche und <c>d</c> für verdrehte Edwards-Kurven.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Cofactor">
      <summary>Der Kofaktor der Kurve.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.CurveType">
      <summary>Identifiziert die Komposition des <see cref="T:System.Security.Cryptography.ECCurve" />-Objekts.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.G">
      <summary>Der Generator oder Ausgangspunkt für Vorgänge auf der Kurve.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Hash">
      <summary>Der Name des Hashalgorithmus, der verwendet wurde, um die Kurvenkoeffizienten (<see cref="F:System.Security.Cryptography.ECCurve.A" /> und <see cref="F:System.Security.Cryptography.ECCurve.B" />) aus dem <see cref="F:System.Security.Cryptography.ECCurve.Seed" /> unter dem ANSI X9.62-Generierungsalgorithmus zu generieren. Gilt nur für explizite Kurven.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Order">
      <summary>Die Reihenfolge der Kurve. Gilt nur für explizite Kurven.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Polynomial">
      <summary>Die Polynomkurve. Gilt nur für Charakteristik-2-Kurven.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Prime">
      <summary>Die Primzahl, die das Basisfeld angibt. Gilt nur für Primkurven.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.Seed">
      <summary>Der Startwert für die Generierung der Koeffizienten unter dem ANSI X9.62-Generierungsalgorithmus. Gilt nur für explizite Kurven.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromFriendlyName(System.String)">
      <summary>Erstellt unter Verwendung des angegebenen Anzeigenamens des Bezeichners eine benannte Kurve.</summary>
      <param name="oidFriendlyName">Der Anzeigename des Bezeichners.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidFriendlyName" /> ist <see langword="null" />.</exception>
      <returns>Ein Objekt, das die benannte Kurve darstellt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromOid(System.Security.Cryptography.Oid)">
      <summary>Erstellt eine benannte Kurve mithilfe des angegebenen <see cref="T:System.Security.Cryptography.Oid" />-Objekts.</summary>
      <param name="curveOid">Der zu verwendende Objektbezeichner.</param>
      <returns>Ein Objekt, das die benannte Kurve darstellt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.CreateFromValue(System.String)">
      <summary>Erstellt eine benannte Kurve mit der angegebenen Dezimaldarstellung des Bezeichners (mit Punkten als Trennzeichen).</summary>
      <param name="oidValue">Die Nummer des Bezeichners in Dezimalschreibweise.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="oidValue" /> ist <see langword="null" />.</exception>
      <returns>Ein Objekt, das die benannte Kurve darstellt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECCurve.Validate">
      <summary>Überprüft die Integrität der aktuellen Kurve. Löst eine <see cref="T:System.Security.Cryptography.CryptographicException" />-Ausnahme aus, wenn die Struktur ungültig ist.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Kurvenparameter sind für den aktuellen Kurventyp ungültig.</exception>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsCharacteristic2">
      <summary>Ruft einen Wert ab, der angibt, ob der Kurventyp eine explizite Charakteristik-2-Kurve angibt.</summary>
      <returns>
        <see langword="true" />, wenn die Kurve eine explizite Charakteristik-2-Kurve ist. <see langword="false" />, wenn die Kurve eine benannte Charakteristik-2-, eine Prim- oder eine implizite Kurve ist.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsExplicit">
      <summary>Ruft einen Wert ab, der angibt, ob der Kurventyp eine explizite Kurve (Prim- oder Charakteristik 2) angibt.</summary>
      <returns>
        <see langword="true" />, wenn die Kurve eine explizite Kurve (Prim- oder Charakteristik 2) ist. <see langword="false" />, wenn die Kurve eine benannte oder eine implizite Kurve ist.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsNamed">
      <summary>Ruft einen Wert ab, der angibt, ob der Kurventyp eine benannte Kurve angibt.</summary>
      <returns>
        <see langword="true" /> , wenn die Kurve eine benannte Kurve ist. <see langword="false" /> Wenn die Kurve eine implizite oder eine explizite Kurve (Primzahlen oder Merkmal 2) ist.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.IsPrime">
      <summary>Ruft einen Wert ab, der angibt, ob der Kurventyp eine explizite Primkurve angibt.</summary>
      <returns>
        <see langword="true" />, wenn die Kurve eine explizite Primkurve ist. <see langword="false" />, wenn die Kurve eine benannte Prim-, eine Charakteristik-2- oder eine implizite Kurve ist.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.Oid">
      <summary>Ruft den Bezeichner einer benannten Kurve ab.</summary>
      <returns>Der Bezeichner einer benannten Kurve.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.ECCurveType">
      <summary>Gibt an, wie die Daten in einem <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt interpretiert werden sollen.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Characteristic2">
      <summary>Die Kurvenparameter stellen eine Charakteristik-2-Kurve dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Implicit">
      <summary>Es werden keine Kurvendaten interpretiert. Es wird davon ausgegangen, dass der Aufrufer weiß, welche Kurve verwendet wird.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.Named">
      <summary>Die Kurvenparameter stellen eine benannte Kurve dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeMontgomery">
      <summary>Die Kurvenparameter stellen eine Primkurve mit der Formel B * y^2 = x^3 + A*x^2 + x dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeShortWeierstrass">
      <summary>Die Kurvenparameter stellen eine Primkurve mit der Formel y^2 = x^3 + A * x + B im Primfeld P dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECCurve.ECCurveType.PrimeTwistedEdwards">
      <summary>Die Kurvenparameter stellen eine Primkurve mit der Formel A*x^2 + y^2 = 1 + B*x^2*y^2 im Primfeld P dar.</summary>
    </member>
    <member name="T:System.Security.Cryptography.ECCurve.NamedCurves">
      <summary>Stellt eine Factoryklasse zum Erstellen benannter Kurven dar.</summary>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160r1">
      <summary>Ruft eine benannte brainpoolP160r1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP160r1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP160t1">
      <summary>Ruft eine benannte brainpoolP160t1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP160t1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192r1">
      <summary>Ruft eine benannte brainpoolP192r1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP192r1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP192t1">
      <summary>Ruft eine benannte brainpoolP192t1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP192t1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224r1">
      <summary>Ruft eine benannte brainpoolP224r1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP224r1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP224t1">
      <summary>Ruft eine benannte brainpoolP224t1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP224t1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256r1">
      <summary>Ruft eine benannte brainpoolP256r1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP256r1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP256t1">
      <summary>Ruft eine benannte brainpoolP256t1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP256t1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320r1">
      <summary>Ruft eine benannte brainpoolP320r1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP320r1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP320t1">
      <summary>Ruft eine benannte brainpoolP320t1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP320t1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384r1">
      <summary>Ruft eine benannte brainpoolP384r1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP384r1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP384t1">
      <summary>Ruft eine benannte brainpoolP384t1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP384t1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512r1">
      <summary>Ruft eine benannte brainpoolP512r1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP512r1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.brainpoolP512t1">
      <summary>Ruft eine benannte brainpoolP512t1-Kurve ab.</summary>
      <returns>Eine benannte brainpoolP512t1-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP256">
      <summary>Ruft eine benannte nistP256-Kurve ab.</summary>
      <returns>Eine benannte nistP256-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP384">
      <summary>Ruft eine benannte nistP384-Kurve ab.</summary>
      <returns>Eine benannte nistP384-Kurve.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECCurve.NamedCurves.nistP521">
      <summary>Ruft eine benannte nistP521-Kurve ab.</summary>
      <returns>Eine benannte nistP521-Kurve.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellman">
      <summary>Stellt eine abstrakte Basisklasse bereit, von der Implementierungen des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus abgeleitet werden können. Diese Klasse stellt einen grundlegenden Satz an Operationen bereit, den alle ECDH-Implementierungen unterstützen müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create">
      <summary>Erstellt eine neue Instanz der Standardimplementierung des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus.</summary>
      <returns>Eine neue Instanz der Standardimplementierung dieser Klasse.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
      <summary>Erstellt eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) mit einem neuen Paar aus öffentlichem und privatem Schlüssel, das über die angegebene Kurve generiert wurde.</summary>
      <param name="curve">Die Kurve, die für das Generieren eines neuen Paars aus privatem und öffentlichem Schlüssel verwendet wird.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> führt keine Validierung durch.</exception>
      <returns>Eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman).</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
      <summary>Erstellt eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) mit dem Schlüssel, der im angegebenen <see cref="T:System.Security.Cryptography.ECParameters" />-Objekt beschrieben wird.</summary>
      <param name="parameters">Die Parameter für den ECC-Algorithmus (Elliptic Curve Cryptography)</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> führt keine Validierung durch.</exception>
      <returns>Eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman).</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
      <summary>Erstellt eine neue Instanz der angegebenen Implementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman)</summary>
      <param name="algorithm">Der Name einer Implementierung des ECDH-Algorithmus.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="algorithm" />-Parameter ist <see langword="null" />.</exception>
      <returns>Eine neue Instanz der angegebenen Implementierung dieser Klasse. Wenn der angegebene Name des Algorithmus keiner ECDH-Implementierung zugeordnet ist, gibt diese Methode <see langword="null" /> zurück.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Führt die Schlüsselableitung mithilfe eines angegebenen Hashalgorithmus aus</summary>
      <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</param>
      <exception cref="T:System.ArgumentException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.

- oder -

Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.

- oder -

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</exception>
      <returns>Der Hash des gemeinsamen geheimen Schlüssels.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
      <summary>Führt die Schlüsselableitung bei der Implementierung in einer abgeleiteten Klasse mithilfe eines angegebenen Hashalgorithmus mit optionalen vorangestellten oder angefügten Daten aus.</summary>
      <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</param>
      <param name="secretPrepend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</param>
      <param name="secretAppend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <exception cref="T:System.ArgumentException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.

- oder -

Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.

- oder -

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</exception>
      <returns>Der Hash des gemeinsamen geheimen Schlüssels nach dem Voranstellen oder Anfügen von Daten wie angefordert.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Führt die Schlüsselableitung mithilfe eines angegebenen HMAC-Algorithmus (Hash-based Message Authentication Code, Hash-Nachrichtenauthentifizierungscode) aus.</summary>
      <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</param>
      <param name="hmacKey">Der Schlüssel für den HMAC.</param>
      <exception cref="T:System.ArgumentException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.

- oder -

Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.

- oder -

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</exception>
      <returns>Der HMAC des gemeinsamen geheimen Schlüssels.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
      <summary>Führt die Schlüsselableitung bei der Implementierung in einer abgeleiteten Klasse mithilfe eines angegebenen HMAC-Algorithmus (Hash-based Message Authentication Code, Hash-Nachrichtenauthentifizierungscode) mit optionalen vorangestellten oder angefügten Daten aus.</summary>
      <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</param>
      <param name="hmacKey">Der Schlüssel für den HMAC.</param>
      <param name="secretPrepend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</param>
      <param name="secretAppend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <exception cref="T:System.ArgumentException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.

- oder -

Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.

- oder -

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</exception>
      <returns>Der HMAC des gemeinsamen geheimen Schlüssels nach dem Voranstellen oder Anfügen von Daten wie angefordert.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
      <summary>Führt bei der Implementierung in einer abgeleiteten Klasse eine Schlüsselableitung für den gemeinsamen geheimen Schlüssel durch.</summary>
      <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
      <exception cref="T:System.ArgumentException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.

- oder -

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</exception>
      <returns>Das Ergebnis der Schlüsselableitungsfunktion, wobei der gemeinsame geheime Schlüssel als Eingabe verwendet wird.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
      <summary>Führt eine Schlüsselableitung bei der Implementierung in einer abgeleiteten Klasse mithilfe der Pseudozufallsfunktion von TLS 1.1 (Transport Layer Security) durch.</summary>
      <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
      <param name="prfLabel">Die ASCII-codierte PRF-Bezeichnung.</param>
      <param name="prfSeed">Der 64-Byte-PRF-Startwert.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <exception cref="T:System.ArgumentException">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherPartyPublicKey" />, <paramref name="prfLabel" /> oder <paramref name="prfSeed" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="prfSeed" /> ist nicht genau 64 Bytes lang.

- oder -

Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.

- oder -

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</exception>
      <returns>Die ersten 48 Bytes der Pseudozufallsfunktion von TLS 1.1, wobei der gemeinsame geheime Schlüssel als Schlüssel verwendet wird.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey">
      <summary>Exportiert den aktuellen Schlüssel im ECPrivateKey-Format.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>Ein Bytearray mit der ECPrivateKey-Darstellung dieses Schlüssels.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse Informationen zum öffentlichen oder zum öffentlichen und privaten Schlüssel unter Verwendung der expliziten Kurvenform aus einem verwendeten <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Schlüssel in eine <see cref="T:System.Security.Cryptography.ECParameters" />-Struktur, damit sie an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden können.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Ein Objekt, das unter Verwendung des expliziten Kurvenformats den Punkt auf der Kurve für diesen Schlüssel darstellt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse Informationen zum öffentlichen oder zum öffentlichen und privaten Schlüssel aus einem verwendeten <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Schlüssel in eine <see cref="T:System.Security.Cryptography.ECParameters" />-Struktur, damit sie an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden können.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, um private Parameter einzuschließen, oder <see langword="false" />, um nur die öffentlichen Parameter einzuschließen.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Ein Objekt, das den Punkt auf der Kurve für diesen Schlüssel darstellt. Es kann an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)">
      <summary>Diese Methode löst in allen Fällen aus.</summary>
      <param name="xmlString">Die XML-Zeichenfolge zur Wiederherstellung des <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekts.</param>
      <exception cref="T:System.NotImplementedException">In allen Fällen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>Generiert beim Überschreiben in einer abgeleiteten Klasse ein neues kurzlebiges Paar aus privatem und öffentlichem Schlüssel für die angegebene Kurve.</summary>
      <param name="curve">Die Kurve, die für das Generieren eines kurzlebigen Paars aus privatem und öffentlichem Schlüssel verwendet wird.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="curve" /> führt keine Validierung durch.</exception>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer ECPrivateKey-Struktur und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer ECPrivateKey-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-ECPrivateKey-Struktur dar.

- oder -

Fehler beim Schlüsselimport.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem bytebasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass die anzuwendende Schlüsselableitungsfunktion die Legacy-PKCS#12-KDF ist, die <see cref="T:System.Char" />-basierte Kennwörter erfordert.

- oder -

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem zeichenbasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen mit RFC 7468 PEM-codierten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des Schlüssels, der importiert werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält einen verschlüsselten PEM-codierten Schlüssel.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>Importiert beim Überschreiben in einer abgeleiteten Klasse die angegebenen Parameter für eine <see cref="T:System.Security.Cryptography.ECCurve" /> als einen kurzlebigen Schlüssel in das aktuelle <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Objekt.</summary>
      <param name="parameters">Die zu importierenden Parameter der Kurve.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> führt keine Validierung durch.</exception>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-PrivateKeyInfo-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer PKCS#8-PrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-PrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert den öffentlichen Schlüssel aus einer X.509-SubjectPublicKeyInfo-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer X.509-SubjectPublicKeyInfo-Struktur in der ASN.1-DER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-DER-codierte X.509-SubjectPublicKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)">
      <summary>Diese Methode löst in allen Fällen aus.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.NotImplementedException">In allen Fällen.</exception>
      <returns>Diese Methode gibt keinen Wert zurück.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im <see langword="ECPrivateKey" />-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, die die <see langword="ECPrivateKey" />-Daten empfangen soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem bytebasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Verschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.

- oder -

<paramref name="pbeParameters" /> gibt an, dass <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> verwendet werden soll, wofür <see cref="T:System.Char" />-basierte Kennwörter erforderlich sind.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem zeichenbasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="password">Das Kennwort, das bei der Verschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-PrivateKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die PKCS#8-PrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im X.509-SubjectPublicKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die X.509-SubjectPublicKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
      <summary>Ruft den Namen des Algorithmus für den Schlüsselaustausch ab.</summary>
      <returns>Der Name des Algorithmus für den Schlüsselaustausch.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.PublicKey">
      <summary>Ruft den öffentlichen Schlüssel ab, der von der aktuellen ECDH (Elliptic Curve Diffie-Hellman)-Instanz verwendet wird.</summary>
      <returns>Der öffentliche Teil des ECDH-Schlüsselpaares, der von dieser <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Instanz verwendet wird.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
      <summary>Ruft den Namen des Signaturalgorithmus ab.</summary>
      <returns>Immer <see langword="null" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDiffieHellmanPublicKey">
      <summary>Stellt eine abstrakte Basisklasse bereit, von der alle <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />-Implementierungen erben müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Klasse.</summary>
      <param name="keyBlob">Ein Bytearray, das ein <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Objekt darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="keyBlob" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose">
      <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose(System.Boolean)">
      <summary>Gibt die von der <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportExplicitParameters">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse die expliziten <see cref="T:System.Security.Cryptography.ECParameters" /> für ein <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt.</summary>
      <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Ein Objekt, das unter Verwendung des expliziten Kurvenformats den Punkt auf der Kurve für diesen Schlüssel darstellt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportParameters">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse die benannten oder expliziten <see cref="T:System.Security.Cryptography.ECParameters" /> für ein <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt.</summary>
      <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Ein Objekt, das den Punkt auf der Kurve für diesen Schlüssel darstellt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToByteArray">
      <summary>Serialisiert das <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Schlüssel-BLOB in ein Bytearray.</summary>
      <returns>Ein Bytearray, das den serialisierten öffentlichen ECDH (Elliptic Curve Diffie-Hellman)-Schlüssel enthält.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToXmlString">
      <summary>Serialisiert den öffentlichen <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Schlüssel in eine XML-Zeichenfolge.</summary>
      <returns>Eine XML-Zeichenfolge, die den serialisierten öffentlichen ECDH (Elliptic Curve Diffie-Hellman)-Schlüssel enthält.</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECDsa">
      <summary>Stellt eine abstrakte Basisklasse, die den ECDSA (Elliptic Curve Digital Signature Algorithm) kapselt.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDsa" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create">
      <summary>Erstellt eine neue Instanz der Standardimplementierung des ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
      <returns>Eine neue Instanz der Standardimplementierung (<see cref="T:System.Security.Cryptography.ECDsaCng" />) dieser Klasse.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECCurve)">
      <summary>Erstellt eine neue Instanz der ECDSA-Standardimplementierung (Elliptic Curve Digital Signature Algorithm) mit einem neu generierten Schlüssel über der angegebenen Kurve.</summary>
      <param name="curve">Die Kurve für die Schlüsselgenerierung.</param>
      <returns>Eine neue Instanz der Standardimplementierung (<see cref="T:System.Security.Cryptography.ECDsaCng" />) dieser Klasse.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECParameters)">
      <summary>Erstellt eine neue Instanz der ECDSA-Standardimplementierung (Elliptic Curve Digital Signature Algorithm) mit den angegebenen Parametern als Schlüssel.</summary>
      <param name="parameters">Die Parameter, die den zu verwendenden Schlüssel darstellen.</param>
      <returns>Eine neue Instanz der Standardimplementierung (<see cref="T:System.Security.Cryptography.ECDsaCng" />) dieser Klasse.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.Create(System.String)">
      <summary>Erstellt eine neue Instanz der angegebenen Implementierung des ECDSA (Elliptic Curve Digital Signature Algorithm).</summary>
      <param name="algorithm">Der Name einer ECDSA-Implementierung. Die folgenden Zeichenfolgen verweisen alle auf dieselbe Implementierung, bei der es sich um die einzige aktuell in .NET Framework unterstützte Implementierung handelt: 
- "ECDsa" 
- "ECDsaCng" 
- "System.Security.Cryptography.ECDsaCng" 
Sie können zudem den Namen einer benutzerdefinierten ECDSA-Implementierung bereitstellen.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="algorithm" />-Parameter ist <see langword="null" />.</exception>
      <returns>Eine neue Instanz der angegebenen Implementierung dieser Klasse. Wenn der angegebene Algorithmusname keiner ECDSA-Implementierung zugeordnet werden kann, gibt diese Methode <see langword="null" /> zurück.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportECPrivateKey">
      <summary>Exportiert den aktuellen Schlüssel im ECPrivateKey-Format.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>Ein Bytearray mit der ECPrivateKey-Darstellung dieses Schlüssels.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportExplicitParameters(System.Boolean)">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse die expliziten Parameter für eine elliptische Kurve.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Parameter, die unter Verwendung des expliziten Kurvenformats den Punkt auf der Kurve für diesen Schlüssel darstellen.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ExportParameters(System.Boolean)">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse die benannten oder expliziten Parameter für eine elliptische Kurve. Wenn die Kurve einen Namen hat, enthält das Feld <see cref="F:System.Security.Cryptography.ECParameters.Curve" /> benannte Kurvenparameter, andernfalls enthält sie explizite Parameter.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Parameter, die den Punkt auf der Kurve für diesen Schlüssel darstellen.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.FromXmlString(System.String)">
      <summary>Diese Methode löst in allen Fällen aus.</summary>
      <param name="xmlString">Die XML-Zeichenfolge zur Wiederherstellung des <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekts.</param>
      <exception cref="T:System.NotImplementedException">In allen Fällen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.GenerateKey(System.Security.Cryptography.ECCurve)">
      <summary>Generiert beim Überschreiben in einer abgeleiteten Klasse ein neues kurzlebiges Paar aus privatem und öffentlichem Schlüssel für die angegebene Kurve, wobei der aktuelle Schlüssel ersetzt wird</summary>
      <param name="curve">Die Kurve zum Generieren des Schlüssels.</param>
      <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)">
      <summary>Ruft die größte Größe (in Bytes) für eine Signatur ab, die von diesem Schlüssel im angegeben Format generiert wird.</summary>
      <param name="signatureFormat">Das Codierungsformat für eine Signatur.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <returns>Die größte Größe (in Bytes) für eine Signatur, die von diesem Schlüssel im angegeben Format generiert wird.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert des angegebenen Teils eines Bytearrays mithilfe des angegebenen Hashalgorithmus.</summary>
      <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
      <param name="offset">Der Index des ersten Bytes in <paramref name="data" />, für das der Hashwert berechnet werden soll.</param>
      <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert des angegebenen Binärdatenstroms mithilfe des angegebenen Hashalgorithmus.</summary>
      <param name="data">Der binäre Datenstrom, für den der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer ECPrivateKey-Struktur und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer ECPrivateKey-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-ECPrivateKey-Struktur dar.

- oder -

Fehler beim Schlüsselimport.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem bytebasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass die anzuwendende Schlüsselableitungsfunktion die Legacy-PKCS#12-KDF ist, die <see cref="T:System.Char" />-basierte Kennwörter erfordert.

- oder -

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem zeichenbasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 
Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen mit RFC 7468 PEM-codierten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des Schlüssels, der importiert werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.

- oder -

<paramref name="input" /> enthält einen verschlüsselten PEM-codierten Schlüssel.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportParameters(System.Security.Cryptography.ECParameters)">
      <summary>Importiert beim Überschreiben in einer abgeleiteten Klasse die angegebenen Parameter.</summary>
      <param name="parameters">Die Kurvenparameter.</param>
      <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-PrivateKeyInfo-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer PKCS#8-PrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-PrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert den öffentlichen Schlüssel aus einer X.509-SubjectPublicKeyInfo-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer X.509-SubjectPublicKeyInfo-Struktur in der ASN.1-DER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-DER-codierte X.509-SubjectPublicKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet den Hashwert eines Teils des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und signiert den sich ergebenden Hashwert.</summary>
      <param name="data">Die Eingabedaten, für die der Hashwert berechnet werden soll.</param>
      <param name="offset">Der Offset im Array, ab dem Daten verwendet werden sollen.</param>
      <param name="count">Die Anzahl der Bytes im Array, die als Daten verwendet werden sollen.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="offset">Der Offset in <paramref name="data" />, ab dem Hashing erfolgen soll.</param>
      <param name="count">Die Anzahl der aus <paramref name="data" /> zu lesenden Bytes.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.
 
- oder - 
 <paramref name="offset" /> ist kleiner als Null.
 
- oder - 
 <paramref name="count" /> ist kleiner als Null.
 
- oder - 
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet den Hashwert des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und signiert den resultierenden Hashwert.</summary>
      <param name="data">Die Eingabedaten, für die der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet den Hashwert des angegebenen Datenstroms mithilfe des angegebenen Hashalgorithmus und signiert den resultierenden Hashwert.</summary>
      <param name="data">Der Eingabedatenstrom, für den der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignDataCore(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignDataCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn unter Verwendung des angegebenen Signaturformats.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[])">
      <summary>Generiert eine digitale Signatur für den angegebenen Hashwert.</summary>
      <param name="hash">Der Hashwert der signierten Daten.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="hash" />-Parameter ist <see langword="null" />.</exception>
      <returns>Eine digitale Signatur für den angegebenen Hashwert.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet die ECDSA-Signatur für den angegebenen Hashwert im angegebenen Format.</summary>
      <param name="hash">Der zu signierende Hashwert.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.SignHashCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Berechnet die ECDSA-Signatur für den angegebenen Hashwert im angegebenen Format.</summary>
      <param name="hash">Der zu signierende Hashwert.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>Die ECDSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.ToXmlString(System.Boolean)">
      <summary>Diese Methode löst in allen Fällen aus.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.NotImplementedException">In allen Fällen.</exception>
      <returns>Diese Methode gibt keinen Wert zurück.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im ECPrivateKey-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, die die ECPrivateKey-Daten empfangen soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem bytebasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Verschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.

- oder -

<paramref name="pbeParameters" /> gibt an, dass <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> verwendet werden soll, wofür <see cref="T:System.Char" />-basierte Kennwörter erforderlich sind.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem zeichenbasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="password">Das Kennwort, das bei der Verschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-PrivateKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die PKCS#8-PrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im X.509-SubjectPublicKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die X.509-SubjectPublicKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Versucht, den Hashwert der angegebenen schreibgeschützten Spanne von Bytes in das angegebene Ziel unter Verwendung des angegebenen Hashalgorithmus zu berechnen.</summary>
      <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zum Empfangen des Hashwerts nicht lang genug ist.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Versucht, die digitale ECDSA-Signatur für die angegebene schreibgeschützte Spanne von Bytes in das angegebene Ziel unter Verwendung des angegebenen Hashalgorithmus und des aktuellen Schlüssels zu berechnen.</summary>
      <param name="data">Die zu signierenden Daten.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten zum Signieren verwendet werden soll</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zum Empfangen der Signatur nicht lang genug ist.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die ECDSA-Signatur für die angegebenen Daten im angegebenen Format im angegebenen Puffer zu erstellen.</summary>
      <param name="data">Die Daten, die gehasht und signiert werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignDataCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die ECDSA-Signatur für die angegebenen Daten im angegebenen Format im angegebenen Puffer zu erstellen.</summary>
      <param name="data">Die Daten, die gehasht und signiert werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die digitale ECDSA-Signatur für die angegebene schreibgeschützte Spanne von Bytes zu berechnen, die einen Datenhash in das angegebene Ziel darstellen, indem der aktuelle Schlüssel verwendet wird.</summary>
      <param name="hash">Der Hashwert der signierten Daten.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zum Empfangen der Signatur nicht lang genug ist.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die ECDSA-Signatur für den angegebenen Hashwert im angegebenen Format im angegebenen Puffer zu erstellen.</summary>
      <param name="hash">Der zu signierende Hashwert.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.TrySignHashCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)">
      <summary>Versucht, die ECDSA-Signatur für den angegebenen Hashwert im angegebenen Format im angegebenen Puffer zu erstellen.</summary>
      <param name="hash">Der zu signierende Hashwert.</param>
      <param name="destination">Der Puffer zum Empfangen der Signatur</param>
      <param name="signatureFormat">Das Codierungsformat, das für die Signatur verwendet werden soll.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Signaturvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Signatur zu empfangen, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur für den aktuellen Schlüssel und die bereitgestellten Daten mit einem angegebenen Hashalgorithmus geeignet ist</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur für den aktuellen Schlüssel und dem bereitgestellten Teil der Daten mit einem angegebenen Hashalgorithmus geeignet ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="offset">Der Startindex, an dem der Hashwert berechnet werden soll.</param>
      <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Ein Array, das die signierten Daten enthält.</param>
      <param name="offset">Der Startindex des signierten Teils von <paramref name="data" />.</param>
      <param name="count">Die Anzahl der Bytes in <paramref name="data" />, die signiert wurden.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.
 
- oder - 
 <paramref name="offset" /> ist kleiner als Null.
 
- oder - 
 <paramref name="count" /> ist kleiner als Null.
 
- oder - 
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur für den aktuellen Schlüssel und die bereitgestellten Daten mit einem angegebenen Hashalgorithmus geeignet ist</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" /> ist <see langword="null" /> oder weist einen leeren <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)">
      <summary>Überprüft, ob eine digitale Signatur für den aktuellen Schlüssel und die bereitgestellten Daten mit einem angegebenen Hashalgorithmus geeignet ist</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyDataCore(System.IO.Stream,System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyDataCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für die angegebenen Daten gültig ist.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der für den Hashwert der Daten für den Überprüfungsvorgang verwendet wird.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Hash- oder Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[])">
      <summary>Überprüft, ob eine digitale Signatur für den aktuellen Schlüssel und den bereitgestellten Datenhash geeignet ist.</summary>
      <param name="hash">Der Hashwert der zu überprüfenden Daten.</param>
      <param name="signature">Die digitale Signatur der Daten, die mit dem Hashwert überprüft werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für den bereitgestellten Hash gültig ist.</summary>
      <param name="hash">Der signierte Hash.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> oder <paramref name="signature" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Überprüft, ob eine digitale Signatur für den aktuellen Schlüssel und den bereitgestellten Datenhash geeignet ist.</summary>
      <param name="hash">Der Hashwert der zu überprüfenden Daten.</param>
      <param name="signature">Die digitale Signatur der Daten, die mit dem Hashwert überprüft werden sollen.</param>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für den bereitgestellten Hash gültig ist.</summary>
      <param name="hash">Der signierte Hash.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signatureFormat" /> weist kein bekanntes Format auf.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.ECDsa.VerifyHashCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)">
      <summary>Überprüft, ob eine digitale Signatur für den bereitgestellten Hash gültig ist.</summary>
      <param name="hash">Der signierte Hash.</param>
      <param name="signature">Die zu überprüfende Signatur.</param>
      <param name="signatureFormat">Das Codierungsformat für <paramref name="signature" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Überprüfungsvorgang ist ein Fehler aufgetreten.</exception>
      <returns>
        <see langword="true" />, wenn die digitale Signatur für die angegebenen Daten gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.KeyExchangeAlgorithm">
      <summary>Ruft den Namen des Algorithmus für den Schlüsselaustausch ab.</summary>
      <returns>Immer <see langword="null" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.ECDsa.SignatureAlgorithm">
      <summary>Ruft den Namen des Signaturalgorithmus ab.</summary>
      <returns>Die Zeichenfolge "ECDsa".</returns>
    </member>
    <member name="T:System.Security.Cryptography.ECParameters">
      <summary>Stellt die Standardparameter für den ECC-Algorithmus (Elliptic Curve Cryptography) dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Curve">
      <summary>Stellt die Kurve dar, die dem öffentlichen Schlüssel (<see cref="F:System.Security.Cryptography.ECParameters.Q" />) und dem optionalen privaten Schlüssel (<see cref="F:System.Security.Cryptography.ECParameters.D" />) zugeordnet ist.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.D">
      <summary>Stellt den privaten Schlüssel <see langword="D" /> für den ECC-Algorithmus (Elliptic Curve Cryptography) dar, der im Big-Endian-Format gespeichert wird.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECParameters.Q">
      <summary>Stellt den öffentlichen Schlüssel <see langword="Q" /> für den ECC-Algorithmus (Elliptic Curve Cryptography) dar.</summary>
    </member>
    <member name="M:System.Security.Cryptography.ECParameters.Validate">
      <summary>Überprüft das aktuelle Objekt.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Schlüssel- oder Kurvenparameter sind für den aktuellen Kurventyp ungültig.</exception>
    </member>
    <member name="T:System.Security.Cryptography.ECPoint">
      <summary>Stellt ein Koordinatenpaar (X, Y) für Strukturen der Kryptografie für elliptische Kurven (elliptic curve cryptography, ECC) dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.X">
      <summary>Stellt die X-Koordinate dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.ECPoint.Y">
      <summary>Stellt die Y-Koordinate dar.</summary>
    </member>
    <member name="T:System.Security.Cryptography.HKDF">
      <summary>RFC5869 HMAC-basierte HKDF (Extract-and-Expand Key Derivation)</summary>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.DeriveKey(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Int32,System.Byte[],System.Byte[])">
      <summary>Führt HKDF-Funktionen zum Erweitern und Extrahieren für die Schlüsselableitung aus.</summary>
      <param name="hashAlgorithmName">Der Hashalgorithmus, der für HMAC-Vorgänge verwendet wird.</param>
      <param name="ikm">Das Eingabe-Schlüsselerstellungsmaterial.</param>
      <param name="outputLength">Die Länge des Ausgabe-Schlüsselerstellungsmaterials.</param>
      <param name="salt">Der optionale Salt-Wert (ein nicht geheimer zufälliger Wert). Wenn keine Angabe erfolgt, wird standardmäßig ein Bytearray mit derselben Länge wie die Ausgabe des angegebenen Hashalgorithmus verwendet.</param>
      <param name="info">Der optionale Kontext und anwendungsspezifische Informationen.</param>
      <returns>Das Ausgabe-Schlüsselerstellungsmaterial.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.DeriveKey(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Führt HKDF-Funktionen zum Erweitern und Extrahieren für die Schlüsselableitung aus.</summary>
      <param name="hashAlgorithmName">Der Hashalgorithmus, der für HMAC-Vorgänge verwendet wird.</param>
      <param name="ikm">Das Eingabe-Schlüsselerstellungsmaterial.</param>
      <param name="output">Der Ausgabepuffer, der das Ausgabe-Schlüsselerstellungsmaterial darstellt.</param>
      <param name="salt">Der Salt-Wert (ein nicht geheimer zufälliger Wert).</param>
      <param name="info">Der Kontext und anwendungsspezifische Informationen (kann eine leere Spanne sein).</param>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Expand(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Int32,System.Byte[])">
      <summary>Führt die HKDF-Expand-Funktion aus (siehe Abschnitt  2.3 von RFC5869).</summary>
      <param name="hashAlgorithmName">Der Hashalgorithmus, der für HMAC-Vorgänge verwendet wird.</param>
      <param name="prk">Der Pseudozufallsschlüssel, der mindestens so lang ist wie das Ausgabebytearray des angegebenen Hashalgorithmus (in der Regel die Ausgabe aus dem Erweiterungsschritt).</param>
      <param name="outputLength">Die Länge des Ausgabe-Schlüsselerstellungsmaterials.</param>
      <param name="info">Der optionale Kontext und anwendungsspezifische Informationen.</param>
      <returns>Das Ausgabe-Schlüsselerstellungsmaterial.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Expand(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
      <summary>Führt die HKDF-Expand-Funktion aus. Weitere Informationen finden Sie im Abschnitt 2.3 von RFC5869.</summary>
      <param name="hashAlgorithmName">Der Hashalgorithmus, der für HMAC-Vorgänge verwendet wird.</param>
      <param name="prk">Der Pseudozufallsschlüssel, der mindestens so lang ist wie das Ausgabebytearray des angegebenen Hashalgorithmus (in der Regel die Ausgabe aus dem Erweiterungsschritt).</param>
      <param name="output">Der Zielpuffer, der das Ausgabe-Schlüsselerstellungsmaterial empfängt.</param>
      <param name="info">Der Kontext und anwendungsspezifische Informationen (kann eine leere Spanne sein).</param>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Extract(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
      <summary>Führt die HKDF-Extract-Funktion aus.
Weitere Informationen finden Sie im Abschnitt 2.2 von RFC5869.</summary>
      <param name="hashAlgorithmName">Der Hashalgorithmus, der für HMAC-Vorgänge verwendet wird.</param>
      <param name="ikm">Das Eingabe-Schlüsselerstellungsmaterial.</param>
      <param name="salt">Der optionale Salt-Wert (ein nicht geheimer zufälliger Wert). Wenn keine Angabe erfolgt, wird standardmäßig ein Bytearray mit derselben Länge wie die Ausgabe des angegebenen Hashalgorithmus verwendet.</param>
      <returns>Der Pseudozufallsschlüssel (prk).</returns>
    </member>
    <member name="M:System.Security.Cryptography.HKDF.Extract(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Führt die HKDF-Extract-Funktion aus.
Weitere Informationen finden Sie im Abschnitt 2.2 von RFC5869.</summary>
      <param name="hashAlgorithmName">Der Hashalgorithmus, der für HMAC-Vorgänge verwendet wird.</param>
      <param name="ikm">Das Eingabe-Schlüsselerstellungsmaterial.</param>
      <param name="salt">Der Salt-Wert (ein nicht geheimer zufälliger Wert).</param>
      <param name="prk">Der Zielpuffer, der den Pseudozufallsschlüssel (prk) empfängt.</param>
      <returns>Die Anzahl der in den <paramref name="prk" />-Puffer geschriebenen Bytes.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACMD5">
      <summary>Berechnet unter Verwendung der <see cref="T:System.Security.Cryptography.MD5" />-Hashfunktion einen Hash-Nachrichtenauthentifizierungscode (HMAC, Hash-based Message Authentication Code).</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACMD5" />-Klasse mit einem zufällig erzeugten Schlüssel.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACMD5" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Der geheime Schlüssel für die <see cref="T:System.Security.Cryptography.HMACMD5" />-Verschlüsselung. Der Schlüssel kann eine beliebige Länge aufweisen. Ab einer Länge von mehr als 64 Bytes wird jedoch unter Verwendung des SHA-1-Hashalgorithmus ein 64-Byte-Schlüssel aus ihm abgeleitet. Für den geheimen Schlüssel wird daher eine Größe von 64 Bytes empfohlen.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.Dispose(System.Boolean)">
      <summary>Gibt die von <see cref="T:System.Security.Cryptography.HMACMD5" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="rgb">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
      <param name="ib">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</param>
      <param name="cb">Die Anzahl der Bytes im Bytearray, die als Daten verwendet werden sollen.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="source">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.HashFinal">
      <summary>Schließt die HMAC-Berechnung ab, nachdem die letzten Daten vom Algorithmus verarbeitet wurden.</summary>
      <returns>Der berechnete HMAC-Wert in einem Bytearray.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.Initialize">
      <summary>Setzt den Hashalgorithmus auf seinen ursprünglichen Zustand zurück.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACMD5.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die HMAC-Berechnung abzuschließen, nachdem die letzten Daten vom HMAC-Algorithmus verarbeitet wurden.</summary>
      <param name="destination">Der Puffer, der den HMAC-Wert empfangen soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACMD5.Key">
      <summary>Ruft den Schlüssel für die HMAC-Berechnung ab oder legt diesen fest.</summary>
      <returns>Der Schlüssel, der bei der HMAC-Berechnung verwendet werden soll.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA1">
      <summary>Berechnet unter Verwendung der <see cref="T:System.Security.Cryptography.SHA1" />-Hashfunktion einen Hash-Nachrichtenauthentifizierungscode (HMAC, Hash-based Message Authentication Code).</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA1" />-Klasse mit einem zufällig erzeugten Schlüssel.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA1" />-Klasse mit den angegebenen Schlüsseldaten.</summary>
      <param name="key">Der geheime Schlüssel für die <see cref="T:System.Security.Cryptography.HMACSHA1" />-Verschlüsselung. Der Schlüssel kann eine beliebige Länge aufweisen. Ab einer Länge von mehr als 64 Bytes wird jedoch unter Verwendung des SHA-1-Hashalgorithmus ein 64-Byte-Schlüssel aus ihm abgeleitet. Für den geheimen Schlüssel wird daher eine Größe von 64 Bytes empfohlen.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA1" />-Klasse mit den angegebenen Schlüsseldaten und einem Wert, der angibt, ob die verwaltete Version des SHA1-Algorithmus verwendet werden soll.</summary>
      <param name="key">Der geheime Schlüssel für die <see cref="T:System.Security.Cryptography.HMACSHA1" />-Verschlüsselung. Der Schlüssel kann eine beliebige Länge aufweisen. Ab einer Länge von mehr als 64 Bytes wird jedoch unter Verwendung des SHA-1-Hashalgorithmus ein 64-Byte-Schlüssel aus ihm abgeleitet. Für den geheimen Schlüssel wird daher eine Größe von 64 Bytes empfohlen.</param>
      <param name="useManagedSha1">
        <see langword="true" />, um die verwaltete Implementierung des SHA1-Algorithmus zu verwenden (die <see cref="T:System.Security.Cryptography.SHA1Managed" />-Klasse), <see langword="false" />, um die nicht verwaltete Implementierung zu verwenden (die <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />-Klasse).</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.Dispose(System.Boolean)">
      <summary>Dieser Member überschreibt <see cref="M:System.Security.Cryptography.KeyedHashAlgorithm.Dispose(System.Boolean)" />. Das zugehörige Thema enthält möglicherweise eine umfassendere Dokumentation.

Gibt die von <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, wenn sowohl verwaltete als auch nicht verwaltete Ressourcen freigegeben werden sollen. FALSE, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Leitet die in das Objekt geschriebenen Daten in den SHA1-Hashalgorithmus zum Berechnen von hashbasiertem Nachrichtenauthentifizierungscode weiter.</summary>
      <param name="rgb">Die Eingabedaten.</param>
      <param name="ib">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</param>
      <param name="cb">Die Anzahl der Bytes im Array, die als Daten verwendet werden sollen.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="source">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.HashFinal">
      <summary>Schließt die HMAC-Berechnung ab, nachdem die letzten Daten vom Algorithmus verarbeitet wurden.</summary>
      <returns>Der berechnete HMAC-Wert in einem Bytearray.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.Initialize">
      <summary>Setzt den Hashalgorithmus auf seinen ursprünglichen Zustand zurück.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA1.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die HMAC-Berechnung abzuschließen, nachdem die letzten Daten vom HMAC-Algorithmus verarbeitet wurden.</summary>
      <param name="destination">Der Puffer, der den HMAC-Wert empfangen soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA1.Key">
      <summary>Ruft den im Hashalgorithmus zu verwendenden Schlüssel ab oder legt diesen fest.</summary>
      <returns>Der im Hashalgorithmus zu verwendende Schlüssel.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA256">
      <summary>Berechnet unter Verwendung der <see cref="T:System.Security.Cryptography.SHA256" />-Hashfunktion einen Hash-Nachrichtenauthentifizierungscode (HMAC, Hash-based Message Authentication Code).</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA256" />-Klasse mit einem zufällig erzeugten Schlüssel.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA256" />-Klasse mit den angegebenen Schlüsseldaten.</summary>
      <param name="key">Der geheime Schlüssel für die <see cref="T:System.Security.Cryptography.HMACSHA256" />-Verschlüsselung. Der Schlüssel kann eine beliebige Länge aufweisen. Allerdings ist die empfohlene Größe 64 Bytes. Wenn der Schlüssel eine Länge von mehr als 64 Byte aufweist, wird aus ihm jedoch unter Verwendung des SHA-256-Hashalgorithmus ein 64-Byte-Schlüssel abgeleitet. Wenn kleiner als 64 Byte lang, wird sie auf 64 Byte aufgefüllt.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.Dispose(System.Boolean)">
      <summary>Gibt die von <see cref="T:System.Security.Cryptography.HMACSHA256" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="rgb">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
      <param name="ib">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</param>
      <param name="cb">Die Anzahl der Bytes im Bytearray, die als Daten verwendet werden sollen.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="source">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.HashFinal">
      <summary>Schließt die HMAC-Berechnung ab, nachdem die letzten Daten vom Algorithmus verarbeitet wurden.</summary>
      <returns>Der berechnete HMAC-Wert in einem Bytearray.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.Initialize">
      <summary>Setzt den Hashalgorithmus auf seinen ursprünglichen Zustand zurück.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA256.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die HMAC-Berechnung abzuschließen, nachdem die letzten Daten vom HMAC-Algorithmus verarbeitet wurden.</summary>
      <param name="destination">Der Puffer, der den HMAC-Wert empfangen soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA256.Key">
      <summary>Ruft den Schlüssel für die HMAC-Berechnung ab oder legt diesen fest.</summary>
      <returns>Der Schlüssel, der bei der HMAC-Berechnung verwendet werden soll.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA384">
      <summary>Berechnet unter Verwendung der <see cref="T:System.Security.Cryptography.SHA384" />-Hashfunktion einen Hash-Nachrichtenauthentifizierungscode (HMAC, Hash-based Message Authentication Code).</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA384" />-Klasse mit einem zufällig erzeugten Schlüssel.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA384" />-Klasse unter Verwendung der angegebenen Schlüsseldaten.</summary>
      <param name="key">Der geheime Schlüssel für die <see cref="T:System.Security.Cryptography.HMACSHA384" />-Verschlüsselung. Der Schlüssel kann eine beliebige Länge aufweisen. Allerdings ist die empfohlene Größe 128 Bytes. Wenn der Schlüssel eine Länge von mehr als 128 Byte aufweist, wird aus ihm jedoch unter Verwendung des SHA-384-Hashalgorithmus ein 128-Byte-Schlüssel abgeleitet. Wenn kürzer als 128 Byte, wird sie auf 128 Byte aufgefüllt.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.Dispose(System.Boolean)">
      <summary>Gibt die von <see cref="T:System.Security.Cryptography.HMACSHA384" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="rgb">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
      <param name="ib">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</param>
      <param name="cb">Die Anzahl der Bytes im Bytearray, die als Daten verwendet werden sollen.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="source">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.HashFinal">
      <summary>Schließt die HMAC-Berechnung ab, nachdem die letzten Daten vom Algorithmus verarbeitet wurden.</summary>
      <returns>Der berechnete HMAC-Wert in einem Bytearray.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.Initialize">
      <summary>Setzt den Hashalgorithmus auf seinen ursprünglichen Zustand zurück.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA384.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die HMAC-Berechnung abzuschließen, nachdem die letzten Daten vom HMAC-Algorithmus verarbeitet wurden.</summary>
      <param name="destination">Der Puffer, der den HMAC-Wert empfangen soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA384.Key">
      <summary>Ruft den Schlüssel für die HMAC-Berechnung ab oder legt diesen fest.</summary>
      <returns>Der Schlüssel, der bei der HMAC-Berechnung verwendet werden soll.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA384.ProduceLegacyHmacValues">
      <summary>Stellt eine Methode zur Umgehung des Problems mit der .NET Framework 2.0-Implementierung des <see cref="T:System.Security.Cryptography.HMACSHA384" />-Algorithmus bereit, die mit der .NET Framework 2.0 Service Pack 1-Implementierung des Algorithmus nicht übereinstimmt.</summary>
      <returns>
        <see langword="true" />, um .NET Framework 2.0 Service Pack 1-Anwendungen für die Interaktion mit .NET Framework 2.0-Anwendungen zu aktivieren; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.HMACSHA512">
      <summary>Berechnet unter Verwendung der <see cref="T:System.Security.Cryptography.SHA512" />-Hashfunktion einen Hash-Nachrichtenauthentifizierungscode (HMAC, Hash-based Message Authentication Code).</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA512" />-Klasse mit einem zufällig erzeugten Schlüssel.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.#ctor(System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA512" />-Klasse mit den angegebenen Schlüsseldaten.</summary>
      <param name="key">Der geheime Schlüssel für die <see cref="T:System.Security.Cryptography.HMACSHA512" />-Verschlüsselung. Der Schlüssel kann eine beliebige Länge aufweisen. Allerdings ist die empfohlene Größe 128 Bytes. Wenn der Schlüssel eine Länge von mehr als 128 Byte aufweist, wird aus ihm jedoch unter Verwendung des SHA-512-Hashalgorithmus ein 128-Byte-Schlüssel abgeleitet. Wenn kürzer als 128 Byte, wird sie auf 128 Byte aufgefüllt.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.Dispose(System.Boolean)">
      <summary>Gibt die von <see cref="T:System.Security.Cryptography.HMACSHA512" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="rgb">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
      <param name="ib">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</param>
      <param name="cb">Die Anzahl der Bytes im Bytearray, die als Daten verwendet werden sollen.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashCore(System.ReadOnlySpan{System.Byte})">
      <summary>Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</summary>
      <param name="source">Die Eingabe, für die der HMAC-Wert berechnet wird.</param>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.HashFinal">
      <summary>Schließt die HMAC-Berechnung ab, nachdem die letzten Daten vom Algorithmus verarbeitet wurden.</summary>
      <returns>Der berechnete HMAC-Wert in einem Bytearray.</returns>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.Initialize">
      <summary>Setzt den Hashalgorithmus auf seinen ursprünglichen Zustand zurück.</summary>
    </member>
    <member name="M:System.Security.Cryptography.HMACSHA512.TryHashFinal(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die HMAC-Berechnung abzuschließen, nachdem die letzten Daten vom HMAC-Algorithmus verarbeitet wurden.</summary>
      <param name="destination">Der Puffer, der den HMAC-Wert empfangen soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA512.Key">
      <summary>Ruft den Schlüssel für die HMAC-Berechnung ab oder legt diesen fest.</summary>
      <returns>Der Schlüssel, der bei der HMAC-Berechnung verwendet werden soll.</returns>
    </member>
    <member name="P:System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues">
      <summary>Stellt eine Methode zur Umgehung des Problems mit der .NET Framework 2.0-Implementierung des <see cref="T:System.Security.Cryptography.HMACSHA512" />-Algorithmus bereit, die mit der .NET Framework 2.0 Service Pack 1-Implementierung nicht übereinstimmt.</summary>
      <returns>
        <see langword="true" />, um .NET Framework 2.0 Service Pack 1-Anwendungen für die Interaktion mit .NET Framework 2.0-Anwendungen zu aktivieren; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.IncrementalHash">
      <summary>Stellt Unterstützung für die Berechnung eines Hash- oder eines auf einem Hash basierenden HMAC-Werts (Hash-based Message Authentication Code) inkrementell über mehrere Segmente hinweg bereit.</summary>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
      <summary>Fügt die angegebenen Daten den Daten hinzu, die bereits im Hash oder HMAC verarbeitet wurden.</summary>
      <param name="data">Die zu verarbeitenden Daten.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Security.Cryptography.IncrementalHash" />-Objekt wurde bereits entfernt.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
      <summary>Fügt die angegebene Zahl an Bytes aus den angegebenen Daten in die bereits verarbeiteten im Hash oder HMAC (Hash-basierter Nachrichtenauthentifizierungscode) ein, beginnend mit dem angegebenen Offset.</summary>
      <param name="data">Die zu verarbeitenden Daten.</param>
      <param name="offset">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</param>
      <param name="count">Die Anzahl der Bytes, die aus <paramref name="data" /> verwendet werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> oder <paramref name="offset" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="count" /> ist größer als <paramref name="data" /> lang ist.</exception>
      <exception cref="T:System.ArgumentException">Die Summe aus <paramref name="offset" /> und <paramref name="count" /> ist größer als die Datenlänge.</exception>
      <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Security.Cryptography.IncrementalHash" />-Objekt wurde bereits entfernt.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})">
      <summary>Fügt die angegebenen Daten den Daten hinzu, die bereits im Hash oder HMAC (hashbasierter Nachrichtenauthentifizierungscode) verarbeitet wurden.</summary>
      <param name="data">Die zu verarbeitenden Daten.</param>
      <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Security.Cryptography.IncrementalHash" />-Objekt wurde bereits entfernt.</exception>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Erstellt einen <see cref="T:System.Security.Cryptography.IncrementalHash" /> für den angegebenen Algorithmus.</summary>
      <param name="hashAlgorithm">Der Name des Hashalgorithmus, der ausgeführt werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> ist kein bekannter Hashalgorithmus.</exception>
      <returns>Ein <see cref="T:System.Security.Cryptography.IncrementalHash" />-Instanz, die bereit ist, den von <paramref name="hashAlgorithm" /> angegebenen Hashalgorithmus zu berechnen.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
      <summary>Erstellt <see cref="T:System.Security.Cryptography.IncrementalHash" /> für den Algorithmus des hashbasierten Nachrichtenauthentifizierungscodes (HMAC, Hash-based Message Authentication Code) mithilfe des angegebenen Hashalgorithmus und Schlüssels.</summary>
      <param name="hashAlgorithm">Der Name des Hashalgorithmus, der im HMAC ausgeführt werden soll.</param>
      <param name="key">Der geheime Schlüssel für den HMAC. Der Schlüssel kann von beliebiger Länge sein, doch ein Schlüssel, der länger als die Ausgabegröße des angegebenen Hashalgorithmus ist, wird mit eindeutigem Hashwert berechnet, um den Schlüssel mit richtiger Größe abzuleiten. Daher ist die empfohlene Größe des geheimen Schlüssels die Ausgabegröße des angegebenen Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> ist kein bekannter Hashalgorithmus.</exception>
      <returns>Eine Instanz der <see cref="T:System.Security.Cryptography.IncrementalHash" />-Klasse, die den angegebenen Hashalgorithmus berechnen kann.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.ReadOnlySpan{System.Byte})">
      <summary>Es wird ein <see cref="T:System.Security.Cryptography.IncrementalHash" /> für den Algorithmus des hashbasierten Nachrichtenauthentifizierungscodes (HMAC, Hash-based Message Authentication Code) mithilfe des durch <paramref name="hashAlgorithm" /> angegebenen Hashalgorithmus und eines durch <paramref name="key" /> angegebenen Schlüssels erstellt.</summary>
      <param name="hashAlgorithm">Der Name des Hashalgorithmus, der im HMAC ausgeführt werden soll.</param>
      <param name="key">Der geheime Schlüssel für den HMAC. Der Schlüssel kann von beliebiger Länge sein, doch ein Schlüssel, der länger als die Ausgabegröße des durch <paramref name="hashAlgorithm" /> angegebenen Hashalgorithmus ist, wird (unter Verwendung des durch <paramref name="hashAlgorithm" /> angegebenen Algorithmus) mit eindeutigem Hashwert berechnet, um einen Schlüssel mit richtiger Größe abzuleiten. Daher ist die empfohlene Größe des geheimen Schlüssels die Ausgabegröße des von <paramref name="hashAlgorithm" /> angegebenen Hashwerts.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder die leere Zeichenfolge.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="hashAlgorithm" /> ist kein bekannter Hashalgorithmus.</exception>
      <returns>Dies ist eine Hashinstanz, die den von <paramref name="hashAlgorithm" /> angegebenen Hashalgorithmus berechnen soll.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.Dispose">
      <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Security.Cryptography.IncrementalHash" />-Klasse verwendeten Ressourcen frei.</summary>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetCurrentHash">
      <summary>Ruft den Hash oder HMAC (Hash-based Message Authentication Code) für die Daten ab, die von früheren Aufrufen der <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" />-Methoden gesammelt wurden, ohne das Objekt auf seinen ursprünglichen Zustand zurückzusetzen.</summary>
      <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits verworfen.</exception>
      <returns>Der berechnete Hash oder HMAC.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetCurrentHash(System.Span{System.Byte})">
      <summary>Ruft den Hash oder HMAC (Hash-based Message Authentication Code) für die Daten ab, die von früheren Aufrufen der <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" />-Methoden gesammelt wurden, ohne das Objekt auf seinen ursprünglichen Zustand zurückzusetzen.</summary>
      <param name="destination">Der Puffer, der den Hash- oder HMAC-Wert empfangen soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="destination" /> weist einen <see cref="P:System.Span`1.Length" />-Wert auf, der kleiner als <see cref="P:System.Security.Cryptography.IncrementalHash.HashLengthInBytes" /> ist.</exception>
      <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits verworfen.</exception>
      <returns>Die Anzahl der Bytes, die in <paramref name="destination" /> geschrieben wurden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
      <summary>Ruft den Hash oder HMAC für die Daten ab, die von früheren Aufrufen der <see cref="Overload:System.Security.Cryptography.IncrementalHash.AppendData" />-Methoden gesammelt wurden, und setzt das Objekt auf seinen ursprünglichen Zustand zurück.</summary>
      <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Security.Cryptography.IncrementalHash" />-Objekt wurde bereits entfernt.</exception>
      <returns>Der berechnete Hash oder HMAC.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset(System.Span{System.Byte})">
      <summary>Ruft den Hash oder HMAC (Hash-based Message Authentication Code) für die Daten ab, die von früheren Aufrufen der <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" />-Methoden gesammelt wurden, und setzt das Objekt auf seinen ursprünglichen Zustand zurück.</summary>
      <param name="destination">Der Puffer, der den Hash- oder HMAC-Wert empfangen soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="destination" /> weist einen <see cref="P:System.Span`1.Length" />-Wert auf, der kleiner als <see cref="P:System.Security.Cryptography.IncrementalHash.HashLengthInBytes" /> ist.</exception>
      <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits verworfen.</exception>
      <returns>Die Anzahl der Bytes, die in <paramref name="destination" /> geschrieben wurden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.TryGetCurrentHash(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den Hash oder HMAC (Hash-based Message Authentication Code) für die Daten abzurufen, die von früheren Aufrufen der <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.ReadOnlySpan{System.Byte})" />-Methoden gesammelt wurden, ohne das Objekt auf seinen ursprünglichen Zustand zurückzusetzen.</summary>
      <param name="destination">Der Puffer, der den Hash- oder HMAC-Wert empfangen soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.
Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits verworfen.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des Hash- oder HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.IncrementalHash.TryGetHashAndReset(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, die Hashberechnung abzuschließen, nachdem die letzten Daten vom Hashalgorithmus verarbeitet wurden.</summary>
      <param name="destination">Der Puffer, der den Hash- oder HMAC-Wert empfangen soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Security.Cryptography.IncrementalHash" />-Objekt wurde bereits entfernt.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des Hash- oder HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
      <summary>Ruft den Namen des Algorithmus ab, der ausgeführt wird. HMAC-Algorithmen wird „HMAC“ vorangestellt, um sie von einem unverschlüsselten Digest zu unterscheiden.</summary>
      <returns>Der Name des Algorithmus, der ausgeführt wird.</returns>
    </member>
    <member name="P:System.Security.Cryptography.IncrementalHash.HashLengthInBytes">
      <summary>Ruft die Ausgabegröße dieses Hash- oder HMAC-Algorithmus in Bytes ab.</summary>
      <returns>Die Ausgabegröße dieses Hash-oder HMAC-Algorithmus in Bytes.</returns>
    </member>
    <member name="T:System.Security.Cryptography.MaskGenerationMethod">
      <summary>Stellt die abstrakte Klasse dar, von der alle Algorithmen zur Generierung von Masken abgeleitet werden müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.MaskGenerationMethod" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>Generiert beim Überschreiben in einer abgeleiteten Klasse eine Maske mit der angegebenen Länge unter Verwendung des angegebenen zufälligen Startwerts.</summary>
      <param name="rgbSeed">Der zufällige Startwert zum Berechnen der Maske.</param>
      <param name="cbReturn">Die Länge der generierten Maske in Bytes.</param>
      <returns>Eine zufällig generierte Maske, deren Länge dem <paramref name="cbReturn" />-Parameter entspricht.</returns>
    </member>
    <member name="T:System.Security.Cryptography.MD5">
      <summary>Stellt die abstrakte Klasse dar, von der alle Implementierungen des <see cref="T:System.Security.Cryptography.MD5" />-Hashalgorithmus vererbt werden.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.MD5" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create">
      <summary>Erstellt eine Instanz der Standardimplementierung des <see cref="T:System.Security.Cryptography.MD5" />-Hashalgorithmus.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">Der Algorithmus wurde bei aktiviertem FIPS (Federal Information Processing Standards)-Modus verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz des <see cref="T:System.Security.Cryptography.MD5" />-Hashalgorithmus.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.Create(System.String)">
      <summary>Erstellt eine Instanz der angegebenen Implementierung des <see cref="T:System.Security.Cryptography.MD5" />-Hashalgorithmus.</summary>
      <param name="algName">Der Name der spezifischen Implementierung von <see cref="T:System.Security.Cryptography.MD5" />, die verwendet werden soll.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">Der durch den <paramref name="algName" />-Parameter beschriebene Algorithmus wurde bei aktiviertem FIPS-Modus (Federal Information Processing Standards) verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.MD5" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.HashData(System.Byte[])">
      <summary>Berechnet den Datenhash mithilfe des MD5-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des MD5-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des MD5-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <exception cref="T:System.ArgumentException">Der Puffer in <paramref name="destination" /> ist zu klein, um die berechnete Hashgröße zu speichern. Der MD5-Algorithmus erzeugt immer einen 128-Bit-Hash oder 16 Bytes.</exception>
      <returns>Die Gesamtanzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.MD5.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den Datenhash mithilfe des MD5-Algorithmus zu berechnen.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zu klein ist, um den berechneten Hash zu speichern, andernfalls <see langword="true" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.PKCS1MaskGenerationMethod">
      <summary>Berechnet Masken für Schlüsselaustauschalgorithmen anhand von PKCS #1.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PKCS1MaskGenerationMethod" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.PKCS1MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)">
      <summary>Generiert eine Maske aus dem angegebenen Zufallsstartwert der angegebenen Länge und gibt diese Maske zurück.</summary>
      <param name="rgbSeed">Der Zufallsstartwert zum Berechnen der Maske.</param>
      <param name="cbReturn">Die Länge der generierten Maske in Bytes.</param>
      <returns>Eine zufällig generierte Maske, deren Länge dem <paramref name="cbReturn" />-Parameter entspricht.</returns>
    </member>
    <member name="P:System.Security.Cryptography.PKCS1MaskGenerationMethod.HashName">
      <summary>Ruft den Namen des Hashalgorithmustyps ab, der zum Generieren der Maske verwendet werden soll, oder legt diesen Namen fest.</summary>
      <returns>Der Name des Typs, der den Hashalgorithmus implementiert, mit dem die Maske berechnet werden soll.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RandomNumberGenerator">
      <summary>Stellt die abstrakte Klasse dar, von der alle Implementierungen von Zufallszahlen-Generatoren für die Kryptographie abgeleitet werden.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create">
      <summary>Erstellt eine Instanz der Standardimplementierung eines Kryptographie-Zufallszahlen-Generators, der zum Generieren von Zufallsdaten verwendet werden kann.</summary>
      <returns>Eine neue Instanz eines Kryptografie-Zufallszahlen-Generators.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Create(System.String)">
      <summary>Erstellt eine Instanz der angegebenen Implementierung eines Kryptografie-Zufallszahlen-Generators.</summary>
      <param name="rngName">Der Name der zu verwendenden Implementierung des Zufallszahlen-Generators.</param>
      <returns>Eine neue Instanz eines Kryptografie-Zufallszahlen-Generators.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose">
      <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse alle Ressourcen frei, die von der aktuellen Instanz der <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />-Klasse verwendet werden.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Dispose(System.Boolean)">
      <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse die von <see cref="T:System.Security.Cryptography.RandomNumberGenerator" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.Fill(System.Span{System.Byte})">
      <summary>Füllt einen Bereich mit kryptographisch starken, zufälligen Bytes.</summary>
      <param name="data">Der mit kryptographisch starken, zufälligen Bytes auszufüllende Bereich.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[])">
      <summary>Füllt beim Überschreiben in einer abgeleiteten Klasse ein Bytearray mit einer kryptographisch starken Zufallsfolge von Werten.</summary>
      <param name="data">Das mit kryptographisch starken, zufälligen Bytes auszufüllende Array.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>Füllt das angegebene Bytearray mit einer kryptografisch starken Folge zufälliger Werte aus.</summary>
      <param name="data">Das mit kryptographisch starken, zufälligen Bytes auszufüllende Array.</param>
      <param name="offset">Der Index des Arrays, an dem der Füllvorgang beginnen soll.</param>
      <param name="count">Die Anzahl der zu füllenden Bytes.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> oder <paramref name="count" /> ist kleiner als 0 (null)</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="offset" /> plus <paramref name="count" /> überschreitet den Wert von <paramref name="data" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Span{System.Byte})">
      <summary>Füllt einen Bereich mit kryptographisch starken, zufälligen Bytes.</summary>
      <param name="data">Der mit kryptographisch starken, zufälligen Bytes auszufüllende Bereich.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32)">
      <summary>Generiert einen zufälligen Integerwert zwischen 0 (einschließlich) und einer angegebenen oberen Grenze (ausschließlich) mithilfe eines kryptografisch starken Zufallszahlengenerators.</summary>
      <param name="toExclusive">Die obere Grenze (ausschließlich) des Zufallsbereichs.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="toExclusive" />-Parameter ist kleiner oder gleich 0.</exception>
      <returns>Ein zufälliger Integerwert zwischen 0 (einschließlich) und <paramref name="toExclusive" /> (ausschließlich).</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32,System.Int32)">
      <summary>Generiert einen zufälligen Integerwert zwischen einer angegebenen unteren Grenze (einschließlich) und einer angegebenen oberen Grenze (ausschließlich) mithilfe eines kryptografisch starken Zufallszahlengenerators.</summary>
      <param name="fromInclusive">Die untere Grenze (einschließlich) des Zufallsbereichs.</param>
      <param name="toExclusive">Die obere Grenze (ausschließlich) des Zufallsbereichs.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="toExclusive" />-Parameter ist kleiner als oder gleich dem <paramref name="fromInclusive" />-Parameter.</exception>
      <returns>Ein zufälliger Integerwert zwischen <paramref name="fromInclusive" /> (einschließlich) und <paramref name="toExclusive" /> (ausschließlich).</returns>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Byte[])">
      <summary>Füllt beim Überschreiben in einer abgeleiteten Klasse ein Bytearray mit einer kryptographisch starken Zufallsfolge von Werten, die ungleich 0 sind.</summary>
      <param name="data">Das mit kryptographisch starken, zufälligen Bytes ungleich 0 auszufüllende Array.</param>
    </member>
    <member name="M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Span{System.Byte})">
      <summary>Füllt einen Bytebereich mit einer kryptografisch starken, zufälligen Folge von Werten ungleich NULL aus.</summary>
      <param name="data">Der mit kryptographisch starken, zufälligen Bytes ungleich NULL auszufüllende Bereich.</param>
    </member>
    <member name="T:System.Security.Cryptography.RC2">
      <summary>Stellt die Basisklasse dar, von der alle Implementierungen des <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus abgeleitet werden müssen.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RC2.EffectiveKeySizeValue">
      <summary>Stellt die effektive Größe des geheimen Schlüssels für den <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus in Bits dar.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.RC2" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create">
      <summary>Erstellt eine Instanz eines Kryptografieobjekts, um den <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus auszuführen.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">Der Algorithmus wurde bei aktiviertem FIPS (Federal Information Processing Standards)-Modus verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine Instanz eines Kryptografieobjekts.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RC2.Create(System.String)">
      <summary>Erstellt eine Instanz eines Kryptografieobjekts, um die angegebene Implementierung des <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus auszuführen.</summary>
      <param name="AlgName">Der Name der spezifischen Implementierung von <see cref="T:System.Security.Cryptography.RC2" />, die verwendet werden soll.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">Der durch den <paramref name="algName" />-Parameter beschriebene Algorithmus wurde bei aktiviertem FIPS-Modus (Federal Information Processing Standards) verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine Instanz eines Kryptografieobjekts.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RC2.EffectiveKeySize">
      <summary>Ruft die effektive Größe des geheimen Schlüssels für den <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus in Bits ab oder legt diese fest.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die effektive Größe des Schlüssels ist ungültig.</exception>
      <returns>Die effektive Größe des Schlüssels des <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RC2.KeySize">
      <summary>Ruft die Größe des geheimen Schlüssels für den <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus in Bit ab oder legt diesen fest.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Wert für die RC2-Schlüsselgröße ist kleiner als der Wert für die effektive Schlüsselgröße.</exception>
      <returns>Die Größe des geheimen Schlüssels für den <see cref="T:System.Security.Cryptography.RC2" />-Algorithmus.</returns>
    </member>
    <member name="T:System.Security.Cryptography.Rfc2898DeriveBytes">
      <summary>Implementiert mithilfe eines auf <see cref="T:System.Security.Cryptography.HMACSHA1" /> basierenden Generators für Pseudozufallszahlen die kennwortbasierte Schlüsselableitungsfunktion PBKDF2.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, der Salt und der Anzahl an Iterationen zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="salt">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</param>
      <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
      <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
      <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Salt, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
      <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> ist kleiner als Null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Hashalgorithmusname ist ungültig.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts und des Salts zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="salt">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</param>
      <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
      <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, der Salt und der Anzahl an Iterationen zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="salt">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</param>
      <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
      <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
      <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Salt, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
      <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Hashalgorithmusname ist ungültig.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts und der Saltgröße zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="saltSize">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</param>
      <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes.</exception>
      <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, einer Saltgröße und der Anzahl an Iterationen zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="saltSize">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</param>
      <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
      <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
      <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iterations" /> liegt außerhalb des Bereichs. Für diesen Parameter ist eine nicht negative Zahl erforderlich.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Saltgröße, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</summary>
      <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
      <param name="saltSize">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</param>
      <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="saltSize" /> ist kleiner als Null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Hashalgorithmusname ist ungültig.</exception>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
      <summary>Leitet einen kryptografischen Schlüssel vom <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Objekt ab.</summary>
      <param name="algname">Der Name des Algorithmus, für den der Schlüssel abgeleitet werden soll.</param>
      <param name="alghashname">Der Name des Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
      <param name="keySize">Die Größe des abzuleitenden Schlüssels in Bits.</param>
      <param name="rgbIV">Der zum Ableiten des Schlüssels zu verwendende Initialisierungsvektor.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der <paramref name="keySize" />-Parameter ist ungültig.  
  
- oder - 
Der Kryptografiedienstanbieter (Cryptographic Service Provider, CSP) kann nicht abgerufen werden.  
  
- oder - 
Der <paramref name="algname" />-Parameter ist kein gültiger Algorithmusname.  
  
- oder - 
Der <paramref name="alghashname" />-Parameter ist kein gültiger Name eines Hashalgorithmus.</exception>
      <returns>Der abgeleitete Schlüssel.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
      <summary>Gibt die von der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</summary>
      <param name="disposing">
        <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
      <summary>Gibt den pseudozufälligen Schlüssel für dieses Objekt zurück.</summary>
      <param name="cb">Die Anzahl der zu generierenden pseudozufälligen Schlüsselbytes.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="cb" /> liegt außerhalb des Bereichs. Für diesen Parameter ist eine nicht negative Zahl erforderlich.</exception>
      <returns>Ein mit pseudozufälligen Schlüsselbytes gefülltes Bytearray.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
      <summary>Setzt den Zustand der Operation zurück.</summary>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
      <summary>Ruft die Anzahl der Iterationen für die Operation ab oder legt diese fest.</summary>
      <exception cref="T:System.ArgumentOutOfRangeException">Die Iterationsanzahl ist kleiner als 1.</exception>
      <returns>Die Anzahl der Iterationen für die Operation.</returns>
    </member>
    <member name="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
      <summary>Ruft den Salt-Wert des Schlüssels für die Operation ab oder legt diesen fest.</summary>
      <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes.</exception>
      <exception cref="T:System.ArgumentNullException">Die Salt ist <see langword="null" />.</exception>
      <returns>Der Wert der Schlüsselsalt für die Operation.</returns>
    </member>
    <member name="T:System.Security.Cryptography.Rijndael">
      <summary>Stellt die Basisklasse dar, von der alle Implementierungen des symmetrischen <see cref="T:System.Security.Cryptography.Rijndael" />-Verschlüsselungsalgorithmus erben müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.Rijndael" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create">
      <summary>Erstellt ein Kryptografieobjekt zum Ausführen des <see cref="T:System.Security.Cryptography.Rijndael" />-Algorithmus.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">Der Algorithmus wurde bei aktiviertem FIPS (Federal Information Processing Standards)-Modus verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Ein Kryptografieobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.Rijndael.Create(System.String)">
      <summary>Erstellt ein Kryptografieobjekts, um die angegebene Implementierung des <see cref="T:System.Security.Cryptography.Rijndael" />-Algorithmus auszuführen.</summary>
      <param name="algName">Der Name der zu erstellenden besonderen <see cref="T:System.Security.Cryptography.Rijndael" />-Implementierung.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">Der durch den <paramref name="algName" />-Parameter beschriebene Algorithmus wurde bei aktiviertem FIPS-Modus (Federal Information Processing Standards) verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Ein Kryptografieobjekt.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RijndaelManaged">
      <summary>Greift auf die verwaltete Version des <see cref="T:System.Security.Cryptography.Rijndael" />-Algorithmus zu. Diese Klasse kann nicht vererbt werden.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RijndaelManaged" />-Klasse.</summary>
      <exception cref="T:System.InvalidOperationException">Diese Klasse ist mit dem FIPS-Algorithmus nicht kompatibel.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor">
      <summary>Erstellt ein symmetrisches Entschlüsselungsobjekt mit der aktuellen <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />-Eigenschaft und dem Initialisierungsvektor (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <returns>Ein symmetrisches Entschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Erstellt ein symmetrisches <see cref="T:System.Security.Cryptography.Rijndael" />-Entschlüsselungsobjekt mit der angegebenen <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />-Eigenschaft und dem angegebenen Initialisierungsvektor (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <param name="rgbKey">Der geheime Schlüssel für den symmetrischen Algorithmus. Die Schlüsselgröße muss 128, 192 oder 256 Bits betragen.</param>
      <param name="rgbIV">Der für den symmetrischen Algorithmus zu verwendende Initialisierungsvektor.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="rgbKey" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="rgbIV" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Wert der <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> Eigenschaft ist nicht <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> oder <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
      <returns>Ein symmetrisches <see cref="T:System.Security.Cryptography.Rijndael" />-Entschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor">
      <summary>Erstellt ein symmetrisches Verschlüsselungsobjekt mit der aktuellen <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />-Eigenschaft und dem aktuellen Initialisierungsvektor (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <returns>Ein symmetrisches Verschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Erstellt ein symmetrisches <see cref="T:System.Security.Cryptography.Rijndael" />-Verschlüsselungsobjekt mit der angegebenen <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />-Eigenschaft und dem angegebenen Initialisierungsvektor (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
      <param name="rgbKey">Der geheime Schlüssel für den symmetrischen Algorithmus. Die Schlüsselgröße muss 128, 192 oder 256 Bits betragen.</param>
      <param name="rgbIV">Der für den symmetrischen Algorithmus zu verwendende Initialisierungsvektor.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="rgbKey" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="rgbIV" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Wert der <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" /> Eigenschaft ist nicht <see cref="F:System.Security.Cryptography.CipherMode.ECB" />, <see cref="F:System.Security.Cryptography.CipherMode.CBC" /> oder <see cref="F:System.Security.Cryptography.CipherMode.CFB" />.</exception>
      <returns>Ein symmetrisches <see cref="T:System.Security.Cryptography.Rijndael" />-Verschlüsselungsobjekt.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateIV">
      <summary>Generiert einen zufälligen Initialisierungsvektor (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) für den Algorithmus.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RijndaelManaged.GenerateKey">
      <summary>Generiert einen zufälligen <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> für den Algorithmus.</summary>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.BlockSize">
      <summary>Ruft die Blockgröße des kryptografischen Vorgangs in Bits ab oder legt diese fest.</summary>
      <returns>Die Blockgröße des kryptografischen Vorgangs in Bits. Der Standardwert ist 128 Bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.IV">
      <summary>Ruft den Initialisierungsvektor (IV) für den symmetrischen Algorithmus ab oder legt diesen fest.</summary>
      <returns>Der Initialisierungs Vektor (IV), der für den symmetrischen Algorithmus verwendet werden soll.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Key">
      <summary>Ruft den geheimen Schlüssel für den symmetrischen Algorithmus ab oder legt diesen fest.</summary>
      <returns>Der geheime Schlüssel, der für den symmetrischen Algorithmus verwendet wird.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.KeySize">
      <summary>Ruft die Größe des geheimen Schlüssels für den symmetrischen Algorithmus in Bits ab oder legt diese fest.</summary>
      <returns>Die Größe des für den symmetrischen Algorithmus verwendeten geheimen Schlüssels in Bits. Der Standardwert ist 256 Bits.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.LegalKeySizes">
      <summary>Ruft die vom symmetrischen Algorithmus unterstützten Schlüsselgrößen in Bits ab.</summary>
      <returns>Die Schlüsselgrößen in Bits, die vom symmetrischen Algorithmus unterstützt werden.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Mode">
      <summary>Ruft den Modus für die Ausführung des symmetrischen Algorithmus ab oder legt diesen fest.</summary>
      <returns>Der Modus für die Ausführung des symmetrischen Algorithmus. Der Standardwert ist <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RijndaelManaged.Padding">
      <summary>Ruft den im symmetrischen Algorithmus verwendeten Füllzeichenmodus ab oder legt diesen fest.</summary>
      <returns>Der im symmetrischen Algorithmus verwendete Füllzeichenmodus. Der Standardwert ist <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSA">
      <summary>Stellt die Basisklasse dar, von der alle Implementierungen des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus erben.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSA" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create">
      <summary>Erstellt eine Instanz der Standardimplementierung des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus.</summary>
      <returns>Eine neue Instanz der Standardimplementierung von <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Int32)">
      <summary>Erstellt einen neuen kurzlebigen RSA-Schlüssel mit der angegebenen Schlüsselgröße.</summary>
      <param name="keySizeInBits">Die Schlüsselgröße in Bits.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="keySizeInBits" /> wird nicht von der Standardimplementierung unterstützt.</exception>
      <returns>Ein neuer kurzlebiger RSA-Schlüssel mit der angegebenen Schlüsselgröße.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.Security.Cryptography.RSAParameters)">
      <summary>Erstellt einen neuen kurzlebigen RSA-Schlüssel mit den angegebenen RSA-Schlüsselparametern.</summary>
      <param name="parameters">Die Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="parameters" /> ist kein gültiger RSA-Schlüssel.</exception>
      <returns>Ein neuer kurzlebiger RSA-Schlüssel.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Create(System.String)">
      <summary>Erstellt eine Instanz der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.RSA" />.</summary>
      <param name="algName">Der Name der Implementierung von <see cref="T:System.Security.Cryptography.RSA" />, die verwendet werden soll.</param>
      <returns>Eine neue Instanz der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Entschlüsselt, falls in einer abgeleiteten Klasse überschrieben, die Eingabedaten mithilfe des angegebenen Paddingmodus.</summary>
      <param name="data">Die zu entschlüsselnden Daten.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

Die Länge von <paramref name="data" /> ist ungleich der Anzahl von Bytes für <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />.

- oder - 

Diese Instanz stellt nur einen öffentlichen Schlüssel dar. 

- oder - 

Fehler beim Verschlüsselungsvorgang.</exception>
      <returns>Die entschlüsselten Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.DecryptValue(System.Byte[])">
      <summary>Entschlüsselt beim Überschreiben in einer abgeleiteten Klasse die Eingabedaten mithilfe des privaten Schlüssels.</summary>
      <param name="rgb">Der verschlüsselte Text, der entschlüsselt werden soll.</param>
      <exception cref="T:System.NotSupportedException">Dieser Methodenaufruf wird nicht unterstützt. Diese Ausnahme wird ab .NET Framework 4.6 ausgelöst.</exception>
      <returns>Die resultierende Entschlüsselung des <paramref name="rgb" />-Parameters in Klartext.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Verschlüsselt beim Überschreiben in einer abgeleiteten Klasse die Eingabedaten mithilfe des angegebenen Paddingmodus.</summary>
      <param name="data">Die zu verschlüsselnden Daten.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

<paramref name="data" /> ist zu lang für die Kombination von <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" /> und dem ausgewählten Padding.

- oder - 

Der Verschlüsselungsvorgang ist fehlgeschlagen.</exception>
      <returns>Die verschlüsselten Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.EncryptValue(System.Byte[])">
      <summary>Verschlüsselt beim Überschreiben in einer abgeleiteten Klasse die Eingabedaten mithilfe des öffentlichen Schlüssels.</summary>
      <param name="rgb">Der zu verschlüsselnde Klartext.</param>
      <exception cref="T:System.NotSupportedException">Dieser Methodenaufruf wird nicht unterstützt. Diese Ausnahme wird ab .NET Framework 4.6 ausgelöst.</exception>
      <returns>Die resultierende Verschlüsselung des <paramref name="rgb" />-Parameters als verschlüsselter Text.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportParameters(System.Boolean)">
      <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Parameter konnten nicht exportiert werden.</exception>
      <returns>Die Parameter für <see cref="T:System.Security.Cryptography.RSA" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPrivateKey">
      <summary>Exportiert den aktuellen Schlüssel im PKCS#1-RSAPrivateKey-Format.</summary>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>Ein Bytearray mit der PKCS#1-RSAPrivateKey-Darstellung dieses Schlüssels.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ExportRSAPublicKey">
      <summary>Exportiert den Teil mit dem öffentlichen Schlüssel des aktuellen Schlüssels in das PKCS#1-RSAPublicKey-Format.</summary>
      <returns>Ein Bytearray mit der PKCS#1-RSAPublicKey-Darstellung dieses Schlüssels.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.FromXmlString(System.String)">
      <summary>Initialisiert ein <see cref="T:System.Security.Cryptography.RSA" />-Objekt mit den Schlüsselinformationen aus einer XML-Zeichenfolge.</summary>
      <param name="xmlString">Die XML-Zeichenfolge mit den <see cref="T:System.Security.Cryptography.RSA" />-Schlüsselinformationen.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="xmlString" />-Parameter ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Format des <paramref name="xmlString" />-Parameters ist nicht gültig.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert eines angegebenen Teils eines Bytearrays mithilfe eines angegebenen Hashalgorithmus.</summary>
      <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
      <param name="offset">Der Index des ersten Bytes in <paramref name="data" />, für das der Hashwert berechnet werden soll.</param>
      <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)">
      <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert eines angegebenen Binärdatenstroms mithilfe eines angegebenen Hashalgorithmus.</summary>
      <param name="data">Der binäre Datenstrom, für den der Hashwert berechnet werden soll.</param>
      <param name="hashAlgorithm">Der hash-Algorithmus.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem bytebasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass die anzuwendende Schlüsselableitungsfunktion die Legacy-PKCS#12-KDF ist, die <see cref="T:System.Char" />-basierte Kennwörter erfordert.

- oder - 

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem zeichenbasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder - 

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</param>
      <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder - 

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder - 

Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportFromPem(System.ReadOnlySpan{System.Char})">
      <summary>Importiert einen mit RFC 7468 PEM-codierten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="input">Der PEM-Text des Schlüssels, der importiert werden soll.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.

- oder - 

<paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.

- oder - 

<paramref name="input" /> enthält einen verschlüsselten PEM-codierten Schlüssel.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportParameters(System.Security.Cryptography.RSAParameters)">
      <summary>Importiert beim Überschreiben in einer abgeleiteten Klasse die angegebenen <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
      <param name="parameters">Die Parameter für <see cref="T:System.Security.Cryptography.RSA" />.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-PrivateKeyInfo-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer PKCS#8-PrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-PrivateKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#1-RSAPrivateKey-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer PKCS#1-RSAPrivateKey-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#1-RSAPrivateKey-Struktur dar.

- oder - 

Fehler beim Schlüsselimport.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportRSAPublicKey(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert den öffentlichen Schlüssel aus einer PKCS#1-RSAPublicKey-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer PKCS#1-RSAPublicKey-Struktur in der ASN.1-BER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#1-RSAPublicKey-Struktur dar.

- oder - 

Fehler beim Schlüsselimport.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>Importiert den öffentlichen Schlüssel aus einer X.509-SubjectPublicKeyInfo-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
      <param name="source">Die Bytes einer X.509-SubjectPublicKeyInfo-Struktur in der ASN.1-DER-Codierung.</param>
      <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-DER-codierte X.509-SubjectPublicKeyInfo-Struktur dar.

- oder - 

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder - 

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder - 

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Berechnet den Hashwert eines Teils des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und Paddingmodus und signiert den resultierenden Hashwert.</summary>
      <param name="data">Die Eingabedaten, die gehasht und signiert werden sollen.</param>
      <param name="offset">Der Offset im Array, ab dem Daten verwendet werden sollen.</param>
      <param name="count">Die Anzahl der Bytes im Array, die als Daten verwendet werden sollen.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder - 

Fehler beim Erstellen der Signatur.</exception>
      <returns>Die RSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Berechnet den Hashwert des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und Paddingmodus (Auffüllmodus) und signiert den resultierenden Hashwert.</summary>
      <param name="data">Die Eingabedaten, die gehasht und signiert werden sollen.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder - 

Fehler beim Erstellen der Signatur.</exception>
      <returns>Die RSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Berechnet den Hashwert des angegebenen Datenstroms mithilfe des angegebenen Hashalgorithmus und Paddingsmodus und signiert den resultierenden Hashwert.</summary>
      <param name="data">Der Eingabedatenstrom, der gehasht und signiert werden soll.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder - 

Fehler beim Erstellen der Signatur.</exception>
      <returns>Die RSA-Signatur für die angegebenen Daten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Signatur für den angegebenen Hashwert unter Verwendung des angegebenen Paddings.</summary>
      <param name="hash">Der Hashwert der zu signierenden Daten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> oder <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder - 

Fehler beim Erstellen der Signatur.</exception>
      <returns>Die RSA-Signatur für den angegebenen Hashwert.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.ToXmlString(System.Boolean)">
      <summary>Erstellt eine XML-Zeichenfolge mit dem Schlüssel des aktuellen <see cref="T:System.Security.Cryptography.RSA" />-Objekts und gibt diese zurück.</summary>
      <param name="includePrivateParameters">
        <see langword="true" />, um einen öffentlichen und einen privaten RSA-Schlüssel einzuschließen. <see langword="false" />, um nur den öffentlichen Schlüssel einzuschließen.</param>
      <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
      <returns>Eine XML-Zeichenfolge mit dem Schlüssel des aktuellen <see cref="T:System.Security.Cryptography.RSA" />-Objekts.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryDecrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <summary>Versucht, die Eingabedaten mithilfe des angegebenen Paddingmodus zu entschlüsseln, wobei das Ergebnis in einen bereitgestellten Puffer geschrieben wird.</summary>
      <param name="data">Die zu entschlüsselnden Daten.</param>
      <param name="destination">Der Puffer, der die entschlüsselten Daten empfangen soll.</param>
      <param name="padding">Der Paddingmodus.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

Die Länge von <paramref name="data" /> ist ungleich der Anzahl von Bytes für <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />.

- oder - 

Diese Instanz stellt nur einen öffentlichen Schlüssel dar. 

- oder - 

Fehler beim Verschlüsselungsvorgang.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen der entschlüsselten Daten lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryEncrypt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.RSAEncryptionPadding,System.Int32@)">
      <summary>Versucht, die Eingabedaten mithilfe eines angegebenen Paddingmodus in einen bereitgestellten Puffer zu verschlüsseln.</summary>
      <param name="data">Die zu verschlüsselnden Daten.</param>
      <param name="destination">Der Puffer, der die verschlüsselten Daten empfangen soll.</param>
      <param name="padding">Der Paddingmodus.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

<paramref name="data" /> ist zu lang für die Kombination von <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" /> und dem ausgewählten Padding.

- oder - 

Der Verschlüsselungsvorgang ist fehlgeschlagen.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen der verschlüsselten Daten lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem bytebasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="passwordBytes">Die Bytes, die als Kennwort bei der Verschlüsselung des Schlüsselmaterials verwendet werden.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.

- oder - 

<paramref name="pbeParameters" /> gibt an, dass <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> verwendet werden soll, wofür <see cref="T:System.Char" />-basierte Kennwörter erforderlich sind.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem zeichenbasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="password">Das Kennwort, das bei der Verschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
      <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
      <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#8-PrivateKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die PKCS#8-PrivateKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPrivateKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#1-RSAPrivateKey-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die PKCS#1-RSAPrivateKey-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportRSAPublicKey(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im PKCS#1-RSAPublicKey-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die PKCS#1-RSAPublicKey-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den aktuellen Schlüssel im X.509-SubjectPublicKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
      <param name="destination">Die Bytespanne, in der die X.509-SubjectPublicKeyInfo-Daten empfangen werden sollen.</param>
      <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)">
      <summary>Versucht, den Hashwert der angegebenen Daten unter Verwendung eines angegebenen Algorithmus zu berechnen, wobei die Ergebnisse in einen angegebenen Puffer geschrieben werden.</summary>
      <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des Hashwerts lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <summary>Versucht, den Hash für die angegebenen Daten mit dem angegebenen Algorithmus zu berechnen und den Hash mit dem aktuellen Schlüssel zu signieren, wobei die Signatur in einen bereitgestellten Puffer geschrieben wird.</summary>
      <param name="data">Die Eingabedaten, die gehasht und signiert werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen der RSA-Signatur.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <param name="padding">Der Paddingmodus.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder - 

Fehler beim Erstellen der Signatur.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen der RSA-Signatur lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding,System.Int32@)">
      <summary>Versucht, den Hash mit dem aktuellen Schlüssel zu signieren, wobei die Signatur in einen bereitgestellten Puffer geschrieben wird.</summary>
      <param name="hash">Der Hashwert der zu signierenden Daten.</param>
      <param name="destination" />
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <param name="padding">Der Paddingmodus.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird nicht initialisiert behandelt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.

- oder - 

Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder - 

Fehler beim Erstellen der Signatur.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="destination" /> zum Empfangen der RSA-Signatur lang genug ist. Andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der angegebenen Daten unter Verwendung des angegebenen Hashalgorithmus und Paddingmodus berechnet und mit der angegebenen Signatur verglichen wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="signature" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der Daten in einem Teil eines Bytearrays unter Verwendung des angegebenen Hashalgorithmus und Paddings und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="offset">Der Startindex, an dem der Hashwert berechnet werden soll.</param>
      <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="signature" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert des angegebenen Datenstroms unter Verwendung des angegebenen Hashalgorithmus und Paddings und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="data" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="signature" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der angegebenen Daten unter Verwendung des angegebenen Hashalgorithmus und Paddingmodus berechnet und mit der angegebenen Signatur verglichen wird.</summary>
      <param name="data">Die signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert in der Signatur unter Verwendung des angegebenen Hashalgorithmus und Paddings ermittelt und mit dem angegebenen Hashwert verglichen wird.</summary>
      <param name="hash">Der Hashwert der signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts verwendete Hashalgorithmus.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> oder <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSA.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert in der Signatur unter Verwendung des angegebenen Hashalgorithmus und Paddings ermittelt und mit dem angegebenen Hashwert verglichen wird.</summary>
      <param name="hash">Der Hashwert der signierten Daten.</param>
      <param name="signature">Die zu überprüfenden Signaturdaten.</param>
      <param name="hashAlgorithm">Der zum Erstellen des Hashwerts verwendete Hashalgorithmus.</param>
      <param name="padding">Der Paddingmodus.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="hash" /> oder <paramref name="padding" /> ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="padding" /> ist unbekannt oder wird von dieser Implementierung nicht unterstützt.</exception>
      <returns>
        <see langword="true" />, wenn die Signatur gültig ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSA.KeyExchangeAlgorithm">
      <summary>Ruft den Namen des in dieser Implementierung von <see cref="T:System.Security.Cryptography.RSA" /> verfügbaren Algorithmus für den Schlüsselaustausch ab.</summary>
      <returns>Gibt „RSA“ zurück.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSA.SignatureAlgorithm">
      <summary>Ruft den Namen des in dieser Implementierung von <see cref="T:System.Security.Cryptography.RSA" />verfügbaren Signaturalgorithmus ab.</summary>
      <returns>Gibt „RSA“ zurück.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPadding">
      <summary>Gibt den Auffüllmodus und die Parameter an, die bei RSA-Verschlüsselungs- oder Entschlüsselungsvorgängen zu verwenden sind.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.CreateOaep(System.Security.Cryptography.HashAlgorithmName)">
      <summary>Erstellt eine neue <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />-Instanz, deren <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" /><see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> mit dem angegebenen Hashalgorithmus entspricht.</summary>
      <param name="hashAlgorithm">Der Hashalgorithmus.</param>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      <returns>Ein Objekt, dessen <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" />-Modus <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" /> mit dem durch <paramref name="hashAlgorithm" /> angegebenen Hashalgorithmus entspricht.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Object)">
      <summary>Bestimmt, ob das angegebene Objekt mit der aktuellen Instanz identisch ist.</summary>
      <param name="obj">Das zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="obj" /> der aktuellen Instanz entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Bestimmt, ob das angegebene <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />-Objekt mit der aktuellen Instanz identisch ist.</summary>
      <param name="other">Das zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn <paramref name="other" /> der aktuellen Instanz entspricht, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.GetHashCode">
      <summary>Gibt den Hash dieses <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />-Objekts zurück.</summary>
      <returns>Der Hash dieser Instanz.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Equality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Gibt an, ob zwei angegebene <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />-Objekte gleich sind.</summary>
      <param name="left">Das erste zu vergleichende Objekt.</param>
      <param name="right">Das zweite zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn <see langword="left" /> und <see langword="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.op_Inequality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)">
      <summary>Gibt an, ob zwei angegebene <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />-Objekte ungleich sind.</summary>
      <param name="left">Das erste zu vergleichende Objekt.</param>
      <param name="right">Das zweite zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn <see langword="left" /> und <see langword="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAEncryptionPadding.ToString">
      <summary>Gibt die Zeichenfolgendarstellung der aktuellen <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" /> -Instanz zurück.</summary>
      <returns>Die Zeichenfolgendarstellung des aktuellen Objekts.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Mode">
      <summary>Ruft den Auffüllmodus ab, der von dieser <see cref="T:System.Security.Cryptography.RSAEncryptionPadding" />-Instanz dargestellt wird.</summary>
      <returns>Ein Paddingmodus.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepHashAlgorithm">
      <summary>Ruft den Hashalgorithmus in Verbindung mit dem <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" />-Paddingmodus ab.</summary>
      <returns>Der hash-Algorithmus.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1">
      <summary>Ruft ein Objekt ab, das den OAEP-Verschlüsselungsstandard (Optimal Asymmetric Encryption Padding) mit einem SHA1-Hashalgorithmus darstellt.</summary>
      <returns>Ein Objekt, das den OAEP-Verschlüsselungsstandard mit einem SHA1-Hashalgorithmus darstellt.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA256">
      <summary>Ruft ein Objekt ab, das den OAEP-Verschlüsselungsstandard (Optimal Asymmetric Encryption Padding) mit einem SHA256-Hashalgorithmus darstellt.</summary>
      <returns>Ein Objekt, das den OAEP-Verschlüsselungsstandard mit einem SHA256-Hashalgorithmus darstellt.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA384">
      <summary>Ruft ein Objekt ab, das den OAEP-Verschlüsselungsstandard (Optimal Asymmetric Encryption Padding) mit einem SHA-384-Hashalgorithmus darstellt.</summary>
      <returns>Ein Objekt, das den OAEP-Verschlüsselungsstandard mit einem SHA384-Hashalgorithmus darstellt.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA512">
      <summary>Ruft ein Objekt ab, das den OAEP-Verschlüsselungsstandard (Optimal Asymmetric Encryption Padding) mit einem SHA512-Hashalgorithmus darstellt.</summary>
      <returns>Ein Objekt, das den OAEP-Verschlüsselungsstandard mit einem SHA512-Hashalgorithmus darstellt.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1">
      <summary>Ruft ein Objekt ab, das den Verschlüsselungsstandard PKCS #1 darstellt.</summary>
      <returns>Ein Objekt, das den Verschlüsselungsstandard PKCS #1 darstellt.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAEncryptionPaddingMode">
      <summary>Gibt den Paddingmodus an, der bei RSA-Verschlüsselungs- oder Entschlüsselungsvorgängen zu verwenden ist.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep">
      <summary>Optimales Padding bei der asymmetrischen Verschlüsselung. Dies wird für neue Anwendungen empfohlen.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5 Dies wird für die Kompatibilität mit vorhandenen Anwendungen unterstützt.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter">
      <summary>Entschlüsselt OAEP (Optimal Asymmetric Encryption Padding)-Schlüsselaustauschdaten.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den privaten Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrahiert geheime Informationen aus den verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="rgbData">Die Schlüsselaustauschdaten, in denen die geheimen Informationen verborgen sind.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Überprüfung der Schlüsselaustauschdaten ist fehlgeschlagen.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der Schlüssel fehlt.</exception>
      <returns>Die geheimen Informationen, die aus den Schlüsselaustauschdaten abgeleitet werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt den privaten Schlüssel für das Entschlüsseln der Informationen des geheimen Schlüssels fest.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den privaten Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.Parameters">
      <summary>Ruft die Parameter für den OAEP (Optimal Asymmetric Encryption Padding)-Schlüsselaustausch ab.</summary>
      <returns>Eine XML-Zeichenfolge mit Parametern für den OAEP-Schlüsselaustauschvorgang.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter">
      <summary>Erstellt Daten für den OAEP-Schlüsselaustausch (Optimal Asymmetric Encryption Padding) mithilfe von <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den öffentlichen Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Erstellt anhand der angegebenen Eingabedaten die verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="rgbData">Die beim Schlüsselaustausch zu übergebenden geheimen Informationen.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der Schlüssel fehlt.</exception>
      <returns>Die an den beabsichtigten Empfänger zu sendenden verschlüsselten Schlüsselaustauschdaten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Erstellt anhand der angegebenen Eingabedaten die verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="rgbData">Die beim Schlüsselaustausch zu übergebenden geheimen Informationen.</param>
      <param name="symAlgType">Dieser Parameter wird in der aktuellen Version nicht verwendet.</param>
      <returns>Die an den beabsichtigten Empfänger zu sendenden verschlüsselten Schlüsselaustauschdaten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt den öffentlichen Schlüssel zum Verschlüsseln der Schlüsselaustauschdaten fest.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den öffentlichen Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameter">
      <summary>Ruft den Parameter ab, der zum Erzeugen von Abständen im Erstellungsprozess für den Schlüsselaustausch verwendet wird, oder legt diesen Parameter fest.</summary>
      <returns>Der Parameterwert.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Parameters">
      <summary>Ruft die Parameter für den OAEP (Optimal Asymmetric Encryption Padding)-Schlüsselaustausch ab.</summary>
      <returns>Eine XML-Zeichenfolge mit Parametern für den OAEP-Schlüsselaustauschvorgang.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.Rng">
      <summary>Ruft den Algorithmus des Zufallszahlengenerators ab, der bei der Erstellung des Schlüsselaustauschs verwendet werden soll, oder legt ihn fest.</summary>
      <returns>Die Instanz eines zu verwendenden Algorithmus des Zufallszahlengenerators.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAParameters">
      <summary>Stellt die Standardparameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.D">
      <summary>Stellt den <see langword="D" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DP">
      <summary>Stellt den <see langword="DP" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.DQ">
      <summary>Stellt den <see langword="DQ" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Exponent">
      <summary>Stellt den <see langword="Exponent" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.InverseQ">
      <summary>Stellt den <see langword="InverseQ" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Modulus">
      <summary>Stellt den <see langword="Modulus" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.P">
      <summary>Stellt den <see langword="P" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSAParameters.Q">
      <summary>Stellt den <see langword="Q" />-Parameter für den <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus dar.</summary>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter">
      <summary>Entschlüsselt die PKCS #1-Schlüsselaustauschdaten.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den privaten Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])">
      <summary>Extrahiert geheime Informationen aus den verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="rgbIn">Die Schlüsselaustauschdaten, in denen die geheimen Informationen verborgen sind.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der Schlüssel fehlt.</exception>
      <returns>Die geheimen Informationen, die aus den Schlüsselaustauschdaten abgeleitet werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt den privaten Schlüssel für das Entschlüsseln der Informationen des geheimen Schlüssels fest.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den privaten Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.Parameters">
      <summary>Ruft die Parameter für den PKCS #1-Schlüsselaustausch ab.</summary>
      <returns>Eine XML-Zeichenfolge mit Parametern für den PKCS #1-Schlüsselaustauschvorgang.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.RNG">
      <summary>Ruft den Algorithmus des Zufallszahlengenerators ab, der bei der Erstellung des Schlüsselaustauschs verwendet werden soll, oder legt ihn fest.</summary>
      <returns>Die Instanz eines zu verwendenden Algorithmus des Zufallszahlengenerators.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter">
      <summary>Erstellt die PKCS#1-Schlüsselaustauschdaten mithilfe von <see cref="T:System.Security.Cryptography.RSA" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den öffentlichen Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[])">
      <summary>Erstellt anhand der angegebenen Eingabedaten die verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="rgbData">Die beim Schlüsselaustausch zu übergebenden geheimen Informationen.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">
        <paramref name="rgbData" /> ist zu groß.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der Schlüssel ist <see langword="null" />.</exception>
      <returns>Die an den beabsichtigten Empfänger zu sendenden verschlüsselten Schlüsselaustauschdaten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)">
      <summary>Erstellt anhand der angegebenen Eingabedaten die verschlüsselten Schlüsselaustauschdaten.</summary>
      <param name="rgbData">Die beim Schlüsselaustausch zu übergebenden geheimen Informationen.</param>
      <param name="symAlgType">Dieser Parameter wird in der aktuellen Version nicht verwendet.</param>
      <returns>Die an den beabsichtigten Empfänger zu sendenden verschlüsselten Schlüsselaustauschdaten.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt den öffentlichen Schlüssel zum Verschlüsseln der Schlüsselaustauschdaten fest.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den öffentlichen Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Parameters">
      <summary>Ruft die Parameter für den PKCS #1-Schlüsselaustausch ab.</summary>
      <returns>Eine XML-Zeichenfolge mit Parametern für den PKCS #1-Schlüsselaustauschvorgang.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.Rng">
      <summary>Ruft den Algorithmus des Zufallszahlengenerators ab, der bei der Erstellung des Schlüsselaustauschs verwendet werden soll, oder legt ihn fest.</summary>
      <returns>Die Instanz eines zu verwendenden Algorithmus des Zufallszahlengenerators.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter">
      <summary>Überprüft eine <see cref="T:System.Security.Cryptography.RSA" /> PKCS #1 v1.5-Signatur.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz von <see cref="T:System.Security.Cryptography.RSA" />, die den öffentlichen Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetHashAlgorithm(System.String)">
      <summary>Legt den Hashalgorithmus fest, der zum Überprüfen der Signatur verwendet werden soll.</summary>
      <param name="strName">Der Name des Hashalgorithmus, der zum Überprüfen der Signatur verwendet werden soll.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt den öffentlichen Schlüssel fest, der zum Überprüfen der Signatur verwendet werden soll.</summary>
      <param name="key">Die Instanz von <see cref="T:System.Security.Cryptography.RSA" />, die den öffentlichen Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])">
      <summary>Überprüft die <see cref="T:System.Security.Cryptography.RSA" />-PKCS #1-Signatur für die angegebenen Daten.</summary>
      <param name="rgbHash">Die mit <paramref name="rgbSignature" /> signierten Daten.</param>
      <param name="rgbSignature">Die für <paramref name="rgbHash" /> zu überprüfende Signatur.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der Schlüssel ist <see langword="null" />.  
  
- oder - 
Der Hashalgorithmus ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="rgbHash" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="rgbSignature" />-Parameter ist <see langword="null" />.</exception>
      <returns>
        <see langword="true" />, wenn <paramref name="rgbSignature" /> der Signatur entspricht, die mit dem angegebenen Hashalgorithmus und Schlüssel für <paramref name="rgbHash" /> berechnet wurde, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter">
      <summary>Erstellt eine <see cref="T:System.Security.Cryptography.RSA" /> PKCS #1 v1.5-Signatur.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" />-Klasse mit dem angegebenen Schlüssel.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den privaten Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.CreateSignature(System.Byte[])">
      <summary>Erstellt die <see cref="T:System.Security.Cryptography.RSA" /> PKCS #1-Signatur für die angegebenen Daten.</summary>
      <param name="rgbHash">Die zu signierenden Daten.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Der Schlüssel ist <see langword="null" />.  
  
- oder - 
Der Hashalgorithmus ist <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="rgbHash" />-Parameter ist <see langword="null" />.</exception>
      <returns>Die digitale Signatur für <paramref name="rgbHash" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetHashAlgorithm(System.String)">
      <summary>Legt den Hashalgorithmus fest, der zum Erstellen der Signatur verwendet werden soll.</summary>
      <param name="strName">Der Name des Hashalgorithmus, der zum Erstellen der Signatur verwendet werden soll.</param>
    </member>
    <member name="M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Legt den zum Erstellen der Signatur zu verwendenden privaten Schlüssel fest.</summary>
      <param name="key">Die Instanz des <see cref="T:System.Security.Cryptography.RSA" />-Algorithmus, der den privaten Schlüssel enthält.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> ist <see langword="null" />.</exception>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePadding">
      <summary>Gibt den Auffüllmodus und Parameter an, die bei Vorgängen zum Erstellen oder Überprüfen der RSA-Signatur zu verwenden sind.</summary>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Object)">
      <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
      <param name="obj">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Security.Cryptography.RSASignaturePadding)">
      <summary>Gibt einen Wert zurück, der angibt, ob diese <see cref="T:System.Security.Cryptography.RSASignaturePadding" />-Instanz gleich einem angegebenen -Objekt ist.</summary>
      <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
      <returns>
        <see langword="true" />, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.GetHashCode">
      <summary>Gibt den Hashcode für diese <see cref="T:System.Security.Cryptography.RSASignaturePadding" />-Instanz zurück.</summary>
      <returns>Der Hashcode für diese <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> -Instanz.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Equality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Gibt an, ob zwei angegebene <see cref="T:System.Security.Cryptography.RSASignaturePadding" />-Objekte gleich sind.</summary>
      <param name="left">Das erste zu vergleichende Objekt.</param>
      <param name="right">Das zweite zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn <see langword="left" /> und <see langword="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.op_Inequality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)">
      <summary>Gibt an, ob zwei angegebene <see cref="T:System.Security.Cryptography.RSASignaturePadding" />-Objekte ungleich sind.</summary>
      <param name="left">Das erste zu vergleichende Objekt.</param>
      <param name="right">Das zweite zu vergleichende Objekt.</param>
      <returns>
        <see langword="true" />, wenn <see langword="left" /> und <see langword="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.RSASignaturePadding.ToString">
      <summary>Gibt die Zeichenfolgendarstellung der aktuellen <see cref="T:System.Security.Cryptography.RSASignaturePadding" /> -Instanz zurück.</summary>
      <returns>Die Zeichenfolgendarstellung des aktuellen Objekts.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Mode">
      <summary>Ruft den Auffüllmodus dieser <see cref="T:System.Security.Cryptography.RSASignaturePadding" />-Instanz ab.</summary>
      <returns>Der Paddingmodus (entweder <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" /> oder <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" />) dieser Instanz.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1">
      <summary>Ruft ein Objekt ab, das den PKCS #1 v1.5-Auffüllmodus verwendet.</summary>
      <returns>Ein Objekt, das den <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1" />-Paddingmodus verwendet.</returns>
    </member>
    <member name="P:System.Security.Cryptography.RSASignaturePadding.Pss">
      <summary>Ruft ein Objekt ab, das den PSS-Auffüllmodus verwendet.</summary>
      <returns>Ein Objekt, das den <see cref="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss" />-Paddingmodus mit der Anzahl von Salt-Bytes verwendet, die der Größe des Hashes entspricht.</returns>
    </member>
    <member name="T:System.Security.Cryptography.RSASignaturePaddingMode">
      <summary>Gibt den Paddingmodus an, der bei Vorgängen zum Erstellen oder Überprüfen der RSA-Signatur zu verwenden ist.</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pkcs1">
      <summary>PKCS #1 v1.5</summary>
    </member>
    <member name="F:System.Security.Cryptography.RSASignaturePaddingMode.Pss">
      <summary>Probabilistisches Signaturschema</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA1">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA1" />-Hash für die Eingabedaten.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <exception cref="T:System.InvalidOperationException">Die Richtlinie für dieses Objekt ist mit dem FIPS-Algorithmus nicht kompatibel.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create">
      <summary>Erstellt eine Instanz der Standardimplementierung von <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA1" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.Create(System.String)">
      <summary>Erstellt eine Instanz der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA1" />.</summary>
      <param name="hashName">Der Name der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA1" />, die verwendet werden soll.</param>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA1" /> unter Verwendung der angegebenen Implementierung.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.HashData(System.Byte[])">
      <summary>Berechnet den Datenhash mithilfe des SHA1-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA1-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA1-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <exception cref="T:System.ArgumentException">Der Puffer in <paramref name="destination" /> ist zu klein, um die berechnete Hashgröße zu speichern. Der SHA1-Algorithmus erzeugt immer einen 160-Bit-Hash oder 20 Bytes.</exception>
      <returns>Die Gesamtanzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA1.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den Datenhash mithilfe des SHA1-Algorithmus zu berechnen.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zu klein ist, um den berechneten Hash zu speichern, andernfalls <see langword="true" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA1Managed">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA1" />-Hash für die Eingabedaten unter Verwendung der verwalteten Bibliothek.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.SHA1Managed" />-Klasse.</summary>
      <exception cref="T:System.InvalidOperationException">Diese Klasse ist mit dem FIPS-Algorithmus nicht kompatibel.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA1Managed.Initialize">
      <summary>Initialisiert eine Instanz von <see cref="T:System.Security.Cryptography.SHA1Managed" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA256">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA256" />-Hash für die Eingabedaten.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create">
      <summary>Erstellt eine Instanz der Standardimplementierung von <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">Nur in .NET Framework 4.6.1 und früheren Versionen: Der Algorithmus wurde bei aktiviertem FIPS-Modus verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA256" />. Diese Methode erstellt in .NET Framework eine Instanz der <see cref="T:System.Security.Cryptography.SHA256Managed" />-Klasse, wenn der FIPS-Modus (Federal Information Processing Standard) nicht aktiv ist. Wenn der FIPS-Modus aktiv ist, erstellt sie eine Instanz der <see cref="T:System.Security.Cryptography.SHA256Cng" />-Klasse. In .NET Core gibt sie eine Instanz einer privaten Klasse zurück, die von <see cref="T:System.Security.Cryptography.SHA256" /> abgeleitet wird.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.Create(System.String)">
      <summary>Erstellt eine Instanz einer angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA256" />.</summary>
      <param name="hashName">Der Name der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA256" />, die verwendet werden soll.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">Nur in .NET Framework: FIPS-Modus ist aktiviert, aber <paramref name="hashName" /> fordert <see cref="T:System.Security.Cryptography.SHA256Managed" /> an, was nicht FIPS-kompatibel ist.</exception>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA256" /> unter Verwendung der angegebenen Implementierung.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.HashData(System.Byte[])">
      <summary>Berechnet den Datenhash mithilfe des SHA256-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA256-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA256-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <exception cref="T:System.ArgumentException">Der Puffer in <paramref name="destination" /> ist zu klein, um die berechnete Hashgröße zu speichern. Der SHA256-Algorithmus erzeugt immer einen 256-Bit-Hash oder 32 Bytes.</exception>
      <returns>Die Gesamtanzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA256.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den Datenhash mithilfe des SHA256-Algorithmus zu berechnen.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zu klein ist, um den berechneten Hash zu speichern, andernfalls <see langword="true" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA256Managed">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA256" />-Hash für die Eingabedaten unter Verwendung der verwalteten Bibliothek.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.SHA256Managed" />-Klasse unter Verwendung der verwalteten Bibliothek.</summary>
      <exception cref="T:System.InvalidOperationException">Die FIPS-Sicherheitseinstellung (Federal Information Processing Standards) ist aktiviert. Diese Implementierung ist nicht Bestandteil der auf der Windows-Plattform FIPS-überprüften kryptografischen Algorithmen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA256Managed.Initialize">
      <summary>Initialisiert eine Instanz von <see cref="T:System.Security.Cryptography.SHA256Managed" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA384">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA384" />-Hash für die Eingabedaten.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create">
      <summary>Erstellt eine Instanz der Standardimplementierung von <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">Der Algorithmus wurde bei aktiviertem FIPS (Federal Information Processing Standards)-Modus verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA384" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.Create(System.String)">
      <summary>Erstellt eine Instanz einer angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA384" />.</summary>
      <param name="hashName">Der Name der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA384" />, die verwendet werden soll.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">Der durch den <paramref name="hashName" />-Parameter beschriebene Algorithmus wurde bei aktiviertem FIPS-Modus (Federal Information Processing Standards) verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA384" /> unter Verwendung der angegebenen Implementierung.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.HashData(System.Byte[])">
      <summary>Berechnet den Datenhash mithilfe des SHA384-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA384-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA384-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <exception cref="T:System.ArgumentException">Der Puffer in <paramref name="destination" /> ist zu klein, um die berechnete Hashgröße zu speichern. Der SHA384-Algorithmus erzeugt immer einen 384-Bit-Hash oder 48 Bytes.</exception>
      <returns>Die Gesamtanzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA384.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den Datenhash mithilfe des SHA384-Algorithmus zu berechnen.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zu klein ist, um den berechneten Hash zu speichern, andernfalls <see langword="true" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA384Managed">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA384" />-Hash für die Eingabedaten unter Verwendung der verwalteten Bibliothek.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.SHA384Managed" />-Klasse.</summary>
      <exception cref="T:System.InvalidOperationException">Die FIPS-Sicherheitseinstellung (Federal Information Processing Standards) ist aktiviert. Diese Implementierung ist nicht Bestandteil der auf der Windows-Plattform FIPS-überprüften kryptografischen Algorithmen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA384Managed.Initialize">
      <summary>Initialisiert eine Instanz von <see cref="T:System.Security.Cryptography.SHA384Managed" />.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SHA512">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA512" />-Hash für die Eingabedaten.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create">
      <summary>Erstellt eine Instanz der Standardimplementierung von <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
      <exception cref="T:System.Reflection.TargetInvocationException">Der Algorithmus wurde bei aktiviertem FIPS (Federal Information Processing Standards)-Modus verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA512" />.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.Create(System.String)">
      <summary>Erstellt eine Instanz einer angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA512" />.</summary>
      <param name="hashName">Der Name der angegebenen Implementierung von <see cref="T:System.Security.Cryptography.SHA512" />, die verwendet werden soll.</param>
      <exception cref="T:System.Reflection.TargetInvocationException">Der durch den <paramref name="hashName" />-Parameter beschriebene Algorithmus wurde bei aktiviertem FIPS-Modus (Federal Information Processing Standards) verwendet, ist aber nicht FIPS-kompatibel.</exception>
      <returns>Eine neue Instanz von <see cref="T:System.Security.Cryptography.SHA512" /> unter Verwendung der angegebenen Implementierung.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.HashData(System.Byte[])">
      <summary>Berechnet den Datenhash mithilfe des SHA512-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ist <see langword="null" />.</exception>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.HashData(System.ReadOnlySpan{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA512-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <returns>Der Datenhash.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.HashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
      <summary>Berechnet den Datenhash mithilfe des SHA512-Algorithmus.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <exception cref="T:System.ArgumentException">Der Puffer in <paramref name="destination" /> ist zu klein, um die berechnete Hashgröße zu speichern. Der SHA1-Algorithmus erzeugt immer einen 512-Bit-Hash oder 64 Bytes.</exception>
      <returns>Die Gesamtanzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SHA512.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
      <summary>Versucht, den Datenhash mithilfe des SHA512-Algorithmus zu berechnen.</summary>
      <param name="source">Die Daten, die gehasht werden sollen.</param>
      <param name="destination">Der Puffer zum Empfangen des Hashwerts.</param>
      <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.</param>
      <returns>
        <see langword="false" />, wenn <paramref name="destination" /> zu klein ist, um den berechneten Hash zu speichern, andernfalls <see langword="true" />.</returns>
    </member>
    <member name="T:System.Security.Cryptography.SHA512Managed">
      <summary>Berechnet den <see cref="T:System.Security.Cryptography.SHA512" />-Hashalgorithmus für die Eingabedaten unter Verwendung der verwalteten Bibliothek.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.SHA512Managed" />-Klasse.</summary>
      <exception cref="T:System.InvalidOperationException">Die FIPS-Sicherheitseinstellung (Federal Information Processing Standards) ist aktiviert. Diese Implementierung ist nicht Bestandteil der auf der Windows-Plattform FIPS-überprüften kryptografischen Algorithmen.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SHA512Managed.Initialize">
      <summary>Initialisiert mithilfe der verwalteten Bibliothek eine Instanz der <see cref="T:System.Security.Cryptography.SHA512Managed" />-Klasse.</summary>
    </member>
    <member name="T:System.Security.Cryptography.SignatureDescription">
      <summary>Enthält Informationen über die Eigenschaften einer digitalen Signatur.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.SignatureDescription" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.#ctor(System.Security.SecurityElement)">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.SignatureDescription" />-Klasse aus dem angegebenen <see cref="T:System.Security.SecurityElement" />.</summary>
      <param name="el">Das <see cref="T:System.Security.SecurityElement" />, aus dem die Algorithmen für die Signaturbeschreibung abgerufen werden.</param>
      <exception cref="T:System.ArgumentNullException">Der <paramref name="el" />-Parameter ist <see langword="null" />.</exception>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Erstellt eine <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />-Instanz mit dem angegebenen Schlüssel unter Verwendung der <see cref="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm" />-Eigenschaft.</summary>
      <param name="key">Der in der <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />-Klasse zu verwendende Schlüssel.</param>
      <returns>Die neu erstellte <see cref="T:System.Security.Cryptography.AsymmetricSignatureDeformatter" />-Instanz.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateDigest">
      <summary>Erstellt eine <see cref="T:System.Security.Cryptography.HashAlgorithm" />-Instanz unter Verwendung der <see cref="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm" />-Eigenschaft.</summary>
      <returns>Die neu erstellte <see cref="T:System.Security.Cryptography.HashAlgorithm" />-Instanz.</returns>
    </member>
    <member name="M:System.Security.Cryptography.SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm)">
      <summary>Erstellt eine <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />-Instanz mit dem angegebenen Schlüssel unter Verwendung der <see cref="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm" />-Eigenschaft.</summary>
      <param name="key">Der in der <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />-Klasse zu verwendende Schlüssel.</param>
      <returns>Die neu erstellte <see cref="T:System.Security.Cryptography.AsymmetricSignatureFormatter" />-Instanz.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DeformatterAlgorithm">
      <summary>Ruft den Deformatierungsalgorithmus für die Signaturbeschreibung ab oder legt diesen fest.</summary>
      <returns>Der Deformatierungsalgorithmus für die Signaturbeschreibung.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.DigestAlgorithm">
      <summary>Ruft den Digest-Algorithmus für die Signaturbeschreibung ab oder legt diesen fest.</summary>
      <returns>Der Digest-Algorithmus für die Signaturbeschreibung.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.FormatterAlgorithm">
      <summary>Ruft den Formatierungsalgorithmus für die Signaturbeschreibung ab oder legt diesen fest.</summary>
      <returns>Der Formatierungsalgorithmus für die Signaturbeschreibung.</returns>
    </member>
    <member name="P:System.Security.Cryptography.SignatureDescription.KeyAlgorithm">
      <summary>Ruft den Schlüsselalgorithmus für die Signaturbeschreibung ab oder legt diesen fest.</summary>
      <returns>Der Schlüsselalgorithmus für die Signaturbeschreibung.</returns>
    </member>
    <member name="T:System.Security.Cryptography.TripleDES">
      <summary>Stellt die Basisklasse für Triple-DES-Algorithmen dar, von der alle <see cref="T:System.Security.Cryptography.TripleDES" />-Implementierungen abgeleitet werden müssen.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.#ctor">
      <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.TripleDES" />-Klasse.</summary>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create">
      <summary>Erstellt eine Instanz eines Kryptografieobjekts, um den <see cref="T:System.Security.Cryptography.TripleDES" />-Algorithmus auszuführen.</summary>
      <returns>Eine Instanz eines Kryptografieobjekts.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.Create(System.String)">
      <summary>Erstellt eine Instanz eines Kryptografieobjekts, um die angegebene Implementierung des <see cref="T:System.Security.Cryptography.TripleDES" />-Algorithmus auszuführen.</summary>
      <param name="str">Der Name der spezifischen Implementierung von <see cref="T:System.Security.Cryptography.TripleDES" />, die verwendet werden soll.</param>
      <returns>Eine Instanz eines Kryptografieobjekts.</returns>
    </member>
    <member name="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])">
      <summary>Bestimmt, ob der angegebene Schlüssel schwach ist.</summary>
      <param name="rgbKey">Der geheime Schlüssel zum Testen auf Schwächen.</param>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Die Größe des <paramref name="rgbKey" />-Parameters ist nicht gültig.</exception>
      <returns>
        <see langword="true" />, wenn der Schlüssel schwach ist, andernfalls <see langword="false" />.</returns>
    </member>
    <member name="P:System.Security.Cryptography.TripleDES.Key">
      <summary>Ruft den geheimen Schlüssel für den <see cref="T:System.Security.Cryptography.TripleDES" />-Algorithmus ab oder legt diesen fest.</summary>
      <exception cref="T:System.ArgumentNullException">Es wurde versucht, den Schlüssel auf <see langword="null" /> festzulegen.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Es wurde versucht, einen Schlüssel festzulegen, dessen Länge ungültig ist.  
  
- oder - 
Es wurde versucht, einen Weak-Schlüssel festzulegen (siehe <see cref="M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])" />).</exception>
      <returns>Der geheime Schlüssel für den <see cref="T:System.Security.Cryptography.TripleDES" />-Algorithmus.</returns>
    </member>
  </members>
</doc>